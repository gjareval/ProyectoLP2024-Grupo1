Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ELSEIF

Grammar

Rule 0     S' -> statement
Rule 1     statement -> blocks
Rule 2     statement -> import blocks
Rule 3     statement -> package blocks
Rule 4     statement -> package import blocks
Rule 5     statement -> main LBRACE blocks RBRACE
Rule 6     statement -> package main LBRACE blocks RBRACE
Rule 7     statement -> import main LBRACE blocks RBRACE
Rule 8     statement -> package import main LBRACE blocks RBRACE
Rule 9     import -> <empty>
Rule 10    import -> IMPORT CHARSTRING
Rule 11    import -> IMPORT LPAREN values_for_import RPAREN
Rule 12    values_for_import -> CHARSTRING
Rule 13    values_for_import -> CHARSTRING values_for_import
Rule 14    package -> PACKAGE VARIABLE
Rule 15    package -> PACKAGE MAIN
Rule 16    main -> FUNCTION MAIN LPAREN RPAREN
Rule 17    blocks -> block
Rule 18    blocks -> block blocks
Rule 19    blocks -> block SEMICOLON blocks
Rule 20    block -> print_statement
Rule 21    block -> input_statement
Rule 22    block -> operation
Rule 23    block -> data_structure
Rule 24    block -> control_structure
Rule 25    block -> function
Rule 26    block -> variable_declaration
Rule 27    block -> variable_assignation
Rule 28    variables -> VARIABLE
Rule 29    variables -> VARIABLE COMMA variables
Rule 30    value -> not_variable_value
Rule 31    value -> VARIABLE LBRACKET RBRACKET
Rule 32    value -> VARIABLE LBRACKET value RBRACKET
Rule 33    value -> VARIABLE
Rule 34    not_variable_value -> CHARSTRING
Rule 35    not_variable_value -> INT
Rule 36    not_variable_value -> FLOAT
Rule 37    not_variable_value -> BOOL
Rule 38    values -> value
Rule 39    values -> value COMMA values
Rule 40    variable_declaration -> VAR variables type
Rule 41    variable_declaration -> VAR variables type ASSIGN value
Rule 42    variable_declaration -> VAR variables type ASSIGN operation
Rule 43    variable_declaration -> VARIABLE SHORTASSIGN value
Rule 44    variable_declaration -> VARIABLE SHORTASSIGN operation
Rule 45    variable_declaration -> CONST VARIABLE ASSIGN value
Rule 46    variable_assignation -> VARIABLE assignation value
Rule 47    variable_assignation -> VARIABLE assignation operation
Rule 48    variable_assignation -> VARIABLE double_operator
Rule 49    variable_assignation -> map_assign
Rule 50    variable_assignation -> array_assign
Rule 51    assignation -> ASSIGN
Rule 52    assignation -> PLUSASSIGN
Rule 53    assignation -> MINUSASSIGN
Rule 54    assignation -> TIMESASSIGN
Rule 55    assignation -> DIVIDEASSIGN
Rule 56    assignation -> MODASSIGN
Rule 57    parameters -> VARIABLE type
Rule 58    parameters -> VARIABLE type COMMA parameters
Rule 59    type -> INT
Rule 60    type -> INT32
Rule 61    type -> INT64
Rule 62    type -> STRING
Rule 63    type -> FLOAT
Rule 64    type -> FLOAT32
Rule 65    type -> FLOAT64
Rule 66    type -> BOOL
Rule 67    function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
Rule 68    function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
Rule 69    function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
Rule 70    function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
Rule 71    function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
Rule 72    function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
Rule 73    function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
Rule 74    function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
Rule 75    return -> RETURN value
Rule 76    return -> RETURN value LBRACKET value RBRACKET
Rule 77    return -> RETURN value PERIOD value
Rule 78    print_statement -> PRINT LPAREN values RPAREN
Rule 79    print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN
Rule 80    print_statement -> PRINT LPAREN operation RPAREN
Rule 81    print_statement -> PRINT LPAREN RPAREN
Rule 82    input_statement -> INPUT LPAREN values RPAREN
Rule 83    input_statement -> INPUT LPAREN operation RPAREN
Rule 84    input_statement -> INPUT LPAREN RPAREN
Rule 85    operator -> PLUS
Rule 86    operator -> MINUS
Rule 87    operator -> TIMES
Rule 88    operator -> DIVIDE
Rule 89    operator -> AND
Rule 90    operator -> OR
Rule 91    operator -> NOT
Rule 92    operator -> LESS
Rule 93    operator -> LESSEQUALS
Rule 94    operator -> GREATER
Rule 95    operator -> GREATEREQUALS
Rule 96    operator -> EQUALS
Rule 97    operator -> DIFFERENT
Rule 98    operation -> value operator value
Rule 99    operation -> value operator LPAREN value RPAREN
Rule 100   operation -> LPAREN value RPAREN operator value
Rule 101   operation -> LPAREN value operator value RPAREN
Rule 102   operation -> value operator operation
Rule 103   operation -> LPAREN value operator operation RPAREN
Rule 104   operation -> LPAREN value RPAREN operator operation
Rule 105   operation -> value operator LPAREN operation RPAREN
Rule 106   operation -> value double_operator
Rule 107   double_operator -> INCREMENT
Rule 108   double_operator -> DECREMENT
Rule 109   control_structure -> conditional_structure
Rule 110   control_structure -> for_estructure
Rule 111   control_structure -> switch_structure
Rule 112   conditional_structure -> IF conditions conditional_body
Rule 113   conditional_structure -> IF conditions conditional_body ELSE conditional_body
Rule 114   conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body
Rule 115   conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
Rule 116   conditional_body -> LBRACE blocks RBRACE
Rule 117   conditional_body -> LBRACE blocks return RBRACE
Rule 118   conditional_body -> LBRACE return RBRACE
Rule 119   conditional_body -> LBRACE BREAK RBRACE
Rule 120   conditional_body -> LBRACE CONTINUE RBRACE
Rule 121   conditions -> condition
Rule 122   conditions -> condition logical_operator conditions
Rule 123   condition -> BOOL
Rule 124   condition -> value relational_operator values
Rule 125   logical_operator -> AND
Rule 126   logical_operator -> OR
Rule 127   logical_operator -> NOT
Rule 128   relational_operator -> GREATER
Rule 129   relational_operator -> LESS
Rule 130   relational_operator -> GREATEREQUALS
Rule 131   relational_operator -> LESSEQUALS
Rule 132   relational_operator -> EQUALS
Rule 133   relational_operator -> DIFFERENT
Rule 134   for_estructure -> for_initialization
Rule 135   for_estructure -> for_infinite_bucle
Rule 136   for_estructure -> for_iterator
Rule 137   for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
Rule 138   for_infinite_bucle -> FOR LBRACE statement RBRACE
Rule 139   for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
Rule 140   switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE
Rule 141   switch_expression -> VARIABLE SHORTASSIGN value
Rule 142   switch_expression -> empty
Rule 143   case_blocks -> case_block
Rule 144   case_blocks -> case_block case_blocks
Rule 145   case_block -> CASE values COLON statement
Rule 146   case_block -> DEFAULT COLON statement
Rule 147   empty -> <empty>
Rule 148   data_structure -> array_structure
Rule 149   data_structure -> map_structure
Rule 150   data_structure -> slice_structure
Rule 151   data_structure -> struct_structure
Rule 152   struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
Rule 153   struct_fields -> struct_field
Rule 154   struct_fields -> struct_field struct_fields
Rule 155   struct_field -> VARIABLE type
Rule 156   array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type
Rule 157   array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
Rule 158   array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
Rule 159   array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value
Rule 160   map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
Rule 161   map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
Rule 162   map_values -> map_value
Rule 163   map_values -> map_value COMMA map_values
Rule 164   map_value -> value COLON value
Rule 165   map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value
Rule 166   slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
Rule 167   slice_structure -> VAR VARIABLE LBRACKET RBRACKET type
Rule 168   slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type
Rule 169   slice_structure -> VARIABLE ASSIGN append_statement
Rule 170   append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN
Rule 171   append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN

Terminals, with rules where they appear

AND                  : 89 125
APPEND               : 170 171
ASSIGN               : 41 42 45 51 157 158 159 165 169
BOOL                 : 37 66 123
BREAK                : 119
CASE                 : 145
CHARSTRING           : 10 12 13 34
COLON                : 145 146 164
COMMA                : 29 39 58 79 139 163 170 171
CONST                : 45
CONTINUE             : 120
DECREMENT            : 108
DEFAULT              : 146
DIFFERENT            : 97 133
DIVIDE               : 88
DIVIDEASSIGN         : 55
ELSE                 : 113 114 115 115
ELSEIF               : 
EQUALS               : 96 132
FLOAT                : 36 63
FLOAT32              : 64
FLOAT64              : 65
FOR                  : 137 138 139
FORMATSTRING         : 79
FUNCTION             : 16 67 68 69 70 71 72 73 74
GREATER              : 94 128
GREATEREQUALS        : 95 130
IF                   : 112 113 114 114 115 115
IMPORT               : 10 11
INCREMENT            : 107
INPUT                : 82 83 84
INT                  : 35 59 156 157 158 159
INT32                : 60
INT64                : 61
LBRACE               : 5 6 7 8 67 68 69 70 71 72 73 74 116 117 118 119 120 137 138 139 140 152 157 160 166 171
LBRACKET             : 31 32 76 156 157 158 158 159 160 161 165 166 167 168 171
LESS                 : 92 129
LESSEQUALS           : 93 131
LPAREN               : 11 16 67 68 69 70 71 72 73 74 78 79 80 81 82 83 84 99 100 101 103 104 105 161 170 171
MAIN                 : 15 16
MAKE                 : 161
MAP                  : 160 161
MINUS                : 86
MINUSASSIGN          : 53
MODASSIGN            : 56
NOT                  : 91 127
OR                   : 90 126
PACKAGE              : 14 15
PERIOD               : 77
PLUS                 : 85
PLUSASSIGN           : 52
PRINT                : 78 80 81
PRINTF               : 79
RANGE                : 139
RBRACE               : 5 6 7 8 67 68 69 70 71 72 73 74 116 117 118 119 120 137 138 139 140 152 157 160 166 171
RBRACKET             : 31 32 76 156 157 158 158 159 160 161 165 166 167 168 171
RETURN               : 75 76 77
RPAREN               : 11 16 67 68 69 70 71 72 73 74 78 79 80 81 82 83 84 99 100 101 103 104 105 161 170 171
SEMICOLON            : 19 137 137
SHORTASSIGN          : 43 44 137 139 141 160 161 166 168
STRING               : 62
STRUCT               : 152
SWITCH               : 140
TIMES                : 87
TIMESASSIGN          : 54
TYPE                 : 152
VAR                  : 40 41 42 156 157 158 167
VARIABLE             : 14 28 29 31 32 33 43 44 45 46 47 48 57 58 67 68 69 70 71 72 73 74 137 139 139 139 141 152 155 156 157 158 159 160 161 165 166 167 168 169 170 171
error                : 

Nonterminals, with rules where they appear

append_statement     : 169
array_assign         : 50
array_structure      : 148
assignation          : 46 47
block                : 17 18 19
blocks               : 1 2 3 4 5 6 7 8 18 19 68 69 71 73 116 117
case_block           : 143 144
case_blocks          : 140 144
condition            : 121 122 137
conditional_body     : 112 113 113 114 114 115 115 115
conditional_structure : 109
conditions           : 112 113 114 114 115 115 122
control_structure    : 24
data_structure       : 23
double_operator      : 48 106 137
empty                : 142
for_estructure       : 110
for_infinite_bucle   : 135
for_initialization   : 134
for_iterator         : 136
function             : 25
import               : 2 4 7 8
input_statement      : 21
logical_operator     : 122
main                 : 5 6 7 8
map_assign           : 49
map_structure        : 149
map_value            : 162 163
map_values           : 160 163
not_variable_value   : 30
operation            : 22 42 44 47 80 83 102 103 104 105
operator             : 98 99 100 101 102 103 104 105
package              : 3 4 6 8
parameters           : 58 71 72 73 74
print_statement      : 20
relational_operator  : 124
return               : 69 70 73 74 117 118
slice_structure      : 150
statement            : 137 138 139 145 146 0
struct_field         : 153 154
struct_fields        : 152 154
struct_structure     : 151
switch_expression    : 140
switch_structure     : 111
type                 : 40 41 42 57 58 69 70 73 74 155 156 157 158 160 160 161 161 166 167 168 171
value                : 32 38 39 41 43 45 46 75 76 76 77 77 98 98 99 99 100 100 101 101 102 103 104 105 106 124 137 137 141 159 164 164 165 165
values               : 39 78 79 82 124 145 157 158 166 170 171
values_for_import    : 11 13
variable_assignation : 27
variable_declaration : 26
variables            : 29 40 41 42

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! LPAREN          [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]
  ! BOOL            [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 1
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 1

    (0) S' -> statement .



state 2

    (1) statement -> blocks .

    $end            reduce using rule 1 (statement -> blocks .)
    RBRACE          reduce using rule 1 (statement -> blocks .)
    CASE            reduce using rule 1 (statement -> blocks .)
    DEFAULT         reduce using rule 1 (statement -> blocks .)


state 3

    (2) statement -> import . blocks
    (7) statement -> import . main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

    blocks                         shift and go to state 47
    main                           shift and go to state 48
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 4

    (3) statement -> package . blocks
    (4) statement -> package . import blocks
    (6) statement -> package . main LBRACE blocks RBRACE
    (8) statement -> package . import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    IMPORT          shift and go to state 7
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! LPAREN          [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]
  ! BOOL            [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]

    blocks                         shift and go to state 49
    import                         shift and go to state 50
    main                           shift and go to state 51
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 5

    (5) statement -> main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 52


state 6

    (17) blocks -> block .
    (18) blocks -> block . blocks
    (19) blocks -> block . SEMICOLON blocks
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    $end            reduce using rule 17 (blocks -> block .)
    RBRACE          reduce using rule 17 (blocks -> block .)
    CASE            reduce using rule 17 (blocks -> block .)
    DEFAULT         reduce using rule 17 (blocks -> block .)
    RETURN          reduce using rule 17 (blocks -> block .)
    SEMICOLON       shift and go to state 54
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

    block                          shift and go to state 6
    blocks                         shift and go to state 53
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 7

    (10) import -> IMPORT . CHARSTRING
    (11) import -> IMPORT . LPAREN values_for_import RPAREN

    CHARSTRING      shift and go to state 56
    LPAREN          shift and go to state 57


state 8

    (34) not_variable_value -> CHARSTRING .

    PLUS            reduce using rule 34 (not_variable_value -> CHARSTRING .)
    MINUS           reduce using rule 34 (not_variable_value -> CHARSTRING .)
    TIMES           reduce using rule 34 (not_variable_value -> CHARSTRING .)
    DIVIDE          reduce using rule 34 (not_variable_value -> CHARSTRING .)
    AND             reduce using rule 34 (not_variable_value -> CHARSTRING .)
    OR              reduce using rule 34 (not_variable_value -> CHARSTRING .)
    NOT             reduce using rule 34 (not_variable_value -> CHARSTRING .)
    LESS            reduce using rule 34 (not_variable_value -> CHARSTRING .)
    LESSEQUALS      reduce using rule 34 (not_variable_value -> CHARSTRING .)
    GREATER         reduce using rule 34 (not_variable_value -> CHARSTRING .)
    GREATEREQUALS   reduce using rule 34 (not_variable_value -> CHARSTRING .)
    EQUALS          reduce using rule 34 (not_variable_value -> CHARSTRING .)
    DIFFERENT       reduce using rule 34 (not_variable_value -> CHARSTRING .)
    INCREMENT       reduce using rule 34 (not_variable_value -> CHARSTRING .)
    DECREMENT       reduce using rule 34 (not_variable_value -> CHARSTRING .)
    RPAREN          reduce using rule 34 (not_variable_value -> CHARSTRING .)
    SEMICOLON       reduce using rule 34 (not_variable_value -> CHARSTRING .)
    PRINT           reduce using rule 34 (not_variable_value -> CHARSTRING .)
    PRINTF          reduce using rule 34 (not_variable_value -> CHARSTRING .)
    INPUT           reduce using rule 34 (not_variable_value -> CHARSTRING .)
    LPAREN          reduce using rule 34 (not_variable_value -> CHARSTRING .)
    FUNCTION        reduce using rule 34 (not_variable_value -> CHARSTRING .)
    VAR             reduce using rule 34 (not_variable_value -> CHARSTRING .)
    VARIABLE        reduce using rule 34 (not_variable_value -> CHARSTRING .)
    CONST           reduce using rule 34 (not_variable_value -> CHARSTRING .)
    TYPE            reduce using rule 34 (not_variable_value -> CHARSTRING .)
    IF              reduce using rule 34 (not_variable_value -> CHARSTRING .)
    SWITCH          reduce using rule 34 (not_variable_value -> CHARSTRING .)
    CHARSTRING      reduce using rule 34 (not_variable_value -> CHARSTRING .)
    INT             reduce using rule 34 (not_variable_value -> CHARSTRING .)
    FLOAT           reduce using rule 34 (not_variable_value -> CHARSTRING .)
    BOOL            reduce using rule 34 (not_variable_value -> CHARSTRING .)
    FOR             reduce using rule 34 (not_variable_value -> CHARSTRING .)
    $end            reduce using rule 34 (not_variable_value -> CHARSTRING .)
    RBRACE          reduce using rule 34 (not_variable_value -> CHARSTRING .)
    CASE            reduce using rule 34 (not_variable_value -> CHARSTRING .)
    DEFAULT         reduce using rule 34 (not_variable_value -> CHARSTRING .)
    RETURN          reduce using rule 34 (not_variable_value -> CHARSTRING .)
    RBRACKET        reduce using rule 34 (not_variable_value -> CHARSTRING .)
    COMMA           reduce using rule 34 (not_variable_value -> CHARSTRING .)
    LBRACE          reduce using rule 34 (not_variable_value -> CHARSTRING .)
    COLON           reduce using rule 34 (not_variable_value -> CHARSTRING .)
    LBRACKET        reduce using rule 34 (not_variable_value -> CHARSTRING .)
    PERIOD          reduce using rule 34 (not_variable_value -> CHARSTRING .)


state 9

    (100) operation -> LPAREN . value RPAREN operator value
    (101) operation -> LPAREN . value operator value RPAREN
    (103) operation -> LPAREN . value operator operation RPAREN
    (104) operation -> LPAREN . value RPAREN operator operation
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 58
    not_variable_value             shift and go to state 36

state 10

    (14) package -> PACKAGE . VARIABLE
    (15) package -> PACKAGE . MAIN

    VARIABLE        shift and go to state 60
    MAIN            shift and go to state 61


state 11

    (43) variable_declaration -> VARIABLE . SHORTASSIGN value
    (44) variable_declaration -> VARIABLE . SHORTASSIGN operation
    (46) variable_assignation -> VARIABLE . assignation value
    (47) variable_assignation -> VARIABLE . assignation operation
    (48) variable_assignation -> VARIABLE . double_operator
    (31) value -> VARIABLE . LBRACKET RBRACKET
    (32) value -> VARIABLE . LBRACKET value RBRACKET
    (33) value -> VARIABLE .
    (160) map_structure -> VARIABLE . SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> VARIABLE . SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> VARIABLE . SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (168) slice_structure -> VARIABLE . SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> VARIABLE . ASSIGN append_statement
    (165) map_assign -> VARIABLE . LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> VARIABLE . LBRACKET INT RBRACKET ASSIGN value
    (51) assignation -> . ASSIGN
    (52) assignation -> . PLUSASSIGN
    (53) assignation -> . MINUSASSIGN
    (54) assignation -> . TIMESASSIGN
    (55) assignation -> . DIVIDEASSIGN
    (56) assignation -> . MODASSIGN
    (107) double_operator -> . INCREMENT
    (108) double_operator -> . DECREMENT

  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
    SHORTASSIGN     shift and go to state 62
    LBRACKET        shift and go to state 65
    PLUS            reduce using rule 33 (value -> VARIABLE .)
    MINUS           reduce using rule 33 (value -> VARIABLE .)
    TIMES           reduce using rule 33 (value -> VARIABLE .)
    DIVIDE          reduce using rule 33 (value -> VARIABLE .)
    AND             reduce using rule 33 (value -> VARIABLE .)
    OR              reduce using rule 33 (value -> VARIABLE .)
    NOT             reduce using rule 33 (value -> VARIABLE .)
    LESS            reduce using rule 33 (value -> VARIABLE .)
    LESSEQUALS      reduce using rule 33 (value -> VARIABLE .)
    GREATER         reduce using rule 33 (value -> VARIABLE .)
    GREATEREQUALS   reduce using rule 33 (value -> VARIABLE .)
    EQUALS          reduce using rule 33 (value -> VARIABLE .)
    DIFFERENT       reduce using rule 33 (value -> VARIABLE .)
    ASSIGN          shift and go to state 66
    PLUSASSIGN      shift and go to state 67
    MINUSASSIGN     shift and go to state 68
    TIMESASSIGN     shift and go to state 69
    DIVIDEASSIGN    shift and go to state 70
    MODASSIGN       shift and go to state 71
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

  ! INCREMENT       [ reduce using rule 33 (value -> VARIABLE .) ]
  ! DECREMENT       [ reduce using rule 33 (value -> VARIABLE .) ]

    assignation                    shift and go to state 63
    double_operator                shift and go to state 64

state 12

    (16) main -> FUNCTION . MAIN LPAREN RPAREN
    (67) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE

    MAIN            shift and go to state 74
    VARIABLE        shift and go to state 75


state 13

    (20) block -> print_statement .

    SEMICOLON       reduce using rule 20 (block -> print_statement .)
    PRINT           reduce using rule 20 (block -> print_statement .)
    PRINTF          reduce using rule 20 (block -> print_statement .)
    INPUT           reduce using rule 20 (block -> print_statement .)
    LPAREN          reduce using rule 20 (block -> print_statement .)
    FUNCTION        reduce using rule 20 (block -> print_statement .)
    VAR             reduce using rule 20 (block -> print_statement .)
    VARIABLE        reduce using rule 20 (block -> print_statement .)
    CONST           reduce using rule 20 (block -> print_statement .)
    TYPE            reduce using rule 20 (block -> print_statement .)
    IF              reduce using rule 20 (block -> print_statement .)
    SWITCH          reduce using rule 20 (block -> print_statement .)
    CHARSTRING      reduce using rule 20 (block -> print_statement .)
    INT             reduce using rule 20 (block -> print_statement .)
    FLOAT           reduce using rule 20 (block -> print_statement .)
    BOOL            reduce using rule 20 (block -> print_statement .)
    FOR             reduce using rule 20 (block -> print_statement .)
    $end            reduce using rule 20 (block -> print_statement .)
    RBRACE          reduce using rule 20 (block -> print_statement .)
    CASE            reduce using rule 20 (block -> print_statement .)
    DEFAULT         reduce using rule 20 (block -> print_statement .)
    RETURN          reduce using rule 20 (block -> print_statement .)


state 14

    (21) block -> input_statement .

    SEMICOLON       reduce using rule 21 (block -> input_statement .)
    PRINT           reduce using rule 21 (block -> input_statement .)
    PRINTF          reduce using rule 21 (block -> input_statement .)
    INPUT           reduce using rule 21 (block -> input_statement .)
    LPAREN          reduce using rule 21 (block -> input_statement .)
    FUNCTION        reduce using rule 21 (block -> input_statement .)
    VAR             reduce using rule 21 (block -> input_statement .)
    VARIABLE        reduce using rule 21 (block -> input_statement .)
    CONST           reduce using rule 21 (block -> input_statement .)
    TYPE            reduce using rule 21 (block -> input_statement .)
    IF              reduce using rule 21 (block -> input_statement .)
    SWITCH          reduce using rule 21 (block -> input_statement .)
    CHARSTRING      reduce using rule 21 (block -> input_statement .)
    INT             reduce using rule 21 (block -> input_statement .)
    FLOAT           reduce using rule 21 (block -> input_statement .)
    BOOL            reduce using rule 21 (block -> input_statement .)
    FOR             reduce using rule 21 (block -> input_statement .)
    $end            reduce using rule 21 (block -> input_statement .)
    RBRACE          reduce using rule 21 (block -> input_statement .)
    CASE            reduce using rule 21 (block -> input_statement .)
    DEFAULT         reduce using rule 21 (block -> input_statement .)
    RETURN          reduce using rule 21 (block -> input_statement .)


state 15

    (22) block -> operation .

    SEMICOLON       reduce using rule 22 (block -> operation .)
    PRINT           reduce using rule 22 (block -> operation .)
    PRINTF          reduce using rule 22 (block -> operation .)
    INPUT           reduce using rule 22 (block -> operation .)
    LPAREN          reduce using rule 22 (block -> operation .)
    FUNCTION        reduce using rule 22 (block -> operation .)
    VAR             reduce using rule 22 (block -> operation .)
    VARIABLE        reduce using rule 22 (block -> operation .)
    CONST           reduce using rule 22 (block -> operation .)
    TYPE            reduce using rule 22 (block -> operation .)
    IF              reduce using rule 22 (block -> operation .)
    SWITCH          reduce using rule 22 (block -> operation .)
    CHARSTRING      reduce using rule 22 (block -> operation .)
    INT             reduce using rule 22 (block -> operation .)
    FLOAT           reduce using rule 22 (block -> operation .)
    BOOL            reduce using rule 22 (block -> operation .)
    FOR             reduce using rule 22 (block -> operation .)
    $end            reduce using rule 22 (block -> operation .)
    RBRACE          reduce using rule 22 (block -> operation .)
    CASE            reduce using rule 22 (block -> operation .)
    DEFAULT         reduce using rule 22 (block -> operation .)
    RETURN          reduce using rule 22 (block -> operation .)


state 16

    (23) block -> data_structure .

    SEMICOLON       reduce using rule 23 (block -> data_structure .)
    PRINT           reduce using rule 23 (block -> data_structure .)
    PRINTF          reduce using rule 23 (block -> data_structure .)
    INPUT           reduce using rule 23 (block -> data_structure .)
    LPAREN          reduce using rule 23 (block -> data_structure .)
    FUNCTION        reduce using rule 23 (block -> data_structure .)
    VAR             reduce using rule 23 (block -> data_structure .)
    VARIABLE        reduce using rule 23 (block -> data_structure .)
    CONST           reduce using rule 23 (block -> data_structure .)
    TYPE            reduce using rule 23 (block -> data_structure .)
    IF              reduce using rule 23 (block -> data_structure .)
    SWITCH          reduce using rule 23 (block -> data_structure .)
    CHARSTRING      reduce using rule 23 (block -> data_structure .)
    INT             reduce using rule 23 (block -> data_structure .)
    FLOAT           reduce using rule 23 (block -> data_structure .)
    BOOL            reduce using rule 23 (block -> data_structure .)
    FOR             reduce using rule 23 (block -> data_structure .)
    $end            reduce using rule 23 (block -> data_structure .)
    RBRACE          reduce using rule 23 (block -> data_structure .)
    CASE            reduce using rule 23 (block -> data_structure .)
    DEFAULT         reduce using rule 23 (block -> data_structure .)
    RETURN          reduce using rule 23 (block -> data_structure .)


state 17

    (24) block -> control_structure .

    SEMICOLON       reduce using rule 24 (block -> control_structure .)
    PRINT           reduce using rule 24 (block -> control_structure .)
    PRINTF          reduce using rule 24 (block -> control_structure .)
    INPUT           reduce using rule 24 (block -> control_structure .)
    LPAREN          reduce using rule 24 (block -> control_structure .)
    FUNCTION        reduce using rule 24 (block -> control_structure .)
    VAR             reduce using rule 24 (block -> control_structure .)
    VARIABLE        reduce using rule 24 (block -> control_structure .)
    CONST           reduce using rule 24 (block -> control_structure .)
    TYPE            reduce using rule 24 (block -> control_structure .)
    IF              reduce using rule 24 (block -> control_structure .)
    SWITCH          reduce using rule 24 (block -> control_structure .)
    CHARSTRING      reduce using rule 24 (block -> control_structure .)
    INT             reduce using rule 24 (block -> control_structure .)
    FLOAT           reduce using rule 24 (block -> control_structure .)
    BOOL            reduce using rule 24 (block -> control_structure .)
    FOR             reduce using rule 24 (block -> control_structure .)
    $end            reduce using rule 24 (block -> control_structure .)
    RBRACE          reduce using rule 24 (block -> control_structure .)
    CASE            reduce using rule 24 (block -> control_structure .)
    DEFAULT         reduce using rule 24 (block -> control_structure .)
    RETURN          reduce using rule 24 (block -> control_structure .)


state 18

    (25) block -> function .

    SEMICOLON       reduce using rule 25 (block -> function .)
    PRINT           reduce using rule 25 (block -> function .)
    PRINTF          reduce using rule 25 (block -> function .)
    INPUT           reduce using rule 25 (block -> function .)
    LPAREN          reduce using rule 25 (block -> function .)
    FUNCTION        reduce using rule 25 (block -> function .)
    VAR             reduce using rule 25 (block -> function .)
    VARIABLE        reduce using rule 25 (block -> function .)
    CONST           reduce using rule 25 (block -> function .)
    TYPE            reduce using rule 25 (block -> function .)
    IF              reduce using rule 25 (block -> function .)
    SWITCH          reduce using rule 25 (block -> function .)
    CHARSTRING      reduce using rule 25 (block -> function .)
    INT             reduce using rule 25 (block -> function .)
    FLOAT           reduce using rule 25 (block -> function .)
    BOOL            reduce using rule 25 (block -> function .)
    FOR             reduce using rule 25 (block -> function .)
    $end            reduce using rule 25 (block -> function .)
    RBRACE          reduce using rule 25 (block -> function .)
    CASE            reduce using rule 25 (block -> function .)
    DEFAULT         reduce using rule 25 (block -> function .)
    RETURN          reduce using rule 25 (block -> function .)


state 19

    (26) block -> variable_declaration .

    SEMICOLON       reduce using rule 26 (block -> variable_declaration .)
    PRINT           reduce using rule 26 (block -> variable_declaration .)
    PRINTF          reduce using rule 26 (block -> variable_declaration .)
    INPUT           reduce using rule 26 (block -> variable_declaration .)
    LPAREN          reduce using rule 26 (block -> variable_declaration .)
    FUNCTION        reduce using rule 26 (block -> variable_declaration .)
    VAR             reduce using rule 26 (block -> variable_declaration .)
    VARIABLE        reduce using rule 26 (block -> variable_declaration .)
    CONST           reduce using rule 26 (block -> variable_declaration .)
    TYPE            reduce using rule 26 (block -> variable_declaration .)
    IF              reduce using rule 26 (block -> variable_declaration .)
    SWITCH          reduce using rule 26 (block -> variable_declaration .)
    CHARSTRING      reduce using rule 26 (block -> variable_declaration .)
    INT             reduce using rule 26 (block -> variable_declaration .)
    FLOAT           reduce using rule 26 (block -> variable_declaration .)
    BOOL            reduce using rule 26 (block -> variable_declaration .)
    FOR             reduce using rule 26 (block -> variable_declaration .)
    $end            reduce using rule 26 (block -> variable_declaration .)
    RBRACE          reduce using rule 26 (block -> variable_declaration .)
    CASE            reduce using rule 26 (block -> variable_declaration .)
    DEFAULT         reduce using rule 26 (block -> variable_declaration .)
    RETURN          reduce using rule 26 (block -> variable_declaration .)


state 20

    (27) block -> variable_assignation .

    SEMICOLON       reduce using rule 27 (block -> variable_assignation .)
    PRINT           reduce using rule 27 (block -> variable_assignation .)
    PRINTF          reduce using rule 27 (block -> variable_assignation .)
    INPUT           reduce using rule 27 (block -> variable_assignation .)
    LPAREN          reduce using rule 27 (block -> variable_assignation .)
    FUNCTION        reduce using rule 27 (block -> variable_assignation .)
    VAR             reduce using rule 27 (block -> variable_assignation .)
    VARIABLE        reduce using rule 27 (block -> variable_assignation .)
    CONST           reduce using rule 27 (block -> variable_assignation .)
    TYPE            reduce using rule 27 (block -> variable_assignation .)
    IF              reduce using rule 27 (block -> variable_assignation .)
    SWITCH          reduce using rule 27 (block -> variable_assignation .)
    CHARSTRING      reduce using rule 27 (block -> variable_assignation .)
    INT             reduce using rule 27 (block -> variable_assignation .)
    FLOAT           reduce using rule 27 (block -> variable_assignation .)
    BOOL            reduce using rule 27 (block -> variable_assignation .)
    FOR             reduce using rule 27 (block -> variable_assignation .)
    $end            reduce using rule 27 (block -> variable_assignation .)
    RBRACE          reduce using rule 27 (block -> variable_assignation .)
    CASE            reduce using rule 27 (block -> variable_assignation .)
    DEFAULT         reduce using rule 27 (block -> variable_assignation .)
    RETURN          reduce using rule 27 (block -> variable_assignation .)


state 21

    (78) print_statement -> PRINT . LPAREN values RPAREN
    (80) print_statement -> PRINT . LPAREN operation RPAREN
    (81) print_statement -> PRINT . LPAREN RPAREN

    LPAREN          shift and go to state 76


state 22

    (79) print_statement -> PRINTF . LPAREN FORMATSTRING COMMA values RPAREN

    LPAREN          shift and go to state 77


state 23

    (82) input_statement -> INPUT . LPAREN values RPAREN
    (83) input_statement -> INPUT . LPAREN operation RPAREN
    (84) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 78


state 24

    (98) operation -> value . operator value
    (99) operation -> value . operator LPAREN value RPAREN
    (102) operation -> value . operator operation
    (105) operation -> value . operator LPAREN operation RPAREN
    (106) operation -> value . double_operator
    (85) operator -> . PLUS
    (86) operator -> . MINUS
    (87) operator -> . TIMES
    (88) operator -> . DIVIDE
    (89) operator -> . AND
    (90) operator -> . OR
    (91) operator -> . NOT
    (92) operator -> . LESS
    (93) operator -> . LESSEQUALS
    (94) operator -> . GREATER
    (95) operator -> . GREATEREQUALS
    (96) operator -> . EQUALS
    (97) operator -> . DIFFERENT
    (107) double_operator -> . INCREMENT
    (108) double_operator -> . DECREMENT

    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    NOT             shift and go to state 87
    LESS            shift and go to state 88
    LESSEQUALS      shift and go to state 89
    GREATER         shift and go to state 90
    GREATEREQUALS   shift and go to state 91
    EQUALS          shift and go to state 92
    DIFFERENT       shift and go to state 93
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    operator                       shift and go to state 79
    double_operator                shift and go to state 80

state 25

    (148) data_structure -> array_structure .

    SEMICOLON       reduce using rule 148 (data_structure -> array_structure .)
    PRINT           reduce using rule 148 (data_structure -> array_structure .)
    PRINTF          reduce using rule 148 (data_structure -> array_structure .)
    INPUT           reduce using rule 148 (data_structure -> array_structure .)
    LPAREN          reduce using rule 148 (data_structure -> array_structure .)
    FUNCTION        reduce using rule 148 (data_structure -> array_structure .)
    VAR             reduce using rule 148 (data_structure -> array_structure .)
    VARIABLE        reduce using rule 148 (data_structure -> array_structure .)
    CONST           reduce using rule 148 (data_structure -> array_structure .)
    TYPE            reduce using rule 148 (data_structure -> array_structure .)
    IF              reduce using rule 148 (data_structure -> array_structure .)
    SWITCH          reduce using rule 148 (data_structure -> array_structure .)
    CHARSTRING      reduce using rule 148 (data_structure -> array_structure .)
    INT             reduce using rule 148 (data_structure -> array_structure .)
    FLOAT           reduce using rule 148 (data_structure -> array_structure .)
    BOOL            reduce using rule 148 (data_structure -> array_structure .)
    FOR             reduce using rule 148 (data_structure -> array_structure .)
    $end            reduce using rule 148 (data_structure -> array_structure .)
    RBRACE          reduce using rule 148 (data_structure -> array_structure .)
    CASE            reduce using rule 148 (data_structure -> array_structure .)
    DEFAULT         reduce using rule 148 (data_structure -> array_structure .)
    RETURN          reduce using rule 148 (data_structure -> array_structure .)


state 26

    (149) data_structure -> map_structure .

    SEMICOLON       reduce using rule 149 (data_structure -> map_structure .)
    PRINT           reduce using rule 149 (data_structure -> map_structure .)
    PRINTF          reduce using rule 149 (data_structure -> map_structure .)
    INPUT           reduce using rule 149 (data_structure -> map_structure .)
    LPAREN          reduce using rule 149 (data_structure -> map_structure .)
    FUNCTION        reduce using rule 149 (data_structure -> map_structure .)
    VAR             reduce using rule 149 (data_structure -> map_structure .)
    VARIABLE        reduce using rule 149 (data_structure -> map_structure .)
    CONST           reduce using rule 149 (data_structure -> map_structure .)
    TYPE            reduce using rule 149 (data_structure -> map_structure .)
    IF              reduce using rule 149 (data_structure -> map_structure .)
    SWITCH          reduce using rule 149 (data_structure -> map_structure .)
    CHARSTRING      reduce using rule 149 (data_structure -> map_structure .)
    INT             reduce using rule 149 (data_structure -> map_structure .)
    FLOAT           reduce using rule 149 (data_structure -> map_structure .)
    BOOL            reduce using rule 149 (data_structure -> map_structure .)
    FOR             reduce using rule 149 (data_structure -> map_structure .)
    $end            reduce using rule 149 (data_structure -> map_structure .)
    RBRACE          reduce using rule 149 (data_structure -> map_structure .)
    CASE            reduce using rule 149 (data_structure -> map_structure .)
    DEFAULT         reduce using rule 149 (data_structure -> map_structure .)
    RETURN          reduce using rule 149 (data_structure -> map_structure .)


state 27

    (150) data_structure -> slice_structure .

    SEMICOLON       reduce using rule 150 (data_structure -> slice_structure .)
    PRINT           reduce using rule 150 (data_structure -> slice_structure .)
    PRINTF          reduce using rule 150 (data_structure -> slice_structure .)
    INPUT           reduce using rule 150 (data_structure -> slice_structure .)
    LPAREN          reduce using rule 150 (data_structure -> slice_structure .)
    FUNCTION        reduce using rule 150 (data_structure -> slice_structure .)
    VAR             reduce using rule 150 (data_structure -> slice_structure .)
    VARIABLE        reduce using rule 150 (data_structure -> slice_structure .)
    CONST           reduce using rule 150 (data_structure -> slice_structure .)
    TYPE            reduce using rule 150 (data_structure -> slice_structure .)
    IF              reduce using rule 150 (data_structure -> slice_structure .)
    SWITCH          reduce using rule 150 (data_structure -> slice_structure .)
    CHARSTRING      reduce using rule 150 (data_structure -> slice_structure .)
    INT             reduce using rule 150 (data_structure -> slice_structure .)
    FLOAT           reduce using rule 150 (data_structure -> slice_structure .)
    BOOL            reduce using rule 150 (data_structure -> slice_structure .)
    FOR             reduce using rule 150 (data_structure -> slice_structure .)
    $end            reduce using rule 150 (data_structure -> slice_structure .)
    RBRACE          reduce using rule 150 (data_structure -> slice_structure .)
    CASE            reduce using rule 150 (data_structure -> slice_structure .)
    DEFAULT         reduce using rule 150 (data_structure -> slice_structure .)
    RETURN          reduce using rule 150 (data_structure -> slice_structure .)


state 28

    (151) data_structure -> struct_structure .

    SEMICOLON       reduce using rule 151 (data_structure -> struct_structure .)
    PRINT           reduce using rule 151 (data_structure -> struct_structure .)
    PRINTF          reduce using rule 151 (data_structure -> struct_structure .)
    INPUT           reduce using rule 151 (data_structure -> struct_structure .)
    LPAREN          reduce using rule 151 (data_structure -> struct_structure .)
    FUNCTION        reduce using rule 151 (data_structure -> struct_structure .)
    VAR             reduce using rule 151 (data_structure -> struct_structure .)
    VARIABLE        reduce using rule 151 (data_structure -> struct_structure .)
    CONST           reduce using rule 151 (data_structure -> struct_structure .)
    TYPE            reduce using rule 151 (data_structure -> struct_structure .)
    IF              reduce using rule 151 (data_structure -> struct_structure .)
    SWITCH          reduce using rule 151 (data_structure -> struct_structure .)
    CHARSTRING      reduce using rule 151 (data_structure -> struct_structure .)
    INT             reduce using rule 151 (data_structure -> struct_structure .)
    FLOAT           reduce using rule 151 (data_structure -> struct_structure .)
    BOOL            reduce using rule 151 (data_structure -> struct_structure .)
    FOR             reduce using rule 151 (data_structure -> struct_structure .)
    $end            reduce using rule 151 (data_structure -> struct_structure .)
    RBRACE          reduce using rule 151 (data_structure -> struct_structure .)
    CASE            reduce using rule 151 (data_structure -> struct_structure .)
    DEFAULT         reduce using rule 151 (data_structure -> struct_structure .)
    RETURN          reduce using rule 151 (data_structure -> struct_structure .)


state 29

    (109) control_structure -> conditional_structure .

    SEMICOLON       reduce using rule 109 (control_structure -> conditional_structure .)
    PRINT           reduce using rule 109 (control_structure -> conditional_structure .)
    PRINTF          reduce using rule 109 (control_structure -> conditional_structure .)
    INPUT           reduce using rule 109 (control_structure -> conditional_structure .)
    LPAREN          reduce using rule 109 (control_structure -> conditional_structure .)
    FUNCTION        reduce using rule 109 (control_structure -> conditional_structure .)
    VAR             reduce using rule 109 (control_structure -> conditional_structure .)
    VARIABLE        reduce using rule 109 (control_structure -> conditional_structure .)
    CONST           reduce using rule 109 (control_structure -> conditional_structure .)
    TYPE            reduce using rule 109 (control_structure -> conditional_structure .)
    IF              reduce using rule 109 (control_structure -> conditional_structure .)
    SWITCH          reduce using rule 109 (control_structure -> conditional_structure .)
    CHARSTRING      reduce using rule 109 (control_structure -> conditional_structure .)
    INT             reduce using rule 109 (control_structure -> conditional_structure .)
    FLOAT           reduce using rule 109 (control_structure -> conditional_structure .)
    BOOL            reduce using rule 109 (control_structure -> conditional_structure .)
    FOR             reduce using rule 109 (control_structure -> conditional_structure .)
    $end            reduce using rule 109 (control_structure -> conditional_structure .)
    RBRACE          reduce using rule 109 (control_structure -> conditional_structure .)
    CASE            reduce using rule 109 (control_structure -> conditional_structure .)
    DEFAULT         reduce using rule 109 (control_structure -> conditional_structure .)
    RETURN          reduce using rule 109 (control_structure -> conditional_structure .)


state 30

    (110) control_structure -> for_estructure .

    SEMICOLON       reduce using rule 110 (control_structure -> for_estructure .)
    PRINT           reduce using rule 110 (control_structure -> for_estructure .)
    PRINTF          reduce using rule 110 (control_structure -> for_estructure .)
    INPUT           reduce using rule 110 (control_structure -> for_estructure .)
    LPAREN          reduce using rule 110 (control_structure -> for_estructure .)
    FUNCTION        reduce using rule 110 (control_structure -> for_estructure .)
    VAR             reduce using rule 110 (control_structure -> for_estructure .)
    VARIABLE        reduce using rule 110 (control_structure -> for_estructure .)
    CONST           reduce using rule 110 (control_structure -> for_estructure .)
    TYPE            reduce using rule 110 (control_structure -> for_estructure .)
    IF              reduce using rule 110 (control_structure -> for_estructure .)
    SWITCH          reduce using rule 110 (control_structure -> for_estructure .)
    CHARSTRING      reduce using rule 110 (control_structure -> for_estructure .)
    INT             reduce using rule 110 (control_structure -> for_estructure .)
    FLOAT           reduce using rule 110 (control_structure -> for_estructure .)
    BOOL            reduce using rule 110 (control_structure -> for_estructure .)
    FOR             reduce using rule 110 (control_structure -> for_estructure .)
    $end            reduce using rule 110 (control_structure -> for_estructure .)
    RBRACE          reduce using rule 110 (control_structure -> for_estructure .)
    CASE            reduce using rule 110 (control_structure -> for_estructure .)
    DEFAULT         reduce using rule 110 (control_structure -> for_estructure .)
    RETURN          reduce using rule 110 (control_structure -> for_estructure .)


state 31

    (111) control_structure -> switch_structure .

    SEMICOLON       reduce using rule 111 (control_structure -> switch_structure .)
    PRINT           reduce using rule 111 (control_structure -> switch_structure .)
    PRINTF          reduce using rule 111 (control_structure -> switch_structure .)
    INPUT           reduce using rule 111 (control_structure -> switch_structure .)
    LPAREN          reduce using rule 111 (control_structure -> switch_structure .)
    FUNCTION        reduce using rule 111 (control_structure -> switch_structure .)
    VAR             reduce using rule 111 (control_structure -> switch_structure .)
    VARIABLE        reduce using rule 111 (control_structure -> switch_structure .)
    CONST           reduce using rule 111 (control_structure -> switch_structure .)
    TYPE            reduce using rule 111 (control_structure -> switch_structure .)
    IF              reduce using rule 111 (control_structure -> switch_structure .)
    SWITCH          reduce using rule 111 (control_structure -> switch_structure .)
    CHARSTRING      reduce using rule 111 (control_structure -> switch_structure .)
    INT             reduce using rule 111 (control_structure -> switch_structure .)
    FLOAT           reduce using rule 111 (control_structure -> switch_structure .)
    BOOL            reduce using rule 111 (control_structure -> switch_structure .)
    FOR             reduce using rule 111 (control_structure -> switch_structure .)
    $end            reduce using rule 111 (control_structure -> switch_structure .)
    RBRACE          reduce using rule 111 (control_structure -> switch_structure .)
    CASE            reduce using rule 111 (control_structure -> switch_structure .)
    DEFAULT         reduce using rule 111 (control_structure -> switch_structure .)
    RETURN          reduce using rule 111 (control_structure -> switch_structure .)


state 32

    (40) variable_declaration -> VAR . variables type
    (41) variable_declaration -> VAR . variables type ASSIGN value
    (42) variable_declaration -> VAR . variables type ASSIGN operation
    (156) array_structure -> VAR . VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> VAR . VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> VAR . VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (167) slice_structure -> VAR . VARIABLE LBRACKET RBRACKET type
    (28) variables -> . VARIABLE
    (29) variables -> . VARIABLE COMMA variables

    VARIABLE        shift and go to state 95

    variables                      shift and go to state 94

state 33

    (45) variable_declaration -> CONST . VARIABLE ASSIGN value

    VARIABLE        shift and go to state 96


state 34

    (49) variable_assignation -> map_assign .

    SEMICOLON       reduce using rule 49 (variable_assignation -> map_assign .)
    PRINT           reduce using rule 49 (variable_assignation -> map_assign .)
    PRINTF          reduce using rule 49 (variable_assignation -> map_assign .)
    INPUT           reduce using rule 49 (variable_assignation -> map_assign .)
    LPAREN          reduce using rule 49 (variable_assignation -> map_assign .)
    FUNCTION        reduce using rule 49 (variable_assignation -> map_assign .)
    VAR             reduce using rule 49 (variable_assignation -> map_assign .)
    VARIABLE        reduce using rule 49 (variable_assignation -> map_assign .)
    CONST           reduce using rule 49 (variable_assignation -> map_assign .)
    TYPE            reduce using rule 49 (variable_assignation -> map_assign .)
    IF              reduce using rule 49 (variable_assignation -> map_assign .)
    SWITCH          reduce using rule 49 (variable_assignation -> map_assign .)
    CHARSTRING      reduce using rule 49 (variable_assignation -> map_assign .)
    INT             reduce using rule 49 (variable_assignation -> map_assign .)
    FLOAT           reduce using rule 49 (variable_assignation -> map_assign .)
    BOOL            reduce using rule 49 (variable_assignation -> map_assign .)
    FOR             reduce using rule 49 (variable_assignation -> map_assign .)
    $end            reduce using rule 49 (variable_assignation -> map_assign .)
    RBRACE          reduce using rule 49 (variable_assignation -> map_assign .)
    CASE            reduce using rule 49 (variable_assignation -> map_assign .)
    DEFAULT         reduce using rule 49 (variable_assignation -> map_assign .)
    RETURN          reduce using rule 49 (variable_assignation -> map_assign .)


state 35

    (50) variable_assignation -> array_assign .

    SEMICOLON       reduce using rule 50 (variable_assignation -> array_assign .)
    PRINT           reduce using rule 50 (variable_assignation -> array_assign .)
    PRINTF          reduce using rule 50 (variable_assignation -> array_assign .)
    INPUT           reduce using rule 50 (variable_assignation -> array_assign .)
    LPAREN          reduce using rule 50 (variable_assignation -> array_assign .)
    FUNCTION        reduce using rule 50 (variable_assignation -> array_assign .)
    VAR             reduce using rule 50 (variable_assignation -> array_assign .)
    VARIABLE        reduce using rule 50 (variable_assignation -> array_assign .)
    CONST           reduce using rule 50 (variable_assignation -> array_assign .)
    TYPE            reduce using rule 50 (variable_assignation -> array_assign .)
    IF              reduce using rule 50 (variable_assignation -> array_assign .)
    SWITCH          reduce using rule 50 (variable_assignation -> array_assign .)
    CHARSTRING      reduce using rule 50 (variable_assignation -> array_assign .)
    INT             reduce using rule 50 (variable_assignation -> array_assign .)
    FLOAT           reduce using rule 50 (variable_assignation -> array_assign .)
    BOOL            reduce using rule 50 (variable_assignation -> array_assign .)
    FOR             reduce using rule 50 (variable_assignation -> array_assign .)
    $end            reduce using rule 50 (variable_assignation -> array_assign .)
    RBRACE          reduce using rule 50 (variable_assignation -> array_assign .)
    CASE            reduce using rule 50 (variable_assignation -> array_assign .)
    DEFAULT         reduce using rule 50 (variable_assignation -> array_assign .)
    RETURN          reduce using rule 50 (variable_assignation -> array_assign .)


state 36

    (30) value -> not_variable_value .

    PLUS            reduce using rule 30 (value -> not_variable_value .)
    MINUS           reduce using rule 30 (value -> not_variable_value .)
    TIMES           reduce using rule 30 (value -> not_variable_value .)
    DIVIDE          reduce using rule 30 (value -> not_variable_value .)
    AND             reduce using rule 30 (value -> not_variable_value .)
    OR              reduce using rule 30 (value -> not_variable_value .)
    NOT             reduce using rule 30 (value -> not_variable_value .)
    LESS            reduce using rule 30 (value -> not_variable_value .)
    LESSEQUALS      reduce using rule 30 (value -> not_variable_value .)
    GREATER         reduce using rule 30 (value -> not_variable_value .)
    GREATEREQUALS   reduce using rule 30 (value -> not_variable_value .)
    EQUALS          reduce using rule 30 (value -> not_variable_value .)
    DIFFERENT       reduce using rule 30 (value -> not_variable_value .)
    INCREMENT       reduce using rule 30 (value -> not_variable_value .)
    DECREMENT       reduce using rule 30 (value -> not_variable_value .)
    RPAREN          reduce using rule 30 (value -> not_variable_value .)
    SEMICOLON       reduce using rule 30 (value -> not_variable_value .)
    PRINT           reduce using rule 30 (value -> not_variable_value .)
    PRINTF          reduce using rule 30 (value -> not_variable_value .)
    INPUT           reduce using rule 30 (value -> not_variable_value .)
    LPAREN          reduce using rule 30 (value -> not_variable_value .)
    FUNCTION        reduce using rule 30 (value -> not_variable_value .)
    VAR             reduce using rule 30 (value -> not_variable_value .)
    VARIABLE        reduce using rule 30 (value -> not_variable_value .)
    CONST           reduce using rule 30 (value -> not_variable_value .)
    TYPE            reduce using rule 30 (value -> not_variable_value .)
    IF              reduce using rule 30 (value -> not_variable_value .)
    SWITCH          reduce using rule 30 (value -> not_variable_value .)
    CHARSTRING      reduce using rule 30 (value -> not_variable_value .)
    INT             reduce using rule 30 (value -> not_variable_value .)
    FLOAT           reduce using rule 30 (value -> not_variable_value .)
    BOOL            reduce using rule 30 (value -> not_variable_value .)
    FOR             reduce using rule 30 (value -> not_variable_value .)
    $end            reduce using rule 30 (value -> not_variable_value .)
    RBRACE          reduce using rule 30 (value -> not_variable_value .)
    CASE            reduce using rule 30 (value -> not_variable_value .)
    DEFAULT         reduce using rule 30 (value -> not_variable_value .)
    RETURN          reduce using rule 30 (value -> not_variable_value .)
    RBRACKET        reduce using rule 30 (value -> not_variable_value .)
    COMMA           reduce using rule 30 (value -> not_variable_value .)
    LBRACE          reduce using rule 30 (value -> not_variable_value .)
    COLON           reduce using rule 30 (value -> not_variable_value .)
    LBRACKET        reduce using rule 30 (value -> not_variable_value .)
    PERIOD          reduce using rule 30 (value -> not_variable_value .)


state 37

    (35) not_variable_value -> INT .

    PLUS            reduce using rule 35 (not_variable_value -> INT .)
    MINUS           reduce using rule 35 (not_variable_value -> INT .)
    TIMES           reduce using rule 35 (not_variable_value -> INT .)
    DIVIDE          reduce using rule 35 (not_variable_value -> INT .)
    AND             reduce using rule 35 (not_variable_value -> INT .)
    OR              reduce using rule 35 (not_variable_value -> INT .)
    NOT             reduce using rule 35 (not_variable_value -> INT .)
    LESS            reduce using rule 35 (not_variable_value -> INT .)
    LESSEQUALS      reduce using rule 35 (not_variable_value -> INT .)
    GREATER         reduce using rule 35 (not_variable_value -> INT .)
    GREATEREQUALS   reduce using rule 35 (not_variable_value -> INT .)
    EQUALS          reduce using rule 35 (not_variable_value -> INT .)
    DIFFERENT       reduce using rule 35 (not_variable_value -> INT .)
    INCREMENT       reduce using rule 35 (not_variable_value -> INT .)
    DECREMENT       reduce using rule 35 (not_variable_value -> INT .)
    RPAREN          reduce using rule 35 (not_variable_value -> INT .)
    SEMICOLON       reduce using rule 35 (not_variable_value -> INT .)
    PRINT           reduce using rule 35 (not_variable_value -> INT .)
    PRINTF          reduce using rule 35 (not_variable_value -> INT .)
    INPUT           reduce using rule 35 (not_variable_value -> INT .)
    LPAREN          reduce using rule 35 (not_variable_value -> INT .)
    FUNCTION        reduce using rule 35 (not_variable_value -> INT .)
    VAR             reduce using rule 35 (not_variable_value -> INT .)
    VARIABLE        reduce using rule 35 (not_variable_value -> INT .)
    CONST           reduce using rule 35 (not_variable_value -> INT .)
    TYPE            reduce using rule 35 (not_variable_value -> INT .)
    IF              reduce using rule 35 (not_variable_value -> INT .)
    SWITCH          reduce using rule 35 (not_variable_value -> INT .)
    CHARSTRING      reduce using rule 35 (not_variable_value -> INT .)
    INT             reduce using rule 35 (not_variable_value -> INT .)
    FLOAT           reduce using rule 35 (not_variable_value -> INT .)
    BOOL            reduce using rule 35 (not_variable_value -> INT .)
    FOR             reduce using rule 35 (not_variable_value -> INT .)
    $end            reduce using rule 35 (not_variable_value -> INT .)
    RBRACE          reduce using rule 35 (not_variable_value -> INT .)
    CASE            reduce using rule 35 (not_variable_value -> INT .)
    DEFAULT         reduce using rule 35 (not_variable_value -> INT .)
    RETURN          reduce using rule 35 (not_variable_value -> INT .)
    COMMA           reduce using rule 35 (not_variable_value -> INT .)
    RBRACKET        reduce using rule 35 (not_variable_value -> INT .)
    LBRACE          reduce using rule 35 (not_variable_value -> INT .)
    COLON           reduce using rule 35 (not_variable_value -> INT .)
    LBRACKET        reduce using rule 35 (not_variable_value -> INT .)
    PERIOD          reduce using rule 35 (not_variable_value -> INT .)


state 38

    (152) struct_structure -> TYPE . VARIABLE STRUCT LBRACE struct_fields RBRACE

    VARIABLE        shift and go to state 97


state 39

    (112) conditional_structure -> IF . conditions conditional_body
    (113) conditional_structure -> IF . conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> IF . conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> IF . conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (121) conditions -> . condition
    (122) conditions -> . condition logical_operator conditions
    (123) condition -> . BOOL
    (124) condition -> . value relational_operator values
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    BOOL            shift and go to state 100
    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44

    conditions                     shift and go to state 98
    condition                      shift and go to state 99
    value                          shift and go to state 101
    not_variable_value             shift and go to state 36

state 40

    (134) for_estructure -> for_initialization .

    SEMICOLON       reduce using rule 134 (for_estructure -> for_initialization .)
    PRINT           reduce using rule 134 (for_estructure -> for_initialization .)
    PRINTF          reduce using rule 134 (for_estructure -> for_initialization .)
    INPUT           reduce using rule 134 (for_estructure -> for_initialization .)
    LPAREN          reduce using rule 134 (for_estructure -> for_initialization .)
    FUNCTION        reduce using rule 134 (for_estructure -> for_initialization .)
    VAR             reduce using rule 134 (for_estructure -> for_initialization .)
    VARIABLE        reduce using rule 134 (for_estructure -> for_initialization .)
    CONST           reduce using rule 134 (for_estructure -> for_initialization .)
    TYPE            reduce using rule 134 (for_estructure -> for_initialization .)
    IF              reduce using rule 134 (for_estructure -> for_initialization .)
    SWITCH          reduce using rule 134 (for_estructure -> for_initialization .)
    CHARSTRING      reduce using rule 134 (for_estructure -> for_initialization .)
    INT             reduce using rule 134 (for_estructure -> for_initialization .)
    FLOAT           reduce using rule 134 (for_estructure -> for_initialization .)
    BOOL            reduce using rule 134 (for_estructure -> for_initialization .)
    FOR             reduce using rule 134 (for_estructure -> for_initialization .)
    $end            reduce using rule 134 (for_estructure -> for_initialization .)
    RBRACE          reduce using rule 134 (for_estructure -> for_initialization .)
    CASE            reduce using rule 134 (for_estructure -> for_initialization .)
    DEFAULT         reduce using rule 134 (for_estructure -> for_initialization .)
    RETURN          reduce using rule 134 (for_estructure -> for_initialization .)


state 41

    (135) for_estructure -> for_infinite_bucle .

    SEMICOLON       reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    PRINT           reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    PRINTF          reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    INPUT           reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    LPAREN          reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    FUNCTION        reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    VAR             reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    VARIABLE        reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    CONST           reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    TYPE            reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    IF              reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    SWITCH          reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    CHARSTRING      reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    INT             reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    FLOAT           reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    BOOL            reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    FOR             reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    $end            reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    RBRACE          reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    CASE            reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    DEFAULT         reduce using rule 135 (for_estructure -> for_infinite_bucle .)
    RETURN          reduce using rule 135 (for_estructure -> for_infinite_bucle .)


state 42

    (136) for_estructure -> for_iterator .

    SEMICOLON       reduce using rule 136 (for_estructure -> for_iterator .)
    PRINT           reduce using rule 136 (for_estructure -> for_iterator .)
    PRINTF          reduce using rule 136 (for_estructure -> for_iterator .)
    INPUT           reduce using rule 136 (for_estructure -> for_iterator .)
    LPAREN          reduce using rule 136 (for_estructure -> for_iterator .)
    FUNCTION        reduce using rule 136 (for_estructure -> for_iterator .)
    VAR             reduce using rule 136 (for_estructure -> for_iterator .)
    VARIABLE        reduce using rule 136 (for_estructure -> for_iterator .)
    CONST           reduce using rule 136 (for_estructure -> for_iterator .)
    TYPE            reduce using rule 136 (for_estructure -> for_iterator .)
    IF              reduce using rule 136 (for_estructure -> for_iterator .)
    SWITCH          reduce using rule 136 (for_estructure -> for_iterator .)
    CHARSTRING      reduce using rule 136 (for_estructure -> for_iterator .)
    INT             reduce using rule 136 (for_estructure -> for_iterator .)
    FLOAT           reduce using rule 136 (for_estructure -> for_iterator .)
    BOOL            reduce using rule 136 (for_estructure -> for_iterator .)
    FOR             reduce using rule 136 (for_estructure -> for_iterator .)
    $end            reduce using rule 136 (for_estructure -> for_iterator .)
    RBRACE          reduce using rule 136 (for_estructure -> for_iterator .)
    CASE            reduce using rule 136 (for_estructure -> for_iterator .)
    DEFAULT         reduce using rule 136 (for_estructure -> for_iterator .)
    RETURN          reduce using rule 136 (for_estructure -> for_iterator .)


state 43

    (140) switch_structure -> SWITCH . switch_expression LBRACE case_blocks RBRACE
    (141) switch_expression -> . VARIABLE SHORTASSIGN value
    (142) switch_expression -> . empty
    (147) empty -> .

    VARIABLE        shift and go to state 103
    LBRACE          reduce using rule 147 (empty -> .)

    switch_expression              shift and go to state 102
    empty                          shift and go to state 104

state 44

    (36) not_variable_value -> FLOAT .

    PLUS            reduce using rule 36 (not_variable_value -> FLOAT .)
    MINUS           reduce using rule 36 (not_variable_value -> FLOAT .)
    TIMES           reduce using rule 36 (not_variable_value -> FLOAT .)
    DIVIDE          reduce using rule 36 (not_variable_value -> FLOAT .)
    AND             reduce using rule 36 (not_variable_value -> FLOAT .)
    OR              reduce using rule 36 (not_variable_value -> FLOAT .)
    NOT             reduce using rule 36 (not_variable_value -> FLOAT .)
    LESS            reduce using rule 36 (not_variable_value -> FLOAT .)
    LESSEQUALS      reduce using rule 36 (not_variable_value -> FLOAT .)
    GREATER         reduce using rule 36 (not_variable_value -> FLOAT .)
    GREATEREQUALS   reduce using rule 36 (not_variable_value -> FLOAT .)
    EQUALS          reduce using rule 36 (not_variable_value -> FLOAT .)
    DIFFERENT       reduce using rule 36 (not_variable_value -> FLOAT .)
    INCREMENT       reduce using rule 36 (not_variable_value -> FLOAT .)
    DECREMENT       reduce using rule 36 (not_variable_value -> FLOAT .)
    RPAREN          reduce using rule 36 (not_variable_value -> FLOAT .)
    SEMICOLON       reduce using rule 36 (not_variable_value -> FLOAT .)
    PRINT           reduce using rule 36 (not_variable_value -> FLOAT .)
    PRINTF          reduce using rule 36 (not_variable_value -> FLOAT .)
    INPUT           reduce using rule 36 (not_variable_value -> FLOAT .)
    LPAREN          reduce using rule 36 (not_variable_value -> FLOAT .)
    FUNCTION        reduce using rule 36 (not_variable_value -> FLOAT .)
    VAR             reduce using rule 36 (not_variable_value -> FLOAT .)
    VARIABLE        reduce using rule 36 (not_variable_value -> FLOAT .)
    CONST           reduce using rule 36 (not_variable_value -> FLOAT .)
    TYPE            reduce using rule 36 (not_variable_value -> FLOAT .)
    IF              reduce using rule 36 (not_variable_value -> FLOAT .)
    SWITCH          reduce using rule 36 (not_variable_value -> FLOAT .)
    CHARSTRING      reduce using rule 36 (not_variable_value -> FLOAT .)
    INT             reduce using rule 36 (not_variable_value -> FLOAT .)
    FLOAT           reduce using rule 36 (not_variable_value -> FLOAT .)
    BOOL            reduce using rule 36 (not_variable_value -> FLOAT .)
    FOR             reduce using rule 36 (not_variable_value -> FLOAT .)
    $end            reduce using rule 36 (not_variable_value -> FLOAT .)
    RBRACE          reduce using rule 36 (not_variable_value -> FLOAT .)
    CASE            reduce using rule 36 (not_variable_value -> FLOAT .)
    DEFAULT         reduce using rule 36 (not_variable_value -> FLOAT .)
    RETURN          reduce using rule 36 (not_variable_value -> FLOAT .)
    RBRACKET        reduce using rule 36 (not_variable_value -> FLOAT .)
    COMMA           reduce using rule 36 (not_variable_value -> FLOAT .)
    LBRACE          reduce using rule 36 (not_variable_value -> FLOAT .)
    COLON           reduce using rule 36 (not_variable_value -> FLOAT .)
    LBRACKET        reduce using rule 36 (not_variable_value -> FLOAT .)
    PERIOD          reduce using rule 36 (not_variable_value -> FLOAT .)


state 45

    (37) not_variable_value -> BOOL .

    PLUS            reduce using rule 37 (not_variable_value -> BOOL .)
    MINUS           reduce using rule 37 (not_variable_value -> BOOL .)
    TIMES           reduce using rule 37 (not_variable_value -> BOOL .)
    DIVIDE          reduce using rule 37 (not_variable_value -> BOOL .)
    AND             reduce using rule 37 (not_variable_value -> BOOL .)
    OR              reduce using rule 37 (not_variable_value -> BOOL .)
    NOT             reduce using rule 37 (not_variable_value -> BOOL .)
    LESS            reduce using rule 37 (not_variable_value -> BOOL .)
    LESSEQUALS      reduce using rule 37 (not_variable_value -> BOOL .)
    GREATER         reduce using rule 37 (not_variable_value -> BOOL .)
    GREATEREQUALS   reduce using rule 37 (not_variable_value -> BOOL .)
    EQUALS          reduce using rule 37 (not_variable_value -> BOOL .)
    DIFFERENT       reduce using rule 37 (not_variable_value -> BOOL .)
    INCREMENT       reduce using rule 37 (not_variable_value -> BOOL .)
    DECREMENT       reduce using rule 37 (not_variable_value -> BOOL .)
    RPAREN          reduce using rule 37 (not_variable_value -> BOOL .)
    SEMICOLON       reduce using rule 37 (not_variable_value -> BOOL .)
    PRINT           reduce using rule 37 (not_variable_value -> BOOL .)
    PRINTF          reduce using rule 37 (not_variable_value -> BOOL .)
    INPUT           reduce using rule 37 (not_variable_value -> BOOL .)
    LPAREN          reduce using rule 37 (not_variable_value -> BOOL .)
    FUNCTION        reduce using rule 37 (not_variable_value -> BOOL .)
    VAR             reduce using rule 37 (not_variable_value -> BOOL .)
    VARIABLE        reduce using rule 37 (not_variable_value -> BOOL .)
    CONST           reduce using rule 37 (not_variable_value -> BOOL .)
    TYPE            reduce using rule 37 (not_variable_value -> BOOL .)
    IF              reduce using rule 37 (not_variable_value -> BOOL .)
    SWITCH          reduce using rule 37 (not_variable_value -> BOOL .)
    CHARSTRING      reduce using rule 37 (not_variable_value -> BOOL .)
    INT             reduce using rule 37 (not_variable_value -> BOOL .)
    FLOAT           reduce using rule 37 (not_variable_value -> BOOL .)
    BOOL            reduce using rule 37 (not_variable_value -> BOOL .)
    FOR             reduce using rule 37 (not_variable_value -> BOOL .)
    $end            reduce using rule 37 (not_variable_value -> BOOL .)
    RBRACE          reduce using rule 37 (not_variable_value -> BOOL .)
    CASE            reduce using rule 37 (not_variable_value -> BOOL .)
    DEFAULT         reduce using rule 37 (not_variable_value -> BOOL .)
    RETURN          reduce using rule 37 (not_variable_value -> BOOL .)
    RBRACKET        reduce using rule 37 (not_variable_value -> BOOL .)
    COMMA           reduce using rule 37 (not_variable_value -> BOOL .)
    LBRACE          reduce using rule 37 (not_variable_value -> BOOL .)
    COLON           reduce using rule 37 (not_variable_value -> BOOL .)
    LBRACKET        reduce using rule 37 (not_variable_value -> BOOL .)
    PERIOD          reduce using rule 37 (not_variable_value -> BOOL .)


state 46

    (137) for_initialization -> FOR . VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> FOR . LBRACE statement RBRACE
    (139) for_iterator -> FOR . VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 105
    LBRACE          shift and go to state 106


state 47

    (2) statement -> import blocks .

    $end            reduce using rule 2 (statement -> import blocks .)
    RBRACE          reduce using rule 2 (statement -> import blocks .)
    CASE            reduce using rule 2 (statement -> import blocks .)
    DEFAULT         reduce using rule 2 (statement -> import blocks .)


state 48

    (7) statement -> import main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 107


state 49

    (3) statement -> package blocks .

    $end            reduce using rule 3 (statement -> package blocks .)
    RBRACE          reduce using rule 3 (statement -> package blocks .)
    CASE            reduce using rule 3 (statement -> package blocks .)
    DEFAULT         reduce using rule 3 (statement -> package blocks .)


state 50

    (4) statement -> package import . blocks
    (8) statement -> package import . main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

    blocks                         shift and go to state 108
    main                           shift and go to state 109
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 51

    (6) statement -> package main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 110


state 52

    (5) statement -> main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

    blocks                         shift and go to state 111
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 53

    (18) blocks -> block blocks .

    $end            reduce using rule 18 (blocks -> block blocks .)
    RBRACE          reduce using rule 18 (blocks -> block blocks .)
    CASE            reduce using rule 18 (blocks -> block blocks .)
    DEFAULT         reduce using rule 18 (blocks -> block blocks .)
    RETURN          reduce using rule 18 (blocks -> block blocks .)


state 54

    (19) blocks -> block SEMICOLON . blocks
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

    block                          shift and go to state 6
    blocks                         shift and go to state 112
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 55

    (67) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE

    VARIABLE        shift and go to state 75


state 56

    (10) import -> IMPORT CHARSTRING .

    FUNCTION        reduce using rule 10 (import -> IMPORT CHARSTRING .)
    PRINT           reduce using rule 10 (import -> IMPORT CHARSTRING .)
    PRINTF          reduce using rule 10 (import -> IMPORT CHARSTRING .)
    INPUT           reduce using rule 10 (import -> IMPORT CHARSTRING .)
    LPAREN          reduce using rule 10 (import -> IMPORT CHARSTRING .)
    VAR             reduce using rule 10 (import -> IMPORT CHARSTRING .)
    VARIABLE        reduce using rule 10 (import -> IMPORT CHARSTRING .)
    CONST           reduce using rule 10 (import -> IMPORT CHARSTRING .)
    TYPE            reduce using rule 10 (import -> IMPORT CHARSTRING .)
    IF              reduce using rule 10 (import -> IMPORT CHARSTRING .)
    SWITCH          reduce using rule 10 (import -> IMPORT CHARSTRING .)
    CHARSTRING      reduce using rule 10 (import -> IMPORT CHARSTRING .)
    INT             reduce using rule 10 (import -> IMPORT CHARSTRING .)
    FLOAT           reduce using rule 10 (import -> IMPORT CHARSTRING .)
    BOOL            reduce using rule 10 (import -> IMPORT CHARSTRING .)
    FOR             reduce using rule 10 (import -> IMPORT CHARSTRING .)


state 57

    (11) import -> IMPORT LPAREN . values_for_import RPAREN
    (12) values_for_import -> . CHARSTRING
    (13) values_for_import -> . CHARSTRING values_for_import

    CHARSTRING      shift and go to state 114

    values_for_import              shift and go to state 113

state 58

    (100) operation -> LPAREN value . RPAREN operator value
    (101) operation -> LPAREN value . operator value RPAREN
    (103) operation -> LPAREN value . operator operation RPAREN
    (104) operation -> LPAREN value . RPAREN operator operation
    (85) operator -> . PLUS
    (86) operator -> . MINUS
    (87) operator -> . TIMES
    (88) operator -> . DIVIDE
    (89) operator -> . AND
    (90) operator -> . OR
    (91) operator -> . NOT
    (92) operator -> . LESS
    (93) operator -> . LESSEQUALS
    (94) operator -> . GREATER
    (95) operator -> . GREATEREQUALS
    (96) operator -> . EQUALS
    (97) operator -> . DIFFERENT

    RPAREN          shift and go to state 115
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    NOT             shift and go to state 87
    LESS            shift and go to state 88
    LESSEQUALS      shift and go to state 89
    GREATER         shift and go to state 90
    GREATEREQUALS   shift and go to state 91
    EQUALS          shift and go to state 92
    DIFFERENT       shift and go to state 93

    operator                       shift and go to state 116

state 59

    (31) value -> VARIABLE . LBRACKET RBRACKET
    (32) value -> VARIABLE . LBRACKET value RBRACKET
    (33) value -> VARIABLE .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACKET        shift and go to state 117
    RPAREN          reduce using rule 33 (value -> VARIABLE .)
    PLUS            reduce using rule 33 (value -> VARIABLE .)
    MINUS           reduce using rule 33 (value -> VARIABLE .)
    TIMES           reduce using rule 33 (value -> VARIABLE .)
    DIVIDE          reduce using rule 33 (value -> VARIABLE .)
    AND             reduce using rule 33 (value -> VARIABLE .)
    OR              reduce using rule 33 (value -> VARIABLE .)
    NOT             reduce using rule 33 (value -> VARIABLE .)
    LESS            reduce using rule 33 (value -> VARIABLE .)
    LESSEQUALS      reduce using rule 33 (value -> VARIABLE .)
    GREATER         reduce using rule 33 (value -> VARIABLE .)
    GREATEREQUALS   reduce using rule 33 (value -> VARIABLE .)
    EQUALS          reduce using rule 33 (value -> VARIABLE .)
    DIFFERENT       reduce using rule 33 (value -> VARIABLE .)
    INCREMENT       reduce using rule 33 (value -> VARIABLE .)
    DECREMENT       reduce using rule 33 (value -> VARIABLE .)
    SEMICOLON       reduce using rule 33 (value -> VARIABLE .)
    PRINT           reduce using rule 33 (value -> VARIABLE .)
    PRINTF          reduce using rule 33 (value -> VARIABLE .)
    INPUT           reduce using rule 33 (value -> VARIABLE .)
    LPAREN          reduce using rule 33 (value -> VARIABLE .)
    FUNCTION        reduce using rule 33 (value -> VARIABLE .)
    VAR             reduce using rule 33 (value -> VARIABLE .)
    VARIABLE        reduce using rule 33 (value -> VARIABLE .)
    CONST           reduce using rule 33 (value -> VARIABLE .)
    TYPE            reduce using rule 33 (value -> VARIABLE .)
    IF              reduce using rule 33 (value -> VARIABLE .)
    SWITCH          reduce using rule 33 (value -> VARIABLE .)
    CHARSTRING      reduce using rule 33 (value -> VARIABLE .)
    INT             reduce using rule 33 (value -> VARIABLE .)
    FLOAT           reduce using rule 33 (value -> VARIABLE .)
    BOOL            reduce using rule 33 (value -> VARIABLE .)
    FOR             reduce using rule 33 (value -> VARIABLE .)
    $end            reduce using rule 33 (value -> VARIABLE .)
    RBRACE          reduce using rule 33 (value -> VARIABLE .)
    CASE            reduce using rule 33 (value -> VARIABLE .)
    DEFAULT         reduce using rule 33 (value -> VARIABLE .)
    RETURN          reduce using rule 33 (value -> VARIABLE .)
    RBRACKET        reduce using rule 33 (value -> VARIABLE .)
    COMMA           reduce using rule 33 (value -> VARIABLE .)
    LBRACE          reduce using rule 33 (value -> VARIABLE .)
    COLON           reduce using rule 33 (value -> VARIABLE .)
    PERIOD          reduce using rule 33 (value -> VARIABLE .)

  ! LBRACKET        [ reduce using rule 33 (value -> VARIABLE .) ]


state 60

    (14) package -> PACKAGE VARIABLE .

    IMPORT          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    FUNCTION        reduce using rule 14 (package -> PACKAGE VARIABLE .)
    PRINT           reduce using rule 14 (package -> PACKAGE VARIABLE .)
    PRINTF          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    INPUT           reduce using rule 14 (package -> PACKAGE VARIABLE .)
    LPAREN          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    VAR             reduce using rule 14 (package -> PACKAGE VARIABLE .)
    VARIABLE        reduce using rule 14 (package -> PACKAGE VARIABLE .)
    CONST           reduce using rule 14 (package -> PACKAGE VARIABLE .)
    TYPE            reduce using rule 14 (package -> PACKAGE VARIABLE .)
    IF              reduce using rule 14 (package -> PACKAGE VARIABLE .)
    SWITCH          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    CHARSTRING      reduce using rule 14 (package -> PACKAGE VARIABLE .)
    INT             reduce using rule 14 (package -> PACKAGE VARIABLE .)
    FLOAT           reduce using rule 14 (package -> PACKAGE VARIABLE .)
    BOOL            reduce using rule 14 (package -> PACKAGE VARIABLE .)
    FOR             reduce using rule 14 (package -> PACKAGE VARIABLE .)


state 61

    (15) package -> PACKAGE MAIN .

    IMPORT          reduce using rule 15 (package -> PACKAGE MAIN .)
    FUNCTION        reduce using rule 15 (package -> PACKAGE MAIN .)
    PRINT           reduce using rule 15 (package -> PACKAGE MAIN .)
    PRINTF          reduce using rule 15 (package -> PACKAGE MAIN .)
    INPUT           reduce using rule 15 (package -> PACKAGE MAIN .)
    LPAREN          reduce using rule 15 (package -> PACKAGE MAIN .)
    VAR             reduce using rule 15 (package -> PACKAGE MAIN .)
    VARIABLE        reduce using rule 15 (package -> PACKAGE MAIN .)
    CONST           reduce using rule 15 (package -> PACKAGE MAIN .)
    TYPE            reduce using rule 15 (package -> PACKAGE MAIN .)
    IF              reduce using rule 15 (package -> PACKAGE MAIN .)
    SWITCH          reduce using rule 15 (package -> PACKAGE MAIN .)
    CHARSTRING      reduce using rule 15 (package -> PACKAGE MAIN .)
    INT             reduce using rule 15 (package -> PACKAGE MAIN .)
    FLOAT           reduce using rule 15 (package -> PACKAGE MAIN .)
    BOOL            reduce using rule 15 (package -> PACKAGE MAIN .)
    FOR             reduce using rule 15 (package -> PACKAGE MAIN .)


state 62

    (43) variable_declaration -> VARIABLE SHORTASSIGN . value
    (44) variable_declaration -> VARIABLE SHORTASSIGN . operation
    (160) map_structure -> VARIABLE SHORTASSIGN . MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> VARIABLE SHORTASSIGN . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> VARIABLE SHORTASSIGN . LBRACKET RBRACKET type LBRACE values RBRACE
    (168) slice_structure -> VARIABLE SHORTASSIGN . LBRACKET RBRACKET type
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    MAP             shift and go to state 120
    MAKE            shift and go to state 122
    LBRACKET        shift and go to state 121
    VARIABLE        shift and go to state 59
    LPAREN          shift and go to state 9
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 118
    operation                      shift and go to state 119
    not_variable_value             shift and go to state 36

state 63

    (46) variable_assignation -> VARIABLE assignation . value
    (47) variable_assignation -> VARIABLE assignation . operation
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    LPAREN          shift and go to state 9
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 123
    operation                      shift and go to state 124
    not_variable_value             shift and go to state 36

state 64

    (48) variable_assignation -> VARIABLE double_operator .

    SEMICOLON       reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    PRINT           reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    PRINTF          reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    INPUT           reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    LPAREN          reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    FUNCTION        reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    VAR             reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    VARIABLE        reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    CONST           reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    TYPE            reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    IF              reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    SWITCH          reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    CHARSTRING      reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    INT             reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    FLOAT           reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    BOOL            reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    FOR             reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    $end            reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    RBRACE          reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    CASE            reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    DEFAULT         reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)
    RETURN          reduce using rule 48 (variable_assignation -> VARIABLE double_operator .)


state 65

    (31) value -> VARIABLE LBRACKET . RBRACKET
    (32) value -> VARIABLE LBRACKET . value RBRACKET
    (165) map_assign -> VARIABLE LBRACKET . value RBRACKET ASSIGN value
    (159) array_assign -> VARIABLE LBRACKET . INT RBRACKET ASSIGN value
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    RBRACKET        shift and go to state 125
    INT             shift and go to state 127
    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 126
    not_variable_value             shift and go to state 36

state 66

    (169) slice_structure -> VARIABLE ASSIGN . append_statement
    (51) assignation -> ASSIGN .
    (170) append_statement -> . APPEND LPAREN VARIABLE COMMA values RPAREN
    (171) append_statement -> . APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN

    VARIABLE        reduce using rule 51 (assignation -> ASSIGN .)
    LPAREN          reduce using rule 51 (assignation -> ASSIGN .)
    CHARSTRING      reduce using rule 51 (assignation -> ASSIGN .)
    INT             reduce using rule 51 (assignation -> ASSIGN .)
    FLOAT           reduce using rule 51 (assignation -> ASSIGN .)
    BOOL            reduce using rule 51 (assignation -> ASSIGN .)
    APPEND          shift and go to state 129

    append_statement               shift and go to state 128

state 67

    (52) assignation -> PLUSASSIGN .

    VARIABLE        reduce using rule 52 (assignation -> PLUSASSIGN .)
    LPAREN          reduce using rule 52 (assignation -> PLUSASSIGN .)
    CHARSTRING      reduce using rule 52 (assignation -> PLUSASSIGN .)
    INT             reduce using rule 52 (assignation -> PLUSASSIGN .)
    FLOAT           reduce using rule 52 (assignation -> PLUSASSIGN .)
    BOOL            reduce using rule 52 (assignation -> PLUSASSIGN .)


state 68

    (53) assignation -> MINUSASSIGN .

    VARIABLE        reduce using rule 53 (assignation -> MINUSASSIGN .)
    LPAREN          reduce using rule 53 (assignation -> MINUSASSIGN .)
    CHARSTRING      reduce using rule 53 (assignation -> MINUSASSIGN .)
    INT             reduce using rule 53 (assignation -> MINUSASSIGN .)
    FLOAT           reduce using rule 53 (assignation -> MINUSASSIGN .)
    BOOL            reduce using rule 53 (assignation -> MINUSASSIGN .)


state 69

    (54) assignation -> TIMESASSIGN .

    VARIABLE        reduce using rule 54 (assignation -> TIMESASSIGN .)
    LPAREN          reduce using rule 54 (assignation -> TIMESASSIGN .)
    CHARSTRING      reduce using rule 54 (assignation -> TIMESASSIGN .)
    INT             reduce using rule 54 (assignation -> TIMESASSIGN .)
    FLOAT           reduce using rule 54 (assignation -> TIMESASSIGN .)
    BOOL            reduce using rule 54 (assignation -> TIMESASSIGN .)


state 70

    (55) assignation -> DIVIDEASSIGN .

    VARIABLE        reduce using rule 55 (assignation -> DIVIDEASSIGN .)
    LPAREN          reduce using rule 55 (assignation -> DIVIDEASSIGN .)
    CHARSTRING      reduce using rule 55 (assignation -> DIVIDEASSIGN .)
    INT             reduce using rule 55 (assignation -> DIVIDEASSIGN .)
    FLOAT           reduce using rule 55 (assignation -> DIVIDEASSIGN .)
    BOOL            reduce using rule 55 (assignation -> DIVIDEASSIGN .)


state 71

    (56) assignation -> MODASSIGN .

    VARIABLE        reduce using rule 56 (assignation -> MODASSIGN .)
    LPAREN          reduce using rule 56 (assignation -> MODASSIGN .)
    CHARSTRING      reduce using rule 56 (assignation -> MODASSIGN .)
    INT             reduce using rule 56 (assignation -> MODASSIGN .)
    FLOAT           reduce using rule 56 (assignation -> MODASSIGN .)
    BOOL            reduce using rule 56 (assignation -> MODASSIGN .)


state 72

    (107) double_operator -> INCREMENT .

    SEMICOLON       reduce using rule 107 (double_operator -> INCREMENT .)
    PRINT           reduce using rule 107 (double_operator -> INCREMENT .)
    PRINTF          reduce using rule 107 (double_operator -> INCREMENT .)
    INPUT           reduce using rule 107 (double_operator -> INCREMENT .)
    LPAREN          reduce using rule 107 (double_operator -> INCREMENT .)
    FUNCTION        reduce using rule 107 (double_operator -> INCREMENT .)
    VAR             reduce using rule 107 (double_operator -> INCREMENT .)
    VARIABLE        reduce using rule 107 (double_operator -> INCREMENT .)
    CONST           reduce using rule 107 (double_operator -> INCREMENT .)
    TYPE            reduce using rule 107 (double_operator -> INCREMENT .)
    IF              reduce using rule 107 (double_operator -> INCREMENT .)
    SWITCH          reduce using rule 107 (double_operator -> INCREMENT .)
    CHARSTRING      reduce using rule 107 (double_operator -> INCREMENT .)
    INT             reduce using rule 107 (double_operator -> INCREMENT .)
    FLOAT           reduce using rule 107 (double_operator -> INCREMENT .)
    BOOL            reduce using rule 107 (double_operator -> INCREMENT .)
    FOR             reduce using rule 107 (double_operator -> INCREMENT .)
    $end            reduce using rule 107 (double_operator -> INCREMENT .)
    RBRACE          reduce using rule 107 (double_operator -> INCREMENT .)
    CASE            reduce using rule 107 (double_operator -> INCREMENT .)
    DEFAULT         reduce using rule 107 (double_operator -> INCREMENT .)
    RETURN          reduce using rule 107 (double_operator -> INCREMENT .)
    RPAREN          reduce using rule 107 (double_operator -> INCREMENT .)
    LBRACE          reduce using rule 107 (double_operator -> INCREMENT .)


state 73

    (108) double_operator -> DECREMENT .

    SEMICOLON       reduce using rule 108 (double_operator -> DECREMENT .)
    PRINT           reduce using rule 108 (double_operator -> DECREMENT .)
    PRINTF          reduce using rule 108 (double_operator -> DECREMENT .)
    INPUT           reduce using rule 108 (double_operator -> DECREMENT .)
    LPAREN          reduce using rule 108 (double_operator -> DECREMENT .)
    FUNCTION        reduce using rule 108 (double_operator -> DECREMENT .)
    VAR             reduce using rule 108 (double_operator -> DECREMENT .)
    VARIABLE        reduce using rule 108 (double_operator -> DECREMENT .)
    CONST           reduce using rule 108 (double_operator -> DECREMENT .)
    TYPE            reduce using rule 108 (double_operator -> DECREMENT .)
    IF              reduce using rule 108 (double_operator -> DECREMENT .)
    SWITCH          reduce using rule 108 (double_operator -> DECREMENT .)
    CHARSTRING      reduce using rule 108 (double_operator -> DECREMENT .)
    INT             reduce using rule 108 (double_operator -> DECREMENT .)
    FLOAT           reduce using rule 108 (double_operator -> DECREMENT .)
    BOOL            reduce using rule 108 (double_operator -> DECREMENT .)
    FOR             reduce using rule 108 (double_operator -> DECREMENT .)
    $end            reduce using rule 108 (double_operator -> DECREMENT .)
    RBRACE          reduce using rule 108 (double_operator -> DECREMENT .)
    CASE            reduce using rule 108 (double_operator -> DECREMENT .)
    DEFAULT         reduce using rule 108 (double_operator -> DECREMENT .)
    RETURN          reduce using rule 108 (double_operator -> DECREMENT .)
    RPAREN          reduce using rule 108 (double_operator -> DECREMENT .)
    LBRACE          reduce using rule 108 (double_operator -> DECREMENT .)


state 74

    (16) main -> FUNCTION MAIN . LPAREN RPAREN

    LPAREN          shift and go to state 130


state 75

    (67) function -> FUNCTION VARIABLE . LPAREN RPAREN LBRACE RBRACE
    (68) function -> FUNCTION VARIABLE . LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> FUNCTION VARIABLE . LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> FUNCTION VARIABLE . LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN type LBRACE return RBRACE

    LPAREN          shift and go to state 131


state 76

    (78) print_statement -> PRINT LPAREN . values RPAREN
    (80) print_statement -> PRINT LPAREN . operation RPAREN
    (81) print_statement -> PRINT LPAREN . RPAREN
    (38) values -> . value
    (39) values -> . value COMMA values
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    RPAREN          shift and go to state 133
    LPAREN          shift and go to state 9
    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    values                         shift and go to state 132
    operation                      shift and go to state 134
    value                          shift and go to state 135
    not_variable_value             shift and go to state 36

state 77

    (79) print_statement -> PRINTF LPAREN . FORMATSTRING COMMA values RPAREN

    FORMATSTRING    shift and go to state 136


state 78

    (82) input_statement -> INPUT LPAREN . values RPAREN
    (83) input_statement -> INPUT LPAREN . operation RPAREN
    (84) input_statement -> INPUT LPAREN . RPAREN
    (38) values -> . value
    (39) values -> . value COMMA values
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    RPAREN          shift and go to state 138
    LPAREN          shift and go to state 9
    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    values                         shift and go to state 137
    operation                      shift and go to state 139
    value                          shift and go to state 135
    not_variable_value             shift and go to state 36

state 79

    (98) operation -> value operator . value
    (99) operation -> value operator . LPAREN value RPAREN
    (102) operation -> value operator . operation
    (105) operation -> value operator . LPAREN operation RPAREN
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    LPAREN          shift and go to state 141
    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 140
    operation                      shift and go to state 142
    not_variable_value             shift and go to state 36

state 80

    (106) operation -> value double_operator .

    SEMICOLON       reduce using rule 106 (operation -> value double_operator .)
    PRINT           reduce using rule 106 (operation -> value double_operator .)
    PRINTF          reduce using rule 106 (operation -> value double_operator .)
    INPUT           reduce using rule 106 (operation -> value double_operator .)
    LPAREN          reduce using rule 106 (operation -> value double_operator .)
    FUNCTION        reduce using rule 106 (operation -> value double_operator .)
    VAR             reduce using rule 106 (operation -> value double_operator .)
    VARIABLE        reduce using rule 106 (operation -> value double_operator .)
    CONST           reduce using rule 106 (operation -> value double_operator .)
    TYPE            reduce using rule 106 (operation -> value double_operator .)
    IF              reduce using rule 106 (operation -> value double_operator .)
    SWITCH          reduce using rule 106 (operation -> value double_operator .)
    CHARSTRING      reduce using rule 106 (operation -> value double_operator .)
    INT             reduce using rule 106 (operation -> value double_operator .)
    FLOAT           reduce using rule 106 (operation -> value double_operator .)
    BOOL            reduce using rule 106 (operation -> value double_operator .)
    FOR             reduce using rule 106 (operation -> value double_operator .)
    $end            reduce using rule 106 (operation -> value double_operator .)
    RBRACE          reduce using rule 106 (operation -> value double_operator .)
    CASE            reduce using rule 106 (operation -> value double_operator .)
    DEFAULT         reduce using rule 106 (operation -> value double_operator .)
    RETURN          reduce using rule 106 (operation -> value double_operator .)
    RPAREN          reduce using rule 106 (operation -> value double_operator .)


state 81

    (85) operator -> PLUS .

    LPAREN          reduce using rule 85 (operator -> PLUS .)
    VARIABLE        reduce using rule 85 (operator -> PLUS .)
    CHARSTRING      reduce using rule 85 (operator -> PLUS .)
    INT             reduce using rule 85 (operator -> PLUS .)
    FLOAT           reduce using rule 85 (operator -> PLUS .)
    BOOL            reduce using rule 85 (operator -> PLUS .)


state 82

    (86) operator -> MINUS .

    LPAREN          reduce using rule 86 (operator -> MINUS .)
    VARIABLE        reduce using rule 86 (operator -> MINUS .)
    CHARSTRING      reduce using rule 86 (operator -> MINUS .)
    INT             reduce using rule 86 (operator -> MINUS .)
    FLOAT           reduce using rule 86 (operator -> MINUS .)
    BOOL            reduce using rule 86 (operator -> MINUS .)


state 83

    (87) operator -> TIMES .

    LPAREN          reduce using rule 87 (operator -> TIMES .)
    VARIABLE        reduce using rule 87 (operator -> TIMES .)
    CHARSTRING      reduce using rule 87 (operator -> TIMES .)
    INT             reduce using rule 87 (operator -> TIMES .)
    FLOAT           reduce using rule 87 (operator -> TIMES .)
    BOOL            reduce using rule 87 (operator -> TIMES .)


state 84

    (88) operator -> DIVIDE .

    LPAREN          reduce using rule 88 (operator -> DIVIDE .)
    VARIABLE        reduce using rule 88 (operator -> DIVIDE .)
    CHARSTRING      reduce using rule 88 (operator -> DIVIDE .)
    INT             reduce using rule 88 (operator -> DIVIDE .)
    FLOAT           reduce using rule 88 (operator -> DIVIDE .)
    BOOL            reduce using rule 88 (operator -> DIVIDE .)


state 85

    (89) operator -> AND .

    LPAREN          reduce using rule 89 (operator -> AND .)
    VARIABLE        reduce using rule 89 (operator -> AND .)
    CHARSTRING      reduce using rule 89 (operator -> AND .)
    INT             reduce using rule 89 (operator -> AND .)
    FLOAT           reduce using rule 89 (operator -> AND .)
    BOOL            reduce using rule 89 (operator -> AND .)


state 86

    (90) operator -> OR .

    LPAREN          reduce using rule 90 (operator -> OR .)
    VARIABLE        reduce using rule 90 (operator -> OR .)
    CHARSTRING      reduce using rule 90 (operator -> OR .)
    INT             reduce using rule 90 (operator -> OR .)
    FLOAT           reduce using rule 90 (operator -> OR .)
    BOOL            reduce using rule 90 (operator -> OR .)


state 87

    (91) operator -> NOT .

    LPAREN          reduce using rule 91 (operator -> NOT .)
    VARIABLE        reduce using rule 91 (operator -> NOT .)
    CHARSTRING      reduce using rule 91 (operator -> NOT .)
    INT             reduce using rule 91 (operator -> NOT .)
    FLOAT           reduce using rule 91 (operator -> NOT .)
    BOOL            reduce using rule 91 (operator -> NOT .)


state 88

    (92) operator -> LESS .

    LPAREN          reduce using rule 92 (operator -> LESS .)
    VARIABLE        reduce using rule 92 (operator -> LESS .)
    CHARSTRING      reduce using rule 92 (operator -> LESS .)
    INT             reduce using rule 92 (operator -> LESS .)
    FLOAT           reduce using rule 92 (operator -> LESS .)
    BOOL            reduce using rule 92 (operator -> LESS .)


state 89

    (93) operator -> LESSEQUALS .

    LPAREN          reduce using rule 93 (operator -> LESSEQUALS .)
    VARIABLE        reduce using rule 93 (operator -> LESSEQUALS .)
    CHARSTRING      reduce using rule 93 (operator -> LESSEQUALS .)
    INT             reduce using rule 93 (operator -> LESSEQUALS .)
    FLOAT           reduce using rule 93 (operator -> LESSEQUALS .)
    BOOL            reduce using rule 93 (operator -> LESSEQUALS .)


state 90

    (94) operator -> GREATER .

    LPAREN          reduce using rule 94 (operator -> GREATER .)
    VARIABLE        reduce using rule 94 (operator -> GREATER .)
    CHARSTRING      reduce using rule 94 (operator -> GREATER .)
    INT             reduce using rule 94 (operator -> GREATER .)
    FLOAT           reduce using rule 94 (operator -> GREATER .)
    BOOL            reduce using rule 94 (operator -> GREATER .)


state 91

    (95) operator -> GREATEREQUALS .

    LPAREN          reduce using rule 95 (operator -> GREATEREQUALS .)
    VARIABLE        reduce using rule 95 (operator -> GREATEREQUALS .)
    CHARSTRING      reduce using rule 95 (operator -> GREATEREQUALS .)
    INT             reduce using rule 95 (operator -> GREATEREQUALS .)
    FLOAT           reduce using rule 95 (operator -> GREATEREQUALS .)
    BOOL            reduce using rule 95 (operator -> GREATEREQUALS .)


state 92

    (96) operator -> EQUALS .

    LPAREN          reduce using rule 96 (operator -> EQUALS .)
    VARIABLE        reduce using rule 96 (operator -> EQUALS .)
    CHARSTRING      reduce using rule 96 (operator -> EQUALS .)
    INT             reduce using rule 96 (operator -> EQUALS .)
    FLOAT           reduce using rule 96 (operator -> EQUALS .)
    BOOL            reduce using rule 96 (operator -> EQUALS .)


state 93

    (97) operator -> DIFFERENT .

    LPAREN          reduce using rule 97 (operator -> DIFFERENT .)
    VARIABLE        reduce using rule 97 (operator -> DIFFERENT .)
    CHARSTRING      reduce using rule 97 (operator -> DIFFERENT .)
    INT             reduce using rule 97 (operator -> DIFFERENT .)
    FLOAT           reduce using rule 97 (operator -> DIFFERENT .)
    BOOL            reduce using rule 97 (operator -> DIFFERENT .)


state 94

    (40) variable_declaration -> VAR variables . type
    (41) variable_declaration -> VAR variables . type ASSIGN value
    (42) variable_declaration -> VAR variables . type ASSIGN operation
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 144
    INT32           shift and go to state 145
    INT64           shift and go to state 146
    STRING          shift and go to state 147
    FLOAT           shift and go to state 148
    FLOAT32         shift and go to state 149
    FLOAT64         shift and go to state 150
    BOOL            shift and go to state 151

    type                           shift and go to state 143

state 95

    (156) array_structure -> VAR VARIABLE . LBRACKET INT RBRACKET type
    (157) array_structure -> VAR VARIABLE . ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> VAR VARIABLE . LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (167) slice_structure -> VAR VARIABLE . LBRACKET RBRACKET type
    (28) variables -> VARIABLE .
    (29) variables -> VARIABLE . COMMA variables

    LBRACKET        shift and go to state 152
    ASSIGN          shift and go to state 153
    INT             reduce using rule 28 (variables -> VARIABLE .)
    INT32           reduce using rule 28 (variables -> VARIABLE .)
    INT64           reduce using rule 28 (variables -> VARIABLE .)
    STRING          reduce using rule 28 (variables -> VARIABLE .)
    FLOAT           reduce using rule 28 (variables -> VARIABLE .)
    FLOAT32         reduce using rule 28 (variables -> VARIABLE .)
    FLOAT64         reduce using rule 28 (variables -> VARIABLE .)
    BOOL            reduce using rule 28 (variables -> VARIABLE .)
    COMMA           shift and go to state 154


state 96

    (45) variable_declaration -> CONST VARIABLE . ASSIGN value

    ASSIGN          shift and go to state 155


state 97

    (152) struct_structure -> TYPE VARIABLE . STRUCT LBRACE struct_fields RBRACE

    STRUCT          shift and go to state 156


state 98

    (112) conditional_structure -> IF conditions . conditional_body
    (113) conditional_structure -> IF conditions . conditional_body ELSE conditional_body
    (114) conditional_structure -> IF conditions . conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> IF conditions . conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (116) conditional_body -> . LBRACE blocks RBRACE
    (117) conditional_body -> . LBRACE blocks return RBRACE
    (118) conditional_body -> . LBRACE return RBRACE
    (119) conditional_body -> . LBRACE BREAK RBRACE
    (120) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 158

    conditional_body               shift and go to state 157

state 99

    (121) conditions -> condition .
    (122) conditions -> condition . logical_operator conditions
    (125) logical_operator -> . AND
    (126) logical_operator -> . OR
    (127) logical_operator -> . NOT

    LBRACE          reduce using rule 121 (conditions -> condition .)
    AND             shift and go to state 160
    OR              shift and go to state 161
    NOT             shift and go to state 162

    logical_operator               shift and go to state 159

state 100

    (123) condition -> BOOL .
    (37) not_variable_value -> BOOL .

    AND             reduce using rule 123 (condition -> BOOL .)
    OR              reduce using rule 123 (condition -> BOOL .)
    NOT             reduce using rule 123 (condition -> BOOL .)
    LBRACE          reduce using rule 123 (condition -> BOOL .)
    SEMICOLON       reduce using rule 123 (condition -> BOOL .)
    GREATER         reduce using rule 37 (not_variable_value -> BOOL .)
    LESS            reduce using rule 37 (not_variable_value -> BOOL .)
    GREATEREQUALS   reduce using rule 37 (not_variable_value -> BOOL .)
    LESSEQUALS      reduce using rule 37 (not_variable_value -> BOOL .)
    EQUALS          reduce using rule 37 (not_variable_value -> BOOL .)
    DIFFERENT       reduce using rule 37 (not_variable_value -> BOOL .)


state 101

    (124) condition -> value . relational_operator values
    (128) relational_operator -> . GREATER
    (129) relational_operator -> . LESS
    (130) relational_operator -> . GREATEREQUALS
    (131) relational_operator -> . LESSEQUALS
    (132) relational_operator -> . EQUALS
    (133) relational_operator -> . DIFFERENT

    GREATER         shift and go to state 164
    LESS            shift and go to state 165
    GREATEREQUALS   shift and go to state 166
    LESSEQUALS      shift and go to state 167
    EQUALS          shift and go to state 168
    DIFFERENT       shift and go to state 169

    relational_operator            shift and go to state 163

state 102

    (140) switch_structure -> SWITCH switch_expression . LBRACE case_blocks RBRACE

    LBRACE          shift and go to state 170


state 103

    (141) switch_expression -> VARIABLE . SHORTASSIGN value

    SHORTASSIGN     shift and go to state 171


state 104

    (142) switch_expression -> empty .

    LBRACE          reduce using rule 142 (switch_expression -> empty .)


state 105

    (137) for_initialization -> FOR VARIABLE . SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (139) for_iterator -> FOR VARIABLE . COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 172
    COMMA           shift and go to state 173


state 106

    (138) for_infinite_bucle -> FOR LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! LPAREN          [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]
  ! BOOL            [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 174
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 107

    (7) statement -> import main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

    blocks                         shift and go to state 175
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 108

    (4) statement -> package import blocks .

    $end            reduce using rule 4 (statement -> package import blocks .)
    RBRACE          reduce using rule 4 (statement -> package import blocks .)
    CASE            reduce using rule 4 (statement -> package import blocks .)
    DEFAULT         reduce using rule 4 (statement -> package import blocks .)


state 109

    (8) statement -> package import main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 176


state 110

    (6) statement -> package main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

    blocks                         shift and go to state 177
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 111

    (5) statement -> main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 178


state 112

    (19) blocks -> block SEMICOLON blocks .

    $end            reduce using rule 19 (blocks -> block SEMICOLON blocks .)
    RBRACE          reduce using rule 19 (blocks -> block SEMICOLON blocks .)
    CASE            reduce using rule 19 (blocks -> block SEMICOLON blocks .)
    DEFAULT         reduce using rule 19 (blocks -> block SEMICOLON blocks .)
    RETURN          reduce using rule 19 (blocks -> block SEMICOLON blocks .)


state 113

    (11) import -> IMPORT LPAREN values_for_import . RPAREN

    RPAREN          shift and go to state 179


state 114

    (12) values_for_import -> CHARSTRING .
    (13) values_for_import -> CHARSTRING . values_for_import
    (12) values_for_import -> . CHARSTRING
    (13) values_for_import -> . CHARSTRING values_for_import

    RPAREN          reduce using rule 12 (values_for_import -> CHARSTRING .)
    CHARSTRING      shift and go to state 114

    values_for_import              shift and go to state 180

state 115

    (100) operation -> LPAREN value RPAREN . operator value
    (104) operation -> LPAREN value RPAREN . operator operation
    (85) operator -> . PLUS
    (86) operator -> . MINUS
    (87) operator -> . TIMES
    (88) operator -> . DIVIDE
    (89) operator -> . AND
    (90) operator -> . OR
    (91) operator -> . NOT
    (92) operator -> . LESS
    (93) operator -> . LESSEQUALS
    (94) operator -> . GREATER
    (95) operator -> . GREATEREQUALS
    (96) operator -> . EQUALS
    (97) operator -> . DIFFERENT

    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    NOT             shift and go to state 87
    LESS            shift and go to state 88
    LESSEQUALS      shift and go to state 89
    GREATER         shift and go to state 90
    GREATEREQUALS   shift and go to state 91
    EQUALS          shift and go to state 92
    DIFFERENT       shift and go to state 93

    operator                       shift and go to state 181

state 116

    (101) operation -> LPAREN value operator . value RPAREN
    (103) operation -> LPAREN value operator . operation RPAREN
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    LPAREN          shift and go to state 9
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 182
    operation                      shift and go to state 183
    not_variable_value             shift and go to state 36

state 117

    (31) value -> VARIABLE LBRACKET . RBRACKET
    (32) value -> VARIABLE LBRACKET . value RBRACKET
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    RBRACKET        shift and go to state 125
    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 184
    not_variable_value             shift and go to state 36

state 118

    (43) variable_declaration -> VARIABLE SHORTASSIGN value .
    (98) operation -> value . operator value
    (99) operation -> value . operator LPAREN value RPAREN
    (102) operation -> value . operator operation
    (105) operation -> value . operator LPAREN operation RPAREN
    (106) operation -> value . double_operator
    (85) operator -> . PLUS
    (86) operator -> . MINUS
    (87) operator -> . TIMES
    (88) operator -> . DIVIDE
    (89) operator -> . AND
    (90) operator -> . OR
    (91) operator -> . NOT
    (92) operator -> . LESS
    (93) operator -> . LESSEQUALS
    (94) operator -> . GREATER
    (95) operator -> . GREATEREQUALS
    (96) operator -> . EQUALS
    (97) operator -> . DIFFERENT
    (107) double_operator -> . INCREMENT
    (108) double_operator -> . DECREMENT

    SEMICOLON       reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    PRINT           reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    PRINTF          reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INPUT           reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    LPAREN          reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FUNCTION        reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VAR             reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VARIABLE        reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CONST           reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    TYPE            reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    IF              reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    SWITCH          reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CHARSTRING      reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INT             reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FLOAT           reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    BOOL            reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FOR             reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    $end            reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    RBRACE          reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CASE            reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    DEFAULT         reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    RETURN          reduce using rule 43 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    NOT             shift and go to state 87
    LESS            shift and go to state 88
    LESSEQUALS      shift and go to state 89
    GREATER         shift and go to state 90
    GREATEREQUALS   shift and go to state 91
    EQUALS          shift and go to state 92
    DIFFERENT       shift and go to state 93
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    operator                       shift and go to state 79
    double_operator                shift and go to state 80

state 119

    (44) variable_declaration -> VARIABLE SHORTASSIGN operation .

    SEMICOLON       reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    PRINT           reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    PRINTF          reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    INPUT           reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    LPAREN          reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FUNCTION        reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    VAR             reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    VARIABLE        reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CONST           reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    TYPE            reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    IF              reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    SWITCH          reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CHARSTRING      reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    INT             reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FLOAT           reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    BOOL            reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FOR             reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    $end            reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    RBRACE          reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CASE            reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    DEFAULT         reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    RETURN          reduce using rule 44 (variable_declaration -> VARIABLE SHORTASSIGN operation .)


state 120

    (160) map_structure -> VARIABLE SHORTASSIGN MAP . LBRACKET type RBRACKET type LBRACE map_values RBRACE

    LBRACKET        shift and go to state 185


state 121

    (166) slice_structure -> VARIABLE SHORTASSIGN LBRACKET . RBRACKET type LBRACE values RBRACE
    (168) slice_structure -> VARIABLE SHORTASSIGN LBRACKET . RBRACKET type

    RBRACKET        shift and go to state 186


state 122

    (161) map_structure -> VARIABLE SHORTASSIGN MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN

    LPAREN          shift and go to state 187


state 123

    (46) variable_assignation -> VARIABLE assignation value .
    (98) operation -> value . operator value
    (99) operation -> value . operator LPAREN value RPAREN
    (102) operation -> value . operator operation
    (105) operation -> value . operator LPAREN operation RPAREN
    (106) operation -> value . double_operator
    (85) operator -> . PLUS
    (86) operator -> . MINUS
    (87) operator -> . TIMES
    (88) operator -> . DIVIDE
    (89) operator -> . AND
    (90) operator -> . OR
    (91) operator -> . NOT
    (92) operator -> . LESS
    (93) operator -> . LESSEQUALS
    (94) operator -> . GREATER
    (95) operator -> . GREATEREQUALS
    (96) operator -> . EQUALS
    (97) operator -> . DIFFERENT
    (107) double_operator -> . INCREMENT
    (108) double_operator -> . DECREMENT

    SEMICOLON       reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    PRINT           reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    PRINTF          reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    INPUT           reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    LPAREN          reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    FUNCTION        reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    VAR             reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    VARIABLE        reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    CONST           reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    TYPE            reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    IF              reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    SWITCH          reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    CHARSTRING      reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    INT             reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    FLOAT           reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    BOOL            reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    FOR             reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    $end            reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    RBRACE          reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    CASE            reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    DEFAULT         reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    RETURN          reduce using rule 46 (variable_assignation -> VARIABLE assignation value .)
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    NOT             shift and go to state 87
    LESS            shift and go to state 88
    LESSEQUALS      shift and go to state 89
    GREATER         shift and go to state 90
    GREATEREQUALS   shift and go to state 91
    EQUALS          shift and go to state 92
    DIFFERENT       shift and go to state 93
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    operator                       shift and go to state 79
    double_operator                shift and go to state 80

state 124

    (47) variable_assignation -> VARIABLE assignation operation .

    SEMICOLON       reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    PRINT           reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    PRINTF          reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    INPUT           reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    LPAREN          reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    FUNCTION        reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    VAR             reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    VARIABLE        reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    CONST           reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    TYPE            reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    IF              reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    SWITCH          reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    CHARSTRING      reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    INT             reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    FLOAT           reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    BOOL            reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    FOR             reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    $end            reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    RBRACE          reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    CASE            reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    DEFAULT         reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)
    RETURN          reduce using rule 47 (variable_assignation -> VARIABLE assignation operation .)


state 125

    (31) value -> VARIABLE LBRACKET RBRACKET .

    PLUS            reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    MINUS           reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    TIMES           reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    DIVIDE          reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    AND             reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    OR              reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    NOT             reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    LESS            reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    LESSEQUALS      reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    GREATER         reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    GREATEREQUALS   reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    EQUALS          reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    DIFFERENT       reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    INCREMENT       reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    DECREMENT       reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    RPAREN          reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    PRINT           reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    PRINTF          reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    INPUT           reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    LPAREN          reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    FUNCTION        reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    VAR             reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    VARIABLE        reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    CONST           reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    TYPE            reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    IF              reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    SWITCH          reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    CHARSTRING      reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    INT             reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    FLOAT           reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    BOOL            reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    FOR             reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    $end            reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    RBRACE          reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    CASE            reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    DEFAULT         reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    RETURN          reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    COMMA           reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    LBRACE          reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    COLON           reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    LBRACKET        reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)
    PERIOD          reduce using rule 31 (value -> VARIABLE LBRACKET RBRACKET .)


state 126

    (32) value -> VARIABLE LBRACKET value . RBRACKET
    (165) map_assign -> VARIABLE LBRACKET value . RBRACKET ASSIGN value

    RBRACKET        shift and go to state 188


state 127

    (159) array_assign -> VARIABLE LBRACKET INT . RBRACKET ASSIGN value
    (35) not_variable_value -> INT .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 189

  ! RBRACKET        [ reduce using rule 35 (not_variable_value -> INT .) ]


state 128

    (169) slice_structure -> VARIABLE ASSIGN append_statement .

    SEMICOLON       reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    PRINT           reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    PRINTF          reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    INPUT           reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    LPAREN          reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FUNCTION        reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    VAR             reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    VARIABLE        reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CONST           reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    TYPE            reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    IF              reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    SWITCH          reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CHARSTRING      reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    INT             reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FLOAT           reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    BOOL            reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FOR             reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    $end            reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    RBRACE          reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CASE            reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    DEFAULT         reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)
    RETURN          reduce using rule 169 (slice_structure -> VARIABLE ASSIGN append_statement .)


state 129

    (170) append_statement -> APPEND . LPAREN VARIABLE COMMA values RPAREN
    (171) append_statement -> APPEND . LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN

    LPAREN          shift and go to state 190


state 130

    (16) main -> FUNCTION MAIN LPAREN . RPAREN

    RPAREN          shift and go to state 191


state 131

    (67) function -> FUNCTION VARIABLE LPAREN . RPAREN LBRACE RBRACE
    (68) function -> FUNCTION VARIABLE LPAREN . RPAREN LBRACE blocks RBRACE
    (69) function -> FUNCTION VARIABLE LPAREN . RPAREN type LBRACE blocks return RBRACE
    (70) function -> FUNCTION VARIABLE LPAREN . RPAREN type LBRACE return RBRACE
    (71) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN LBRACE blocks RBRACE
    (72) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN LBRACE RBRACE
    (73) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN type LBRACE return RBRACE
    (57) parameters -> . VARIABLE type
    (58) parameters -> . VARIABLE type COMMA parameters

    RPAREN          shift and go to state 193
    VARIABLE        shift and go to state 192

    parameters                     shift and go to state 194

state 132

    (78) print_statement -> PRINT LPAREN values . RPAREN

    RPAREN          shift and go to state 195


state 133

    (81) print_statement -> PRINT LPAREN RPAREN .

    SEMICOLON       reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    PRINT           reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    PRINTF          reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    INPUT           reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    LPAREN          reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    FUNCTION        reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    VAR             reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    VARIABLE        reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    CONST           reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    TYPE            reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    IF              reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    SWITCH          reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    CHARSTRING      reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    INT             reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    FLOAT           reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    BOOL            reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    FOR             reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    $end            reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    RBRACE          reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    CASE            reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    DEFAULT         reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)
    RETURN          reduce using rule 81 (print_statement -> PRINT LPAREN RPAREN .)


state 134

    (80) print_statement -> PRINT LPAREN operation . RPAREN

    RPAREN          shift and go to state 196


state 135

    (38) values -> value .
    (39) values -> value . COMMA values
    (98) operation -> value . operator value
    (99) operation -> value . operator LPAREN value RPAREN
    (102) operation -> value . operator operation
    (105) operation -> value . operator LPAREN operation RPAREN
    (106) operation -> value . double_operator
    (85) operator -> . PLUS
    (86) operator -> . MINUS
    (87) operator -> . TIMES
    (88) operator -> . DIVIDE
    (89) operator -> . AND
    (90) operator -> . OR
    (91) operator -> . NOT
    (92) operator -> . LESS
    (93) operator -> . LESSEQUALS
    (94) operator -> . GREATER
    (95) operator -> . GREATEREQUALS
    (96) operator -> . EQUALS
    (97) operator -> . DIFFERENT
    (107) double_operator -> . INCREMENT
    (108) double_operator -> . DECREMENT

    RPAREN          reduce using rule 38 (values -> value .)
    COMMA           shift and go to state 197
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    NOT             shift and go to state 87
    LESS            shift and go to state 88
    LESSEQUALS      shift and go to state 89
    GREATER         shift and go to state 90
    GREATEREQUALS   shift and go to state 91
    EQUALS          shift and go to state 92
    DIFFERENT       shift and go to state 93
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    operator                       shift and go to state 79
    double_operator                shift and go to state 80

state 136

    (79) print_statement -> PRINTF LPAREN FORMATSTRING . COMMA values RPAREN

    COMMA           shift and go to state 198


state 137

    (82) input_statement -> INPUT LPAREN values . RPAREN

    RPAREN          shift and go to state 199


state 138

    (84) input_statement -> INPUT LPAREN RPAREN .

    SEMICOLON       reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    PRINT           reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    PRINTF          reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    LPAREN          reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    FUNCTION        reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    VAR             reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    VARIABLE        reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    CONST           reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    TYPE            reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    IF              reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    SWITCH          reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    CHARSTRING      reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    INT             reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    FLOAT           reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    BOOL            reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    $end            reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    CASE            reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    DEFAULT         reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)
    RETURN          reduce using rule 84 (input_statement -> INPUT LPAREN RPAREN .)


state 139

    (83) input_statement -> INPUT LPAREN operation . RPAREN

    RPAREN          shift and go to state 200


state 140

    (98) operation -> value operator value .
    (98) operation -> value . operator value
    (99) operation -> value . operator LPAREN value RPAREN
    (102) operation -> value . operator operation
    (105) operation -> value . operator LPAREN operation RPAREN
    (106) operation -> value . double_operator
    (85) operator -> . PLUS
    (86) operator -> . MINUS
    (87) operator -> . TIMES
    (88) operator -> . DIVIDE
    (89) operator -> . AND
    (90) operator -> . OR
    (91) operator -> . NOT
    (92) operator -> . LESS
    (93) operator -> . LESSEQUALS
    (94) operator -> . GREATER
    (95) operator -> . GREATEREQUALS
    (96) operator -> . EQUALS
    (97) operator -> . DIFFERENT
    (107) double_operator -> . INCREMENT
    (108) double_operator -> . DECREMENT

    SEMICOLON       reduce using rule 98 (operation -> value operator value .)
    PRINT           reduce using rule 98 (operation -> value operator value .)
    PRINTF          reduce using rule 98 (operation -> value operator value .)
    INPUT           reduce using rule 98 (operation -> value operator value .)
    LPAREN          reduce using rule 98 (operation -> value operator value .)
    FUNCTION        reduce using rule 98 (operation -> value operator value .)
    VAR             reduce using rule 98 (operation -> value operator value .)
    VARIABLE        reduce using rule 98 (operation -> value operator value .)
    CONST           reduce using rule 98 (operation -> value operator value .)
    TYPE            reduce using rule 98 (operation -> value operator value .)
    IF              reduce using rule 98 (operation -> value operator value .)
    SWITCH          reduce using rule 98 (operation -> value operator value .)
    CHARSTRING      reduce using rule 98 (operation -> value operator value .)
    INT             reduce using rule 98 (operation -> value operator value .)
    FLOAT           reduce using rule 98 (operation -> value operator value .)
    BOOL            reduce using rule 98 (operation -> value operator value .)
    FOR             reduce using rule 98 (operation -> value operator value .)
    $end            reduce using rule 98 (operation -> value operator value .)
    RBRACE          reduce using rule 98 (operation -> value operator value .)
    CASE            reduce using rule 98 (operation -> value operator value .)
    DEFAULT         reduce using rule 98 (operation -> value operator value .)
    RETURN          reduce using rule 98 (operation -> value operator value .)
    RPAREN          reduce using rule 98 (operation -> value operator value .)
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    NOT             shift and go to state 87
    LESS            shift and go to state 88
    LESSEQUALS      shift and go to state 89
    GREATER         shift and go to state 90
    GREATEREQUALS   shift and go to state 91
    EQUALS          shift and go to state 92
    DIFFERENT       shift and go to state 93
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    operator                       shift and go to state 79
    double_operator                shift and go to state 80

state 141

    (99) operation -> value operator LPAREN . value RPAREN
    (105) operation -> value operator LPAREN . operation RPAREN
    (100) operation -> LPAREN . value RPAREN operator value
    (101) operation -> LPAREN . value operator value RPAREN
    (103) operation -> LPAREN . value operator operation RPAREN
    (104) operation -> LPAREN . value RPAREN operator operation
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    LPAREN          shift and go to state 9
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 201
    operation                      shift and go to state 202
    not_variable_value             shift and go to state 36

state 142

    (102) operation -> value operator operation .

    SEMICOLON       reduce using rule 102 (operation -> value operator operation .)
    PRINT           reduce using rule 102 (operation -> value operator operation .)
    PRINTF          reduce using rule 102 (operation -> value operator operation .)
    INPUT           reduce using rule 102 (operation -> value operator operation .)
    LPAREN          reduce using rule 102 (operation -> value operator operation .)
    FUNCTION        reduce using rule 102 (operation -> value operator operation .)
    VAR             reduce using rule 102 (operation -> value operator operation .)
    VARIABLE        reduce using rule 102 (operation -> value operator operation .)
    CONST           reduce using rule 102 (operation -> value operator operation .)
    TYPE            reduce using rule 102 (operation -> value operator operation .)
    IF              reduce using rule 102 (operation -> value operator operation .)
    SWITCH          reduce using rule 102 (operation -> value operator operation .)
    CHARSTRING      reduce using rule 102 (operation -> value operator operation .)
    INT             reduce using rule 102 (operation -> value operator operation .)
    FLOAT           reduce using rule 102 (operation -> value operator operation .)
    BOOL            reduce using rule 102 (operation -> value operator operation .)
    FOR             reduce using rule 102 (operation -> value operator operation .)
    $end            reduce using rule 102 (operation -> value operator operation .)
    RBRACE          reduce using rule 102 (operation -> value operator operation .)
    CASE            reduce using rule 102 (operation -> value operator operation .)
    DEFAULT         reduce using rule 102 (operation -> value operator operation .)
    RETURN          reduce using rule 102 (operation -> value operator operation .)
    RPAREN          reduce using rule 102 (operation -> value operator operation .)


state 143

    (40) variable_declaration -> VAR variables type .
    (41) variable_declaration -> VAR variables type . ASSIGN value
    (42) variable_declaration -> VAR variables type . ASSIGN operation

    SEMICOLON       reduce using rule 40 (variable_declaration -> VAR variables type .)
    PRINT           reduce using rule 40 (variable_declaration -> VAR variables type .)
    PRINTF          reduce using rule 40 (variable_declaration -> VAR variables type .)
    INPUT           reduce using rule 40 (variable_declaration -> VAR variables type .)
    LPAREN          reduce using rule 40 (variable_declaration -> VAR variables type .)
    FUNCTION        reduce using rule 40 (variable_declaration -> VAR variables type .)
    VAR             reduce using rule 40 (variable_declaration -> VAR variables type .)
    VARIABLE        reduce using rule 40 (variable_declaration -> VAR variables type .)
    CONST           reduce using rule 40 (variable_declaration -> VAR variables type .)
    TYPE            reduce using rule 40 (variable_declaration -> VAR variables type .)
    IF              reduce using rule 40 (variable_declaration -> VAR variables type .)
    SWITCH          reduce using rule 40 (variable_declaration -> VAR variables type .)
    CHARSTRING      reduce using rule 40 (variable_declaration -> VAR variables type .)
    INT             reduce using rule 40 (variable_declaration -> VAR variables type .)
    FLOAT           reduce using rule 40 (variable_declaration -> VAR variables type .)
    BOOL            reduce using rule 40 (variable_declaration -> VAR variables type .)
    FOR             reduce using rule 40 (variable_declaration -> VAR variables type .)
    $end            reduce using rule 40 (variable_declaration -> VAR variables type .)
    RBRACE          reduce using rule 40 (variable_declaration -> VAR variables type .)
    CASE            reduce using rule 40 (variable_declaration -> VAR variables type .)
    DEFAULT         reduce using rule 40 (variable_declaration -> VAR variables type .)
    RETURN          reduce using rule 40 (variable_declaration -> VAR variables type .)
    ASSIGN          shift and go to state 203


state 144

    (59) type -> INT .

    ASSIGN          reduce using rule 59 (type -> INT .)
    SEMICOLON       reduce using rule 59 (type -> INT .)
    PRINT           reduce using rule 59 (type -> INT .)
    PRINTF          reduce using rule 59 (type -> INT .)
    INPUT           reduce using rule 59 (type -> INT .)
    LPAREN          reduce using rule 59 (type -> INT .)
    FUNCTION        reduce using rule 59 (type -> INT .)
    VAR             reduce using rule 59 (type -> INT .)
    VARIABLE        reduce using rule 59 (type -> INT .)
    CONST           reduce using rule 59 (type -> INT .)
    TYPE            reduce using rule 59 (type -> INT .)
    IF              reduce using rule 59 (type -> INT .)
    SWITCH          reduce using rule 59 (type -> INT .)
    CHARSTRING      reduce using rule 59 (type -> INT .)
    INT             reduce using rule 59 (type -> INT .)
    FLOAT           reduce using rule 59 (type -> INT .)
    BOOL            reduce using rule 59 (type -> INT .)
    FOR             reduce using rule 59 (type -> INT .)
    $end            reduce using rule 59 (type -> INT .)
    RBRACE          reduce using rule 59 (type -> INT .)
    CASE            reduce using rule 59 (type -> INT .)
    DEFAULT         reduce using rule 59 (type -> INT .)
    RETURN          reduce using rule 59 (type -> INT .)
    RBRACKET        reduce using rule 59 (type -> INT .)
    LBRACE          reduce using rule 59 (type -> INT .)
    COMMA           reduce using rule 59 (type -> INT .)
    RPAREN          reduce using rule 59 (type -> INT .)


state 145

    (60) type -> INT32 .

    ASSIGN          reduce using rule 60 (type -> INT32 .)
    SEMICOLON       reduce using rule 60 (type -> INT32 .)
    PRINT           reduce using rule 60 (type -> INT32 .)
    PRINTF          reduce using rule 60 (type -> INT32 .)
    INPUT           reduce using rule 60 (type -> INT32 .)
    LPAREN          reduce using rule 60 (type -> INT32 .)
    FUNCTION        reduce using rule 60 (type -> INT32 .)
    VAR             reduce using rule 60 (type -> INT32 .)
    VARIABLE        reduce using rule 60 (type -> INT32 .)
    CONST           reduce using rule 60 (type -> INT32 .)
    TYPE            reduce using rule 60 (type -> INT32 .)
    IF              reduce using rule 60 (type -> INT32 .)
    SWITCH          reduce using rule 60 (type -> INT32 .)
    CHARSTRING      reduce using rule 60 (type -> INT32 .)
    INT             reduce using rule 60 (type -> INT32 .)
    FLOAT           reduce using rule 60 (type -> INT32 .)
    BOOL            reduce using rule 60 (type -> INT32 .)
    FOR             reduce using rule 60 (type -> INT32 .)
    $end            reduce using rule 60 (type -> INT32 .)
    RBRACE          reduce using rule 60 (type -> INT32 .)
    CASE            reduce using rule 60 (type -> INT32 .)
    DEFAULT         reduce using rule 60 (type -> INT32 .)
    RETURN          reduce using rule 60 (type -> INT32 .)
    RBRACKET        reduce using rule 60 (type -> INT32 .)
    LBRACE          reduce using rule 60 (type -> INT32 .)
    COMMA           reduce using rule 60 (type -> INT32 .)
    RPAREN          reduce using rule 60 (type -> INT32 .)


state 146

    (61) type -> INT64 .

    ASSIGN          reduce using rule 61 (type -> INT64 .)
    SEMICOLON       reduce using rule 61 (type -> INT64 .)
    PRINT           reduce using rule 61 (type -> INT64 .)
    PRINTF          reduce using rule 61 (type -> INT64 .)
    INPUT           reduce using rule 61 (type -> INT64 .)
    LPAREN          reduce using rule 61 (type -> INT64 .)
    FUNCTION        reduce using rule 61 (type -> INT64 .)
    VAR             reduce using rule 61 (type -> INT64 .)
    VARIABLE        reduce using rule 61 (type -> INT64 .)
    CONST           reduce using rule 61 (type -> INT64 .)
    TYPE            reduce using rule 61 (type -> INT64 .)
    IF              reduce using rule 61 (type -> INT64 .)
    SWITCH          reduce using rule 61 (type -> INT64 .)
    CHARSTRING      reduce using rule 61 (type -> INT64 .)
    INT             reduce using rule 61 (type -> INT64 .)
    FLOAT           reduce using rule 61 (type -> INT64 .)
    BOOL            reduce using rule 61 (type -> INT64 .)
    FOR             reduce using rule 61 (type -> INT64 .)
    $end            reduce using rule 61 (type -> INT64 .)
    RBRACE          reduce using rule 61 (type -> INT64 .)
    CASE            reduce using rule 61 (type -> INT64 .)
    DEFAULT         reduce using rule 61 (type -> INT64 .)
    RETURN          reduce using rule 61 (type -> INT64 .)
    RBRACKET        reduce using rule 61 (type -> INT64 .)
    LBRACE          reduce using rule 61 (type -> INT64 .)
    COMMA           reduce using rule 61 (type -> INT64 .)
    RPAREN          reduce using rule 61 (type -> INT64 .)


state 147

    (62) type -> STRING .

    ASSIGN          reduce using rule 62 (type -> STRING .)
    SEMICOLON       reduce using rule 62 (type -> STRING .)
    PRINT           reduce using rule 62 (type -> STRING .)
    PRINTF          reduce using rule 62 (type -> STRING .)
    INPUT           reduce using rule 62 (type -> STRING .)
    LPAREN          reduce using rule 62 (type -> STRING .)
    FUNCTION        reduce using rule 62 (type -> STRING .)
    VAR             reduce using rule 62 (type -> STRING .)
    VARIABLE        reduce using rule 62 (type -> STRING .)
    CONST           reduce using rule 62 (type -> STRING .)
    TYPE            reduce using rule 62 (type -> STRING .)
    IF              reduce using rule 62 (type -> STRING .)
    SWITCH          reduce using rule 62 (type -> STRING .)
    CHARSTRING      reduce using rule 62 (type -> STRING .)
    INT             reduce using rule 62 (type -> STRING .)
    FLOAT           reduce using rule 62 (type -> STRING .)
    BOOL            reduce using rule 62 (type -> STRING .)
    FOR             reduce using rule 62 (type -> STRING .)
    $end            reduce using rule 62 (type -> STRING .)
    RBRACE          reduce using rule 62 (type -> STRING .)
    CASE            reduce using rule 62 (type -> STRING .)
    DEFAULT         reduce using rule 62 (type -> STRING .)
    RETURN          reduce using rule 62 (type -> STRING .)
    RBRACKET        reduce using rule 62 (type -> STRING .)
    LBRACE          reduce using rule 62 (type -> STRING .)
    COMMA           reduce using rule 62 (type -> STRING .)
    RPAREN          reduce using rule 62 (type -> STRING .)


state 148

    (63) type -> FLOAT .

    ASSIGN          reduce using rule 63 (type -> FLOAT .)
    SEMICOLON       reduce using rule 63 (type -> FLOAT .)
    PRINT           reduce using rule 63 (type -> FLOAT .)
    PRINTF          reduce using rule 63 (type -> FLOAT .)
    INPUT           reduce using rule 63 (type -> FLOAT .)
    LPAREN          reduce using rule 63 (type -> FLOAT .)
    FUNCTION        reduce using rule 63 (type -> FLOAT .)
    VAR             reduce using rule 63 (type -> FLOAT .)
    VARIABLE        reduce using rule 63 (type -> FLOAT .)
    CONST           reduce using rule 63 (type -> FLOAT .)
    TYPE            reduce using rule 63 (type -> FLOAT .)
    IF              reduce using rule 63 (type -> FLOAT .)
    SWITCH          reduce using rule 63 (type -> FLOAT .)
    CHARSTRING      reduce using rule 63 (type -> FLOAT .)
    INT             reduce using rule 63 (type -> FLOAT .)
    FLOAT           reduce using rule 63 (type -> FLOAT .)
    BOOL            reduce using rule 63 (type -> FLOAT .)
    FOR             reduce using rule 63 (type -> FLOAT .)
    $end            reduce using rule 63 (type -> FLOAT .)
    RBRACE          reduce using rule 63 (type -> FLOAT .)
    CASE            reduce using rule 63 (type -> FLOAT .)
    DEFAULT         reduce using rule 63 (type -> FLOAT .)
    RETURN          reduce using rule 63 (type -> FLOAT .)
    RBRACKET        reduce using rule 63 (type -> FLOAT .)
    LBRACE          reduce using rule 63 (type -> FLOAT .)
    COMMA           reduce using rule 63 (type -> FLOAT .)
    RPAREN          reduce using rule 63 (type -> FLOAT .)


state 149

    (64) type -> FLOAT32 .

    ASSIGN          reduce using rule 64 (type -> FLOAT32 .)
    SEMICOLON       reduce using rule 64 (type -> FLOAT32 .)
    PRINT           reduce using rule 64 (type -> FLOAT32 .)
    PRINTF          reduce using rule 64 (type -> FLOAT32 .)
    INPUT           reduce using rule 64 (type -> FLOAT32 .)
    LPAREN          reduce using rule 64 (type -> FLOAT32 .)
    FUNCTION        reduce using rule 64 (type -> FLOAT32 .)
    VAR             reduce using rule 64 (type -> FLOAT32 .)
    VARIABLE        reduce using rule 64 (type -> FLOAT32 .)
    CONST           reduce using rule 64 (type -> FLOAT32 .)
    TYPE            reduce using rule 64 (type -> FLOAT32 .)
    IF              reduce using rule 64 (type -> FLOAT32 .)
    SWITCH          reduce using rule 64 (type -> FLOAT32 .)
    CHARSTRING      reduce using rule 64 (type -> FLOAT32 .)
    INT             reduce using rule 64 (type -> FLOAT32 .)
    FLOAT           reduce using rule 64 (type -> FLOAT32 .)
    BOOL            reduce using rule 64 (type -> FLOAT32 .)
    FOR             reduce using rule 64 (type -> FLOAT32 .)
    $end            reduce using rule 64 (type -> FLOAT32 .)
    RBRACE          reduce using rule 64 (type -> FLOAT32 .)
    CASE            reduce using rule 64 (type -> FLOAT32 .)
    DEFAULT         reduce using rule 64 (type -> FLOAT32 .)
    RETURN          reduce using rule 64 (type -> FLOAT32 .)
    RBRACKET        reduce using rule 64 (type -> FLOAT32 .)
    LBRACE          reduce using rule 64 (type -> FLOAT32 .)
    COMMA           reduce using rule 64 (type -> FLOAT32 .)
    RPAREN          reduce using rule 64 (type -> FLOAT32 .)


state 150

    (65) type -> FLOAT64 .

    ASSIGN          reduce using rule 65 (type -> FLOAT64 .)
    SEMICOLON       reduce using rule 65 (type -> FLOAT64 .)
    PRINT           reduce using rule 65 (type -> FLOAT64 .)
    PRINTF          reduce using rule 65 (type -> FLOAT64 .)
    INPUT           reduce using rule 65 (type -> FLOAT64 .)
    LPAREN          reduce using rule 65 (type -> FLOAT64 .)
    FUNCTION        reduce using rule 65 (type -> FLOAT64 .)
    VAR             reduce using rule 65 (type -> FLOAT64 .)
    VARIABLE        reduce using rule 65 (type -> FLOAT64 .)
    CONST           reduce using rule 65 (type -> FLOAT64 .)
    TYPE            reduce using rule 65 (type -> FLOAT64 .)
    IF              reduce using rule 65 (type -> FLOAT64 .)
    SWITCH          reduce using rule 65 (type -> FLOAT64 .)
    CHARSTRING      reduce using rule 65 (type -> FLOAT64 .)
    INT             reduce using rule 65 (type -> FLOAT64 .)
    FLOAT           reduce using rule 65 (type -> FLOAT64 .)
    BOOL            reduce using rule 65 (type -> FLOAT64 .)
    FOR             reduce using rule 65 (type -> FLOAT64 .)
    $end            reduce using rule 65 (type -> FLOAT64 .)
    RBRACE          reduce using rule 65 (type -> FLOAT64 .)
    CASE            reduce using rule 65 (type -> FLOAT64 .)
    DEFAULT         reduce using rule 65 (type -> FLOAT64 .)
    RETURN          reduce using rule 65 (type -> FLOAT64 .)
    RBRACKET        reduce using rule 65 (type -> FLOAT64 .)
    LBRACE          reduce using rule 65 (type -> FLOAT64 .)
    COMMA           reduce using rule 65 (type -> FLOAT64 .)
    RPAREN          reduce using rule 65 (type -> FLOAT64 .)


state 151

    (66) type -> BOOL .

    ASSIGN          reduce using rule 66 (type -> BOOL .)
    SEMICOLON       reduce using rule 66 (type -> BOOL .)
    PRINT           reduce using rule 66 (type -> BOOL .)
    PRINTF          reduce using rule 66 (type -> BOOL .)
    INPUT           reduce using rule 66 (type -> BOOL .)
    LPAREN          reduce using rule 66 (type -> BOOL .)
    FUNCTION        reduce using rule 66 (type -> BOOL .)
    VAR             reduce using rule 66 (type -> BOOL .)
    VARIABLE        reduce using rule 66 (type -> BOOL .)
    CONST           reduce using rule 66 (type -> BOOL .)
    TYPE            reduce using rule 66 (type -> BOOL .)
    IF              reduce using rule 66 (type -> BOOL .)
    SWITCH          reduce using rule 66 (type -> BOOL .)
    CHARSTRING      reduce using rule 66 (type -> BOOL .)
    INT             reduce using rule 66 (type -> BOOL .)
    FLOAT           reduce using rule 66 (type -> BOOL .)
    BOOL            reduce using rule 66 (type -> BOOL .)
    FOR             reduce using rule 66 (type -> BOOL .)
    $end            reduce using rule 66 (type -> BOOL .)
    RBRACE          reduce using rule 66 (type -> BOOL .)
    CASE            reduce using rule 66 (type -> BOOL .)
    DEFAULT         reduce using rule 66 (type -> BOOL .)
    RETURN          reduce using rule 66 (type -> BOOL .)
    RBRACKET        reduce using rule 66 (type -> BOOL .)
    LBRACE          reduce using rule 66 (type -> BOOL .)
    COMMA           reduce using rule 66 (type -> BOOL .)
    RPAREN          reduce using rule 66 (type -> BOOL .)


state 152

    (156) array_structure -> VAR VARIABLE LBRACKET . INT RBRACKET type
    (158) array_structure -> VAR VARIABLE LBRACKET . INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (167) slice_structure -> VAR VARIABLE LBRACKET . RBRACKET type

    INT             shift and go to state 204
    RBRACKET        shift and go to state 205


state 153

    (157) array_structure -> VAR VARIABLE ASSIGN . LBRACKET INT RBRACKET type LBRACE values RBRACE

    LBRACKET        shift and go to state 206


state 154

    (29) variables -> VARIABLE COMMA . variables
    (28) variables -> . VARIABLE
    (29) variables -> . VARIABLE COMMA variables

    VARIABLE        shift and go to state 207

    variables                      shift and go to state 208

state 155

    (45) variable_declaration -> CONST VARIABLE ASSIGN . value
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 209
    not_variable_value             shift and go to state 36

state 156

    (152) struct_structure -> TYPE VARIABLE STRUCT . LBRACE struct_fields RBRACE

    LBRACE          shift and go to state 210


state 157

    (112) conditional_structure -> IF conditions conditional_body .
    (113) conditional_structure -> IF conditions conditional_body . ELSE conditional_body
    (114) conditional_structure -> IF conditions conditional_body . ELSE IF conditions conditional_body
    (115) conditional_structure -> IF conditions conditional_body . ELSE IF conditions conditional_body ELSE conditional_body

    SEMICOLON       reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    PRINT           reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    PRINTF          reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    INPUT           reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    LPAREN          reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    FUNCTION        reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    VAR             reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    VARIABLE        reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    CONST           reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    TYPE            reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    IF              reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    SWITCH          reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    CHARSTRING      reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    INT             reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    FLOAT           reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    BOOL            reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    FOR             reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    $end            reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    RBRACE          reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    CASE            reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    DEFAULT         reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    RETURN          reduce using rule 112 (conditional_structure -> IF conditions conditional_body .)
    ELSE            shift and go to state 211


state 158

    (116) conditional_body -> LBRACE . blocks RBRACE
    (117) conditional_body -> LBRACE . blocks return RBRACE
    (118) conditional_body -> LBRACE . return RBRACE
    (119) conditional_body -> LBRACE . BREAK RBRACE
    (120) conditional_body -> LBRACE . CONTINUE RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (75) return -> . RETURN value
    (76) return -> . RETURN value LBRACKET value RBRACKET
    (77) return -> . RETURN value PERIOD value
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    BREAK           shift and go to state 214
    CONTINUE        shift and go to state 215
    RETURN          shift and go to state 216
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

    blocks                         shift and go to state 212
    return                         shift and go to state 213
    block                          shift and go to state 6
    value                          shift and go to state 24
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 159

    (122) conditions -> condition logical_operator . conditions
    (121) conditions -> . condition
    (122) conditions -> . condition logical_operator conditions
    (123) condition -> . BOOL
    (124) condition -> . value relational_operator values
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    BOOL            shift and go to state 100
    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44

    condition                      shift and go to state 99
    conditions                     shift and go to state 217
    value                          shift and go to state 101
    not_variable_value             shift and go to state 36

state 160

    (125) logical_operator -> AND .

    BOOL            reduce using rule 125 (logical_operator -> AND .)
    VARIABLE        reduce using rule 125 (logical_operator -> AND .)
    CHARSTRING      reduce using rule 125 (logical_operator -> AND .)
    INT             reduce using rule 125 (logical_operator -> AND .)
    FLOAT           reduce using rule 125 (logical_operator -> AND .)


state 161

    (126) logical_operator -> OR .

    BOOL            reduce using rule 126 (logical_operator -> OR .)
    VARIABLE        reduce using rule 126 (logical_operator -> OR .)
    CHARSTRING      reduce using rule 126 (logical_operator -> OR .)
    INT             reduce using rule 126 (logical_operator -> OR .)
    FLOAT           reduce using rule 126 (logical_operator -> OR .)


state 162

    (127) logical_operator -> NOT .

    BOOL            reduce using rule 127 (logical_operator -> NOT .)
    VARIABLE        reduce using rule 127 (logical_operator -> NOT .)
    CHARSTRING      reduce using rule 127 (logical_operator -> NOT .)
    INT             reduce using rule 127 (logical_operator -> NOT .)
    FLOAT           reduce using rule 127 (logical_operator -> NOT .)


state 163

    (124) condition -> value relational_operator . values
    (38) values -> . value
    (39) values -> . value COMMA values
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 218
    values                         shift and go to state 219
    not_variable_value             shift and go to state 36

state 164

    (128) relational_operator -> GREATER .

    VARIABLE        reduce using rule 128 (relational_operator -> GREATER .)
    CHARSTRING      reduce using rule 128 (relational_operator -> GREATER .)
    INT             reduce using rule 128 (relational_operator -> GREATER .)
    FLOAT           reduce using rule 128 (relational_operator -> GREATER .)
    BOOL            reduce using rule 128 (relational_operator -> GREATER .)


state 165

    (129) relational_operator -> LESS .

    VARIABLE        reduce using rule 129 (relational_operator -> LESS .)
    CHARSTRING      reduce using rule 129 (relational_operator -> LESS .)
    INT             reduce using rule 129 (relational_operator -> LESS .)
    FLOAT           reduce using rule 129 (relational_operator -> LESS .)
    BOOL            reduce using rule 129 (relational_operator -> LESS .)


state 166

    (130) relational_operator -> GREATEREQUALS .

    VARIABLE        reduce using rule 130 (relational_operator -> GREATEREQUALS .)
    CHARSTRING      reduce using rule 130 (relational_operator -> GREATEREQUALS .)
    INT             reduce using rule 130 (relational_operator -> GREATEREQUALS .)
    FLOAT           reduce using rule 130 (relational_operator -> GREATEREQUALS .)
    BOOL            reduce using rule 130 (relational_operator -> GREATEREQUALS .)


state 167

    (131) relational_operator -> LESSEQUALS .

    VARIABLE        reduce using rule 131 (relational_operator -> LESSEQUALS .)
    CHARSTRING      reduce using rule 131 (relational_operator -> LESSEQUALS .)
    INT             reduce using rule 131 (relational_operator -> LESSEQUALS .)
    FLOAT           reduce using rule 131 (relational_operator -> LESSEQUALS .)
    BOOL            reduce using rule 131 (relational_operator -> LESSEQUALS .)


state 168

    (132) relational_operator -> EQUALS .

    VARIABLE        reduce using rule 132 (relational_operator -> EQUALS .)
    CHARSTRING      reduce using rule 132 (relational_operator -> EQUALS .)
    INT             reduce using rule 132 (relational_operator -> EQUALS .)
    FLOAT           reduce using rule 132 (relational_operator -> EQUALS .)
    BOOL            reduce using rule 132 (relational_operator -> EQUALS .)


state 169

    (133) relational_operator -> DIFFERENT .

    VARIABLE        reduce using rule 133 (relational_operator -> DIFFERENT .)
    CHARSTRING      reduce using rule 133 (relational_operator -> DIFFERENT .)
    INT             reduce using rule 133 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 133 (relational_operator -> DIFFERENT .)
    BOOL            reduce using rule 133 (relational_operator -> DIFFERENT .)


state 170

    (140) switch_structure -> SWITCH switch_expression LBRACE . case_blocks RBRACE
    (143) case_blocks -> . case_block
    (144) case_blocks -> . case_block case_blocks
    (145) case_block -> . CASE values COLON statement
    (146) case_block -> . DEFAULT COLON statement

    CASE            shift and go to state 222
    DEFAULT         shift and go to state 223

    case_blocks                    shift and go to state 220
    case_block                     shift and go to state 221

state 171

    (141) switch_expression -> VARIABLE SHORTASSIGN . value
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 224
    not_variable_value             shift and go to state 36

state 172

    (137) for_initialization -> FOR VARIABLE SHORTASSIGN . value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 225
    not_variable_value             shift and go to state 36

state 173

    (139) for_iterator -> FOR VARIABLE COMMA . VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 226


state 174

    (138) for_infinite_bucle -> FOR LBRACE statement . RBRACE

    RBRACE          shift and go to state 227


state 175

    (7) statement -> import main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 228


state 176

    (8) statement -> package import main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

    blocks                         shift and go to state 229
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 177

    (6) statement -> package main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 230


state 178

    (5) statement -> main LBRACE blocks RBRACE .

    $end            reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)
    CASE            reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)


state 179

    (11) import -> IMPORT LPAREN values_for_import RPAREN .

    FUNCTION        reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    PRINT           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    PRINTF          reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    INPUT           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    LPAREN          reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    VAR             reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    VARIABLE        reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    CONST           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    TYPE            reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    IF              reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    SWITCH          reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    CHARSTRING      reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    INT             reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    FLOAT           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    BOOL            reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    FOR             reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)


state 180

    (13) values_for_import -> CHARSTRING values_for_import .

    RPAREN          reduce using rule 13 (values_for_import -> CHARSTRING values_for_import .)


state 181

    (100) operation -> LPAREN value RPAREN operator . value
    (104) operation -> LPAREN value RPAREN operator . operation
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    LPAREN          shift and go to state 9
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 231
    operation                      shift and go to state 232
    not_variable_value             shift and go to state 36

state 182

    (101) operation -> LPAREN value operator value . RPAREN
    (98) operation -> value . operator value
    (99) operation -> value . operator LPAREN value RPAREN
    (102) operation -> value . operator operation
    (105) operation -> value . operator LPAREN operation RPAREN
    (106) operation -> value . double_operator
    (85) operator -> . PLUS
    (86) operator -> . MINUS
    (87) operator -> . TIMES
    (88) operator -> . DIVIDE
    (89) operator -> . AND
    (90) operator -> . OR
    (91) operator -> . NOT
    (92) operator -> . LESS
    (93) operator -> . LESSEQUALS
    (94) operator -> . GREATER
    (95) operator -> . GREATEREQUALS
    (96) operator -> . EQUALS
    (97) operator -> . DIFFERENT
    (107) double_operator -> . INCREMENT
    (108) double_operator -> . DECREMENT

    RPAREN          shift and go to state 233
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    NOT             shift and go to state 87
    LESS            shift and go to state 88
    LESSEQUALS      shift and go to state 89
    GREATER         shift and go to state 90
    GREATEREQUALS   shift and go to state 91
    EQUALS          shift and go to state 92
    DIFFERENT       shift and go to state 93
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    operator                       shift and go to state 79
    double_operator                shift and go to state 80

state 183

    (103) operation -> LPAREN value operator operation . RPAREN

    RPAREN          shift and go to state 234


state 184

    (32) value -> VARIABLE LBRACKET value . RBRACKET

    RBRACKET        shift and go to state 235


state 185

    (160) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET . type RBRACKET type LBRACE map_values RBRACE
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 144
    INT32           shift and go to state 145
    INT64           shift and go to state 146
    STRING          shift and go to state 147
    FLOAT           shift and go to state 148
    FLOAT32         shift and go to state 149
    FLOAT64         shift and go to state 150
    BOOL            shift and go to state 151

    type                           shift and go to state 236

state 186

    (166) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET . type LBRACE values RBRACE
    (168) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET . type
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 144
    INT32           shift and go to state 145
    INT64           shift and go to state 146
    STRING          shift and go to state 147
    FLOAT           shift and go to state 148
    FLOAT32         shift and go to state 149
    FLOAT64         shift and go to state 150
    BOOL            shift and go to state 151

    type                           shift and go to state 237

state 187

    (161) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN

    MAP             shift and go to state 238


state 188

    (32) value -> VARIABLE LBRACKET value RBRACKET .
    (165) map_assign -> VARIABLE LBRACKET value RBRACKET . ASSIGN value

    PLUS            reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    MINUS           reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    TIMES           reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    DIVIDE          reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    AND             reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    OR              reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    NOT             reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    LESS            reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    LESSEQUALS      reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    GREATER         reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    GREATEREQUALS   reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    EQUALS          reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    DIFFERENT       reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    INCREMENT       reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    DECREMENT       reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    ASSIGN          shift and go to state 239


state 189

    (159) array_assign -> VARIABLE LBRACKET INT RBRACKET . ASSIGN value

    ASSIGN          shift and go to state 240


state 190

    (170) append_statement -> APPEND LPAREN . VARIABLE COMMA values RPAREN
    (171) append_statement -> APPEND LPAREN . VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN

    VARIABLE        shift and go to state 241


state 191

    (16) main -> FUNCTION MAIN LPAREN RPAREN .

    LBRACE          reduce using rule 16 (main -> FUNCTION MAIN LPAREN RPAREN .)


state 192

    (57) parameters -> VARIABLE . type
    (58) parameters -> VARIABLE . type COMMA parameters
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 144
    INT32           shift and go to state 145
    INT64           shift and go to state 146
    STRING          shift and go to state 147
    FLOAT           shift and go to state 148
    FLOAT32         shift and go to state 149
    FLOAT64         shift and go to state 150
    BOOL            shift and go to state 151

    type                           shift and go to state 242

state 193

    (67) function -> FUNCTION VARIABLE LPAREN RPAREN . LBRACE RBRACE
    (68) function -> FUNCTION VARIABLE LPAREN RPAREN . LBRACE blocks RBRACE
    (69) function -> FUNCTION VARIABLE LPAREN RPAREN . type LBRACE blocks return RBRACE
    (70) function -> FUNCTION VARIABLE LPAREN RPAREN . type LBRACE return RBRACE
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    LBRACE          shift and go to state 243
    INT             shift and go to state 144
    INT32           shift and go to state 145
    INT64           shift and go to state 146
    STRING          shift and go to state 147
    FLOAT           shift and go to state 148
    FLOAT32         shift and go to state 149
    FLOAT64         shift and go to state 150
    BOOL            shift and go to state 151

    type                           shift and go to state 244

state 194

    (71) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN LBRACE blocks RBRACE
    (72) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN LBRACE RBRACE
    (73) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN type LBRACE blocks return RBRACE
    (74) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN type LBRACE return RBRACE

    RPAREN          shift and go to state 245


state 195

    (78) print_statement -> PRINT LPAREN values RPAREN .

    SEMICOLON       reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    PRINT           reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    PRINTF          reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    INPUT           reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    LPAREN          reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    VAR             reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    CONST           reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    TYPE            reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    IF              reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    SWITCH          reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    CHARSTRING      reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    INT             reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    FLOAT           reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    BOOL            reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    FOR             reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    $end            reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    RBRACE          reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    CASE            reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    DEFAULT         reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)
    RETURN          reduce using rule 78 (print_statement -> PRINT LPAREN values RPAREN .)


state 196

    (80) print_statement -> PRINT LPAREN operation RPAREN .

    SEMICOLON       reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    PRINT           reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    PRINTF          reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    INPUT           reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    LPAREN          reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    VAR             reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    CONST           reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    TYPE            reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    IF              reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    SWITCH          reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    INT             reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    BOOL            reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    FOR             reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    $end            reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    CASE            reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)
    RETURN          reduce using rule 80 (print_statement -> PRINT LPAREN operation RPAREN .)


state 197

    (39) values -> value COMMA . values
    (38) values -> . value
    (39) values -> . value COMMA values
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 218
    values                         shift and go to state 246
    not_variable_value             shift and go to state 36

state 198

    (79) print_statement -> PRINTF LPAREN FORMATSTRING COMMA . values RPAREN
    (38) values -> . value
    (39) values -> . value COMMA values
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    values                         shift and go to state 247
    value                          shift and go to state 218
    not_variable_value             shift and go to state 36

state 199

    (82) input_statement -> INPUT LPAREN values RPAREN .

    SEMICOLON       reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    PRINT           reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    PRINTF          reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    INPUT           reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    LPAREN          reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    VAR             reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    CONST           reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    TYPE            reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    IF              reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    SWITCH          reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    CHARSTRING      reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    INT             reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    FLOAT           reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    BOOL            reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    FOR             reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    $end            reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    RBRACE          reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    CASE            reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    DEFAULT         reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)
    RETURN          reduce using rule 82 (input_statement -> INPUT LPAREN values RPAREN .)


state 200

    (83) input_statement -> INPUT LPAREN operation RPAREN .

    SEMICOLON       reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    PRINT           reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    PRINTF          reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    INPUT           reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    LPAREN          reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    VAR             reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    CONST           reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    TYPE            reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    IF              reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    SWITCH          reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    INT             reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    BOOL            reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    FOR             reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    $end            reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    CASE            reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)
    RETURN          reduce using rule 83 (input_statement -> INPUT LPAREN operation RPAREN .)


state 201

    (99) operation -> value operator LPAREN value . RPAREN
    (100) operation -> LPAREN value . RPAREN operator value
    (101) operation -> LPAREN value . operator value RPAREN
    (103) operation -> LPAREN value . operator operation RPAREN
    (104) operation -> LPAREN value . RPAREN operator operation
    (98) operation -> value . operator value
    (99) operation -> value . operator LPAREN value RPAREN
    (102) operation -> value . operator operation
    (105) operation -> value . operator LPAREN operation RPAREN
    (106) operation -> value . double_operator
    (85) operator -> . PLUS
    (86) operator -> . MINUS
    (87) operator -> . TIMES
    (88) operator -> . DIVIDE
    (89) operator -> . AND
    (90) operator -> . OR
    (91) operator -> . NOT
    (92) operator -> . LESS
    (93) operator -> . LESSEQUALS
    (94) operator -> . GREATER
    (95) operator -> . GREATEREQUALS
    (96) operator -> . EQUALS
    (97) operator -> . DIFFERENT
    (107) double_operator -> . INCREMENT
    (108) double_operator -> . DECREMENT

    RPAREN          shift and go to state 249
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    NOT             shift and go to state 87
    LESS            shift and go to state 88
    LESSEQUALS      shift and go to state 89
    GREATER         shift and go to state 90
    GREATEREQUALS   shift and go to state 91
    EQUALS          shift and go to state 92
    DIFFERENT       shift and go to state 93
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    operator                       shift and go to state 248
    double_operator                shift and go to state 80

state 202

    (105) operation -> value operator LPAREN operation . RPAREN

    RPAREN          shift and go to state 250


state 203

    (41) variable_declaration -> VAR variables type ASSIGN . value
    (42) variable_declaration -> VAR variables type ASSIGN . operation
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    LPAREN          shift and go to state 9
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 251
    operation                      shift and go to state 252
    not_variable_value             shift and go to state 36

state 204

    (156) array_structure -> VAR VARIABLE LBRACKET INT . RBRACKET type
    (158) array_structure -> VAR VARIABLE LBRACKET INT . RBRACKET type ASSIGN LBRACKET values RBRACKET

    RBRACKET        shift and go to state 253


state 205

    (167) slice_structure -> VAR VARIABLE LBRACKET RBRACKET . type
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 144
    INT32           shift and go to state 145
    INT64           shift and go to state 146
    STRING          shift and go to state 147
    FLOAT           shift and go to state 148
    FLOAT32         shift and go to state 149
    FLOAT64         shift and go to state 150
    BOOL            shift and go to state 151

    type                           shift and go to state 254

state 206

    (157) array_structure -> VAR VARIABLE ASSIGN LBRACKET . INT RBRACKET type LBRACE values RBRACE

    INT             shift and go to state 255


state 207

    (28) variables -> VARIABLE .
    (29) variables -> VARIABLE . COMMA variables

    INT             reduce using rule 28 (variables -> VARIABLE .)
    INT32           reduce using rule 28 (variables -> VARIABLE .)
    INT64           reduce using rule 28 (variables -> VARIABLE .)
    STRING          reduce using rule 28 (variables -> VARIABLE .)
    FLOAT           reduce using rule 28 (variables -> VARIABLE .)
    FLOAT32         reduce using rule 28 (variables -> VARIABLE .)
    FLOAT64         reduce using rule 28 (variables -> VARIABLE .)
    BOOL            reduce using rule 28 (variables -> VARIABLE .)
    COMMA           shift and go to state 154


state 208

    (29) variables -> VARIABLE COMMA variables .

    INT             reduce using rule 29 (variables -> VARIABLE COMMA variables .)
    INT32           reduce using rule 29 (variables -> VARIABLE COMMA variables .)
    INT64           reduce using rule 29 (variables -> VARIABLE COMMA variables .)
    STRING          reduce using rule 29 (variables -> VARIABLE COMMA variables .)
    FLOAT           reduce using rule 29 (variables -> VARIABLE COMMA variables .)
    FLOAT32         reduce using rule 29 (variables -> VARIABLE COMMA variables .)
    FLOAT64         reduce using rule 29 (variables -> VARIABLE COMMA variables .)
    BOOL            reduce using rule 29 (variables -> VARIABLE COMMA variables .)


state 209

    (45) variable_declaration -> CONST VARIABLE ASSIGN value .

    SEMICOLON       reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    PRINT           reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    PRINTF          reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    INPUT           reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    LPAREN          reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    FUNCTION        reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    VAR             reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    VARIABLE        reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    CONST           reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    TYPE            reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    IF              reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    SWITCH          reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    CHARSTRING      reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    INT             reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    FLOAT           reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    BOOL            reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    FOR             reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    $end            reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    RBRACE          reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    CASE            reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    DEFAULT         reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    RETURN          reduce using rule 45 (variable_declaration -> CONST VARIABLE ASSIGN value .)


state 210

    (152) struct_structure -> TYPE VARIABLE STRUCT LBRACE . struct_fields RBRACE
    (153) struct_fields -> . struct_field
    (154) struct_fields -> . struct_field struct_fields
    (155) struct_field -> . VARIABLE type

    VARIABLE        shift and go to state 256

    struct_fields                  shift and go to state 257
    struct_field                   shift and go to state 258

state 211

    (113) conditional_structure -> IF conditions conditional_body ELSE . conditional_body
    (114) conditional_structure -> IF conditions conditional_body ELSE . IF conditions conditional_body
    (115) conditional_structure -> IF conditions conditional_body ELSE . IF conditions conditional_body ELSE conditional_body
    (116) conditional_body -> . LBRACE blocks RBRACE
    (117) conditional_body -> . LBRACE blocks return RBRACE
    (118) conditional_body -> . LBRACE return RBRACE
    (119) conditional_body -> . LBRACE BREAK RBRACE
    (120) conditional_body -> . LBRACE CONTINUE RBRACE

    IF              shift and go to state 259
    LBRACE          shift and go to state 158

    conditional_body               shift and go to state 260

state 212

    (116) conditional_body -> LBRACE blocks . RBRACE
    (117) conditional_body -> LBRACE blocks . return RBRACE
    (75) return -> . RETURN value
    (76) return -> . RETURN value LBRACKET value RBRACKET
    (77) return -> . RETURN value PERIOD value

    RBRACE          shift and go to state 261
    RETURN          shift and go to state 216

    return                         shift and go to state 262

state 213

    (118) conditional_body -> LBRACE return . RBRACE

    RBRACE          shift and go to state 263


state 214

    (119) conditional_body -> LBRACE BREAK . RBRACE

    RBRACE          shift and go to state 264


state 215

    (120) conditional_body -> LBRACE CONTINUE . RBRACE

    RBRACE          shift and go to state 265


state 216

    (75) return -> RETURN . value
    (76) return -> RETURN . value LBRACKET value RBRACKET
    (77) return -> RETURN . value PERIOD value
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 266
    not_variable_value             shift and go to state 36

state 217

    (122) conditions -> condition logical_operator conditions .

    LBRACE          reduce using rule 122 (conditions -> condition logical_operator conditions .)


state 218

    (38) values -> value .
    (39) values -> value . COMMA values

    AND             reduce using rule 38 (values -> value .)
    OR              reduce using rule 38 (values -> value .)
    NOT             reduce using rule 38 (values -> value .)
    LBRACE          reduce using rule 38 (values -> value .)
    SEMICOLON       reduce using rule 38 (values -> value .)
    RPAREN          reduce using rule 38 (values -> value .)
    COLON           reduce using rule 38 (values -> value .)
    RBRACE          reduce using rule 38 (values -> value .)
    RBRACKET        reduce using rule 38 (values -> value .)
    COMMA           shift and go to state 197


state 219

    (124) condition -> value relational_operator values .

    AND             reduce using rule 124 (condition -> value relational_operator values .)
    OR              reduce using rule 124 (condition -> value relational_operator values .)
    NOT             reduce using rule 124 (condition -> value relational_operator values .)
    LBRACE          reduce using rule 124 (condition -> value relational_operator values .)
    SEMICOLON       reduce using rule 124 (condition -> value relational_operator values .)


state 220

    (140) switch_structure -> SWITCH switch_expression LBRACE case_blocks . RBRACE

    RBRACE          shift and go to state 267


state 221

    (143) case_blocks -> case_block .
    (144) case_blocks -> case_block . case_blocks
    (143) case_blocks -> . case_block
    (144) case_blocks -> . case_block case_blocks
    (145) case_block -> . CASE values COLON statement
    (146) case_block -> . DEFAULT COLON statement

    RBRACE          reduce using rule 143 (case_blocks -> case_block .)
    CASE            shift and go to state 222
    DEFAULT         shift and go to state 223

    case_block                     shift and go to state 221
    case_blocks                    shift and go to state 268

state 222

    (145) case_block -> CASE . values COLON statement
    (38) values -> . value
    (39) values -> . value COMMA values
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    values                         shift and go to state 269
    value                          shift and go to state 218
    not_variable_value             shift and go to state 36

state 223

    (146) case_block -> DEFAULT . COLON statement

    COLON           shift and go to state 270


state 224

    (141) switch_expression -> VARIABLE SHORTASSIGN value .

    LBRACE          reduce using rule 141 (switch_expression -> VARIABLE SHORTASSIGN value .)


state 225

    (137) for_initialization -> FOR VARIABLE SHORTASSIGN value . SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 271


state 226

    (139) for_iterator -> FOR VARIABLE COMMA VARIABLE . SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 272


state 227

    (138) for_infinite_bucle -> FOR LBRACE statement RBRACE .

    SEMICOLON       reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    PRINT           reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    PRINTF          reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INPUT           reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    LPAREN          reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VAR             reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CONST           reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    TYPE            reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    IF              reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    SWITCH          reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INT             reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FLOAT           reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    BOOL            reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FOR             reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    $end            reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RBRACE          reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CASE            reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RETURN          reduce using rule 138 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)


state 228

    (7) statement -> import main LBRACE blocks RBRACE .

    $end            reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)
    CASE            reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)


state 229

    (8) statement -> package import main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 273


state 230

    (6) statement -> package main LBRACE blocks RBRACE .

    $end            reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)
    CASE            reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)


state 231

    (100) operation -> LPAREN value RPAREN operator value .
    (98) operation -> value . operator value
    (99) operation -> value . operator LPAREN value RPAREN
    (102) operation -> value . operator operation
    (105) operation -> value . operator LPAREN operation RPAREN
    (106) operation -> value . double_operator
    (85) operator -> . PLUS
    (86) operator -> . MINUS
    (87) operator -> . TIMES
    (88) operator -> . DIVIDE
    (89) operator -> . AND
    (90) operator -> . OR
    (91) operator -> . NOT
    (92) operator -> . LESS
    (93) operator -> . LESSEQUALS
    (94) operator -> . GREATER
    (95) operator -> . GREATEREQUALS
    (96) operator -> . EQUALS
    (97) operator -> . DIFFERENT
    (107) double_operator -> . INCREMENT
    (108) double_operator -> . DECREMENT

    SEMICOLON       reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    PRINT           reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    PRINTF          reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    INPUT           reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    LPAREN          reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    FUNCTION        reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    VAR             reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    VARIABLE        reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    CONST           reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    TYPE            reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    IF              reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    SWITCH          reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    CHARSTRING      reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    INT             reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    FLOAT           reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    BOOL            reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    FOR             reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    $end            reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    RBRACE          reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    CASE            reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    DEFAULT         reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    RETURN          reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    RPAREN          reduce using rule 100 (operation -> LPAREN value RPAREN operator value .)
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    NOT             shift and go to state 87
    LESS            shift and go to state 88
    LESSEQUALS      shift and go to state 89
    GREATER         shift and go to state 90
    GREATEREQUALS   shift and go to state 91
    EQUALS          shift and go to state 92
    DIFFERENT       shift and go to state 93
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    operator                       shift and go to state 79
    double_operator                shift and go to state 80

state 232

    (104) operation -> LPAREN value RPAREN operator operation .

    SEMICOLON       reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    PRINT           reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    PRINTF          reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    INPUT           reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    LPAREN          reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    FUNCTION        reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    VAR             reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    VARIABLE        reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    CONST           reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    TYPE            reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    IF              reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    SWITCH          reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    CHARSTRING      reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    INT             reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    FLOAT           reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    BOOL            reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    FOR             reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    $end            reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    RBRACE          reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    CASE            reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    DEFAULT         reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    RETURN          reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)
    RPAREN          reduce using rule 104 (operation -> LPAREN value RPAREN operator operation .)


state 233

    (101) operation -> LPAREN value operator value RPAREN .

    SEMICOLON       reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    PRINT           reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    PRINTF          reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    INPUT           reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    LPAREN          reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    FUNCTION        reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    VAR             reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    VARIABLE        reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    CONST           reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    TYPE            reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    IF              reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    SWITCH          reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    CHARSTRING      reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    INT             reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    FLOAT           reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    BOOL            reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    FOR             reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    $end            reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    RBRACE          reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    CASE            reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    DEFAULT         reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    RETURN          reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)
    RPAREN          reduce using rule 101 (operation -> LPAREN value operator value RPAREN .)


state 234

    (103) operation -> LPAREN value operator operation RPAREN .

    SEMICOLON       reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    PRINT           reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    PRINTF          reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    INPUT           reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    LPAREN          reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    FUNCTION        reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    VAR             reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    VARIABLE        reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    CONST           reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    TYPE            reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    IF              reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    SWITCH          reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    CHARSTRING      reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    INT             reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    FLOAT           reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    BOOL            reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    FOR             reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    $end            reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    RBRACE          reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    CASE            reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    DEFAULT         reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    RETURN          reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)
    RPAREN          reduce using rule 103 (operation -> LPAREN value operator operation RPAREN .)


state 235

    (32) value -> VARIABLE LBRACKET value RBRACKET .

    RPAREN          reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    PLUS            reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    MINUS           reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    TIMES           reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    DIVIDE          reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    AND             reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    OR              reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    NOT             reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    LESS            reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    LESSEQUALS      reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    GREATER         reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    GREATEREQUALS   reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    EQUALS          reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    DIFFERENT       reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    INCREMENT       reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    DECREMENT       reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    SEMICOLON       reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    PRINT           reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    PRINTF          reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    INPUT           reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    LPAREN          reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    FUNCTION        reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    VAR             reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    VARIABLE        reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    CONST           reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    TYPE            reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    IF              reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    SWITCH          reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    CHARSTRING      reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    INT             reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    FLOAT           reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    BOOL            reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    FOR             reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    $end            reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    RBRACE          reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    CASE            reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    DEFAULT         reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    RETURN          reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    RBRACKET        reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    COMMA           reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    LBRACE          reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    COLON           reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    LBRACKET        reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)
    PERIOD          reduce using rule 32 (value -> VARIABLE LBRACKET value RBRACKET .)


state 236

    (160) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type . RBRACKET type LBRACE map_values RBRACE

    RBRACKET        shift and go to state 274


state 237

    (166) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type . LBRACE values RBRACE
    (168) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .

    LBRACE          shift and go to state 275
    SEMICOLON       reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    PRINT           reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    PRINTF          reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    INPUT           reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    LPAREN          reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FUNCTION        reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    VAR             reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CONST           reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    TYPE            reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    IF              reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CHARSTRING      reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    INT             reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FLOAT           reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    BOOL            reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FOR             reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    $end            reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CASE            reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    RETURN          reduce using rule 168 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)


state 238

    (161) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN

    LBRACKET        shift and go to state 276


state 239

    (165) map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN . value
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 277
    not_variable_value             shift and go to state 36

state 240

    (159) array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN . value
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 278
    not_variable_value             shift and go to state 36

state 241

    (170) append_statement -> APPEND LPAREN VARIABLE . COMMA values RPAREN
    (171) append_statement -> APPEND LPAREN VARIABLE . COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN

    COMMA           shift and go to state 279


state 242

    (57) parameters -> VARIABLE type .
    (58) parameters -> VARIABLE type . COMMA parameters

    RPAREN          reduce using rule 57 (parameters -> VARIABLE type .)
    COMMA           shift and go to state 280


state 243

    (67) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE . RBRACE
    (68) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    RBRACE          shift and go to state 281
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

    blocks                         shift and go to state 282
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 244

    (69) function -> FUNCTION VARIABLE LPAREN RPAREN type . LBRACE blocks return RBRACE
    (70) function -> FUNCTION VARIABLE LPAREN RPAREN type . LBRACE return RBRACE

    LBRACE          shift and go to state 283


state 245

    (71) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . LBRACE blocks RBRACE
    (72) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . LBRACE RBRACE
    (73) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . type LBRACE blocks return RBRACE
    (74) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . type LBRACE return RBRACE
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    LBRACE          shift and go to state 284
    INT             shift and go to state 144
    INT32           shift and go to state 145
    INT64           shift and go to state 146
    STRING          shift and go to state 147
    FLOAT           shift and go to state 148
    FLOAT32         shift and go to state 149
    FLOAT64         shift and go to state 150
    BOOL            shift and go to state 151

    type                           shift and go to state 285

state 246

    (39) values -> value COMMA values .

    RPAREN          reduce using rule 39 (values -> value COMMA values .)
    AND             reduce using rule 39 (values -> value COMMA values .)
    OR              reduce using rule 39 (values -> value COMMA values .)
    NOT             reduce using rule 39 (values -> value COMMA values .)
    LBRACE          reduce using rule 39 (values -> value COMMA values .)
    SEMICOLON       reduce using rule 39 (values -> value COMMA values .)
    COLON           reduce using rule 39 (values -> value COMMA values .)
    RBRACE          reduce using rule 39 (values -> value COMMA values .)
    RBRACKET        reduce using rule 39 (values -> value COMMA values .)


state 247

    (79) print_statement -> PRINTF LPAREN FORMATSTRING COMMA values . RPAREN

    RPAREN          shift and go to state 286


state 248

    (101) operation -> LPAREN value operator . value RPAREN
    (103) operation -> LPAREN value operator . operation RPAREN
    (98) operation -> value operator . value
    (99) operation -> value operator . LPAREN value RPAREN
    (102) operation -> value operator . operation
    (105) operation -> value operator . LPAREN operation RPAREN
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    LPAREN          shift and go to state 141
    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 287
    operation                      shift and go to state 288
    not_variable_value             shift and go to state 36

state 249

    (99) operation -> value operator LPAREN value RPAREN .
    (100) operation -> LPAREN value RPAREN . operator value
    (104) operation -> LPAREN value RPAREN . operator operation
    (85) operator -> . PLUS
    (86) operator -> . MINUS
    (87) operator -> . TIMES
    (88) operator -> . DIVIDE
    (89) operator -> . AND
    (90) operator -> . OR
    (91) operator -> . NOT
    (92) operator -> . LESS
    (93) operator -> . LESSEQUALS
    (94) operator -> . GREATER
    (95) operator -> . GREATEREQUALS
    (96) operator -> . EQUALS
    (97) operator -> . DIFFERENT

    SEMICOLON       reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    PRINT           reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    PRINTF          reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    INPUT           reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    LPAREN          reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    FUNCTION        reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    VAR             reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    VARIABLE        reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    CONST           reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    TYPE            reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    IF              reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    SWITCH          reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    CHARSTRING      reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    INT             reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    FLOAT           reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    BOOL            reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    FOR             reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    $end            reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    RBRACE          reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    CASE            reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    DEFAULT         reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    RETURN          reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    RPAREN          reduce using rule 99 (operation -> value operator LPAREN value RPAREN .)
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    NOT             shift and go to state 87
    LESS            shift and go to state 88
    LESSEQUALS      shift and go to state 89
    GREATER         shift and go to state 90
    GREATEREQUALS   shift and go to state 91
    EQUALS          shift and go to state 92
    DIFFERENT       shift and go to state 93

    operator                       shift and go to state 181

state 250

    (105) operation -> value operator LPAREN operation RPAREN .

    SEMICOLON       reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    PRINT           reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    PRINTF          reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    INPUT           reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    LPAREN          reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    VAR             reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    CONST           reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    TYPE            reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    IF              reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    SWITCH          reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    INT             reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    FLOAT           reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    BOOL            reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    FOR             reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    $end            reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    RBRACE          reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    CASE            reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    RETURN          reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)
    RPAREN          reduce using rule 105 (operation -> value operator LPAREN operation RPAREN .)


state 251

    (41) variable_declaration -> VAR variables type ASSIGN value .
    (98) operation -> value . operator value
    (99) operation -> value . operator LPAREN value RPAREN
    (102) operation -> value . operator operation
    (105) operation -> value . operator LPAREN operation RPAREN
    (106) operation -> value . double_operator
    (85) operator -> . PLUS
    (86) operator -> . MINUS
    (87) operator -> . TIMES
    (88) operator -> . DIVIDE
    (89) operator -> . AND
    (90) operator -> . OR
    (91) operator -> . NOT
    (92) operator -> . LESS
    (93) operator -> . LESSEQUALS
    (94) operator -> . GREATER
    (95) operator -> . GREATEREQUALS
    (96) operator -> . EQUALS
    (97) operator -> . DIFFERENT
    (107) double_operator -> . INCREMENT
    (108) double_operator -> . DECREMENT

    SEMICOLON       reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    PRINT           reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    PRINTF          reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    INPUT           reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    LPAREN          reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    FUNCTION        reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    VAR             reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    VARIABLE        reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    CONST           reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    TYPE            reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    IF              reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    SWITCH          reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    CHARSTRING      reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    INT             reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    FLOAT           reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    BOOL            reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    FOR             reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    $end            reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    RBRACE          reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    CASE            reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    DEFAULT         reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    RETURN          reduce using rule 41 (variable_declaration -> VAR variables type ASSIGN value .)
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    NOT             shift and go to state 87
    LESS            shift and go to state 88
    LESSEQUALS      shift and go to state 89
    GREATER         shift and go to state 90
    GREATEREQUALS   shift and go to state 91
    EQUALS          shift and go to state 92
    DIFFERENT       shift and go to state 93
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    operator                       shift and go to state 79
    double_operator                shift and go to state 80

state 252

    (42) variable_declaration -> VAR variables type ASSIGN operation .

    SEMICOLON       reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    PRINT           reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    PRINTF          reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    INPUT           reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    LPAREN          reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    FUNCTION        reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    VAR             reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    VARIABLE        reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    CONST           reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    TYPE            reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    IF              reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    SWITCH          reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    CHARSTRING      reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    INT             reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    FLOAT           reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    BOOL            reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    FOR             reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    $end            reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    RBRACE          reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    CASE            reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    DEFAULT         reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)
    RETURN          reduce using rule 42 (variable_declaration -> VAR variables type ASSIGN operation .)


state 253

    (156) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET . type
    (158) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET . type ASSIGN LBRACKET values RBRACKET
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 144
    INT32           shift and go to state 145
    INT64           shift and go to state 146
    STRING          shift and go to state 147
    FLOAT           shift and go to state 148
    FLOAT32         shift and go to state 149
    FLOAT64         shift and go to state 150
    BOOL            shift and go to state 151

    type                           shift and go to state 289

state 254

    (167) slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .

    SEMICOLON       reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    PRINT           reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    PRINTF          reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    INPUT           reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    LPAREN          reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FUNCTION        reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    VAR             reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CONST           reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    TYPE            reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    IF              reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CHARSTRING      reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    INT             reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FLOAT           reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    BOOL            reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FOR             reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    $end            reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CASE            reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    RETURN          reduce using rule 167 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)


state 255

    (157) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT . RBRACKET type LBRACE values RBRACE

    RBRACKET        shift and go to state 290


state 256

    (155) struct_field -> VARIABLE . type
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 144
    INT32           shift and go to state 145
    INT64           shift and go to state 146
    STRING          shift and go to state 147
    FLOAT           shift and go to state 148
    FLOAT32         shift and go to state 149
    FLOAT64         shift and go to state 150
    BOOL            shift and go to state 151

    type                           shift and go to state 291

state 257

    (152) struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields . RBRACE

    RBRACE          shift and go to state 292


state 258

    (153) struct_fields -> struct_field .
    (154) struct_fields -> struct_field . struct_fields
    (153) struct_fields -> . struct_field
    (154) struct_fields -> . struct_field struct_fields
    (155) struct_field -> . VARIABLE type

    RBRACE          reduce using rule 153 (struct_fields -> struct_field .)
    VARIABLE        shift and go to state 256

    struct_field                   shift and go to state 258
    struct_fields                  shift and go to state 293

state 259

    (114) conditional_structure -> IF conditions conditional_body ELSE IF . conditions conditional_body
    (115) conditional_structure -> IF conditions conditional_body ELSE IF . conditions conditional_body ELSE conditional_body
    (121) conditions -> . condition
    (122) conditions -> . condition logical_operator conditions
    (123) condition -> . BOOL
    (124) condition -> . value relational_operator values
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    BOOL            shift and go to state 100
    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44

    conditions                     shift and go to state 294
    condition                      shift and go to state 99
    value                          shift and go to state 101
    not_variable_value             shift and go to state 36

state 260

    (113) conditional_structure -> IF conditions conditional_body ELSE conditional_body .

    SEMICOLON       reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    PRINT           reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    PRINTF          reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    LPAREN          reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CONST           reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    SWITCH          reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CHARSTRING      reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    BOOL            reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CASE            reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    DEFAULT         reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RETURN          reduce using rule 113 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)


state 261

    (116) conditional_body -> LBRACE blocks RBRACE .

    ELSE            reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    SEMICOLON       reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    PRINT           reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    INPUT           reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    LPAREN          reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    VAR             reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    CONST           reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    TYPE            reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    IF              reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    INT             reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    BOOL            reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    FOR             reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    $end            reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    CASE            reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)
    RETURN          reduce using rule 116 (conditional_body -> LBRACE blocks RBRACE .)


state 262

    (117) conditional_body -> LBRACE blocks return . RBRACE

    RBRACE          shift and go to state 295


state 263

    (118) conditional_body -> LBRACE return RBRACE .

    ELSE            reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    SEMICOLON       reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    PRINT           reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    PRINTF          reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    INPUT           reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    LPAREN          reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    FUNCTION        reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    VAR             reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    VARIABLE        reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    CONST           reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    TYPE            reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    IF              reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    SWITCH          reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    CHARSTRING      reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    INT             reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    FLOAT           reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    BOOL            reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    FOR             reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    $end            reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    RBRACE          reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    CASE            reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    DEFAULT         reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)
    RETURN          reduce using rule 118 (conditional_body -> LBRACE return RBRACE .)


state 264

    (119) conditional_body -> LBRACE BREAK RBRACE .

    ELSE            reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    SEMICOLON       reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    PRINT           reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    PRINTF          reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    INPUT           reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    LPAREN          reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    FUNCTION        reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    VAR             reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    VARIABLE        reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    CONST           reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    TYPE            reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    IF              reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    SWITCH          reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    CHARSTRING      reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    INT             reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    FLOAT           reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    BOOL            reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    FOR             reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    $end            reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    RBRACE          reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    CASE            reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    DEFAULT         reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)
    RETURN          reduce using rule 119 (conditional_body -> LBRACE BREAK RBRACE .)


state 265

    (120) conditional_body -> LBRACE CONTINUE RBRACE .

    ELSE            reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    SEMICOLON       reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    PRINT           reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    PRINTF          reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INPUT           reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    LPAREN          reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FUNCTION        reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VAR             reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VARIABLE        reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CONST           reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    TYPE            reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    IF              reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    SWITCH          reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CHARSTRING      reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INT             reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FLOAT           reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    BOOL            reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FOR             reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    $end            reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RBRACE          reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CASE            reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    DEFAULT         reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RETURN          reduce using rule 120 (conditional_body -> LBRACE CONTINUE RBRACE .)


state 266

    (75) return -> RETURN value .
    (76) return -> RETURN value . LBRACKET value RBRACKET
    (77) return -> RETURN value . PERIOD value

    RBRACE          reduce using rule 75 (return -> RETURN value .)
    LBRACKET        shift and go to state 296
    PERIOD          shift and go to state 297


state 267

    (140) switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .

    SEMICOLON       reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    PRINT           reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    PRINTF          reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    INPUT           reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    LPAREN          reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FUNCTION        reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    VAR             reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    VARIABLE        reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CONST           reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    TYPE            reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    IF              reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    SWITCH          reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CHARSTRING      reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    INT             reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FLOAT           reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    BOOL            reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FOR             reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    $end            reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    RBRACE          reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CASE            reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    DEFAULT         reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    RETURN          reduce using rule 140 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)


state 268

    (144) case_blocks -> case_block case_blocks .

    RBRACE          reduce using rule 144 (case_blocks -> case_block case_blocks .)


state 269

    (145) case_block -> CASE values . COLON statement

    COLON           shift and go to state 298


state 270

    (146) case_block -> DEFAULT COLON . statement
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! LPAREN          [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]
  ! BOOL            [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 299
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 271

    (137) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON . condition SEMICOLON value double_operator LBRACE statement RBRACE
    (123) condition -> . BOOL
    (124) condition -> . value relational_operator values
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    BOOL            shift and go to state 100
    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44

    value                          shift and go to state 101
    condition                      shift and go to state 300
    not_variable_value             shift and go to state 36

state 272

    (139) for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN . RANGE VARIABLE LBRACE statement RBRACE

    RANGE           shift and go to state 301


state 273

    (8) statement -> package import main LBRACE blocks RBRACE .

    $end            reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)
    CASE            reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)


state 274

    (160) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET . type LBRACE map_values RBRACE
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 144
    INT32           shift and go to state 145
    INT64           shift and go to state 146
    STRING          shift and go to state 147
    FLOAT           shift and go to state 148
    FLOAT32         shift and go to state 149
    FLOAT64         shift and go to state 150
    BOOL            shift and go to state 151

    type                           shift and go to state 302

state 275

    (166) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE . values RBRACE
    (38) values -> . value
    (39) values -> . value COMMA values
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    values                         shift and go to state 303
    value                          shift and go to state 218
    not_variable_value             shift and go to state 36

state 276

    (161) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 144
    INT32           shift and go to state 145
    INT64           shift and go to state 146
    STRING          shift and go to state 147
    FLOAT           shift and go to state 148
    FLOAT32         shift and go to state 149
    FLOAT64         shift and go to state 150
    BOOL            shift and go to state 151

    type                           shift and go to state 304

state 277

    (165) map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .

    SEMICOLON       reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    PRINT           reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    PRINTF          reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    INPUT           reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    LPAREN          reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    FUNCTION        reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    VAR             reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    VARIABLE        reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    CONST           reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    TYPE            reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    IF              reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    SWITCH          reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    CHARSTRING      reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    INT             reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    FLOAT           reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    BOOL            reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    FOR             reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    $end            reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    RBRACE          reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    CASE            reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    DEFAULT         reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    RETURN          reduce using rule 165 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)


state 278

    (159) array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .

    SEMICOLON       reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    PRINT           reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    PRINTF          reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    INPUT           reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    LPAREN          reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    FUNCTION        reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    VAR             reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    VARIABLE        reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    CONST           reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    TYPE            reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    IF              reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    SWITCH          reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    CHARSTRING      reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    INT             reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    FLOAT           reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    BOOL            reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    FOR             reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    $end            reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    RBRACE          reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    CASE            reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    DEFAULT         reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    RETURN          reduce using rule 159 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)


state 279

    (170) append_statement -> APPEND LPAREN VARIABLE COMMA . values RPAREN
    (171) append_statement -> APPEND LPAREN VARIABLE COMMA . LBRACKET RBRACKET type LBRACE values RBRACE RPAREN
    (38) values -> . value
    (39) values -> . value COMMA values
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    LBRACKET        shift and go to state 306
    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    values                         shift and go to state 305
    value                          shift and go to state 218
    not_variable_value             shift and go to state 36

state 280

    (58) parameters -> VARIABLE type COMMA . parameters
    (57) parameters -> . VARIABLE type
    (58) parameters -> . VARIABLE type COMMA parameters

    VARIABLE        shift and go to state 192

    parameters                     shift and go to state 307

state 281

    (67) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .

    SEMICOLON       reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    PRINT           reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    PRINTF          reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    INPUT           reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    LPAREN          reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    FUNCTION        reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    VAR             reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    VARIABLE        reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    CONST           reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    TYPE            reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    IF              reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    SWITCH          reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    CHARSTRING      reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    INT             reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    FLOAT           reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    BOOL            reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    FOR             reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    $end            reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    RBRACE          reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    CASE            reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    DEFAULT         reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)
    RETURN          reduce using rule 67 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE .)


state 282

    (68) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 308


state 283

    (69) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE . blocks return RBRACE
    (70) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE . return RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (75) return -> . RETURN value
    (76) return -> . RETURN value LBRACKET value RBRACKET
    (77) return -> . RETURN value PERIOD value
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    RETURN          shift and go to state 216
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

    blocks                         shift and go to state 309
    return                         shift and go to state 310
    block                          shift and go to state 6
    value                          shift and go to state 24
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 284

    (71) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE . blocks RBRACE
    (72) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE . RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    RBRACE          shift and go to state 312
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

    blocks                         shift and go to state 311
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 285

    (73) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type . LBRACE blocks return RBRACE
    (74) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type . LBRACE return RBRACE

    LBRACE          shift and go to state 313


state 286

    (79) print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .

    SEMICOLON       reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    PRINT           reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    PRINTF          reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    INPUT           reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    LPAREN          reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FUNCTION        reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    VAR             reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    VARIABLE        reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CONST           reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    TYPE            reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    IF              reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    SWITCH          reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CHARSTRING      reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    INT             reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FLOAT           reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    BOOL            reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FOR             reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    $end            reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    RBRACE          reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CASE            reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    DEFAULT         reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    RETURN          reduce using rule 79 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)


state 287

    (101) operation -> LPAREN value operator value . RPAREN
    (98) operation -> value operator value .
    (98) operation -> value . operator value
    (99) operation -> value . operator LPAREN value RPAREN
    (102) operation -> value . operator operation
    (105) operation -> value . operator LPAREN operation RPAREN
    (106) operation -> value . double_operator
    (85) operator -> . PLUS
    (86) operator -> . MINUS
    (87) operator -> . TIMES
    (88) operator -> . DIVIDE
    (89) operator -> . AND
    (90) operator -> . OR
    (91) operator -> . NOT
    (92) operator -> . LESS
    (93) operator -> . LESSEQUALS
    (94) operator -> . GREATER
    (95) operator -> . GREATEREQUALS
    (96) operator -> . EQUALS
    (97) operator -> . DIFFERENT
    (107) double_operator -> . INCREMENT
    (108) double_operator -> . DECREMENT

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 233
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86
    NOT             shift and go to state 87
    LESS            shift and go to state 88
    LESSEQUALS      shift and go to state 89
    GREATER         shift and go to state 90
    GREATEREQUALS   shift and go to state 91
    EQUALS          shift and go to state 92
    DIFFERENT       shift and go to state 93
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

  ! RPAREN          [ reduce using rule 98 (operation -> value operator value .) ]

    operator                       shift and go to state 79
    double_operator                shift and go to state 80

state 288

    (103) operation -> LPAREN value operator operation . RPAREN
    (102) operation -> value operator operation .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 234

  ! RPAREN          [ reduce using rule 102 (operation -> value operator operation .) ]


state 289

    (156) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .
    (158) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type . ASSIGN LBRACKET values RBRACKET

    SEMICOLON       reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    PRINT           reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    PRINTF          reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    INPUT           reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    LPAREN          reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    FUNCTION        reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    VAR             reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    VARIABLE        reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    CONST           reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    TYPE            reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    IF              reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    SWITCH          reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    CHARSTRING      reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    INT             reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    FLOAT           reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    BOOL            reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    FOR             reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    $end            reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    RBRACE          reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    CASE            reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    DEFAULT         reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    RETURN          reduce using rule 156 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    ASSIGN          shift and go to state 314


state 290

    (157) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET . type LBRACE values RBRACE
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 144
    INT32           shift and go to state 145
    INT64           shift and go to state 146
    STRING          shift and go to state 147
    FLOAT           shift and go to state 148
    FLOAT32         shift and go to state 149
    FLOAT64         shift and go to state 150
    BOOL            shift and go to state 151

    type                           shift and go to state 315

state 291

    (155) struct_field -> VARIABLE type .

    VARIABLE        reduce using rule 155 (struct_field -> VARIABLE type .)
    RBRACE          reduce using rule 155 (struct_field -> VARIABLE type .)


state 292

    (152) struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .

    SEMICOLON       reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    PRINT           reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    PRINTF          reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    INPUT           reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    LPAREN          reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FUNCTION        reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    VAR             reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    VARIABLE        reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CONST           reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    TYPE            reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    IF              reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    SWITCH          reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CHARSTRING      reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    INT             reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FLOAT           reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    BOOL            reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FOR             reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    $end            reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    RBRACE          reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CASE            reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    DEFAULT         reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    RETURN          reduce using rule 152 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)


state 293

    (154) struct_fields -> struct_field struct_fields .

    RBRACE          reduce using rule 154 (struct_fields -> struct_field struct_fields .)


state 294

    (114) conditional_structure -> IF conditions conditional_body ELSE IF conditions . conditional_body
    (115) conditional_structure -> IF conditions conditional_body ELSE IF conditions . conditional_body ELSE conditional_body
    (116) conditional_body -> . LBRACE blocks RBRACE
    (117) conditional_body -> . LBRACE blocks return RBRACE
    (118) conditional_body -> . LBRACE return RBRACE
    (119) conditional_body -> . LBRACE BREAK RBRACE
    (120) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 158

    conditional_body               shift and go to state 316

state 295

    (117) conditional_body -> LBRACE blocks return RBRACE .

    ELSE            reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    SEMICOLON       reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    PRINT           reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    PRINTF          reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    INPUT           reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    LPAREN          reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    FUNCTION        reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    VAR             reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    VARIABLE        reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    CONST           reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    TYPE            reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    IF              reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    SWITCH          reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    CHARSTRING      reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    INT             reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    FLOAT           reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    BOOL            reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    FOR             reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    $end            reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    RBRACE          reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    CASE            reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    DEFAULT         reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)
    RETURN          reduce using rule 117 (conditional_body -> LBRACE blocks return RBRACE .)


state 296

    (76) return -> RETURN value LBRACKET . value RBRACKET
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 317
    not_variable_value             shift and go to state 36

state 297

    (77) return -> RETURN value PERIOD . value
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 318
    not_variable_value             shift and go to state 36

state 298

    (145) case_block -> CASE values COLON . statement
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! LPAREN          [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]
  ! BOOL            [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 319
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 299

    (146) case_block -> DEFAULT COLON statement .

    CASE            reduce using rule 146 (case_block -> DEFAULT COLON statement .)
    DEFAULT         reduce using rule 146 (case_block -> DEFAULT COLON statement .)
    RBRACE          reduce using rule 146 (case_block -> DEFAULT COLON statement .)


state 300

    (137) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition . SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 320


state 301

    (139) for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE . VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 321


state 302

    (160) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type . LBRACE map_values RBRACE

    LBRACE          shift and go to state 322


state 303

    (166) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values . RBRACE

    RBRACE          shift and go to state 323


state 304

    (161) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN

    RBRACKET        shift and go to state 324


state 305

    (170) append_statement -> APPEND LPAREN VARIABLE COMMA values . RPAREN

    RPAREN          shift and go to state 325


state 306

    (171) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET . RBRACKET type LBRACE values RBRACE RPAREN

    RBRACKET        shift and go to state 326


state 307

    (58) parameters -> VARIABLE type COMMA parameters .

    RPAREN          reduce using rule 58 (parameters -> VARIABLE type COMMA parameters .)


state 308

    (68) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .

    SEMICOLON       reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    PRINT           reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    LPAREN          reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CONST           reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    BOOL            reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CASE            reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    RETURN          reduce using rule 68 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)


state 309

    (69) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks . return RBRACE
    (75) return -> . RETURN value
    (76) return -> . RETURN value LBRACKET value RBRACKET
    (77) return -> . RETURN value PERIOD value

    RETURN          shift and go to state 216

    return                         shift and go to state 327

state 310

    (70) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return . RBRACE

    RBRACE          shift and go to state 328


state 311

    (71) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 329


state 312

    (72) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .

    SEMICOLON       reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    PRINT           reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    PRINTF          reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    INPUT           reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    LPAREN          reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    FUNCTION        reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    VAR             reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    VARIABLE        reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    CONST           reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    TYPE            reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    IF              reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    SWITCH          reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    CHARSTRING      reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    INT             reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    FLOAT           reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    BOOL            reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    FOR             reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    $end            reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    RBRACE          reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    CASE            reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    DEFAULT         reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)
    RETURN          reduce using rule 72 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE .)


state 313

    (73) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE . blocks return RBRACE
    (74) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE . return RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (75) return -> . RETURN value
    (76) return -> . RETURN value LBRACKET value RBRACKET
    (77) return -> . RETURN value PERIOD value
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    RETURN          shift and go to state 216
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

    blocks                         shift and go to state 330
    return                         shift and go to state 331
    block                          shift and go to state 6
    value                          shift and go to state 24
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 314

    (158) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN . LBRACKET values RBRACKET

    LBRACKET        shift and go to state 332


state 315

    (157) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type . LBRACE values RBRACE

    LBRACE          shift and go to state 333


state 316

    (114) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .
    (115) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body . ELSE conditional_body

    SEMICOLON       reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    PRINT           reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    PRINTF          reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    INPUT           reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    LPAREN          reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    FUNCTION        reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    VAR             reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    VARIABLE        reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    CONST           reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    TYPE            reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    IF              reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    SWITCH          reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    CHARSTRING      reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    INT             reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    FLOAT           reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    BOOL            reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    FOR             reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    $end            reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    RBRACE          reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    CASE            reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    DEFAULT         reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    RETURN          reduce using rule 114 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body .)
    ELSE            shift and go to state 334


state 317

    (76) return -> RETURN value LBRACKET value . RBRACKET

    RBRACKET        shift and go to state 335


state 318

    (77) return -> RETURN value PERIOD value .

    RBRACE          reduce using rule 77 (return -> RETURN value PERIOD value .)


state 319

    (145) case_block -> CASE values COLON statement .

    CASE            reduce using rule 145 (case_block -> CASE values COLON statement .)
    DEFAULT         reduce using rule 145 (case_block -> CASE values COLON statement .)
    RBRACE          reduce using rule 145 (case_block -> CASE values COLON statement .)


state 320

    (137) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON . value double_operator LBRACE statement RBRACE
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 336
    not_variable_value             shift and go to state 36

state 321

    (139) for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE . LBRACE statement RBRACE

    LBRACE          shift and go to state 337


state 322

    (160) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE . map_values RBRACE
    (162) map_values -> . map_value
    (163) map_values -> . map_value COMMA map_values
    (164) map_value -> . value COLON value
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    map_values                     shift and go to state 338
    map_value                      shift and go to state 339
    value                          shift and go to state 340
    not_variable_value             shift and go to state 36

state 323

    (166) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .

    SEMICOLON       reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    PRINT           reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    PRINTF          reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    INPUT           reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    LPAREN          reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FUNCTION        reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    VAR             reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    VARIABLE        reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CONST           reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    TYPE            reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    IF              reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    SWITCH          reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    INT             reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FLOAT           reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    BOOL            reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FOR             reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    $end            reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    RBRACE          reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CASE            reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    DEFAULT         reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    RETURN          reduce using rule 166 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)


state 324

    (161) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 144
    INT32           shift and go to state 145
    INT64           shift and go to state 146
    STRING          shift and go to state 147
    FLOAT           shift and go to state 148
    FLOAT32         shift and go to state 149
    FLOAT64         shift and go to state 150
    BOOL            shift and go to state 151

    type                           shift and go to state 341

state 325

    (170) append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .

    SEMICOLON       reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    PRINT           reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    PRINTF          reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    INPUT           reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    LPAREN          reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FUNCTION        reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    VAR             reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    VARIABLE        reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CONST           reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    TYPE            reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    IF              reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    SWITCH          reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CHARSTRING      reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    INT             reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FLOAT           reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    BOOL            reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FOR             reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    $end            reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    RBRACE          reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CASE            reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    DEFAULT         reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    RETURN          reduce using rule 170 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)


state 326

    (171) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET . type LBRACE values RBRACE RPAREN
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 144
    INT32           shift and go to state 145
    INT64           shift and go to state 146
    STRING          shift and go to state 147
    FLOAT           shift and go to state 148
    FLOAT32         shift and go to state 149
    FLOAT64         shift and go to state 150
    BOOL            shift and go to state 151

    type                           shift and go to state 342

state 327

    (69) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return . RBRACE

    RBRACE          shift and go to state 343


state 328

    (70) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .

    SEMICOLON       reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    PRINT           reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    PRINTF          reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    INPUT           reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    LPAREN          reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    FUNCTION        reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    VAR             reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    VARIABLE        reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    CONST           reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    TYPE            reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    IF              reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    SWITCH          reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    CHARSTRING      reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    INT             reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    FLOAT           reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    BOOL            reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    FOR             reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    $end            reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    RBRACE          reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    CASE            reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    DEFAULT         reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    RETURN          reduce using rule 70 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)


state 329

    (71) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .

    SEMICOLON       reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    PRINT           reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    LPAREN          reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CONST           reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    BOOL            reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CASE            reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    RETURN          reduce using rule 71 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)


state 330

    (73) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks . return RBRACE
    (75) return -> . RETURN value
    (76) return -> . RETURN value LBRACKET value RBRACKET
    (77) return -> . RETURN value PERIOD value

    RETURN          shift and go to state 216

    return                         shift and go to state 344

state 331

    (74) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return . RBRACE

    RBRACE          shift and go to state 345


state 332

    (158) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET . values RBRACKET
    (38) values -> . value
    (39) values -> . value COMMA values
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    values                         shift and go to state 346
    value                          shift and go to state 218
    not_variable_value             shift and go to state 36

state 333

    (157) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE . values RBRACE
    (38) values -> . value
    (39) values -> . value COMMA values
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    values                         shift and go to state 347
    value                          shift and go to state 218
    not_variable_value             shift and go to state 36

state 334

    (115) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE . conditional_body
    (116) conditional_body -> . LBRACE blocks RBRACE
    (117) conditional_body -> . LBRACE blocks return RBRACE
    (118) conditional_body -> . LBRACE return RBRACE
    (119) conditional_body -> . LBRACE BREAK RBRACE
    (120) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 158

    conditional_body               shift and go to state 348

state 335

    (76) return -> RETURN value LBRACKET value RBRACKET .

    RBRACE          reduce using rule 76 (return -> RETURN value LBRACKET value RBRACKET .)


state 336

    (137) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value . double_operator LBRACE statement RBRACE
    (107) double_operator -> . INCREMENT
    (108) double_operator -> . DECREMENT

    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    double_operator                shift and go to state 349

state 337

    (139) for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! LPAREN          [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]
  ! BOOL            [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 350
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 338

    (160) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values . RBRACE

    RBRACE          shift and go to state 351


state 339

    (162) map_values -> map_value .
    (163) map_values -> map_value . COMMA map_values

    RBRACE          reduce using rule 162 (map_values -> map_value .)
    COMMA           shift and go to state 352


state 340

    (164) map_value -> value . COLON value

    COLON           shift and go to state 353


state 341

    (161) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN

    RPAREN          shift and go to state 354


state 342

    (171) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type . LBRACE values RBRACE RPAREN

    LBRACE          shift and go to state 355


state 343

    (69) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .

    SEMICOLON       reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    PRINT           reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    PRINTF          reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    INPUT           reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    LPAREN          reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    FUNCTION        reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    VAR             reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    VARIABLE        reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    CONST           reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    TYPE            reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    IF              reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    SWITCH          reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    CHARSTRING      reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    INT             reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    FLOAT           reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    BOOL            reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    FOR             reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    $end            reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    RBRACE          reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    CASE            reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    DEFAULT         reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    RETURN          reduce using rule 69 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)


state 344

    (73) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return . RBRACE

    RBRACE          shift and go to state 356


state 345

    (74) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .

    SEMICOLON       reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    PRINT           reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    PRINTF          reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    INPUT           reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    LPAREN          reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    FUNCTION        reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    VAR             reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    VARIABLE        reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    CONST           reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    TYPE            reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    IF              reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    SWITCH          reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    CHARSTRING      reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    INT             reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    FLOAT           reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    BOOL            reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    FOR             reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    $end            reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    RBRACE          reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    CASE            reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    DEFAULT         reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    RETURN          reduce using rule 74 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)


state 346

    (158) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values . RBRACKET

    RBRACKET        shift and go to state 357


state 347

    (157) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values . RBRACE

    RBRACE          shift and go to state 358


state 348

    (115) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .

    SEMICOLON       reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    PRINT           reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    PRINTF          reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    LPAREN          reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CONST           reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    SWITCH          reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CHARSTRING      reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    BOOL            reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CASE            reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    DEFAULT         reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RETURN          reduce using rule 115 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)


state 349

    (137) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator . LBRACE statement RBRACE

    LBRACE          shift and go to state 359


state 350

    (139) for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement . RBRACE

    RBRACE          shift and go to state 360


state 351

    (160) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .

    SEMICOLON       reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    PRINT           reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    PRINTF          reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INPUT           reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    LPAREN          reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FUNCTION        reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VAR             reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VARIABLE        reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CONST           reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    TYPE            reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    IF              reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    SWITCH          reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CHARSTRING      reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INT             reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FLOAT           reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    BOOL            reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FOR             reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    $end            reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RBRACE          reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CASE            reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    DEFAULT         reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RETURN          reduce using rule 160 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)


state 352

    (163) map_values -> map_value COMMA . map_values
    (162) map_values -> . map_value
    (163) map_values -> . map_value COMMA map_values
    (164) map_value -> . value COLON value
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    map_value                      shift and go to state 339
    map_values                     shift and go to state 361
    value                          shift and go to state 340
    not_variable_value             shift and go to state 36

state 353

    (164) map_value -> value COLON . value
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    value                          shift and go to state 362
    not_variable_value             shift and go to state 36

state 354

    (161) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .

    SEMICOLON       reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    PRINT           reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    PRINTF          reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INPUT           reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LPAREN          reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FUNCTION        reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VAR             reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CONST           reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TYPE            reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    IF              reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SWITCH          reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CHARSTRING      reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INT             reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FLOAT           reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    BOOL            reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FOR             reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    $end            reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RBRACE          reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CASE            reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RETURN          reduce using rule 161 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)


state 355

    (171) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE . values RBRACE RPAREN
    (38) values -> . value
    (39) values -> . value COMMA values
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL

    VARIABLE        shift and go to state 59
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45

    values                         shift and go to state 363
    value                          shift and go to state 218
    not_variable_value             shift and go to state 36

state 356

    (73) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .

    SEMICOLON       reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    PRINT           reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    PRINTF          reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    INPUT           reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    LPAREN          reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    FUNCTION        reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    VAR             reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    VARIABLE        reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    CONST           reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    TYPE            reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    IF              reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    SWITCH          reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    CHARSTRING      reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    INT             reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    FLOAT           reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    BOOL            reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    FOR             reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    $end            reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    RBRACE          reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    CASE            reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    DEFAULT         reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    RETURN          reduce using rule 73 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)


state 357

    (158) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .

    SEMICOLON       reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    PRINT           reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    PRINTF          reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    INPUT           reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    LPAREN          reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    FUNCTION        reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    VAR             reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    VARIABLE        reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    CONST           reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    TYPE            reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    IF              reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    SWITCH          reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    CHARSTRING      reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    INT             reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    FLOAT           reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    BOOL            reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    FOR             reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    $end            reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    RBRACE          reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    CASE            reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    DEFAULT         reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    RETURN          reduce using rule 158 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)


state 358

    (157) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .

    SEMICOLON       reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    PRINT           reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    PRINTF          reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    INPUT           reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    LPAREN          reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    FUNCTION        reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    VAR             reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    VARIABLE        reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    CONST           reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    TYPE            reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    IF              reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    SWITCH          reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    INT             reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    FLOAT           reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    BOOL            reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    FOR             reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    $end            reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    RBRACE          reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    CASE            reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    DEFAULT         reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    RETURN          reduce using rule 157 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)


state 359

    (137) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (78) print_statement -> . PRINT LPAREN values RPAREN
    (79) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (80) print_statement -> . PRINT LPAREN operation RPAREN
    (81) print_statement -> . PRINT LPAREN RPAREN
    (82) input_statement -> . INPUT LPAREN values RPAREN
    (83) input_statement -> . INPUT LPAREN operation RPAREN
    (84) input_statement -> . INPUT LPAREN RPAREN
    (98) operation -> . value operator value
    (99) operation -> . value operator LPAREN value RPAREN
    (100) operation -> . LPAREN value RPAREN operator value
    (101) operation -> . LPAREN value operator value RPAREN
    (102) operation -> . value operator operation
    (103) operation -> . LPAREN value operator operation RPAREN
    (104) operation -> . LPAREN value RPAREN operator operation
    (105) operation -> . value operator LPAREN operation RPAREN
    (106) operation -> . value double_operator
    (148) data_structure -> . array_structure
    (149) data_structure -> . map_structure
    (150) data_structure -> . slice_structure
    (151) data_structure -> . struct_structure
    (109) control_structure -> . conditional_structure
    (110) control_structure -> . for_estructure
    (111) control_structure -> . switch_structure
    (67) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE RBRACE
    (68) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (69) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (70) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (71) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (72) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE RBRACE
    (73) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (74) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (40) variable_declaration -> . VAR variables type
    (41) variable_declaration -> . VAR variables type ASSIGN value
    (42) variable_declaration -> . VAR variables type ASSIGN operation
    (43) variable_declaration -> . VARIABLE SHORTASSIGN value
    (44) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (45) variable_declaration -> . CONST VARIABLE ASSIGN value
    (46) variable_assignation -> . VARIABLE assignation value
    (47) variable_assignation -> . VARIABLE assignation operation
    (48) variable_assignation -> . VARIABLE double_operator
    (49) variable_assignation -> . map_assign
    (50) variable_assignation -> . array_assign
    (30) value -> . not_variable_value
    (31) value -> . VARIABLE LBRACKET RBRACKET
    (32) value -> . VARIABLE LBRACKET value RBRACKET
    (33) value -> . VARIABLE
    (156) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (157) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (158) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (160) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (161) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (166) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (167) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (168) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (169) slice_structure -> . VARIABLE ASSIGN append_statement
    (152) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (112) conditional_structure -> . IF conditions conditional_body
    (113) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (114) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body
    (115) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (134) for_estructure -> . for_initialization
    (135) for_estructure -> . for_infinite_bucle
    (136) for_estructure -> . for_iterator
    (140) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (165) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (159) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (34) not_variable_value -> . CHARSTRING
    (35) not_variable_value -> . INT
    (36) not_variable_value -> . FLOAT
    (37) not_variable_value -> . BOOL
    (137) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (138) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (139) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    LPAREN          shift and go to state 9
    VAR             shift and go to state 32
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 33
    TYPE            shift and go to state 38
    IF              shift and go to state 39
    SWITCH          shift and go to state 43
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 37
    FLOAT           shift and go to state 44
    BOOL            shift and go to state 45
    FOR             shift and go to state 46

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! LPAREN          [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]
  ! BOOL            [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]

    value                          shift and go to state 24
    statement                      shift and go to state 364
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    map_assign                     shift and go to state 34
    array_assign                   shift and go to state 35
    not_variable_value             shift and go to state 36
    for_initialization             shift and go to state 40
    for_infinite_bucle             shift and go to state 41
    for_iterator                   shift and go to state 42

state 360

    (139) for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .

    SEMICOLON       reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    PRINT           reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    PRINTF          reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INPUT           reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    LPAREN          reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VAR             reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CONST           reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    TYPE            reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    IF              reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    SWITCH          reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INT             reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FLOAT           reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    BOOL            reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FOR             reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    $end            reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RBRACE          reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CASE            reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RETURN          reduce using rule 139 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)


state 361

    (163) map_values -> map_value COMMA map_values .

    RBRACE          reduce using rule 163 (map_values -> map_value COMMA map_values .)


state 362

    (164) map_value -> value COLON value .

    COMMA           reduce using rule 164 (map_value -> value COLON value .)
    RBRACE          reduce using rule 164 (map_value -> value COLON value .)


state 363

    (171) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values . RBRACE RPAREN

    RBRACE          shift and go to state 365


state 364

    (137) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement . RBRACE

    RBRACE          shift and go to state 366


state 365

    (171) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE . RPAREN

    RPAREN          shift and go to state 367


state 366

    (137) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .

    SEMICOLON       reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    PRINT           reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    PRINTF          reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INPUT           reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    LPAREN          reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VAR             reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CONST           reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    TYPE            reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    IF              reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    SWITCH          reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INT             reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FLOAT           reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    BOOL            reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FOR             reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    $end            reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RBRACE          reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CASE            reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RETURN          reduce using rule 137 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)


state 367

    (171) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .

    SEMICOLON       reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    PRINT           reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    PRINTF          reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    INPUT           reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    LPAREN          reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    FUNCTION        reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    VAR             reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    VARIABLE        reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    CONST           reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    TYPE            reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    IF              reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    SWITCH          reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    CHARSTRING      reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    INT             reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    FLOAT           reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    BOOL            reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    FOR             reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    $end            reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    RBRACE          reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    CASE            reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    DEFAULT         reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    RETURN          reduce using rule 171 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FUNCTION in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 0 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 0 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 0 resolved as shift
WARNING: shift/reduce conflict for VAR in state 0 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 0 resolved as shift
WARNING: shift/reduce conflict for CONST in state 0 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 0 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 4 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 4 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 4 resolved as shift
WARNING: shift/reduce conflict for VAR in state 4 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 4 resolved as shift
WARNING: shift/reduce conflict for CONST in state 4 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 4 resolved as shift
WARNING: shift/reduce conflict for IF in state 4 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 4 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 4 resolved as shift
WARNING: shift/reduce conflict for INT in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 4 resolved as shift
WARNING: shift/reduce conflict for FOR in state 4 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 11 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 11 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 59 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 106 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 106 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 106 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 106 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 106 resolved as shift
WARNING: shift/reduce conflict for VAR in state 106 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 106 resolved as shift
WARNING: shift/reduce conflict for CONST in state 106 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 106 resolved as shift
WARNING: shift/reduce conflict for IF in state 106 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 106 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 106 resolved as shift
WARNING: shift/reduce conflict for INT in state 106 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 106 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 106 resolved as shift
WARNING: shift/reduce conflict for FOR in state 106 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 127 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 270 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 270 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 270 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 270 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 270 resolved as shift
WARNING: shift/reduce conflict for VAR in state 270 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 270 resolved as shift
WARNING: shift/reduce conflict for CONST in state 270 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 270 resolved as shift
WARNING: shift/reduce conflict for IF in state 270 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 270 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 270 resolved as shift
WARNING: shift/reduce conflict for INT in state 270 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 270 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 270 resolved as shift
WARNING: shift/reduce conflict for FOR in state 270 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 287 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 288 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 298 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 298 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 298 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 298 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 298 resolved as shift
WARNING: shift/reduce conflict for VAR in state 298 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 298 resolved as shift
WARNING: shift/reduce conflict for CONST in state 298 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 298 resolved as shift
WARNING: shift/reduce conflict for IF in state 298 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 298 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 298 resolved as shift
WARNING: shift/reduce conflict for INT in state 298 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 298 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 298 resolved as shift
WARNING: shift/reduce conflict for FOR in state 298 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 337 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 337 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 337 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 337 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 337 resolved as shift
WARNING: shift/reduce conflict for VAR in state 337 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 337 resolved as shift
WARNING: shift/reduce conflict for CONST in state 337 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 337 resolved as shift
WARNING: shift/reduce conflict for IF in state 337 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 337 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 337 resolved as shift
WARNING: shift/reduce conflict for INT in state 337 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 337 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 337 resolved as shift
WARNING: shift/reduce conflict for FOR in state 337 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 359 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 359 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 359 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 359 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 359 resolved as shift
WARNING: shift/reduce conflict for VAR in state 359 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 359 resolved as shift
WARNING: shift/reduce conflict for CONST in state 359 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 359 resolved as shift
WARNING: shift/reduce conflict for IF in state 359 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 359 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 359 resolved as shift
WARNING: shift/reduce conflict for INT in state 359 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 359 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 359 resolved as shift
WARNING: shift/reduce conflict for FOR in state 359 resolved as shift
