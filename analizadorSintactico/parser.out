Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    APPEND
    CASE
    CONST
    DEFAULT
    DIVIDEASSIGN
    FALSE
    FORMATSTRING
    IDENTIFIER
    IMPORT
    MAIN
    MINUSASSIGN
    MOD
    MODASSIGN
    PACKAGE
    PLUSASSIGN
    SWITCH
    TEXT
    TIMESASSIGN
    TRUE

Grammar

Rule 0     S' -> statement
Rule 1     statement -> structure
Rule 2     statement -> blocks
Rule 3     statement -> function
Rule 4     statement -> parameters
Rule 5     statement -> variable_declaration
Rule 6     blocks -> block
Rule 7     block -> print_statement
Rule 8     block -> input_statement
Rule 9     block -> conditional_structure
Rule 10    block -> operation
Rule 11    block -> list_structure
Rule 12    block -> map_estructure
Rule 13    block -> map_assign
Rule 14    block -> for_estructure
Rule 15    variable_declaration -> VAR VARIABLE type
Rule 16    variable_declaration -> VAR VARIABLE ASSIGN value
Rule 17    variable_declaration -> VARIABLE SHORTASSIGN value
Rule 18    structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE
Rule 19    function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
Rule 20    function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
Rule 21    function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
Rule 22    function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
Rule 23    values -> value
Rule 24    values -> value COMMA values
Rule 25    string_value -> value
Rule 26    string_value -> CHARSTRING
Rule 27    value -> VARIABLE
Rule 28    value -> number
Rule 29    number -> INT
Rule 30    number -> FLOAT
Rule 31    print_statement -> PRINT LPAREN values RPAREN
Rule 32    print_statement -> PRINT LPAREN operation RPAREN
Rule 33    print_statement -> PRINT LPAREN RPAREN
Rule 34    input_statement -> INPUT LPAREN values RPAREN
Rule 35    input_statement -> INPUT LPAREN operation RPAREN
Rule 36    input_statement -> INPUT LPAREN RPAREN
Rule 37    operation -> value operator value
Rule 38    operation -> value operator operation
Rule 39    operation -> value double_operator
Rule 40    operator -> PLUS
Rule 41    operator -> MINUS
Rule 42    operator -> TIMES
Rule 43    operator -> DIVIDE
Rule 44    operator -> ASSIGN
Rule 45    double_operator -> INCREMENT
Rule 46    double_operator -> DECREMENT
Rule 47    parameters -> parameter
Rule 48    parameters -> parameter parameters
Rule 49    parameters -> parameter COMMA parameters
Rule 50    parameter -> VARIABLE type
Rule 51    type -> INT
Rule 52    type -> INT32
Rule 53    type -> INT64
Rule 54    type -> STRING
Rule 55    type -> FLOAT
Rule 56    type -> FLOAT32
Rule 57    type -> FLOAT64
Rule 58    type -> BOOL
Rule 59    conditional_structure -> IF conditions conditional_body
Rule 60    conditional_structure -> IF conditions conditional_body ELSE conditional_body
Rule 61    conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
Rule 62    conditional_body -> LBRACE statement RBRACE
Rule 63    conditional_body -> LBRACE BREAK RBRACE
Rule 64    conditional_body -> LBRACE CONTINUE RBRACE
Rule 65    conditions -> condition
Rule 66    conditions -> condition logical_operator conditions
Rule 67    condition -> value relational_operator value
Rule 68    logical_operator -> AND
Rule 69    logical_operator -> OR
Rule 70    logical_operator -> NOT
Rule 71    relational_operator -> GREATER
Rule 72    relational_operator -> LESS
Rule 73    relational_operator -> GREATEREQUALS
Rule 74    relational_operator -> LESSEQUALS
Rule 75    relational_operator -> EQUALS
Rule 76    relational_operator -> DIFFERENT
Rule 77    for_estructure -> for_initialization
Rule 78    for_estructure -> for_infinite_bucle
Rule 79    for_estructure -> for_iterator
Rule 80    for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
Rule 81    for_infinite_bucle -> FOR LBRACE statement RBRACE
Rule 82    for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
Rule 83    list_structure -> empty_list
Rule 84    list_structure -> list_with_data
Rule 85    list_structure -> defined_list
Rule 86    empty_list -> LBRACE RBRACE
Rule 87    list_with_data -> LBRACE values RBRACE
Rule 88    defined_list -> TYPE VARIABLE LBRACE values RBRACE
Rule 89    map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
Rule 90    map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
Rule 91    map_values -> map_value
Rule 92    map_values -> map_value COMMA map_values
Rule 93    map_value -> string_value COLON string_value
Rule 94    map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 68
APPEND               : 
ASSIGN               : 16 44 94
BOOL                 : 58
BREAK                : 63
CASE                 : 
CHARSTRING           : 26
COLON                : 93
COMMA                : 24 49 92
CONST                : 
CONTINUE             : 64
DECREMENT            : 46
DEFAULT              : 
DIFFERENT            : 76
DIVIDE               : 43
DIVIDEASSIGN         : 
ELSE                 : 60 61 61
EQUALS               : 75
FALSE                : 
FLOAT                : 30 55
FLOAT32              : 56
FLOAT64              : 57
FOR                  : 80 81 82
FORMATSTRING         : 
FUNCTION             : 19 20 21 22
GREATER              : 71
GREATEREQUALS        : 73
IDENTIFIER           : 
IF                   : 59 60 61 61
IMPORT               : 
INCREMENT            : 45
INPUT                : 34 35 36
INT                  : 29 51
INT32                : 52
INT64                : 53
LBRACE               : 18 19 20 21 22 62 63 64 80 81 82 86 87 88 89
LBRACKET             : 89 90 94
LESS                 : 72
LESSEQUALS           : 74
LPAREN               : 19 20 21 22 31 32 33 34 35 36 90
MAIN                 : 
MAKE                 : 90
MAP                  : 89 90
MINUS                : 41
MINUSASSIGN          : 
MOD                  : 
MODASSIGN            : 
NOT                  : 70
OR                   : 69
PACKAGE              : 
PLUS                 : 40
PLUSASSIGN           : 
PRINT                : 31 32 33
RANGE                : 82
RBRACE               : 18 19 20 21 22 62 63 64 80 81 82 86 87 88 89
RBRACKET             : 89 90 94
RETURN               : 19 21
RPAREN               : 19 20 21 22 31 32 33 34 35 36 90
SEMICOLON            : 80 80 82
SHORTASSIGN          : 17 80 82 89 90
STRING               : 54
STRUCT               : 18
SWITCH               : 
TEXT                 : 
TIMES                : 42
TIMESASSIGN          : 
TRUE                 : 
TYPE                 : 18 88
VAR                  : 15 16
VARIABLE             : 15 16 17 18 19 19 20 21 21 22 27 50 80 82 82 82 88 89 90 94
error                : 

Nonterminals, with rules where they appear

block                : 6
blocks               : 2 19 20 21 22
condition            : 65 66 80
conditional_body     : 59 60 60 61 61 61
conditional_structure : 9
conditions           : 59 60 61 61 66
defined_list         : 85
double_operator      : 39 80
empty_list           : 83
for_estructure       : 14
for_infinite_bucle   : 78
for_initialization   : 77
for_iterator         : 79
function             : 3
input_statement      : 8
list_structure       : 11
list_with_data       : 84
logical_operator     : 66
map_assign           : 13
map_estructure       : 12
map_value            : 91 92
map_values           : 89 92
number               : 28
operation            : 10 32 35 38
operator             : 37 38
parameter            : 47 48 49
parameters           : 4 19 20 48 49
print_statement      : 7
relational_operator  : 67
statement            : 18 62 80 81 82 0
string_value         : 93 93 94 94
structure            : 1
type                 : 15 19 21 50 89 89 90 90
value                : 16 17 23 24 25 37 37 38 39 67 67 80 80
values               : 24 31 34 87 88
variable_declaration : 5

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . structure
    (2) statement -> . blocks
    (3) statement -> . function
    (4) statement -> . parameters
    (5) statement -> . variable_declaration
    (18) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (6) blocks -> . block
    (19) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (47) parameters -> . parameter
    (48) parameters -> . parameter parameters
    (49) parameters -> . parameter COMMA parameters
    (15) variable_declaration -> . VAR VARIABLE type
    (16) variable_declaration -> . VAR VARIABLE ASSIGN value
    (17) variable_declaration -> . VARIABLE SHORTASSIGN value
    (7) block -> . print_statement
    (8) block -> . input_statement
    (9) block -> . conditional_structure
    (10) block -> . operation
    (11) block -> . list_structure
    (12) block -> . map_estructure
    (13) block -> . map_assign
    (14) block -> . for_estructure
    (50) parameter -> . VARIABLE type
    (31) print_statement -> . PRINT LPAREN values RPAREN
    (32) print_statement -> . PRINT LPAREN operation RPAREN
    (33) print_statement -> . PRINT LPAREN RPAREN
    (34) input_statement -> . INPUT LPAREN values RPAREN
    (35) input_statement -> . INPUT LPAREN operation RPAREN
    (36) input_statement -> . INPUT LPAREN RPAREN
    (59) conditional_structure -> . IF conditions conditional_body
    (60) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (61) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (37) operation -> . value operator value
    (38) operation -> . value operator operation
    (39) operation -> . value double_operator
    (83) list_structure -> . empty_list
    (84) list_structure -> . list_with_data
    (85) list_structure -> . defined_list
    (89) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (90) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (77) for_estructure -> . for_initialization
    (78) for_estructure -> . for_infinite_bucle
    (79) for_estructure -> . for_iterator
    (27) value -> . VARIABLE
    (28) value -> . number
    (86) empty_list -> . LBRACE RBRACE
    (87) list_with_data -> . LBRACE values RBRACE
    (88) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (80) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (81) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (82) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (29) number -> . INT
    (30) number -> . FLOAT

    TYPE            shift and go to state 7
    FUNCTION        shift and go to state 11
    VAR             shift and go to state 13
    VARIABLE        shift and go to state 8
    PRINT           shift and go to state 23
    INPUT           shift and go to state 24
    IF              shift and go to state 25
    LBRACE          shift and go to state 9
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    statement                      shift and go to state 1
    structure                      shift and go to state 2
    blocks                         shift and go to state 3
    function                       shift and go to state 4
    parameters                     shift and go to state 5
    variable_declaration           shift and go to state 6
    block                          shift and go to state 10
    parameter                      shift and go to state 12
    value                          shift and go to state 14
    print_statement                shift and go to state 15
    input_statement                shift and go to state 16
    conditional_structure          shift and go to state 17
    operation                      shift and go to state 18
    list_structure                 shift and go to state 19
    map_estructure                 shift and go to state 20
    map_assign                     shift and go to state 21
    for_estructure                 shift and go to state 22
    empty_list                     shift and go to state 26
    list_with_data                 shift and go to state 27
    defined_list                   shift and go to state 28
    for_initialization             shift and go to state 29
    for_infinite_bucle             shift and go to state 30
    for_iterator                   shift and go to state 31
    number                         shift and go to state 32

state 1

    (0) S' -> statement .



state 2

    (1) statement -> structure .

    $end            reduce using rule 1 (statement -> structure .)
    RBRACE          reduce using rule 1 (statement -> structure .)


state 3

    (2) statement -> blocks .

    $end            reduce using rule 2 (statement -> blocks .)
    RBRACE          reduce using rule 2 (statement -> blocks .)


state 4

    (3) statement -> function .

    $end            reduce using rule 3 (statement -> function .)
    RBRACE          reduce using rule 3 (statement -> function .)


state 5

    (4) statement -> parameters .

    $end            reduce using rule 4 (statement -> parameters .)
    RBRACE          reduce using rule 4 (statement -> parameters .)


state 6

    (5) statement -> variable_declaration .

    $end            reduce using rule 5 (statement -> variable_declaration .)
    RBRACE          reduce using rule 5 (statement -> variable_declaration .)


state 7

    (18) structure -> TYPE . VARIABLE STRUCT LBRACE statement RBRACE
    (88) defined_list -> TYPE . VARIABLE LBRACE values RBRACE

    VARIABLE        shift and go to state 36


state 8

    (17) variable_declaration -> VARIABLE . SHORTASSIGN value
    (50) parameter -> VARIABLE . type
    (89) map_estructure -> VARIABLE . SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (90) map_estructure -> VARIABLE . SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) map_assign -> VARIABLE . LBRACKET string_value RBRACKET ASSIGN string_value
    (27) value -> VARIABLE .
    (51) type -> . INT
    (52) type -> . INT32
    (53) type -> . INT64
    (54) type -> . STRING
    (55) type -> . FLOAT
    (56) type -> . FLOAT32
    (57) type -> . FLOAT64
    (58) type -> . BOOL

    SHORTASSIGN     shift and go to state 37
    LBRACKET        shift and go to state 39
    PLUS            reduce using rule 27 (value -> VARIABLE .)
    MINUS           reduce using rule 27 (value -> VARIABLE .)
    TIMES           reduce using rule 27 (value -> VARIABLE .)
    DIVIDE          reduce using rule 27 (value -> VARIABLE .)
    ASSIGN          reduce using rule 27 (value -> VARIABLE .)
    INCREMENT       reduce using rule 27 (value -> VARIABLE .)
    DECREMENT       reduce using rule 27 (value -> VARIABLE .)
    INT             shift and go to state 40
    INT32           shift and go to state 41
    INT64           shift and go to state 42
    STRING          shift and go to state 43
    FLOAT           shift and go to state 44
    FLOAT32         shift and go to state 45
    FLOAT64         shift and go to state 46
    BOOL            shift and go to state 47

    type                           shift and go to state 38

state 9

    (86) empty_list -> LBRACE . RBRACE
    (87) list_with_data -> LBRACE . values RBRACE
    (23) values -> . value
    (24) values -> . value COMMA values
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    RBRACE          shift and go to state 48
    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    values                         shift and go to state 49
    value                          shift and go to state 50
    number                         shift and go to state 32

state 10

    (6) blocks -> block .

    $end            reduce using rule 6 (blocks -> block .)
    RBRACE          reduce using rule 6 (blocks -> block .)
    RETURN          reduce using rule 6 (blocks -> block .)


state 11

    (19) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (20) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (21) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (22) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE blocks RBRACE

    VARIABLE        shift and go to state 52


state 12

    (47) parameters -> parameter .
    (48) parameters -> parameter . parameters
    (49) parameters -> parameter . COMMA parameters
    (47) parameters -> . parameter
    (48) parameters -> . parameter parameters
    (49) parameters -> . parameter COMMA parameters
    (50) parameter -> . VARIABLE type

    $end            reduce using rule 47 (parameters -> parameter .)
    RBRACE          reduce using rule 47 (parameters -> parameter .)
    RPAREN          reduce using rule 47 (parameters -> parameter .)
    COMMA           shift and go to state 54
    VARIABLE        shift and go to state 55

    parameter                      shift and go to state 12
    parameters                     shift and go to state 53

state 13

    (15) variable_declaration -> VAR . VARIABLE type
    (16) variable_declaration -> VAR . VARIABLE ASSIGN value

    VARIABLE        shift and go to state 56


state 14

    (37) operation -> value . operator value
    (38) operation -> value . operator operation
    (39) operation -> value . double_operator
    (40) operator -> . PLUS
    (41) operator -> . MINUS
    (42) operator -> . TIMES
    (43) operator -> . DIVIDE
    (44) operator -> . ASSIGN
    (45) double_operator -> . INCREMENT
    (46) double_operator -> . DECREMENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    ASSIGN          shift and go to state 63
    INCREMENT       shift and go to state 64
    DECREMENT       shift and go to state 65

    operator                       shift and go to state 57
    double_operator                shift and go to state 58

state 15

    (7) block -> print_statement .

    $end            reduce using rule 7 (block -> print_statement .)
    RBRACE          reduce using rule 7 (block -> print_statement .)
    RETURN          reduce using rule 7 (block -> print_statement .)


state 16

    (8) block -> input_statement .

    $end            reduce using rule 8 (block -> input_statement .)
    RBRACE          reduce using rule 8 (block -> input_statement .)
    RETURN          reduce using rule 8 (block -> input_statement .)


state 17

    (9) block -> conditional_structure .

    $end            reduce using rule 9 (block -> conditional_structure .)
    RBRACE          reduce using rule 9 (block -> conditional_structure .)
    RETURN          reduce using rule 9 (block -> conditional_structure .)


state 18

    (10) block -> operation .

    $end            reduce using rule 10 (block -> operation .)
    RBRACE          reduce using rule 10 (block -> operation .)
    RETURN          reduce using rule 10 (block -> operation .)


state 19

    (11) block -> list_structure .

    $end            reduce using rule 11 (block -> list_structure .)
    RBRACE          reduce using rule 11 (block -> list_structure .)
    RETURN          reduce using rule 11 (block -> list_structure .)


state 20

    (12) block -> map_estructure .

    $end            reduce using rule 12 (block -> map_estructure .)
    RBRACE          reduce using rule 12 (block -> map_estructure .)
    RETURN          reduce using rule 12 (block -> map_estructure .)


state 21

    (13) block -> map_assign .

    $end            reduce using rule 13 (block -> map_assign .)
    RBRACE          reduce using rule 13 (block -> map_assign .)
    RETURN          reduce using rule 13 (block -> map_assign .)


state 22

    (14) block -> for_estructure .

    $end            reduce using rule 14 (block -> for_estructure .)
    RBRACE          reduce using rule 14 (block -> for_estructure .)
    RETURN          reduce using rule 14 (block -> for_estructure .)


state 23

    (31) print_statement -> PRINT . LPAREN values RPAREN
    (32) print_statement -> PRINT . LPAREN operation RPAREN
    (33) print_statement -> PRINT . LPAREN RPAREN

    LPAREN          shift and go to state 66


state 24

    (34) input_statement -> INPUT . LPAREN values RPAREN
    (35) input_statement -> INPUT . LPAREN operation RPAREN
    (36) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 67


state 25

    (59) conditional_structure -> IF . conditions conditional_body
    (60) conditional_structure -> IF . conditions conditional_body ELSE conditional_body
    (61) conditional_structure -> IF . conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (65) conditions -> . condition
    (66) conditions -> . condition logical_operator conditions
    (67) condition -> . value relational_operator value
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    conditions                     shift and go to state 68
    condition                      shift and go to state 69
    value                          shift and go to state 70
    number                         shift and go to state 32

state 26

    (83) list_structure -> empty_list .

    $end            reduce using rule 83 (list_structure -> empty_list .)
    RBRACE          reduce using rule 83 (list_structure -> empty_list .)
    RETURN          reduce using rule 83 (list_structure -> empty_list .)


state 27

    (84) list_structure -> list_with_data .

    $end            reduce using rule 84 (list_structure -> list_with_data .)
    RBRACE          reduce using rule 84 (list_structure -> list_with_data .)
    RETURN          reduce using rule 84 (list_structure -> list_with_data .)


state 28

    (85) list_structure -> defined_list .

    $end            reduce using rule 85 (list_structure -> defined_list .)
    RBRACE          reduce using rule 85 (list_structure -> defined_list .)
    RETURN          reduce using rule 85 (list_structure -> defined_list .)


state 29

    (77) for_estructure -> for_initialization .

    $end            reduce using rule 77 (for_estructure -> for_initialization .)
    RBRACE          reduce using rule 77 (for_estructure -> for_initialization .)
    RETURN          reduce using rule 77 (for_estructure -> for_initialization .)


state 30

    (78) for_estructure -> for_infinite_bucle .

    $end            reduce using rule 78 (for_estructure -> for_infinite_bucle .)
    RBRACE          reduce using rule 78 (for_estructure -> for_infinite_bucle .)
    RETURN          reduce using rule 78 (for_estructure -> for_infinite_bucle .)


state 31

    (79) for_estructure -> for_iterator .

    $end            reduce using rule 79 (for_estructure -> for_iterator .)
    RBRACE          reduce using rule 79 (for_estructure -> for_iterator .)
    RETURN          reduce using rule 79 (for_estructure -> for_iterator .)


state 32

    (28) value -> number .

    PLUS            reduce using rule 28 (value -> number .)
    MINUS           reduce using rule 28 (value -> number .)
    TIMES           reduce using rule 28 (value -> number .)
    DIVIDE          reduce using rule 28 (value -> number .)
    ASSIGN          reduce using rule 28 (value -> number .)
    INCREMENT       reduce using rule 28 (value -> number .)
    DECREMENT       reduce using rule 28 (value -> number .)
    COMMA           reduce using rule 28 (value -> number .)
    RBRACE          reduce using rule 28 (value -> number .)
    GREATER         reduce using rule 28 (value -> number .)
    LESS            reduce using rule 28 (value -> number .)
    GREATEREQUALS   reduce using rule 28 (value -> number .)
    LESSEQUALS      reduce using rule 28 (value -> number .)
    EQUALS          reduce using rule 28 (value -> number .)
    DIFFERENT       reduce using rule 28 (value -> number .)
    $end            reduce using rule 28 (value -> number .)
    RBRACKET        reduce using rule 28 (value -> number .)
    RPAREN          reduce using rule 28 (value -> number .)
    RETURN          reduce using rule 28 (value -> number .)
    AND             reduce using rule 28 (value -> number .)
    OR              reduce using rule 28 (value -> number .)
    NOT             reduce using rule 28 (value -> number .)
    LBRACE          reduce using rule 28 (value -> number .)
    SEMICOLON       reduce using rule 28 (value -> number .)
    COLON           reduce using rule 28 (value -> number .)


state 33

    (80) for_initialization -> FOR . VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (81) for_infinite_bucle -> FOR . LBRACE statement RBRACE
    (82) for_iterator -> FOR . VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 71
    LBRACE          shift and go to state 72


state 34

    (29) number -> INT .

    PLUS            reduce using rule 29 (number -> INT .)
    MINUS           reduce using rule 29 (number -> INT .)
    TIMES           reduce using rule 29 (number -> INT .)
    DIVIDE          reduce using rule 29 (number -> INT .)
    ASSIGN          reduce using rule 29 (number -> INT .)
    INCREMENT       reduce using rule 29 (number -> INT .)
    DECREMENT       reduce using rule 29 (number -> INT .)
    COMMA           reduce using rule 29 (number -> INT .)
    RBRACE          reduce using rule 29 (number -> INT .)
    GREATER         reduce using rule 29 (number -> INT .)
    LESS            reduce using rule 29 (number -> INT .)
    GREATEREQUALS   reduce using rule 29 (number -> INT .)
    LESSEQUALS      reduce using rule 29 (number -> INT .)
    EQUALS          reduce using rule 29 (number -> INT .)
    DIFFERENT       reduce using rule 29 (number -> INT .)
    $end            reduce using rule 29 (number -> INT .)
    RBRACKET        reduce using rule 29 (number -> INT .)
    RPAREN          reduce using rule 29 (number -> INT .)
    RETURN          reduce using rule 29 (number -> INT .)
    AND             reduce using rule 29 (number -> INT .)
    OR              reduce using rule 29 (number -> INT .)
    NOT             reduce using rule 29 (number -> INT .)
    LBRACE          reduce using rule 29 (number -> INT .)
    SEMICOLON       reduce using rule 29 (number -> INT .)
    COLON           reduce using rule 29 (number -> INT .)


state 35

    (30) number -> FLOAT .

    PLUS            reduce using rule 30 (number -> FLOAT .)
    MINUS           reduce using rule 30 (number -> FLOAT .)
    TIMES           reduce using rule 30 (number -> FLOAT .)
    DIVIDE          reduce using rule 30 (number -> FLOAT .)
    ASSIGN          reduce using rule 30 (number -> FLOAT .)
    INCREMENT       reduce using rule 30 (number -> FLOAT .)
    DECREMENT       reduce using rule 30 (number -> FLOAT .)
    COMMA           reduce using rule 30 (number -> FLOAT .)
    RBRACE          reduce using rule 30 (number -> FLOAT .)
    GREATER         reduce using rule 30 (number -> FLOAT .)
    LESS            reduce using rule 30 (number -> FLOAT .)
    GREATEREQUALS   reduce using rule 30 (number -> FLOAT .)
    LESSEQUALS      reduce using rule 30 (number -> FLOAT .)
    EQUALS          reduce using rule 30 (number -> FLOAT .)
    DIFFERENT       reduce using rule 30 (number -> FLOAT .)
    $end            reduce using rule 30 (number -> FLOAT .)
    RBRACKET        reduce using rule 30 (number -> FLOAT .)
    RPAREN          reduce using rule 30 (number -> FLOAT .)
    RETURN          reduce using rule 30 (number -> FLOAT .)
    AND             reduce using rule 30 (number -> FLOAT .)
    OR              reduce using rule 30 (number -> FLOAT .)
    NOT             reduce using rule 30 (number -> FLOAT .)
    LBRACE          reduce using rule 30 (number -> FLOAT .)
    SEMICOLON       reduce using rule 30 (number -> FLOAT .)
    COLON           reduce using rule 30 (number -> FLOAT .)


state 36

    (18) structure -> TYPE VARIABLE . STRUCT LBRACE statement RBRACE
    (88) defined_list -> TYPE VARIABLE . LBRACE values RBRACE

    STRUCT          shift and go to state 73
    LBRACE          shift and go to state 74


state 37

    (17) variable_declaration -> VARIABLE SHORTASSIGN . value
    (89) map_estructure -> VARIABLE SHORTASSIGN . MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (90) map_estructure -> VARIABLE SHORTASSIGN . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    MAP             shift and go to state 76
    MAKE            shift and go to state 77
    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 75
    number                         shift and go to state 32

state 38

    (50) parameter -> VARIABLE type .

    COMMA           reduce using rule 50 (parameter -> VARIABLE type .)
    VARIABLE        reduce using rule 50 (parameter -> VARIABLE type .)
    $end            reduce using rule 50 (parameter -> VARIABLE type .)
    RBRACE          reduce using rule 50 (parameter -> VARIABLE type .)
    RPAREN          reduce using rule 50 (parameter -> VARIABLE type .)


state 39

    (94) map_assign -> VARIABLE LBRACKET . string_value RBRACKET ASSIGN string_value
    (25) string_value -> . value
    (26) string_value -> . CHARSTRING
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    CHARSTRING      shift and go to state 80
    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    string_value                   shift and go to state 78
    value                          shift and go to state 79
    number                         shift and go to state 32

state 40

    (51) type -> INT .

    COMMA           reduce using rule 51 (type -> INT .)
    VARIABLE        reduce using rule 51 (type -> INT .)
    $end            reduce using rule 51 (type -> INT .)
    RBRACE          reduce using rule 51 (type -> INT .)
    RPAREN          reduce using rule 51 (type -> INT .)
    RBRACKET        reduce using rule 51 (type -> INT .)
    LBRACE          reduce using rule 51 (type -> INT .)


state 41

    (52) type -> INT32 .

    COMMA           reduce using rule 52 (type -> INT32 .)
    VARIABLE        reduce using rule 52 (type -> INT32 .)
    $end            reduce using rule 52 (type -> INT32 .)
    RBRACE          reduce using rule 52 (type -> INT32 .)
    RPAREN          reduce using rule 52 (type -> INT32 .)
    RBRACKET        reduce using rule 52 (type -> INT32 .)
    LBRACE          reduce using rule 52 (type -> INT32 .)


state 42

    (53) type -> INT64 .

    COMMA           reduce using rule 53 (type -> INT64 .)
    VARIABLE        reduce using rule 53 (type -> INT64 .)
    $end            reduce using rule 53 (type -> INT64 .)
    RBRACE          reduce using rule 53 (type -> INT64 .)
    RPAREN          reduce using rule 53 (type -> INT64 .)
    RBRACKET        reduce using rule 53 (type -> INT64 .)
    LBRACE          reduce using rule 53 (type -> INT64 .)


state 43

    (54) type -> STRING .

    COMMA           reduce using rule 54 (type -> STRING .)
    VARIABLE        reduce using rule 54 (type -> STRING .)
    $end            reduce using rule 54 (type -> STRING .)
    RBRACE          reduce using rule 54 (type -> STRING .)
    RPAREN          reduce using rule 54 (type -> STRING .)
    RBRACKET        reduce using rule 54 (type -> STRING .)
    LBRACE          reduce using rule 54 (type -> STRING .)


state 44

    (55) type -> FLOAT .

    COMMA           reduce using rule 55 (type -> FLOAT .)
    VARIABLE        reduce using rule 55 (type -> FLOAT .)
    $end            reduce using rule 55 (type -> FLOAT .)
    RBRACE          reduce using rule 55 (type -> FLOAT .)
    RPAREN          reduce using rule 55 (type -> FLOAT .)
    RBRACKET        reduce using rule 55 (type -> FLOAT .)
    LBRACE          reduce using rule 55 (type -> FLOAT .)


state 45

    (56) type -> FLOAT32 .

    COMMA           reduce using rule 56 (type -> FLOAT32 .)
    VARIABLE        reduce using rule 56 (type -> FLOAT32 .)
    $end            reduce using rule 56 (type -> FLOAT32 .)
    RBRACE          reduce using rule 56 (type -> FLOAT32 .)
    RPAREN          reduce using rule 56 (type -> FLOAT32 .)
    RBRACKET        reduce using rule 56 (type -> FLOAT32 .)
    LBRACE          reduce using rule 56 (type -> FLOAT32 .)


state 46

    (57) type -> FLOAT64 .

    COMMA           reduce using rule 57 (type -> FLOAT64 .)
    VARIABLE        reduce using rule 57 (type -> FLOAT64 .)
    $end            reduce using rule 57 (type -> FLOAT64 .)
    RBRACE          reduce using rule 57 (type -> FLOAT64 .)
    RPAREN          reduce using rule 57 (type -> FLOAT64 .)
    RBRACKET        reduce using rule 57 (type -> FLOAT64 .)
    LBRACE          reduce using rule 57 (type -> FLOAT64 .)


state 47

    (58) type -> BOOL .

    COMMA           reduce using rule 58 (type -> BOOL .)
    VARIABLE        reduce using rule 58 (type -> BOOL .)
    $end            reduce using rule 58 (type -> BOOL .)
    RBRACE          reduce using rule 58 (type -> BOOL .)
    RPAREN          reduce using rule 58 (type -> BOOL .)
    RBRACKET        reduce using rule 58 (type -> BOOL .)
    LBRACE          reduce using rule 58 (type -> BOOL .)


state 48

    (86) empty_list -> LBRACE RBRACE .

    $end            reduce using rule 86 (empty_list -> LBRACE RBRACE .)
    RBRACE          reduce using rule 86 (empty_list -> LBRACE RBRACE .)
    RETURN          reduce using rule 86 (empty_list -> LBRACE RBRACE .)


state 49

    (87) list_with_data -> LBRACE values . RBRACE

    RBRACE          shift and go to state 81


state 50

    (23) values -> value .
    (24) values -> value . COMMA values

    RBRACE          reduce using rule 23 (values -> value .)
    RPAREN          reduce using rule 23 (values -> value .)
    COMMA           shift and go to state 82


state 51

    (27) value -> VARIABLE .

    COMMA           reduce using rule 27 (value -> VARIABLE .)
    RBRACE          reduce using rule 27 (value -> VARIABLE .)
    GREATER         reduce using rule 27 (value -> VARIABLE .)
    LESS            reduce using rule 27 (value -> VARIABLE .)
    GREATEREQUALS   reduce using rule 27 (value -> VARIABLE .)
    LESSEQUALS      reduce using rule 27 (value -> VARIABLE .)
    EQUALS          reduce using rule 27 (value -> VARIABLE .)
    DIFFERENT       reduce using rule 27 (value -> VARIABLE .)
    $end            reduce using rule 27 (value -> VARIABLE .)
    RBRACKET        reduce using rule 27 (value -> VARIABLE .)
    PLUS            reduce using rule 27 (value -> VARIABLE .)
    MINUS           reduce using rule 27 (value -> VARIABLE .)
    TIMES           reduce using rule 27 (value -> VARIABLE .)
    DIVIDE          reduce using rule 27 (value -> VARIABLE .)
    ASSIGN          reduce using rule 27 (value -> VARIABLE .)
    INCREMENT       reduce using rule 27 (value -> VARIABLE .)
    DECREMENT       reduce using rule 27 (value -> VARIABLE .)
    RPAREN          reduce using rule 27 (value -> VARIABLE .)
    RETURN          reduce using rule 27 (value -> VARIABLE .)
    AND             reduce using rule 27 (value -> VARIABLE .)
    OR              reduce using rule 27 (value -> VARIABLE .)
    NOT             reduce using rule 27 (value -> VARIABLE .)
    LBRACE          reduce using rule 27 (value -> VARIABLE .)
    SEMICOLON       reduce using rule 27 (value -> VARIABLE .)
    COLON           reduce using rule 27 (value -> VARIABLE .)


state 52

    (19) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (20) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN LBRACE blocks RBRACE
    (21) function -> FUNCTION VARIABLE . LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (22) function -> FUNCTION VARIABLE . LPAREN RPAREN LBRACE blocks RBRACE

    LPAREN          shift and go to state 83


state 53

    (48) parameters -> parameter parameters .

    $end            reduce using rule 48 (parameters -> parameter parameters .)
    RBRACE          reduce using rule 48 (parameters -> parameter parameters .)
    RPAREN          reduce using rule 48 (parameters -> parameter parameters .)


state 54

    (49) parameters -> parameter COMMA . parameters
    (47) parameters -> . parameter
    (48) parameters -> . parameter parameters
    (49) parameters -> . parameter COMMA parameters
    (50) parameter -> . VARIABLE type

    VARIABLE        shift and go to state 55

    parameter                      shift and go to state 12
    parameters                     shift and go to state 84

state 55

    (50) parameter -> VARIABLE . type
    (51) type -> . INT
    (52) type -> . INT32
    (53) type -> . INT64
    (54) type -> . STRING
    (55) type -> . FLOAT
    (56) type -> . FLOAT32
    (57) type -> . FLOAT64
    (58) type -> . BOOL

    INT             shift and go to state 40
    INT32           shift and go to state 41
    INT64           shift and go to state 42
    STRING          shift and go to state 43
    FLOAT           shift and go to state 44
    FLOAT32         shift and go to state 45
    FLOAT64         shift and go to state 46
    BOOL            shift and go to state 47

    type                           shift and go to state 38

state 56

    (15) variable_declaration -> VAR VARIABLE . type
    (16) variable_declaration -> VAR VARIABLE . ASSIGN value
    (51) type -> . INT
    (52) type -> . INT32
    (53) type -> . INT64
    (54) type -> . STRING
    (55) type -> . FLOAT
    (56) type -> . FLOAT32
    (57) type -> . FLOAT64
    (58) type -> . BOOL

    ASSIGN          shift and go to state 86
    INT             shift and go to state 40
    INT32           shift and go to state 41
    INT64           shift and go to state 42
    STRING          shift and go to state 43
    FLOAT           shift and go to state 44
    FLOAT32         shift and go to state 45
    FLOAT64         shift and go to state 46
    BOOL            shift and go to state 47

    type                           shift and go to state 85

state 57

    (37) operation -> value operator . value
    (38) operation -> value operator . operation
    (27) value -> . VARIABLE
    (28) value -> . number
    (37) operation -> . value operator value
    (38) operation -> . value operator operation
    (39) operation -> . value double_operator
    (29) number -> . INT
    (30) number -> . FLOAT

    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 87
    operation                      shift and go to state 88
    number                         shift and go to state 32

state 58

    (39) operation -> value double_operator .

    $end            reduce using rule 39 (operation -> value double_operator .)
    RPAREN          reduce using rule 39 (operation -> value double_operator .)
    RBRACE          reduce using rule 39 (operation -> value double_operator .)
    RETURN          reduce using rule 39 (operation -> value double_operator .)


state 59

    (40) operator -> PLUS .

    VARIABLE        reduce using rule 40 (operator -> PLUS .)
    INT             reduce using rule 40 (operator -> PLUS .)
    FLOAT           reduce using rule 40 (operator -> PLUS .)


state 60

    (41) operator -> MINUS .

    VARIABLE        reduce using rule 41 (operator -> MINUS .)
    INT             reduce using rule 41 (operator -> MINUS .)
    FLOAT           reduce using rule 41 (operator -> MINUS .)


state 61

    (42) operator -> TIMES .

    VARIABLE        reduce using rule 42 (operator -> TIMES .)
    INT             reduce using rule 42 (operator -> TIMES .)
    FLOAT           reduce using rule 42 (operator -> TIMES .)


state 62

    (43) operator -> DIVIDE .

    VARIABLE        reduce using rule 43 (operator -> DIVIDE .)
    INT             reduce using rule 43 (operator -> DIVIDE .)
    FLOAT           reduce using rule 43 (operator -> DIVIDE .)


state 63

    (44) operator -> ASSIGN .

    VARIABLE        reduce using rule 44 (operator -> ASSIGN .)
    INT             reduce using rule 44 (operator -> ASSIGN .)
    FLOAT           reduce using rule 44 (operator -> ASSIGN .)


state 64

    (45) double_operator -> INCREMENT .

    $end            reduce using rule 45 (double_operator -> INCREMENT .)
    RBRACE          reduce using rule 45 (double_operator -> INCREMENT .)
    RETURN          reduce using rule 45 (double_operator -> INCREMENT .)
    RPAREN          reduce using rule 45 (double_operator -> INCREMENT .)
    LBRACE          reduce using rule 45 (double_operator -> INCREMENT .)


state 65

    (46) double_operator -> DECREMENT .

    $end            reduce using rule 46 (double_operator -> DECREMENT .)
    RBRACE          reduce using rule 46 (double_operator -> DECREMENT .)
    RETURN          reduce using rule 46 (double_operator -> DECREMENT .)
    RPAREN          reduce using rule 46 (double_operator -> DECREMENT .)
    LBRACE          reduce using rule 46 (double_operator -> DECREMENT .)


state 66

    (31) print_statement -> PRINT LPAREN . values RPAREN
    (32) print_statement -> PRINT LPAREN . operation RPAREN
    (33) print_statement -> PRINT LPAREN . RPAREN
    (23) values -> . value
    (24) values -> . value COMMA values
    (37) operation -> . value operator value
    (38) operation -> . value operator operation
    (39) operation -> . value double_operator
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    RPAREN          shift and go to state 90
    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    values                         shift and go to state 89
    operation                      shift and go to state 91
    value                          shift and go to state 92
    number                         shift and go to state 32

state 67

    (34) input_statement -> INPUT LPAREN . values RPAREN
    (35) input_statement -> INPUT LPAREN . operation RPAREN
    (36) input_statement -> INPUT LPAREN . RPAREN
    (23) values -> . value
    (24) values -> . value COMMA values
    (37) operation -> . value operator value
    (38) operation -> . value operator operation
    (39) operation -> . value double_operator
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    RPAREN          shift and go to state 94
    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    values                         shift and go to state 93
    operation                      shift and go to state 95
    value                          shift and go to state 92
    number                         shift and go to state 32

state 68

    (59) conditional_structure -> IF conditions . conditional_body
    (60) conditional_structure -> IF conditions . conditional_body ELSE conditional_body
    (61) conditional_structure -> IF conditions . conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (62) conditional_body -> . LBRACE statement RBRACE
    (63) conditional_body -> . LBRACE BREAK RBRACE
    (64) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 97

    conditional_body               shift and go to state 96

state 69

    (65) conditions -> condition .
    (66) conditions -> condition . logical_operator conditions
    (68) logical_operator -> . AND
    (69) logical_operator -> . OR
    (70) logical_operator -> . NOT

    LBRACE          reduce using rule 65 (conditions -> condition .)
    AND             shift and go to state 99
    OR              shift and go to state 100
    NOT             shift and go to state 101

    logical_operator               shift and go to state 98

state 70

    (67) condition -> value . relational_operator value
    (71) relational_operator -> . GREATER
    (72) relational_operator -> . LESS
    (73) relational_operator -> . GREATEREQUALS
    (74) relational_operator -> . LESSEQUALS
    (75) relational_operator -> . EQUALS
    (76) relational_operator -> . DIFFERENT

    GREATER         shift and go to state 103
    LESS            shift and go to state 104
    GREATEREQUALS   shift and go to state 105
    LESSEQUALS      shift and go to state 106
    EQUALS          shift and go to state 107
    DIFFERENT       shift and go to state 108

    relational_operator            shift and go to state 102

state 71

    (80) for_initialization -> FOR VARIABLE . SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (82) for_iterator -> FOR VARIABLE . SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 109
    SEMICOLON       shift and go to state 110


state 72

    (81) for_infinite_bucle -> FOR LBRACE . statement RBRACE
    (1) statement -> . structure
    (2) statement -> . blocks
    (3) statement -> . function
    (4) statement -> . parameters
    (5) statement -> . variable_declaration
    (18) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (6) blocks -> . block
    (19) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (47) parameters -> . parameter
    (48) parameters -> . parameter parameters
    (49) parameters -> . parameter COMMA parameters
    (15) variable_declaration -> . VAR VARIABLE type
    (16) variable_declaration -> . VAR VARIABLE ASSIGN value
    (17) variable_declaration -> . VARIABLE SHORTASSIGN value
    (7) block -> . print_statement
    (8) block -> . input_statement
    (9) block -> . conditional_structure
    (10) block -> . operation
    (11) block -> . list_structure
    (12) block -> . map_estructure
    (13) block -> . map_assign
    (14) block -> . for_estructure
    (50) parameter -> . VARIABLE type
    (31) print_statement -> . PRINT LPAREN values RPAREN
    (32) print_statement -> . PRINT LPAREN operation RPAREN
    (33) print_statement -> . PRINT LPAREN RPAREN
    (34) input_statement -> . INPUT LPAREN values RPAREN
    (35) input_statement -> . INPUT LPAREN operation RPAREN
    (36) input_statement -> . INPUT LPAREN RPAREN
    (59) conditional_structure -> . IF conditions conditional_body
    (60) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (61) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (37) operation -> . value operator value
    (38) operation -> . value operator operation
    (39) operation -> . value double_operator
    (83) list_structure -> . empty_list
    (84) list_structure -> . list_with_data
    (85) list_structure -> . defined_list
    (89) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (90) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (77) for_estructure -> . for_initialization
    (78) for_estructure -> . for_infinite_bucle
    (79) for_estructure -> . for_iterator
    (27) value -> . VARIABLE
    (28) value -> . number
    (86) empty_list -> . LBRACE RBRACE
    (87) list_with_data -> . LBRACE values RBRACE
    (88) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (80) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (81) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (82) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (29) number -> . INT
    (30) number -> . FLOAT

    TYPE            shift and go to state 7
    FUNCTION        shift and go to state 11
    VAR             shift and go to state 13
    VARIABLE        shift and go to state 8
    PRINT           shift and go to state 23
    INPUT           shift and go to state 24
    IF              shift and go to state 25
    LBRACE          shift and go to state 9
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    statement                      shift and go to state 111
    structure                      shift and go to state 2
    blocks                         shift and go to state 3
    function                       shift and go to state 4
    parameters                     shift and go to state 5
    variable_declaration           shift and go to state 6
    block                          shift and go to state 10
    parameter                      shift and go to state 12
    value                          shift and go to state 14
    print_statement                shift and go to state 15
    input_statement                shift and go to state 16
    conditional_structure          shift and go to state 17
    operation                      shift and go to state 18
    list_structure                 shift and go to state 19
    map_estructure                 shift and go to state 20
    map_assign                     shift and go to state 21
    for_estructure                 shift and go to state 22
    empty_list                     shift and go to state 26
    list_with_data                 shift and go to state 27
    defined_list                   shift and go to state 28
    for_initialization             shift and go to state 29
    for_infinite_bucle             shift and go to state 30
    for_iterator                   shift and go to state 31
    number                         shift and go to state 32

state 73

    (18) structure -> TYPE VARIABLE STRUCT . LBRACE statement RBRACE

    LBRACE          shift and go to state 112


state 74

    (88) defined_list -> TYPE VARIABLE LBRACE . values RBRACE
    (23) values -> . value
    (24) values -> . value COMMA values
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    values                         shift and go to state 113
    value                          shift and go to state 50
    number                         shift and go to state 32

state 75

    (17) variable_declaration -> VARIABLE SHORTASSIGN value .

    $end            reduce using rule 17 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    RBRACE          reduce using rule 17 (variable_declaration -> VARIABLE SHORTASSIGN value .)


state 76

    (89) map_estructure -> VARIABLE SHORTASSIGN MAP . LBRACKET type RBRACKET type LBRACE map_values RBRACE

    LBRACKET        shift and go to state 114


state 77

    (90) map_estructure -> VARIABLE SHORTASSIGN MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN

    LPAREN          shift and go to state 115


state 78

    (94) map_assign -> VARIABLE LBRACKET string_value . RBRACKET ASSIGN string_value

    RBRACKET        shift and go to state 116


state 79

    (25) string_value -> value .

    RBRACKET        reduce using rule 25 (string_value -> value .)
    $end            reduce using rule 25 (string_value -> value .)
    RBRACE          reduce using rule 25 (string_value -> value .)
    RETURN          reduce using rule 25 (string_value -> value .)
    COLON           reduce using rule 25 (string_value -> value .)
    COMMA           reduce using rule 25 (string_value -> value .)


state 80

    (26) string_value -> CHARSTRING .

    RBRACKET        reduce using rule 26 (string_value -> CHARSTRING .)
    $end            reduce using rule 26 (string_value -> CHARSTRING .)
    RBRACE          reduce using rule 26 (string_value -> CHARSTRING .)
    RETURN          reduce using rule 26 (string_value -> CHARSTRING .)
    COLON           reduce using rule 26 (string_value -> CHARSTRING .)
    COMMA           reduce using rule 26 (string_value -> CHARSTRING .)


state 81

    (87) list_with_data -> LBRACE values RBRACE .

    $end            reduce using rule 87 (list_with_data -> LBRACE values RBRACE .)
    RBRACE          reduce using rule 87 (list_with_data -> LBRACE values RBRACE .)
    RETURN          reduce using rule 87 (list_with_data -> LBRACE values RBRACE .)


state 82

    (24) values -> value COMMA . values
    (23) values -> . value
    (24) values -> . value COMMA values
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 50
    values                         shift and go to state 117
    number                         shift and go to state 32

state 83

    (19) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (20) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN LBRACE blocks RBRACE
    (21) function -> FUNCTION VARIABLE LPAREN . RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (22) function -> FUNCTION VARIABLE LPAREN . RPAREN LBRACE blocks RBRACE
    (47) parameters -> . parameter
    (48) parameters -> . parameter parameters
    (49) parameters -> . parameter COMMA parameters
    (50) parameter -> . VARIABLE type

    RPAREN          shift and go to state 119
    VARIABLE        shift and go to state 55

    parameters                     shift and go to state 118
    parameter                      shift and go to state 12

state 84

    (49) parameters -> parameter COMMA parameters .

    $end            reduce using rule 49 (parameters -> parameter COMMA parameters .)
    RBRACE          reduce using rule 49 (parameters -> parameter COMMA parameters .)
    RPAREN          reduce using rule 49 (parameters -> parameter COMMA parameters .)


state 85

    (15) variable_declaration -> VAR VARIABLE type .

    $end            reduce using rule 15 (variable_declaration -> VAR VARIABLE type .)
    RBRACE          reduce using rule 15 (variable_declaration -> VAR VARIABLE type .)


state 86

    (16) variable_declaration -> VAR VARIABLE ASSIGN . value
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 120
    number                         shift and go to state 32

state 87

    (37) operation -> value operator value .
    (37) operation -> value . operator value
    (38) operation -> value . operator operation
    (39) operation -> value . double_operator
    (40) operator -> . PLUS
    (41) operator -> . MINUS
    (42) operator -> . TIMES
    (43) operator -> . DIVIDE
    (44) operator -> . ASSIGN
    (45) double_operator -> . INCREMENT
    (46) double_operator -> . DECREMENT

    $end            reduce using rule 37 (operation -> value operator value .)
    RPAREN          reduce using rule 37 (operation -> value operator value .)
    RBRACE          reduce using rule 37 (operation -> value operator value .)
    RETURN          reduce using rule 37 (operation -> value operator value .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    ASSIGN          shift and go to state 63
    INCREMENT       shift and go to state 64
    DECREMENT       shift and go to state 65

    operator                       shift and go to state 57
    double_operator                shift and go to state 58

state 88

    (38) operation -> value operator operation .

    $end            reduce using rule 38 (operation -> value operator operation .)
    RPAREN          reduce using rule 38 (operation -> value operator operation .)
    RBRACE          reduce using rule 38 (operation -> value operator operation .)
    RETURN          reduce using rule 38 (operation -> value operator operation .)


state 89

    (31) print_statement -> PRINT LPAREN values . RPAREN

    RPAREN          shift and go to state 121


state 90

    (33) print_statement -> PRINT LPAREN RPAREN .

    $end            reduce using rule 33 (print_statement -> PRINT LPAREN RPAREN .)
    RBRACE          reduce using rule 33 (print_statement -> PRINT LPAREN RPAREN .)
    RETURN          reduce using rule 33 (print_statement -> PRINT LPAREN RPAREN .)


state 91

    (32) print_statement -> PRINT LPAREN operation . RPAREN

    RPAREN          shift and go to state 122


state 92

    (23) values -> value .
    (24) values -> value . COMMA values
    (37) operation -> value . operator value
    (38) operation -> value . operator operation
    (39) operation -> value . double_operator
    (40) operator -> . PLUS
    (41) operator -> . MINUS
    (42) operator -> . TIMES
    (43) operator -> . DIVIDE
    (44) operator -> . ASSIGN
    (45) double_operator -> . INCREMENT
    (46) double_operator -> . DECREMENT

    RPAREN          reduce using rule 23 (values -> value .)
    COMMA           shift and go to state 82
    PLUS            shift and go to state 59
    MINUS           shift and go to state 60
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 62
    ASSIGN          shift and go to state 63
    INCREMENT       shift and go to state 64
    DECREMENT       shift and go to state 65

    operator                       shift and go to state 57
    double_operator                shift and go to state 58

state 93

    (34) input_statement -> INPUT LPAREN values . RPAREN

    RPAREN          shift and go to state 123


state 94

    (36) input_statement -> INPUT LPAREN RPAREN .

    $end            reduce using rule 36 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 36 (input_statement -> INPUT LPAREN RPAREN .)
    RETURN          reduce using rule 36 (input_statement -> INPUT LPAREN RPAREN .)


state 95

    (35) input_statement -> INPUT LPAREN operation . RPAREN

    RPAREN          shift and go to state 124


state 96

    (59) conditional_structure -> IF conditions conditional_body .
    (60) conditional_structure -> IF conditions conditional_body . ELSE conditional_body
    (61) conditional_structure -> IF conditions conditional_body . ELSE IF conditions conditional_body ELSE conditional_body

    $end            reduce using rule 59 (conditional_structure -> IF conditions conditional_body .)
    RBRACE          reduce using rule 59 (conditional_structure -> IF conditions conditional_body .)
    RETURN          reduce using rule 59 (conditional_structure -> IF conditions conditional_body .)
    ELSE            shift and go to state 125


state 97

    (62) conditional_body -> LBRACE . statement RBRACE
    (63) conditional_body -> LBRACE . BREAK RBRACE
    (64) conditional_body -> LBRACE . CONTINUE RBRACE
    (1) statement -> . structure
    (2) statement -> . blocks
    (3) statement -> . function
    (4) statement -> . parameters
    (5) statement -> . variable_declaration
    (18) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (6) blocks -> . block
    (19) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (47) parameters -> . parameter
    (48) parameters -> . parameter parameters
    (49) parameters -> . parameter COMMA parameters
    (15) variable_declaration -> . VAR VARIABLE type
    (16) variable_declaration -> . VAR VARIABLE ASSIGN value
    (17) variable_declaration -> . VARIABLE SHORTASSIGN value
    (7) block -> . print_statement
    (8) block -> . input_statement
    (9) block -> . conditional_structure
    (10) block -> . operation
    (11) block -> . list_structure
    (12) block -> . map_estructure
    (13) block -> . map_assign
    (14) block -> . for_estructure
    (50) parameter -> . VARIABLE type
    (31) print_statement -> . PRINT LPAREN values RPAREN
    (32) print_statement -> . PRINT LPAREN operation RPAREN
    (33) print_statement -> . PRINT LPAREN RPAREN
    (34) input_statement -> . INPUT LPAREN values RPAREN
    (35) input_statement -> . INPUT LPAREN operation RPAREN
    (36) input_statement -> . INPUT LPAREN RPAREN
    (59) conditional_structure -> . IF conditions conditional_body
    (60) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (61) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (37) operation -> . value operator value
    (38) operation -> . value operator operation
    (39) operation -> . value double_operator
    (83) list_structure -> . empty_list
    (84) list_structure -> . list_with_data
    (85) list_structure -> . defined_list
    (89) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (90) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (77) for_estructure -> . for_initialization
    (78) for_estructure -> . for_infinite_bucle
    (79) for_estructure -> . for_iterator
    (27) value -> . VARIABLE
    (28) value -> . number
    (86) empty_list -> . LBRACE RBRACE
    (87) list_with_data -> . LBRACE values RBRACE
    (88) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (80) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (81) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (82) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (29) number -> . INT
    (30) number -> . FLOAT

    BREAK           shift and go to state 127
    CONTINUE        shift and go to state 128
    TYPE            shift and go to state 7
    FUNCTION        shift and go to state 11
    VAR             shift and go to state 13
    VARIABLE        shift and go to state 8
    PRINT           shift and go to state 23
    INPUT           shift and go to state 24
    IF              shift and go to state 25
    LBRACE          shift and go to state 9
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    statement                      shift and go to state 126
    structure                      shift and go to state 2
    blocks                         shift and go to state 3
    function                       shift and go to state 4
    parameters                     shift and go to state 5
    variable_declaration           shift and go to state 6
    block                          shift and go to state 10
    parameter                      shift and go to state 12
    value                          shift and go to state 14
    print_statement                shift and go to state 15
    input_statement                shift and go to state 16
    conditional_structure          shift and go to state 17
    operation                      shift and go to state 18
    list_structure                 shift and go to state 19
    map_estructure                 shift and go to state 20
    map_assign                     shift and go to state 21
    for_estructure                 shift and go to state 22
    empty_list                     shift and go to state 26
    list_with_data                 shift and go to state 27
    defined_list                   shift and go to state 28
    for_initialization             shift and go to state 29
    for_infinite_bucle             shift and go to state 30
    for_iterator                   shift and go to state 31
    number                         shift and go to state 32

state 98

    (66) conditions -> condition logical_operator . conditions
    (65) conditions -> . condition
    (66) conditions -> . condition logical_operator conditions
    (67) condition -> . value relational_operator value
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    condition                      shift and go to state 69
    conditions                     shift and go to state 129
    value                          shift and go to state 70
    number                         shift and go to state 32

state 99

    (68) logical_operator -> AND .

    VARIABLE        reduce using rule 68 (logical_operator -> AND .)
    INT             reduce using rule 68 (logical_operator -> AND .)
    FLOAT           reduce using rule 68 (logical_operator -> AND .)


state 100

    (69) logical_operator -> OR .

    VARIABLE        reduce using rule 69 (logical_operator -> OR .)
    INT             reduce using rule 69 (logical_operator -> OR .)
    FLOAT           reduce using rule 69 (logical_operator -> OR .)


state 101

    (70) logical_operator -> NOT .

    VARIABLE        reduce using rule 70 (logical_operator -> NOT .)
    INT             reduce using rule 70 (logical_operator -> NOT .)
    FLOAT           reduce using rule 70 (logical_operator -> NOT .)


state 102

    (67) condition -> value relational_operator . value
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 130
    number                         shift and go to state 32

state 103

    (71) relational_operator -> GREATER .

    VARIABLE        reduce using rule 71 (relational_operator -> GREATER .)
    INT             reduce using rule 71 (relational_operator -> GREATER .)
    FLOAT           reduce using rule 71 (relational_operator -> GREATER .)


state 104

    (72) relational_operator -> LESS .

    VARIABLE        reduce using rule 72 (relational_operator -> LESS .)
    INT             reduce using rule 72 (relational_operator -> LESS .)
    FLOAT           reduce using rule 72 (relational_operator -> LESS .)


state 105

    (73) relational_operator -> GREATEREQUALS .

    VARIABLE        reduce using rule 73 (relational_operator -> GREATEREQUALS .)
    INT             reduce using rule 73 (relational_operator -> GREATEREQUALS .)
    FLOAT           reduce using rule 73 (relational_operator -> GREATEREQUALS .)


state 106

    (74) relational_operator -> LESSEQUALS .

    VARIABLE        reduce using rule 74 (relational_operator -> LESSEQUALS .)
    INT             reduce using rule 74 (relational_operator -> LESSEQUALS .)
    FLOAT           reduce using rule 74 (relational_operator -> LESSEQUALS .)


state 107

    (75) relational_operator -> EQUALS .

    VARIABLE        reduce using rule 75 (relational_operator -> EQUALS .)
    INT             reduce using rule 75 (relational_operator -> EQUALS .)
    FLOAT           reduce using rule 75 (relational_operator -> EQUALS .)


state 108

    (76) relational_operator -> DIFFERENT .

    VARIABLE        reduce using rule 76 (relational_operator -> DIFFERENT .)
    INT             reduce using rule 76 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 76 (relational_operator -> DIFFERENT .)


state 109

    (80) for_initialization -> FOR VARIABLE SHORTASSIGN . value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 131
    number                         shift and go to state 32

state 110

    (82) for_iterator -> FOR VARIABLE SEMICOLON . VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 132


state 111

    (81) for_infinite_bucle -> FOR LBRACE statement . RBRACE

    RBRACE          shift and go to state 133


state 112

    (18) structure -> TYPE VARIABLE STRUCT LBRACE . statement RBRACE
    (1) statement -> . structure
    (2) statement -> . blocks
    (3) statement -> . function
    (4) statement -> . parameters
    (5) statement -> . variable_declaration
    (18) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (6) blocks -> . block
    (19) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (47) parameters -> . parameter
    (48) parameters -> . parameter parameters
    (49) parameters -> . parameter COMMA parameters
    (15) variable_declaration -> . VAR VARIABLE type
    (16) variable_declaration -> . VAR VARIABLE ASSIGN value
    (17) variable_declaration -> . VARIABLE SHORTASSIGN value
    (7) block -> . print_statement
    (8) block -> . input_statement
    (9) block -> . conditional_structure
    (10) block -> . operation
    (11) block -> . list_structure
    (12) block -> . map_estructure
    (13) block -> . map_assign
    (14) block -> . for_estructure
    (50) parameter -> . VARIABLE type
    (31) print_statement -> . PRINT LPAREN values RPAREN
    (32) print_statement -> . PRINT LPAREN operation RPAREN
    (33) print_statement -> . PRINT LPAREN RPAREN
    (34) input_statement -> . INPUT LPAREN values RPAREN
    (35) input_statement -> . INPUT LPAREN operation RPAREN
    (36) input_statement -> . INPUT LPAREN RPAREN
    (59) conditional_structure -> . IF conditions conditional_body
    (60) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (61) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (37) operation -> . value operator value
    (38) operation -> . value operator operation
    (39) operation -> . value double_operator
    (83) list_structure -> . empty_list
    (84) list_structure -> . list_with_data
    (85) list_structure -> . defined_list
    (89) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (90) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (77) for_estructure -> . for_initialization
    (78) for_estructure -> . for_infinite_bucle
    (79) for_estructure -> . for_iterator
    (27) value -> . VARIABLE
    (28) value -> . number
    (86) empty_list -> . LBRACE RBRACE
    (87) list_with_data -> . LBRACE values RBRACE
    (88) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (80) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (81) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (82) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (29) number -> . INT
    (30) number -> . FLOAT

    TYPE            shift and go to state 7
    FUNCTION        shift and go to state 11
    VAR             shift and go to state 13
    VARIABLE        shift and go to state 8
    PRINT           shift and go to state 23
    INPUT           shift and go to state 24
    IF              shift and go to state 25
    LBRACE          shift and go to state 9
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    statement                      shift and go to state 134
    structure                      shift and go to state 2
    blocks                         shift and go to state 3
    function                       shift and go to state 4
    parameters                     shift and go to state 5
    variable_declaration           shift and go to state 6
    block                          shift and go to state 10
    parameter                      shift and go to state 12
    value                          shift and go to state 14
    print_statement                shift and go to state 15
    input_statement                shift and go to state 16
    conditional_structure          shift and go to state 17
    operation                      shift and go to state 18
    list_structure                 shift and go to state 19
    map_estructure                 shift and go to state 20
    map_assign                     shift and go to state 21
    for_estructure                 shift and go to state 22
    empty_list                     shift and go to state 26
    list_with_data                 shift and go to state 27
    defined_list                   shift and go to state 28
    for_initialization             shift and go to state 29
    for_infinite_bucle             shift and go to state 30
    for_iterator                   shift and go to state 31
    number                         shift and go to state 32

state 113

    (88) defined_list -> TYPE VARIABLE LBRACE values . RBRACE

    RBRACE          shift and go to state 135


state 114

    (89) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET . type RBRACKET type LBRACE map_values RBRACE
    (51) type -> . INT
    (52) type -> . INT32
    (53) type -> . INT64
    (54) type -> . STRING
    (55) type -> . FLOAT
    (56) type -> . FLOAT32
    (57) type -> . FLOAT64
    (58) type -> . BOOL

    INT             shift and go to state 40
    INT32           shift and go to state 41
    INT64           shift and go to state 42
    STRING          shift and go to state 43
    FLOAT           shift and go to state 44
    FLOAT32         shift and go to state 45
    FLOAT64         shift and go to state 46
    BOOL            shift and go to state 47

    type                           shift and go to state 136

state 115

    (90) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN

    MAP             shift and go to state 137


state 116

    (94) map_assign -> VARIABLE LBRACKET string_value RBRACKET . ASSIGN string_value

    ASSIGN          shift and go to state 138


state 117

    (24) values -> value COMMA values .

    RBRACE          reduce using rule 24 (values -> value COMMA values .)
    RPAREN          reduce using rule 24 (values -> value COMMA values .)


state 118

    (19) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (20) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN LBRACE blocks RBRACE

    RPAREN          shift and go to state 139


state 119

    (21) function -> FUNCTION VARIABLE LPAREN RPAREN . type LBRACE blocks RETURN VARIABLE RBRACE
    (22) function -> FUNCTION VARIABLE LPAREN RPAREN . LBRACE blocks RBRACE
    (51) type -> . INT
    (52) type -> . INT32
    (53) type -> . INT64
    (54) type -> . STRING
    (55) type -> . FLOAT
    (56) type -> . FLOAT32
    (57) type -> . FLOAT64
    (58) type -> . BOOL

    LBRACE          shift and go to state 141
    INT             shift and go to state 40
    INT32           shift and go to state 41
    INT64           shift and go to state 42
    STRING          shift and go to state 43
    FLOAT           shift and go to state 44
    FLOAT32         shift and go to state 45
    FLOAT64         shift and go to state 46
    BOOL            shift and go to state 47

    type                           shift and go to state 140

state 120

    (16) variable_declaration -> VAR VARIABLE ASSIGN value .

    $end            reduce using rule 16 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    RBRACE          reduce using rule 16 (variable_declaration -> VAR VARIABLE ASSIGN value .)


state 121

    (31) print_statement -> PRINT LPAREN values RPAREN .

    $end            reduce using rule 31 (print_statement -> PRINT LPAREN values RPAREN .)
    RBRACE          reduce using rule 31 (print_statement -> PRINT LPAREN values RPAREN .)
    RETURN          reduce using rule 31 (print_statement -> PRINT LPAREN values RPAREN .)


state 122

    (32) print_statement -> PRINT LPAREN operation RPAREN .

    $end            reduce using rule 32 (print_statement -> PRINT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 32 (print_statement -> PRINT LPAREN operation RPAREN .)
    RETURN          reduce using rule 32 (print_statement -> PRINT LPAREN operation RPAREN .)


state 123

    (34) input_statement -> INPUT LPAREN values RPAREN .

    $end            reduce using rule 34 (input_statement -> INPUT LPAREN values RPAREN .)
    RBRACE          reduce using rule 34 (input_statement -> INPUT LPAREN values RPAREN .)
    RETURN          reduce using rule 34 (input_statement -> INPUT LPAREN values RPAREN .)


state 124

    (35) input_statement -> INPUT LPAREN operation RPAREN .

    $end            reduce using rule 35 (input_statement -> INPUT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 35 (input_statement -> INPUT LPAREN operation RPAREN .)
    RETURN          reduce using rule 35 (input_statement -> INPUT LPAREN operation RPAREN .)


state 125

    (60) conditional_structure -> IF conditions conditional_body ELSE . conditional_body
    (61) conditional_structure -> IF conditions conditional_body ELSE . IF conditions conditional_body ELSE conditional_body
    (62) conditional_body -> . LBRACE statement RBRACE
    (63) conditional_body -> . LBRACE BREAK RBRACE
    (64) conditional_body -> . LBRACE CONTINUE RBRACE

    IF              shift and go to state 142
    LBRACE          shift and go to state 97

    conditional_body               shift and go to state 143

state 126

    (62) conditional_body -> LBRACE statement . RBRACE

    RBRACE          shift and go to state 144


state 127

    (63) conditional_body -> LBRACE BREAK . RBRACE

    RBRACE          shift and go to state 145


state 128

    (64) conditional_body -> LBRACE CONTINUE . RBRACE

    RBRACE          shift and go to state 146


state 129

    (66) conditions -> condition logical_operator conditions .

    LBRACE          reduce using rule 66 (conditions -> condition logical_operator conditions .)


state 130

    (67) condition -> value relational_operator value .

    AND             reduce using rule 67 (condition -> value relational_operator value .)
    OR              reduce using rule 67 (condition -> value relational_operator value .)
    NOT             reduce using rule 67 (condition -> value relational_operator value .)
    LBRACE          reduce using rule 67 (condition -> value relational_operator value .)
    SEMICOLON       reduce using rule 67 (condition -> value relational_operator value .)


state 131

    (80) for_initialization -> FOR VARIABLE SHORTASSIGN value . SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 147


state 132

    (82) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE . SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 148


state 133

    (81) for_infinite_bucle -> FOR LBRACE statement RBRACE .

    $end            reduce using rule 81 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RBRACE          reduce using rule 81 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RETURN          reduce using rule 81 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)


state 134

    (18) structure -> TYPE VARIABLE STRUCT LBRACE statement . RBRACE

    RBRACE          shift and go to state 149


state 135

    (88) defined_list -> TYPE VARIABLE LBRACE values RBRACE .

    $end            reduce using rule 88 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    RBRACE          reduce using rule 88 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    RETURN          reduce using rule 88 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)


state 136

    (89) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type . RBRACKET type LBRACE map_values RBRACE

    RBRACKET        shift and go to state 150


state 137

    (90) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN

    LBRACKET        shift and go to state 151


state 138

    (94) map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN . string_value
    (25) string_value -> . value
    (26) string_value -> . CHARSTRING
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    CHARSTRING      shift and go to state 80
    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    string_value                   shift and go to state 152
    value                          shift and go to state 79
    number                         shift and go to state 32

state 139

    (19) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . type LBRACE blocks RETURN VARIABLE RBRACE
    (20) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . LBRACE blocks RBRACE
    (51) type -> . INT
    (52) type -> . INT32
    (53) type -> . INT64
    (54) type -> . STRING
    (55) type -> . FLOAT
    (56) type -> . FLOAT32
    (57) type -> . FLOAT64
    (58) type -> . BOOL

    LBRACE          shift and go to state 154
    INT             shift and go to state 40
    INT32           shift and go to state 41
    INT64           shift and go to state 42
    STRING          shift and go to state 43
    FLOAT           shift and go to state 44
    FLOAT32         shift and go to state 45
    FLOAT64         shift and go to state 46
    BOOL            shift and go to state 47

    type                           shift and go to state 153

state 140

    (21) function -> FUNCTION VARIABLE LPAREN RPAREN type . LBRACE blocks RETURN VARIABLE RBRACE

    LBRACE          shift and go to state 155


state 141

    (22) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE . blocks RBRACE
    (6) blocks -> . block
    (7) block -> . print_statement
    (8) block -> . input_statement
    (9) block -> . conditional_structure
    (10) block -> . operation
    (11) block -> . list_structure
    (12) block -> . map_estructure
    (13) block -> . map_assign
    (14) block -> . for_estructure
    (31) print_statement -> . PRINT LPAREN values RPAREN
    (32) print_statement -> . PRINT LPAREN operation RPAREN
    (33) print_statement -> . PRINT LPAREN RPAREN
    (34) input_statement -> . INPUT LPAREN values RPAREN
    (35) input_statement -> . INPUT LPAREN operation RPAREN
    (36) input_statement -> . INPUT LPAREN RPAREN
    (59) conditional_structure -> . IF conditions conditional_body
    (60) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (61) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (37) operation -> . value operator value
    (38) operation -> . value operator operation
    (39) operation -> . value double_operator
    (83) list_structure -> . empty_list
    (84) list_structure -> . list_with_data
    (85) list_structure -> . defined_list
    (89) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (90) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (77) for_estructure -> . for_initialization
    (78) for_estructure -> . for_infinite_bucle
    (79) for_estructure -> . for_iterator
    (27) value -> . VARIABLE
    (28) value -> . number
    (86) empty_list -> . LBRACE RBRACE
    (87) list_with_data -> . LBRACE values RBRACE
    (88) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (80) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (81) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (82) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (29) number -> . INT
    (30) number -> . FLOAT

    PRINT           shift and go to state 23
    INPUT           shift and go to state 24
    IF              shift and go to state 25
    VARIABLE        shift and go to state 156
    LBRACE          shift and go to state 9
    TYPE            shift and go to state 158
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    blocks                         shift and go to state 157
    block                          shift and go to state 10
    print_statement                shift and go to state 15
    input_statement                shift and go to state 16
    conditional_structure          shift and go to state 17
    operation                      shift and go to state 18
    list_structure                 shift and go to state 19
    map_estructure                 shift and go to state 20
    map_assign                     shift and go to state 21
    for_estructure                 shift and go to state 22
    value                          shift and go to state 14
    empty_list                     shift and go to state 26
    list_with_data                 shift and go to state 27
    defined_list                   shift and go to state 28
    for_initialization             shift and go to state 29
    for_infinite_bucle             shift and go to state 30
    for_iterator                   shift and go to state 31
    number                         shift and go to state 32

state 142

    (61) conditional_structure -> IF conditions conditional_body ELSE IF . conditions conditional_body ELSE conditional_body
    (65) conditions -> . condition
    (66) conditions -> . condition logical_operator conditions
    (67) condition -> . value relational_operator value
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    conditions                     shift and go to state 159
    condition                      shift and go to state 69
    value                          shift and go to state 70
    number                         shift and go to state 32

state 143

    (60) conditional_structure -> IF conditions conditional_body ELSE conditional_body .

    $end            reduce using rule 60 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 60 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RETURN          reduce using rule 60 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)


state 144

    (62) conditional_body -> LBRACE statement RBRACE .

    ELSE            reduce using rule 62 (conditional_body -> LBRACE statement RBRACE .)
    $end            reduce using rule 62 (conditional_body -> LBRACE statement RBRACE .)
    RBRACE          reduce using rule 62 (conditional_body -> LBRACE statement RBRACE .)
    RETURN          reduce using rule 62 (conditional_body -> LBRACE statement RBRACE .)


state 145

    (63) conditional_body -> LBRACE BREAK RBRACE .

    ELSE            reduce using rule 63 (conditional_body -> LBRACE BREAK RBRACE .)
    $end            reduce using rule 63 (conditional_body -> LBRACE BREAK RBRACE .)
    RBRACE          reduce using rule 63 (conditional_body -> LBRACE BREAK RBRACE .)
    RETURN          reduce using rule 63 (conditional_body -> LBRACE BREAK RBRACE .)


state 146

    (64) conditional_body -> LBRACE CONTINUE RBRACE .

    ELSE            reduce using rule 64 (conditional_body -> LBRACE CONTINUE RBRACE .)
    $end            reduce using rule 64 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RBRACE          reduce using rule 64 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RETURN          reduce using rule 64 (conditional_body -> LBRACE CONTINUE RBRACE .)


state 147

    (80) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON . condition SEMICOLON value double_operator LBRACE statement RBRACE
    (67) condition -> . value relational_operator value
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 70
    condition                      shift and go to state 160
    number                         shift and go to state 32

state 148

    (82) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN . RANGE VARIABLE LBRACE statement RBRACE

    RANGE           shift and go to state 161


state 149

    (18) structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .

    $end            reduce using rule 18 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    RBRACE          reduce using rule 18 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)


state 150

    (89) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET . type LBRACE map_values RBRACE
    (51) type -> . INT
    (52) type -> . INT32
    (53) type -> . INT64
    (54) type -> . STRING
    (55) type -> . FLOAT
    (56) type -> . FLOAT32
    (57) type -> . FLOAT64
    (58) type -> . BOOL

    INT             shift and go to state 40
    INT32           shift and go to state 41
    INT64           shift and go to state 42
    STRING          shift and go to state 43
    FLOAT           shift and go to state 44
    FLOAT32         shift and go to state 45
    FLOAT64         shift and go to state 46
    BOOL            shift and go to state 47

    type                           shift and go to state 162

state 151

    (90) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (51) type -> . INT
    (52) type -> . INT32
    (53) type -> . INT64
    (54) type -> . STRING
    (55) type -> . FLOAT
    (56) type -> . FLOAT32
    (57) type -> . FLOAT64
    (58) type -> . BOOL

    INT             shift and go to state 40
    INT32           shift and go to state 41
    INT64           shift and go to state 42
    STRING          shift and go to state 43
    FLOAT           shift and go to state 44
    FLOAT32         shift and go to state 45
    FLOAT64         shift and go to state 46
    BOOL            shift and go to state 47

    type                           shift and go to state 163

state 152

    (94) map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .

    $end            reduce using rule 94 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    RBRACE          reduce using rule 94 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    RETURN          reduce using rule 94 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)


state 153

    (19) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type . LBRACE blocks RETURN VARIABLE RBRACE

    LBRACE          shift and go to state 164


state 154

    (20) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE . blocks RBRACE
    (6) blocks -> . block
    (7) block -> . print_statement
    (8) block -> . input_statement
    (9) block -> . conditional_structure
    (10) block -> . operation
    (11) block -> . list_structure
    (12) block -> . map_estructure
    (13) block -> . map_assign
    (14) block -> . for_estructure
    (31) print_statement -> . PRINT LPAREN values RPAREN
    (32) print_statement -> . PRINT LPAREN operation RPAREN
    (33) print_statement -> . PRINT LPAREN RPAREN
    (34) input_statement -> . INPUT LPAREN values RPAREN
    (35) input_statement -> . INPUT LPAREN operation RPAREN
    (36) input_statement -> . INPUT LPAREN RPAREN
    (59) conditional_structure -> . IF conditions conditional_body
    (60) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (61) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (37) operation -> . value operator value
    (38) operation -> . value operator operation
    (39) operation -> . value double_operator
    (83) list_structure -> . empty_list
    (84) list_structure -> . list_with_data
    (85) list_structure -> . defined_list
    (89) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (90) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (77) for_estructure -> . for_initialization
    (78) for_estructure -> . for_infinite_bucle
    (79) for_estructure -> . for_iterator
    (27) value -> . VARIABLE
    (28) value -> . number
    (86) empty_list -> . LBRACE RBRACE
    (87) list_with_data -> . LBRACE values RBRACE
    (88) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (80) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (81) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (82) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (29) number -> . INT
    (30) number -> . FLOAT

    PRINT           shift and go to state 23
    INPUT           shift and go to state 24
    IF              shift and go to state 25
    VARIABLE        shift and go to state 156
    LBRACE          shift and go to state 9
    TYPE            shift and go to state 158
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    blocks                         shift and go to state 165
    block                          shift and go to state 10
    print_statement                shift and go to state 15
    input_statement                shift and go to state 16
    conditional_structure          shift and go to state 17
    operation                      shift and go to state 18
    list_structure                 shift and go to state 19
    map_estructure                 shift and go to state 20
    map_assign                     shift and go to state 21
    for_estructure                 shift and go to state 22
    value                          shift and go to state 14
    empty_list                     shift and go to state 26
    list_with_data                 shift and go to state 27
    defined_list                   shift and go to state 28
    for_initialization             shift and go to state 29
    for_infinite_bucle             shift and go to state 30
    for_iterator                   shift and go to state 31
    number                         shift and go to state 32

state 155

    (21) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE . blocks RETURN VARIABLE RBRACE
    (6) blocks -> . block
    (7) block -> . print_statement
    (8) block -> . input_statement
    (9) block -> . conditional_structure
    (10) block -> . operation
    (11) block -> . list_structure
    (12) block -> . map_estructure
    (13) block -> . map_assign
    (14) block -> . for_estructure
    (31) print_statement -> . PRINT LPAREN values RPAREN
    (32) print_statement -> . PRINT LPAREN operation RPAREN
    (33) print_statement -> . PRINT LPAREN RPAREN
    (34) input_statement -> . INPUT LPAREN values RPAREN
    (35) input_statement -> . INPUT LPAREN operation RPAREN
    (36) input_statement -> . INPUT LPAREN RPAREN
    (59) conditional_structure -> . IF conditions conditional_body
    (60) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (61) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (37) operation -> . value operator value
    (38) operation -> . value operator operation
    (39) operation -> . value double_operator
    (83) list_structure -> . empty_list
    (84) list_structure -> . list_with_data
    (85) list_structure -> . defined_list
    (89) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (90) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (77) for_estructure -> . for_initialization
    (78) for_estructure -> . for_infinite_bucle
    (79) for_estructure -> . for_iterator
    (27) value -> . VARIABLE
    (28) value -> . number
    (86) empty_list -> . LBRACE RBRACE
    (87) list_with_data -> . LBRACE values RBRACE
    (88) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (80) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (81) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (82) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (29) number -> . INT
    (30) number -> . FLOAT

    PRINT           shift and go to state 23
    INPUT           shift and go to state 24
    IF              shift and go to state 25
    VARIABLE        shift and go to state 156
    LBRACE          shift and go to state 9
    TYPE            shift and go to state 158
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    blocks                         shift and go to state 166
    block                          shift and go to state 10
    print_statement                shift and go to state 15
    input_statement                shift and go to state 16
    conditional_structure          shift and go to state 17
    operation                      shift and go to state 18
    list_structure                 shift and go to state 19
    map_estructure                 shift and go to state 20
    map_assign                     shift and go to state 21
    for_estructure                 shift and go to state 22
    value                          shift and go to state 14
    empty_list                     shift and go to state 26
    list_with_data                 shift and go to state 27
    defined_list                   shift and go to state 28
    for_initialization             shift and go to state 29
    for_infinite_bucle             shift and go to state 30
    for_iterator                   shift and go to state 31
    number                         shift and go to state 32

state 156

    (89) map_estructure -> VARIABLE . SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (90) map_estructure -> VARIABLE . SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) map_assign -> VARIABLE . LBRACKET string_value RBRACKET ASSIGN string_value
    (27) value -> VARIABLE .

    SHORTASSIGN     shift and go to state 167
    LBRACKET        shift and go to state 39
    PLUS            reduce using rule 27 (value -> VARIABLE .)
    MINUS           reduce using rule 27 (value -> VARIABLE .)
    TIMES           reduce using rule 27 (value -> VARIABLE .)
    DIVIDE          reduce using rule 27 (value -> VARIABLE .)
    ASSIGN          reduce using rule 27 (value -> VARIABLE .)
    INCREMENT       reduce using rule 27 (value -> VARIABLE .)
    DECREMENT       reduce using rule 27 (value -> VARIABLE .)


state 157

    (22) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 168


state 158

    (88) defined_list -> TYPE . VARIABLE LBRACE values RBRACE

    VARIABLE        shift and go to state 169


state 159

    (61) conditional_structure -> IF conditions conditional_body ELSE IF conditions . conditional_body ELSE conditional_body
    (62) conditional_body -> . LBRACE statement RBRACE
    (63) conditional_body -> . LBRACE BREAK RBRACE
    (64) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 97

    conditional_body               shift and go to state 170

state 160

    (80) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition . SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 171


state 161

    (82) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE . VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 172


state 162

    (89) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type . LBRACE map_values RBRACE

    LBRACE          shift and go to state 173


state 163

    (90) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN

    RBRACKET        shift and go to state 174


state 164

    (19) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE . blocks RETURN VARIABLE RBRACE
    (6) blocks -> . block
    (7) block -> . print_statement
    (8) block -> . input_statement
    (9) block -> . conditional_structure
    (10) block -> . operation
    (11) block -> . list_structure
    (12) block -> . map_estructure
    (13) block -> . map_assign
    (14) block -> . for_estructure
    (31) print_statement -> . PRINT LPAREN values RPAREN
    (32) print_statement -> . PRINT LPAREN operation RPAREN
    (33) print_statement -> . PRINT LPAREN RPAREN
    (34) input_statement -> . INPUT LPAREN values RPAREN
    (35) input_statement -> . INPUT LPAREN operation RPAREN
    (36) input_statement -> . INPUT LPAREN RPAREN
    (59) conditional_structure -> . IF conditions conditional_body
    (60) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (61) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (37) operation -> . value operator value
    (38) operation -> . value operator operation
    (39) operation -> . value double_operator
    (83) list_structure -> . empty_list
    (84) list_structure -> . list_with_data
    (85) list_structure -> . defined_list
    (89) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (90) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (77) for_estructure -> . for_initialization
    (78) for_estructure -> . for_infinite_bucle
    (79) for_estructure -> . for_iterator
    (27) value -> . VARIABLE
    (28) value -> . number
    (86) empty_list -> . LBRACE RBRACE
    (87) list_with_data -> . LBRACE values RBRACE
    (88) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (80) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (81) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (82) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (29) number -> . INT
    (30) number -> . FLOAT

    PRINT           shift and go to state 23
    INPUT           shift and go to state 24
    IF              shift and go to state 25
    VARIABLE        shift and go to state 156
    LBRACE          shift and go to state 9
    TYPE            shift and go to state 158
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    blocks                         shift and go to state 175
    block                          shift and go to state 10
    print_statement                shift and go to state 15
    input_statement                shift and go to state 16
    conditional_structure          shift and go to state 17
    operation                      shift and go to state 18
    list_structure                 shift and go to state 19
    map_estructure                 shift and go to state 20
    map_assign                     shift and go to state 21
    for_estructure                 shift and go to state 22
    value                          shift and go to state 14
    empty_list                     shift and go to state 26
    list_with_data                 shift and go to state 27
    defined_list                   shift and go to state 28
    for_initialization             shift and go to state 29
    for_infinite_bucle             shift and go to state 30
    for_iterator                   shift and go to state 31
    number                         shift and go to state 32

state 165

    (20) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 176


state 166

    (21) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks . RETURN VARIABLE RBRACE

    RETURN          shift and go to state 177


state 167

    (89) map_estructure -> VARIABLE SHORTASSIGN . MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (90) map_estructure -> VARIABLE SHORTASSIGN . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN

    MAP             shift and go to state 76
    MAKE            shift and go to state 77


state 168

    (22) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .

    $end            reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)


state 169

    (88) defined_list -> TYPE VARIABLE . LBRACE values RBRACE

    LBRACE          shift and go to state 74


state 170

    (61) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body . ELSE conditional_body

    ELSE            shift and go to state 178


state 171

    (80) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON . value double_operator LBRACE statement RBRACE
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 179
    number                         shift and go to state 32

state 172

    (82) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE . LBRACE statement RBRACE

    LBRACE          shift and go to state 180


state 173

    (89) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE . map_values RBRACE
    (91) map_values -> . map_value
    (92) map_values -> . map_value COMMA map_values
    (93) map_value -> . string_value COLON string_value
    (25) string_value -> . value
    (26) string_value -> . CHARSTRING
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    CHARSTRING      shift and go to state 80
    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    map_values                     shift and go to state 181
    map_value                      shift and go to state 182
    string_value                   shift and go to state 183
    value                          shift and go to state 79
    number                         shift and go to state 32

state 174

    (90) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (51) type -> . INT
    (52) type -> . INT32
    (53) type -> . INT64
    (54) type -> . STRING
    (55) type -> . FLOAT
    (56) type -> . FLOAT32
    (57) type -> . FLOAT64
    (58) type -> . BOOL

    INT             shift and go to state 40
    INT32           shift and go to state 41
    INT64           shift and go to state 42
    STRING          shift and go to state 43
    FLOAT           shift and go to state 44
    FLOAT32         shift and go to state 45
    FLOAT64         shift and go to state 46
    BOOL            shift and go to state 47

    type                           shift and go to state 184

state 175

    (19) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks . RETURN VARIABLE RBRACE

    RETURN          shift and go to state 185


state 176

    (20) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .

    $end            reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)


state 177

    (21) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN . VARIABLE RBRACE

    VARIABLE        shift and go to state 186


state 178

    (61) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE . conditional_body
    (62) conditional_body -> . LBRACE statement RBRACE
    (63) conditional_body -> . LBRACE BREAK RBRACE
    (64) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 97

    conditional_body               shift and go to state 187

state 179

    (80) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value . double_operator LBRACE statement RBRACE
    (45) double_operator -> . INCREMENT
    (46) double_operator -> . DECREMENT

    INCREMENT       shift and go to state 64
    DECREMENT       shift and go to state 65

    double_operator                shift and go to state 188

state 180

    (82) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE . statement RBRACE
    (1) statement -> . structure
    (2) statement -> . blocks
    (3) statement -> . function
    (4) statement -> . parameters
    (5) statement -> . variable_declaration
    (18) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (6) blocks -> . block
    (19) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (47) parameters -> . parameter
    (48) parameters -> . parameter parameters
    (49) parameters -> . parameter COMMA parameters
    (15) variable_declaration -> . VAR VARIABLE type
    (16) variable_declaration -> . VAR VARIABLE ASSIGN value
    (17) variable_declaration -> . VARIABLE SHORTASSIGN value
    (7) block -> . print_statement
    (8) block -> . input_statement
    (9) block -> . conditional_structure
    (10) block -> . operation
    (11) block -> . list_structure
    (12) block -> . map_estructure
    (13) block -> . map_assign
    (14) block -> . for_estructure
    (50) parameter -> . VARIABLE type
    (31) print_statement -> . PRINT LPAREN values RPAREN
    (32) print_statement -> . PRINT LPAREN operation RPAREN
    (33) print_statement -> . PRINT LPAREN RPAREN
    (34) input_statement -> . INPUT LPAREN values RPAREN
    (35) input_statement -> . INPUT LPAREN operation RPAREN
    (36) input_statement -> . INPUT LPAREN RPAREN
    (59) conditional_structure -> . IF conditions conditional_body
    (60) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (61) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (37) operation -> . value operator value
    (38) operation -> . value operator operation
    (39) operation -> . value double_operator
    (83) list_structure -> . empty_list
    (84) list_structure -> . list_with_data
    (85) list_structure -> . defined_list
    (89) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (90) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (77) for_estructure -> . for_initialization
    (78) for_estructure -> . for_infinite_bucle
    (79) for_estructure -> . for_iterator
    (27) value -> . VARIABLE
    (28) value -> . number
    (86) empty_list -> . LBRACE RBRACE
    (87) list_with_data -> . LBRACE values RBRACE
    (88) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (80) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (81) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (82) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (29) number -> . INT
    (30) number -> . FLOAT

    TYPE            shift and go to state 7
    FUNCTION        shift and go to state 11
    VAR             shift and go to state 13
    VARIABLE        shift and go to state 8
    PRINT           shift and go to state 23
    INPUT           shift and go to state 24
    IF              shift and go to state 25
    LBRACE          shift and go to state 9
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    statement                      shift and go to state 189
    structure                      shift and go to state 2
    blocks                         shift and go to state 3
    function                       shift and go to state 4
    parameters                     shift and go to state 5
    variable_declaration           shift and go to state 6
    block                          shift and go to state 10
    parameter                      shift and go to state 12
    value                          shift and go to state 14
    print_statement                shift and go to state 15
    input_statement                shift and go to state 16
    conditional_structure          shift and go to state 17
    operation                      shift and go to state 18
    list_structure                 shift and go to state 19
    map_estructure                 shift and go to state 20
    map_assign                     shift and go to state 21
    for_estructure                 shift and go to state 22
    empty_list                     shift and go to state 26
    list_with_data                 shift and go to state 27
    defined_list                   shift and go to state 28
    for_initialization             shift and go to state 29
    for_infinite_bucle             shift and go to state 30
    for_iterator                   shift and go to state 31
    number                         shift and go to state 32

state 181

    (89) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values . RBRACE

    RBRACE          shift and go to state 190


state 182

    (91) map_values -> map_value .
    (92) map_values -> map_value . COMMA map_values

    RBRACE          reduce using rule 91 (map_values -> map_value .)
    COMMA           shift and go to state 191


state 183

    (93) map_value -> string_value . COLON string_value

    COLON           shift and go to state 192


state 184

    (90) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN

    RPAREN          shift and go to state 193


state 185

    (19) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN . VARIABLE RBRACE

    VARIABLE        shift and go to state 194


state 186

    (21) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE . RBRACE

    RBRACE          shift and go to state 195


state 187

    (61) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .

    $end            reduce using rule 61 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 61 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RETURN          reduce using rule 61 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)


state 188

    (80) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator . LBRACE statement RBRACE

    LBRACE          shift and go to state 196


state 189

    (82) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement . RBRACE

    RBRACE          shift and go to state 197


state 190

    (89) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .

    $end            reduce using rule 89 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RBRACE          reduce using rule 89 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RETURN          reduce using rule 89 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)


state 191

    (92) map_values -> map_value COMMA . map_values
    (91) map_values -> . map_value
    (92) map_values -> . map_value COMMA map_values
    (93) map_value -> . string_value COLON string_value
    (25) string_value -> . value
    (26) string_value -> . CHARSTRING
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    CHARSTRING      shift and go to state 80
    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    map_value                      shift and go to state 182
    map_values                     shift and go to state 198
    string_value                   shift and go to state 183
    value                          shift and go to state 79
    number                         shift and go to state 32

state 192

    (93) map_value -> string_value COLON . string_value
    (25) string_value -> . value
    (26) string_value -> . CHARSTRING
    (27) value -> . VARIABLE
    (28) value -> . number
    (29) number -> . INT
    (30) number -> . FLOAT

    CHARSTRING      shift and go to state 80
    VARIABLE        shift and go to state 51
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    string_value                   shift and go to state 199
    value                          shift and go to state 79
    number                         shift and go to state 32

state 193

    (90) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .

    $end            reduce using rule 90 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RBRACE          reduce using rule 90 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RETURN          reduce using rule 90 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)


state 194

    (19) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE . RBRACE

    RBRACE          shift and go to state 200


state 195

    (21) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .

    $end            reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    RBRACE          reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)


state 196

    (80) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE . statement RBRACE
    (1) statement -> . structure
    (2) statement -> . blocks
    (3) statement -> . function
    (4) statement -> . parameters
    (5) statement -> . variable_declaration
    (18) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (6) blocks -> . block
    (19) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (47) parameters -> . parameter
    (48) parameters -> . parameter parameters
    (49) parameters -> . parameter COMMA parameters
    (15) variable_declaration -> . VAR VARIABLE type
    (16) variable_declaration -> . VAR VARIABLE ASSIGN value
    (17) variable_declaration -> . VARIABLE SHORTASSIGN value
    (7) block -> . print_statement
    (8) block -> . input_statement
    (9) block -> . conditional_structure
    (10) block -> . operation
    (11) block -> . list_structure
    (12) block -> . map_estructure
    (13) block -> . map_assign
    (14) block -> . for_estructure
    (50) parameter -> . VARIABLE type
    (31) print_statement -> . PRINT LPAREN values RPAREN
    (32) print_statement -> . PRINT LPAREN operation RPAREN
    (33) print_statement -> . PRINT LPAREN RPAREN
    (34) input_statement -> . INPUT LPAREN values RPAREN
    (35) input_statement -> . INPUT LPAREN operation RPAREN
    (36) input_statement -> . INPUT LPAREN RPAREN
    (59) conditional_structure -> . IF conditions conditional_body
    (60) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (61) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (37) operation -> . value operator value
    (38) operation -> . value operator operation
    (39) operation -> . value double_operator
    (83) list_structure -> . empty_list
    (84) list_structure -> . list_with_data
    (85) list_structure -> . defined_list
    (89) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (90) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (77) for_estructure -> . for_initialization
    (78) for_estructure -> . for_infinite_bucle
    (79) for_estructure -> . for_iterator
    (27) value -> . VARIABLE
    (28) value -> . number
    (86) empty_list -> . LBRACE RBRACE
    (87) list_with_data -> . LBRACE values RBRACE
    (88) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (80) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (81) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (82) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (29) number -> . INT
    (30) number -> . FLOAT

    TYPE            shift and go to state 7
    FUNCTION        shift and go to state 11
    VAR             shift and go to state 13
    VARIABLE        shift and go to state 8
    PRINT           shift and go to state 23
    INPUT           shift and go to state 24
    IF              shift and go to state 25
    LBRACE          shift and go to state 9
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 14
    statement                      shift and go to state 201
    structure                      shift and go to state 2
    blocks                         shift and go to state 3
    function                       shift and go to state 4
    parameters                     shift and go to state 5
    variable_declaration           shift and go to state 6
    block                          shift and go to state 10
    parameter                      shift and go to state 12
    print_statement                shift and go to state 15
    input_statement                shift and go to state 16
    conditional_structure          shift and go to state 17
    operation                      shift and go to state 18
    list_structure                 shift and go to state 19
    map_estructure                 shift and go to state 20
    map_assign                     shift and go to state 21
    for_estructure                 shift and go to state 22
    empty_list                     shift and go to state 26
    list_with_data                 shift and go to state 27
    defined_list                   shift and go to state 28
    for_initialization             shift and go to state 29
    for_infinite_bucle             shift and go to state 30
    for_iterator                   shift and go to state 31
    number                         shift and go to state 32

state 197

    (82) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .

    $end            reduce using rule 82 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RBRACE          reduce using rule 82 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RETURN          reduce using rule 82 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)


state 198

    (92) map_values -> map_value COMMA map_values .

    RBRACE          reduce using rule 92 (map_values -> map_value COMMA map_values .)


state 199

    (93) map_value -> string_value COLON string_value .

    COMMA           reduce using rule 93 (map_value -> string_value COLON string_value .)
    RBRACE          reduce using rule 93 (map_value -> string_value COLON string_value .)


state 200

    (19) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .

    $end            reduce using rule 19 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    RBRACE          reduce using rule 19 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)


state 201

    (80) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement . RBRACE

    RBRACE          shift and go to state 202


state 202

    (80) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .

    $end            reduce using rule 80 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RBRACE          reduce using rule 80 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RETURN          reduce using rule 80 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)

