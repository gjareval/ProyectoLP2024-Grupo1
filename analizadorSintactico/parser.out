Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    IDENTIFIER
    MOD
    TEXT

Grammar

Rule 0     S' -> statement
Rule 1     statement -> blocks
Rule 2     statement -> import blocks
Rule 3     statement -> package blocks
Rule 4     statement -> package import blocks
Rule 5     statement -> main LBRACE blocks RBRACE
Rule 6     statement -> package main LBRACE blocks RBRACE
Rule 7     statement -> import main LBRACE blocks RBRACE
Rule 8     statement -> package import main LBRACE blocks RBRACE
Rule 9     import -> <empty>
Rule 10    import -> IMPORT CHARSTRING
Rule 11    import -> IMPORT LPAREN values_for_import RPAREN
Rule 12    values_for_import -> CHARSTRING
Rule 13    values_for_import -> CHARSTRING values_for_import
Rule 14    package -> PACKAGE VARIABLE
Rule 15    package -> PACKAGE MAIN
Rule 16    main -> FUNCTION MAIN LPAREN RPAREN
Rule 17    blocks -> block
Rule 18    blocks -> block blocks
Rule 19    blocks -> block SEMICOLON blocks
Rule 20    block -> print_statement
Rule 21    block -> input_statement
Rule 22    block -> operation
Rule 23    block -> data_structure
Rule 24    block -> control_structure
Rule 25    block -> function
Rule 26    block -> parameters
Rule 27    block -> variable_declaration
Rule 28    block -> variable_assignation
Rule 29    block -> return
Rule 30    variable_declaration -> VAR VARIABLE type
Rule 31    variable_declaration -> VAR VARIABLE type ASSIGN value
Rule 32    variable_declaration -> VARIABLE SHORTASSIGN value
Rule 33    variable_declaration -> VARIABLE SHORTASSIGN operation
Rule 34    variable_declaration -> VAR variables type
Rule 35    variable_declaration -> VAR variables type ASSIGN value
Rule 36    variable_declaration -> CONST VARIABLE ASSIGN value
Rule 37    variable_assignation -> VARIABLE assignation value
Rule 38    variable_assignation -> VARIABLE assignation operation
Rule 39    variable_assignation -> VARIABLE double_operator
Rule 40    variable_assignation -> variables assignation value
Rule 41    variable_assignation -> map_assign
Rule 42    variable_assignation -> array_assign
Rule 43    variables -> VARIABLE
Rule 44    variables -> VARIABLE COMMA variables
Rule 45    assignation -> ASSIGN
Rule 46    assignation -> PLUSASSIGN
Rule 47    assignation -> MINUSASSIGN
Rule 48    assignation -> TIMESASSIGN
Rule 49    assignation -> DIVIDEASSIGN
Rule 50    assignation -> MODASSIGN
Rule 51    function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
Rule 52    function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
Rule 53    function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
Rule 54    function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
Rule 55    return -> RETURN value
Rule 56    return -> RETURN value LBRACKET value RBRACKET
Rule 57    return -> RETURN value PERIOD value
Rule 58    return -> RETURN TRUE
Rule 59    return -> RETURN FALSE
Rule 60    values -> value
Rule 61    values -> value COMMA values
Rule 62    value -> VARIABLE
Rule 63    value -> VARIABLE LBRACKET RBRACKET
Rule 64    value -> VARIABLE LBRACKET value RBRACKET
Rule 65    value -> not_variable_value
Rule 66    not_variable_value -> CHARSTRING
Rule 67    not_variable_value -> number
Rule 68    number -> INT
Rule 69    number -> FLOAT
Rule 70    print_statement -> PRINT LPAREN values RPAREN
Rule 71    print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN
Rule 72    print_statement -> PRINT LPAREN operation RPAREN
Rule 73    print_statement -> PRINT LPAREN RPAREN
Rule 74    input_statement -> INPUT LPAREN values RPAREN
Rule 75    input_statement -> INPUT LPAREN operation RPAREN
Rule 76    input_statement -> INPUT LPAREN RPAREN
Rule 77    operation -> value operator value
Rule 78    operation -> value operator LPAREN value RPAREN
Rule 79    operation -> LPAREN value RPAREN operator value
Rule 80    operation -> LPAREN value operator value RPAREN
Rule 81    operation -> value operator operation
Rule 82    operation -> LPAREN value operator operation RPAREN
Rule 83    operation -> LPAREN value RPAREN operator operation
Rule 84    operation -> value operator LPAREN operation RPAREN
Rule 85    operation -> value double_operator
Rule 86    operator -> PLUS
Rule 87    operator -> MINUS
Rule 88    operator -> TIMES
Rule 89    operator -> DIVIDE
Rule 90    operator -> ASSIGN
Rule 91    double_operator -> INCREMENT
Rule 92    double_operator -> DECREMENT
Rule 93    parameters -> parameter
Rule 94    parameters -> parameter COMMA parameters
Rule 95    parameter -> VARIABLE type
Rule 96    type -> INT
Rule 97    type -> INT32
Rule 98    type -> INT64
Rule 99    type -> STRING
Rule 100   type -> FLOAT
Rule 101   type -> FLOAT32
Rule 102   type -> FLOAT64
Rule 103   type -> BOOL
Rule 104   control_structure -> conditional_structure
Rule 105   control_structure -> for_estructure
Rule 106   control_structure -> switch_structure
Rule 107   conditional_structure -> IF conditions conditional_body
Rule 108   conditional_structure -> IF conditions conditional_body ELSE conditional_body
Rule 109   conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
Rule 110   conditional_body -> LBRACE statement RBRACE
Rule 111   conditional_body -> LBRACE BREAK RBRACE
Rule 112   conditional_body -> LBRACE CONTINUE RBRACE
Rule 113   conditions -> condition
Rule 114   conditions -> condition logical_operator conditions
Rule 115   condition -> value relational_operator value
Rule 116   logical_operator -> AND
Rule 117   logical_operator -> OR
Rule 118   logical_operator -> NOT
Rule 119   relational_operator -> GREATER
Rule 120   relational_operator -> LESS
Rule 121   relational_operator -> GREATEREQUALS
Rule 122   relational_operator -> LESSEQUALS
Rule 123   relational_operator -> EQUALS
Rule 124   relational_operator -> DIFFERENT
Rule 125   for_estructure -> for_initialization
Rule 126   for_estructure -> for_infinite_bucle
Rule 127   for_estructure -> for_iterator
Rule 128   for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
Rule 129   for_infinite_bucle -> FOR LBRACE statement RBRACE
Rule 130   for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
Rule 131   switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE
Rule 132   switch_expression -> VARIABLE SHORTASSIGN value
Rule 133   switch_expression -> empty
Rule 134   case_blocks -> case_block
Rule 135   case_blocks -> case_block case_blocks
Rule 136   case_block -> CASE values COLON statement
Rule 137   case_block -> DEFAULT COLON statement
Rule 138   empty -> <empty>
Rule 139   data_structure -> array_structure
Rule 140   data_structure -> map_structure
Rule 141   data_structure -> slice_structure
Rule 142   data_structure -> struct_structure
Rule 143   struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
Rule 144   struct_fields -> struct_field
Rule 145   struct_fields -> struct_field struct_fields
Rule 146   struct_field -> VARIABLE type
Rule 147   array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type
Rule 148   array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
Rule 149   array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
Rule 150   array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value
Rule 151   map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
Rule 152   map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
Rule 153   map_values -> map_value
Rule 154   map_values -> map_value COMMA map_values
Rule 155   map_value -> value COLON value
Rule 156   map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value
Rule 157   slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
Rule 158   slice_structure -> VAR VARIABLE LBRACKET RBRACKET type
Rule 159   slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type
Rule 160   slice_structure -> VARIABLE ASSIGN append_statement
Rule 161   append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN
Rule 162   append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 116
APPEND               : 161 162
ASSIGN               : 31 35 36 45 90 148 149 150 156 160
BOOL                 : 103
BREAK                : 111
CASE                 : 136
CHARSTRING           : 10 12 13 66
COLON                : 136 137 155
COMMA                : 44 61 71 94 130 154 161 162
CONST                : 36
CONTINUE             : 112
DECREMENT            : 92
DEFAULT              : 137
DIFFERENT            : 124
DIVIDE               : 89
DIVIDEASSIGN         : 49
ELSE                 : 108 109 109
EQUALS               : 123
FALSE                : 59
FLOAT                : 69 100
FLOAT32              : 101
FLOAT64              : 102
FOR                  : 128 129 130
FORMATSTRING         : 71
FUNCTION             : 16 51 52 53 54
GREATER              : 119
GREATEREQUALS        : 121
IDENTIFIER           : 
IF                   : 107 108 109 109
IMPORT               : 10 11
INCREMENT            : 91
INPUT                : 74 75 76
INT                  : 68 96 147 148 149 150
INT32                : 97
INT64                : 98
LBRACE               : 5 6 7 8 51 52 53 54 110 111 112 128 129 130 131 143 148 151 157 162
LBRACKET             : 56 63 64 147 148 149 149 150 151 152 156 157 158 159 162
LESS                 : 120
LESSEQUALS           : 122
LPAREN               : 11 16 51 52 53 54 70 71 72 73 74 75 76 78 79 80 82 83 84 152 161 162
MAIN                 : 15 16
MAKE                 : 152
MAP                  : 151 152
MINUS                : 87
MINUSASSIGN          : 47
MOD                  : 
MODASSIGN            : 50
NOT                  : 118
OR                   : 117
PACKAGE              : 14 15
PERIOD               : 57
PLUS                 : 86
PLUSASSIGN           : 46
PRINT                : 70 72 73
PRINTF               : 71
RANGE                : 130
RBRACE               : 5 6 7 8 51 52 53 54 110 111 112 128 129 130 131 143 148 151 157 162
RBRACKET             : 56 63 64 147 148 149 149 150 151 152 156 157 158 159 162
RETURN               : 55 56 57 58 59
RPAREN               : 11 16 51 52 53 54 70 71 72 73 74 75 76 78 79 80 82 83 84 152 161 162
SEMICOLON            : 19 128 128
SHORTASSIGN          : 32 33 128 130 132 151 152 157 159
STRING               : 99
STRUCT               : 143
SWITCH               : 131
TEXT                 : 
TIMES                : 88
TIMESASSIGN          : 48
TRUE                 : 58
TYPE                 : 143
VAR                  : 30 31 34 35 147 148 149 158
VARIABLE             : 14 30 31 32 33 36 37 38 39 43 44 51 52 53 54 62 63 64 95 128 130 130 130 132 143 146 147 148 149 150 151 152 156 157 158 159 160 161 162
error                : 

Nonterminals, with rules where they appear

append_statement     : 160
array_assign         : 42
array_structure      : 139
assignation          : 37 38 40
block                : 17 18 19
blocks               : 1 2 3 4 5 6 7 8 18 19 51 52 53 54
case_block           : 134 135
case_blocks          : 131 135
condition            : 113 114 128
conditional_body     : 107 108 108 109 109 109
conditional_structure : 104
conditions           : 107 108 109 109 114
control_structure    : 24
data_structure       : 23
double_operator      : 39 85 128
empty                : 133
for_estructure       : 105
for_infinite_bucle   : 126
for_initialization   : 125
for_iterator         : 127
function             : 25
import               : 2 4 7 8
input_statement      : 21
logical_operator     : 114
main                 : 5 6 7 8
map_assign           : 41
map_structure        : 140
map_value            : 153 154
map_values           : 151 154
not_variable_value   : 65
number               : 67
operation            : 22 33 38 72 75 81 82 83 84
operator             : 77 78 79 80 81 82 83 84
package              : 3 4 6 8
parameter            : 93 94
parameters           : 26 53 54 94
print_statement      : 20
relational_operator  : 115
return               : 29
slice_structure      : 141
statement            : 110 128 129 130 136 137 0
struct_field         : 144 145
struct_fields        : 143 145
struct_structure     : 142
switch_expression    : 131
switch_structure     : 106
type                 : 30 31 34 35 52 54 95 146 147 148 149 151 151 152 152 157 158 159 162
value                : 31 32 35 36 37 40 55 56 56 57 57 60 61 64 77 77 78 78 79 79 80 80 81 82 83 84 85 115 115 128 128 132 150 155 155 156 156
values               : 61 70 71 74 136 148 149 157 161 162
values_for_import    : 11 13
variable_assignation : 28
variable_declaration : 27
variables            : 34 35 40 44

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! LPAREN          [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 1
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 1

    (0) S' -> statement .



state 2

    (1) statement -> blocks .

    $end            reduce using rule 1 (statement -> blocks .)
    RBRACE          reduce using rule 1 (statement -> blocks .)
    CASE            reduce using rule 1 (statement -> blocks .)
    DEFAULT         reduce using rule 1 (statement -> blocks .)


state 3

    (2) statement -> import . blocks
    (7) statement -> import . main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    blocks                         shift and go to state 52
    main                           shift and go to state 53
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 4

    (3) statement -> package . blocks
    (4) statement -> package . import blocks
    (6) statement -> package . main LBRACE blocks RBRACE
    (8) statement -> package . import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! LPAREN          [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    blocks                         shift and go to state 54
    import                         shift and go to state 55
    main                           shift and go to state 56
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 5

    (5) statement -> main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 57


state 6

    (17) blocks -> block .
    (18) blocks -> block . blocks
    (19) blocks -> block . SEMICOLON blocks
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

    $end            reduce using rule 17 (blocks -> block .)
    RBRACE          reduce using rule 17 (blocks -> block .)
    CASE            reduce using rule 17 (blocks -> block .)
    DEFAULT         reduce using rule 17 (blocks -> block .)
    SEMICOLON       shift and go to state 59
    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 60
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    block                          shift and go to state 6
    blocks                         shift and go to state 58
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 7

    (10) import -> IMPORT . CHARSTRING
    (11) import -> IMPORT . LPAREN values_for_import RPAREN

    CHARSTRING      shift and go to state 61
    LPAREN          shift and go to state 62


state 8

    (66) not_variable_value -> CHARSTRING .

    PLUS            reduce using rule 66 (not_variable_value -> CHARSTRING .)
    MINUS           reduce using rule 66 (not_variable_value -> CHARSTRING .)
    TIMES           reduce using rule 66 (not_variable_value -> CHARSTRING .)
    DIVIDE          reduce using rule 66 (not_variable_value -> CHARSTRING .)
    ASSIGN          reduce using rule 66 (not_variable_value -> CHARSTRING .)
    INCREMENT       reduce using rule 66 (not_variable_value -> CHARSTRING .)
    DECREMENT       reduce using rule 66 (not_variable_value -> CHARSTRING .)
    RPAREN          reduce using rule 66 (not_variable_value -> CHARSTRING .)
    LBRACKET        reduce using rule 66 (not_variable_value -> CHARSTRING .)
    PERIOD          reduce using rule 66 (not_variable_value -> CHARSTRING .)
    SEMICOLON       reduce using rule 66 (not_variable_value -> CHARSTRING .)
    PRINT           reduce using rule 66 (not_variable_value -> CHARSTRING .)
    PRINTF          reduce using rule 66 (not_variable_value -> CHARSTRING .)
    INPUT           reduce using rule 66 (not_variable_value -> CHARSTRING .)
    LPAREN          reduce using rule 66 (not_variable_value -> CHARSTRING .)
    FUNCTION        reduce using rule 66 (not_variable_value -> CHARSTRING .)
    VAR             reduce using rule 66 (not_variable_value -> CHARSTRING .)
    VARIABLE        reduce using rule 66 (not_variable_value -> CHARSTRING .)
    CONST           reduce using rule 66 (not_variable_value -> CHARSTRING .)
    RETURN          reduce using rule 66 (not_variable_value -> CHARSTRING .)
    TYPE            reduce using rule 66 (not_variable_value -> CHARSTRING .)
    IF              reduce using rule 66 (not_variable_value -> CHARSTRING .)
    SWITCH          reduce using rule 66 (not_variable_value -> CHARSTRING .)
    CHARSTRING      reduce using rule 66 (not_variable_value -> CHARSTRING .)
    FOR             reduce using rule 66 (not_variable_value -> CHARSTRING .)
    INT             reduce using rule 66 (not_variable_value -> CHARSTRING .)
    FLOAT           reduce using rule 66 (not_variable_value -> CHARSTRING .)
    $end            reduce using rule 66 (not_variable_value -> CHARSTRING .)
    RBRACE          reduce using rule 66 (not_variable_value -> CHARSTRING .)
    CASE            reduce using rule 66 (not_variable_value -> CHARSTRING .)
    DEFAULT         reduce using rule 66 (not_variable_value -> CHARSTRING .)
    GREATER         reduce using rule 66 (not_variable_value -> CHARSTRING .)
    LESS            reduce using rule 66 (not_variable_value -> CHARSTRING .)
    GREATEREQUALS   reduce using rule 66 (not_variable_value -> CHARSTRING .)
    LESSEQUALS      reduce using rule 66 (not_variable_value -> CHARSTRING .)
    EQUALS          reduce using rule 66 (not_variable_value -> CHARSTRING .)
    DIFFERENT       reduce using rule 66 (not_variable_value -> CHARSTRING .)
    RBRACKET        reduce using rule 66 (not_variable_value -> CHARSTRING .)
    COMMA           reduce using rule 66 (not_variable_value -> CHARSTRING .)
    AND             reduce using rule 66 (not_variable_value -> CHARSTRING .)
    OR              reduce using rule 66 (not_variable_value -> CHARSTRING .)
    NOT             reduce using rule 66 (not_variable_value -> CHARSTRING .)
    LBRACE          reduce using rule 66 (not_variable_value -> CHARSTRING .)
    COLON           reduce using rule 66 (not_variable_value -> CHARSTRING .)


state 9

    (79) operation -> LPAREN . value RPAREN operator value
    (80) operation -> LPAREN . value operator value RPAREN
    (82) operation -> LPAREN . value operator operation RPAREN
    (83) operation -> LPAREN . value RPAREN operator operation
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 63
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 10

    (14) package -> PACKAGE . VARIABLE
    (15) package -> PACKAGE . MAIN

    VARIABLE        shift and go to state 65
    MAIN            shift and go to state 66


state 11

    (32) variable_declaration -> VARIABLE . SHORTASSIGN value
    (33) variable_declaration -> VARIABLE . SHORTASSIGN operation
    (37) variable_assignation -> VARIABLE . assignation value
    (38) variable_assignation -> VARIABLE . assignation operation
    (39) variable_assignation -> VARIABLE . double_operator
    (62) value -> VARIABLE .
    (63) value -> VARIABLE . LBRACKET RBRACKET
    (64) value -> VARIABLE . LBRACKET value RBRACKET
    (151) map_structure -> VARIABLE . SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> VARIABLE . SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> VARIABLE . SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (159) slice_structure -> VARIABLE . SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> VARIABLE . ASSIGN append_statement
    (95) parameter -> VARIABLE . type
    (43) variables -> VARIABLE .
    (44) variables -> VARIABLE . COMMA variables
    (156) map_assign -> VARIABLE . LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> VARIABLE . LBRACKET INT RBRACKET ASSIGN value
    (45) assignation -> . ASSIGN
    (46) assignation -> . PLUSASSIGN
    (47) assignation -> . MINUSASSIGN
    (48) assignation -> . TIMESASSIGN
    (49) assignation -> . DIVIDEASSIGN
    (50) assignation -> . MODASSIGN
    (91) double_operator -> . INCREMENT
    (92) double_operator -> . DECREMENT
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for PLUSASSIGN resolved as shift
  ! shift/reduce conflict for MINUSASSIGN resolved as shift
  ! shift/reduce conflict for TIMESASSIGN resolved as shift
  ! shift/reduce conflict for DIVIDEASSIGN resolved as shift
  ! shift/reduce conflict for MODASSIGN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
    SHORTASSIGN     shift and go to state 67
    PLUS            reduce using rule 62 (value -> VARIABLE .)
    MINUS           reduce using rule 62 (value -> VARIABLE .)
    TIMES           reduce using rule 62 (value -> VARIABLE .)
    DIVIDE          reduce using rule 62 (value -> VARIABLE .)
    LBRACKET        shift and go to state 70
    ASSIGN          shift and go to state 72
    COMMA           shift and go to state 73
    PLUSASSIGN      shift and go to state 75
    MINUSASSIGN     shift and go to state 76
    TIMESASSIGN     shift and go to state 77
    DIVIDEASSIGN    shift and go to state 78
    MODASSIGN       shift and go to state 79
    INCREMENT       shift and go to state 80
    DECREMENT       shift and go to state 81
    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

  ! ASSIGN          [ reduce using rule 62 (value -> VARIABLE .) ]
  ! INCREMENT       [ reduce using rule 62 (value -> VARIABLE .) ]
  ! DECREMENT       [ reduce using rule 62 (value -> VARIABLE .) ]
  ! ASSIGN          [ reduce using rule 43 (variables -> VARIABLE .) ]
  ! PLUSASSIGN      [ reduce using rule 43 (variables -> VARIABLE .) ]
  ! MINUSASSIGN     [ reduce using rule 43 (variables -> VARIABLE .) ]
  ! TIMESASSIGN     [ reduce using rule 43 (variables -> VARIABLE .) ]
  ! DIVIDEASSIGN    [ reduce using rule 43 (variables -> VARIABLE .) ]
  ! MODASSIGN       [ reduce using rule 43 (variables -> VARIABLE .) ]

    assignation                    shift and go to state 68
    double_operator                shift and go to state 69
    type                           shift and go to state 71

state 12

    (16) main -> FUNCTION . MAIN LPAREN RPAREN
    (51) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE

    MAIN            shift and go to state 89
    VARIABLE        shift and go to state 90


state 13

    (20) block -> print_statement .

    SEMICOLON       reduce using rule 20 (block -> print_statement .)
    PRINT           reduce using rule 20 (block -> print_statement .)
    PRINTF          reduce using rule 20 (block -> print_statement .)
    INPUT           reduce using rule 20 (block -> print_statement .)
    LPAREN          reduce using rule 20 (block -> print_statement .)
    FUNCTION        reduce using rule 20 (block -> print_statement .)
    VAR             reduce using rule 20 (block -> print_statement .)
    VARIABLE        reduce using rule 20 (block -> print_statement .)
    CONST           reduce using rule 20 (block -> print_statement .)
    RETURN          reduce using rule 20 (block -> print_statement .)
    TYPE            reduce using rule 20 (block -> print_statement .)
    IF              reduce using rule 20 (block -> print_statement .)
    SWITCH          reduce using rule 20 (block -> print_statement .)
    CHARSTRING      reduce using rule 20 (block -> print_statement .)
    FOR             reduce using rule 20 (block -> print_statement .)
    INT             reduce using rule 20 (block -> print_statement .)
    FLOAT           reduce using rule 20 (block -> print_statement .)
    $end            reduce using rule 20 (block -> print_statement .)
    RBRACE          reduce using rule 20 (block -> print_statement .)
    CASE            reduce using rule 20 (block -> print_statement .)
    DEFAULT         reduce using rule 20 (block -> print_statement .)


state 14

    (21) block -> input_statement .

    SEMICOLON       reduce using rule 21 (block -> input_statement .)
    PRINT           reduce using rule 21 (block -> input_statement .)
    PRINTF          reduce using rule 21 (block -> input_statement .)
    INPUT           reduce using rule 21 (block -> input_statement .)
    LPAREN          reduce using rule 21 (block -> input_statement .)
    FUNCTION        reduce using rule 21 (block -> input_statement .)
    VAR             reduce using rule 21 (block -> input_statement .)
    VARIABLE        reduce using rule 21 (block -> input_statement .)
    CONST           reduce using rule 21 (block -> input_statement .)
    RETURN          reduce using rule 21 (block -> input_statement .)
    TYPE            reduce using rule 21 (block -> input_statement .)
    IF              reduce using rule 21 (block -> input_statement .)
    SWITCH          reduce using rule 21 (block -> input_statement .)
    CHARSTRING      reduce using rule 21 (block -> input_statement .)
    FOR             reduce using rule 21 (block -> input_statement .)
    INT             reduce using rule 21 (block -> input_statement .)
    FLOAT           reduce using rule 21 (block -> input_statement .)
    $end            reduce using rule 21 (block -> input_statement .)
    RBRACE          reduce using rule 21 (block -> input_statement .)
    CASE            reduce using rule 21 (block -> input_statement .)
    DEFAULT         reduce using rule 21 (block -> input_statement .)


state 15

    (22) block -> operation .

    SEMICOLON       reduce using rule 22 (block -> operation .)
    PRINT           reduce using rule 22 (block -> operation .)
    PRINTF          reduce using rule 22 (block -> operation .)
    INPUT           reduce using rule 22 (block -> operation .)
    LPAREN          reduce using rule 22 (block -> operation .)
    FUNCTION        reduce using rule 22 (block -> operation .)
    VAR             reduce using rule 22 (block -> operation .)
    VARIABLE        reduce using rule 22 (block -> operation .)
    CONST           reduce using rule 22 (block -> operation .)
    RETURN          reduce using rule 22 (block -> operation .)
    TYPE            reduce using rule 22 (block -> operation .)
    IF              reduce using rule 22 (block -> operation .)
    SWITCH          reduce using rule 22 (block -> operation .)
    CHARSTRING      reduce using rule 22 (block -> operation .)
    FOR             reduce using rule 22 (block -> operation .)
    INT             reduce using rule 22 (block -> operation .)
    FLOAT           reduce using rule 22 (block -> operation .)
    $end            reduce using rule 22 (block -> operation .)
    RBRACE          reduce using rule 22 (block -> operation .)
    CASE            reduce using rule 22 (block -> operation .)
    DEFAULT         reduce using rule 22 (block -> operation .)


state 16

    (23) block -> data_structure .

    SEMICOLON       reduce using rule 23 (block -> data_structure .)
    PRINT           reduce using rule 23 (block -> data_structure .)
    PRINTF          reduce using rule 23 (block -> data_structure .)
    INPUT           reduce using rule 23 (block -> data_structure .)
    LPAREN          reduce using rule 23 (block -> data_structure .)
    FUNCTION        reduce using rule 23 (block -> data_structure .)
    VAR             reduce using rule 23 (block -> data_structure .)
    VARIABLE        reduce using rule 23 (block -> data_structure .)
    CONST           reduce using rule 23 (block -> data_structure .)
    RETURN          reduce using rule 23 (block -> data_structure .)
    TYPE            reduce using rule 23 (block -> data_structure .)
    IF              reduce using rule 23 (block -> data_structure .)
    SWITCH          reduce using rule 23 (block -> data_structure .)
    CHARSTRING      reduce using rule 23 (block -> data_structure .)
    FOR             reduce using rule 23 (block -> data_structure .)
    INT             reduce using rule 23 (block -> data_structure .)
    FLOAT           reduce using rule 23 (block -> data_structure .)
    $end            reduce using rule 23 (block -> data_structure .)
    RBRACE          reduce using rule 23 (block -> data_structure .)
    CASE            reduce using rule 23 (block -> data_structure .)
    DEFAULT         reduce using rule 23 (block -> data_structure .)


state 17

    (24) block -> control_structure .

    SEMICOLON       reduce using rule 24 (block -> control_structure .)
    PRINT           reduce using rule 24 (block -> control_structure .)
    PRINTF          reduce using rule 24 (block -> control_structure .)
    INPUT           reduce using rule 24 (block -> control_structure .)
    LPAREN          reduce using rule 24 (block -> control_structure .)
    FUNCTION        reduce using rule 24 (block -> control_structure .)
    VAR             reduce using rule 24 (block -> control_structure .)
    VARIABLE        reduce using rule 24 (block -> control_structure .)
    CONST           reduce using rule 24 (block -> control_structure .)
    RETURN          reduce using rule 24 (block -> control_structure .)
    TYPE            reduce using rule 24 (block -> control_structure .)
    IF              reduce using rule 24 (block -> control_structure .)
    SWITCH          reduce using rule 24 (block -> control_structure .)
    CHARSTRING      reduce using rule 24 (block -> control_structure .)
    FOR             reduce using rule 24 (block -> control_structure .)
    INT             reduce using rule 24 (block -> control_structure .)
    FLOAT           reduce using rule 24 (block -> control_structure .)
    $end            reduce using rule 24 (block -> control_structure .)
    RBRACE          reduce using rule 24 (block -> control_structure .)
    CASE            reduce using rule 24 (block -> control_structure .)
    DEFAULT         reduce using rule 24 (block -> control_structure .)


state 18

    (25) block -> function .

    SEMICOLON       reduce using rule 25 (block -> function .)
    PRINT           reduce using rule 25 (block -> function .)
    PRINTF          reduce using rule 25 (block -> function .)
    INPUT           reduce using rule 25 (block -> function .)
    LPAREN          reduce using rule 25 (block -> function .)
    FUNCTION        reduce using rule 25 (block -> function .)
    VAR             reduce using rule 25 (block -> function .)
    VARIABLE        reduce using rule 25 (block -> function .)
    CONST           reduce using rule 25 (block -> function .)
    RETURN          reduce using rule 25 (block -> function .)
    TYPE            reduce using rule 25 (block -> function .)
    IF              reduce using rule 25 (block -> function .)
    SWITCH          reduce using rule 25 (block -> function .)
    CHARSTRING      reduce using rule 25 (block -> function .)
    FOR             reduce using rule 25 (block -> function .)
    INT             reduce using rule 25 (block -> function .)
    FLOAT           reduce using rule 25 (block -> function .)
    $end            reduce using rule 25 (block -> function .)
    RBRACE          reduce using rule 25 (block -> function .)
    CASE            reduce using rule 25 (block -> function .)
    DEFAULT         reduce using rule 25 (block -> function .)


state 19

    (26) block -> parameters .

    SEMICOLON       reduce using rule 26 (block -> parameters .)
    PRINT           reduce using rule 26 (block -> parameters .)
    PRINTF          reduce using rule 26 (block -> parameters .)
    INPUT           reduce using rule 26 (block -> parameters .)
    LPAREN          reduce using rule 26 (block -> parameters .)
    FUNCTION        reduce using rule 26 (block -> parameters .)
    VAR             reduce using rule 26 (block -> parameters .)
    VARIABLE        reduce using rule 26 (block -> parameters .)
    CONST           reduce using rule 26 (block -> parameters .)
    RETURN          reduce using rule 26 (block -> parameters .)
    TYPE            reduce using rule 26 (block -> parameters .)
    IF              reduce using rule 26 (block -> parameters .)
    SWITCH          reduce using rule 26 (block -> parameters .)
    CHARSTRING      reduce using rule 26 (block -> parameters .)
    FOR             reduce using rule 26 (block -> parameters .)
    INT             reduce using rule 26 (block -> parameters .)
    FLOAT           reduce using rule 26 (block -> parameters .)
    $end            reduce using rule 26 (block -> parameters .)
    RBRACE          reduce using rule 26 (block -> parameters .)
    CASE            reduce using rule 26 (block -> parameters .)
    DEFAULT         reduce using rule 26 (block -> parameters .)


state 20

    (27) block -> variable_declaration .

    SEMICOLON       reduce using rule 27 (block -> variable_declaration .)
    PRINT           reduce using rule 27 (block -> variable_declaration .)
    PRINTF          reduce using rule 27 (block -> variable_declaration .)
    INPUT           reduce using rule 27 (block -> variable_declaration .)
    LPAREN          reduce using rule 27 (block -> variable_declaration .)
    FUNCTION        reduce using rule 27 (block -> variable_declaration .)
    VAR             reduce using rule 27 (block -> variable_declaration .)
    VARIABLE        reduce using rule 27 (block -> variable_declaration .)
    CONST           reduce using rule 27 (block -> variable_declaration .)
    RETURN          reduce using rule 27 (block -> variable_declaration .)
    TYPE            reduce using rule 27 (block -> variable_declaration .)
    IF              reduce using rule 27 (block -> variable_declaration .)
    SWITCH          reduce using rule 27 (block -> variable_declaration .)
    CHARSTRING      reduce using rule 27 (block -> variable_declaration .)
    FOR             reduce using rule 27 (block -> variable_declaration .)
    INT             reduce using rule 27 (block -> variable_declaration .)
    FLOAT           reduce using rule 27 (block -> variable_declaration .)
    $end            reduce using rule 27 (block -> variable_declaration .)
    RBRACE          reduce using rule 27 (block -> variable_declaration .)
    CASE            reduce using rule 27 (block -> variable_declaration .)
    DEFAULT         reduce using rule 27 (block -> variable_declaration .)


state 21

    (28) block -> variable_assignation .

    SEMICOLON       reduce using rule 28 (block -> variable_assignation .)
    PRINT           reduce using rule 28 (block -> variable_assignation .)
    PRINTF          reduce using rule 28 (block -> variable_assignation .)
    INPUT           reduce using rule 28 (block -> variable_assignation .)
    LPAREN          reduce using rule 28 (block -> variable_assignation .)
    FUNCTION        reduce using rule 28 (block -> variable_assignation .)
    VAR             reduce using rule 28 (block -> variable_assignation .)
    VARIABLE        reduce using rule 28 (block -> variable_assignation .)
    CONST           reduce using rule 28 (block -> variable_assignation .)
    RETURN          reduce using rule 28 (block -> variable_assignation .)
    TYPE            reduce using rule 28 (block -> variable_assignation .)
    IF              reduce using rule 28 (block -> variable_assignation .)
    SWITCH          reduce using rule 28 (block -> variable_assignation .)
    CHARSTRING      reduce using rule 28 (block -> variable_assignation .)
    FOR             reduce using rule 28 (block -> variable_assignation .)
    INT             reduce using rule 28 (block -> variable_assignation .)
    FLOAT           reduce using rule 28 (block -> variable_assignation .)
    $end            reduce using rule 28 (block -> variable_assignation .)
    RBRACE          reduce using rule 28 (block -> variable_assignation .)
    CASE            reduce using rule 28 (block -> variable_assignation .)
    DEFAULT         reduce using rule 28 (block -> variable_assignation .)


state 22

    (29) block -> return .

    SEMICOLON       reduce using rule 29 (block -> return .)
    PRINT           reduce using rule 29 (block -> return .)
    PRINTF          reduce using rule 29 (block -> return .)
    INPUT           reduce using rule 29 (block -> return .)
    LPAREN          reduce using rule 29 (block -> return .)
    FUNCTION        reduce using rule 29 (block -> return .)
    VAR             reduce using rule 29 (block -> return .)
    VARIABLE        reduce using rule 29 (block -> return .)
    CONST           reduce using rule 29 (block -> return .)
    RETURN          reduce using rule 29 (block -> return .)
    TYPE            reduce using rule 29 (block -> return .)
    IF              reduce using rule 29 (block -> return .)
    SWITCH          reduce using rule 29 (block -> return .)
    CHARSTRING      reduce using rule 29 (block -> return .)
    FOR             reduce using rule 29 (block -> return .)
    INT             reduce using rule 29 (block -> return .)
    FLOAT           reduce using rule 29 (block -> return .)
    $end            reduce using rule 29 (block -> return .)
    RBRACE          reduce using rule 29 (block -> return .)
    CASE            reduce using rule 29 (block -> return .)
    DEFAULT         reduce using rule 29 (block -> return .)


state 23

    (70) print_statement -> PRINT . LPAREN values RPAREN
    (72) print_statement -> PRINT . LPAREN operation RPAREN
    (73) print_statement -> PRINT . LPAREN RPAREN

    LPAREN          shift and go to state 91


state 24

    (71) print_statement -> PRINTF . LPAREN FORMATSTRING COMMA values RPAREN

    LPAREN          shift and go to state 92


state 25

    (74) input_statement -> INPUT . LPAREN values RPAREN
    (75) input_statement -> INPUT . LPAREN operation RPAREN
    (76) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 93


state 26

    (77) operation -> value . operator value
    (78) operation -> value . operator LPAREN value RPAREN
    (81) operation -> value . operator operation
    (84) operation -> value . operator LPAREN operation RPAREN
    (85) operation -> value . double_operator
    (86) operator -> . PLUS
    (87) operator -> . MINUS
    (88) operator -> . TIMES
    (89) operator -> . DIVIDE
    (90) operator -> . ASSIGN
    (91) double_operator -> . INCREMENT
    (92) double_operator -> . DECREMENT

    PLUS            shift and go to state 96
    MINUS           shift and go to state 97
    TIMES           shift and go to state 98
    DIVIDE          shift and go to state 99
    ASSIGN          shift and go to state 100
    INCREMENT       shift and go to state 80
    DECREMENT       shift and go to state 81

    operator                       shift and go to state 94
    double_operator                shift and go to state 95

state 27

    (139) data_structure -> array_structure .

    SEMICOLON       reduce using rule 139 (data_structure -> array_structure .)
    PRINT           reduce using rule 139 (data_structure -> array_structure .)
    PRINTF          reduce using rule 139 (data_structure -> array_structure .)
    INPUT           reduce using rule 139 (data_structure -> array_structure .)
    LPAREN          reduce using rule 139 (data_structure -> array_structure .)
    FUNCTION        reduce using rule 139 (data_structure -> array_structure .)
    VAR             reduce using rule 139 (data_structure -> array_structure .)
    VARIABLE        reduce using rule 139 (data_structure -> array_structure .)
    CONST           reduce using rule 139 (data_structure -> array_structure .)
    RETURN          reduce using rule 139 (data_structure -> array_structure .)
    TYPE            reduce using rule 139 (data_structure -> array_structure .)
    IF              reduce using rule 139 (data_structure -> array_structure .)
    SWITCH          reduce using rule 139 (data_structure -> array_structure .)
    CHARSTRING      reduce using rule 139 (data_structure -> array_structure .)
    FOR             reduce using rule 139 (data_structure -> array_structure .)
    INT             reduce using rule 139 (data_structure -> array_structure .)
    FLOAT           reduce using rule 139 (data_structure -> array_structure .)
    $end            reduce using rule 139 (data_structure -> array_structure .)
    RBRACE          reduce using rule 139 (data_structure -> array_structure .)
    CASE            reduce using rule 139 (data_structure -> array_structure .)
    DEFAULT         reduce using rule 139 (data_structure -> array_structure .)


state 28

    (140) data_structure -> map_structure .

    SEMICOLON       reduce using rule 140 (data_structure -> map_structure .)
    PRINT           reduce using rule 140 (data_structure -> map_structure .)
    PRINTF          reduce using rule 140 (data_structure -> map_structure .)
    INPUT           reduce using rule 140 (data_structure -> map_structure .)
    LPAREN          reduce using rule 140 (data_structure -> map_structure .)
    FUNCTION        reduce using rule 140 (data_structure -> map_structure .)
    VAR             reduce using rule 140 (data_structure -> map_structure .)
    VARIABLE        reduce using rule 140 (data_structure -> map_structure .)
    CONST           reduce using rule 140 (data_structure -> map_structure .)
    RETURN          reduce using rule 140 (data_structure -> map_structure .)
    TYPE            reduce using rule 140 (data_structure -> map_structure .)
    IF              reduce using rule 140 (data_structure -> map_structure .)
    SWITCH          reduce using rule 140 (data_structure -> map_structure .)
    CHARSTRING      reduce using rule 140 (data_structure -> map_structure .)
    FOR             reduce using rule 140 (data_structure -> map_structure .)
    INT             reduce using rule 140 (data_structure -> map_structure .)
    FLOAT           reduce using rule 140 (data_structure -> map_structure .)
    $end            reduce using rule 140 (data_structure -> map_structure .)
    RBRACE          reduce using rule 140 (data_structure -> map_structure .)
    CASE            reduce using rule 140 (data_structure -> map_structure .)
    DEFAULT         reduce using rule 140 (data_structure -> map_structure .)


state 29

    (141) data_structure -> slice_structure .

    SEMICOLON       reduce using rule 141 (data_structure -> slice_structure .)
    PRINT           reduce using rule 141 (data_structure -> slice_structure .)
    PRINTF          reduce using rule 141 (data_structure -> slice_structure .)
    INPUT           reduce using rule 141 (data_structure -> slice_structure .)
    LPAREN          reduce using rule 141 (data_structure -> slice_structure .)
    FUNCTION        reduce using rule 141 (data_structure -> slice_structure .)
    VAR             reduce using rule 141 (data_structure -> slice_structure .)
    VARIABLE        reduce using rule 141 (data_structure -> slice_structure .)
    CONST           reduce using rule 141 (data_structure -> slice_structure .)
    RETURN          reduce using rule 141 (data_structure -> slice_structure .)
    TYPE            reduce using rule 141 (data_structure -> slice_structure .)
    IF              reduce using rule 141 (data_structure -> slice_structure .)
    SWITCH          reduce using rule 141 (data_structure -> slice_structure .)
    CHARSTRING      reduce using rule 141 (data_structure -> slice_structure .)
    FOR             reduce using rule 141 (data_structure -> slice_structure .)
    INT             reduce using rule 141 (data_structure -> slice_structure .)
    FLOAT           reduce using rule 141 (data_structure -> slice_structure .)
    $end            reduce using rule 141 (data_structure -> slice_structure .)
    RBRACE          reduce using rule 141 (data_structure -> slice_structure .)
    CASE            reduce using rule 141 (data_structure -> slice_structure .)
    DEFAULT         reduce using rule 141 (data_structure -> slice_structure .)


state 30

    (142) data_structure -> struct_structure .

    SEMICOLON       reduce using rule 142 (data_structure -> struct_structure .)
    PRINT           reduce using rule 142 (data_structure -> struct_structure .)
    PRINTF          reduce using rule 142 (data_structure -> struct_structure .)
    INPUT           reduce using rule 142 (data_structure -> struct_structure .)
    LPAREN          reduce using rule 142 (data_structure -> struct_structure .)
    FUNCTION        reduce using rule 142 (data_structure -> struct_structure .)
    VAR             reduce using rule 142 (data_structure -> struct_structure .)
    VARIABLE        reduce using rule 142 (data_structure -> struct_structure .)
    CONST           reduce using rule 142 (data_structure -> struct_structure .)
    RETURN          reduce using rule 142 (data_structure -> struct_structure .)
    TYPE            reduce using rule 142 (data_structure -> struct_structure .)
    IF              reduce using rule 142 (data_structure -> struct_structure .)
    SWITCH          reduce using rule 142 (data_structure -> struct_structure .)
    CHARSTRING      reduce using rule 142 (data_structure -> struct_structure .)
    FOR             reduce using rule 142 (data_structure -> struct_structure .)
    INT             reduce using rule 142 (data_structure -> struct_structure .)
    FLOAT           reduce using rule 142 (data_structure -> struct_structure .)
    $end            reduce using rule 142 (data_structure -> struct_structure .)
    RBRACE          reduce using rule 142 (data_structure -> struct_structure .)
    CASE            reduce using rule 142 (data_structure -> struct_structure .)
    DEFAULT         reduce using rule 142 (data_structure -> struct_structure .)


state 31

    (104) control_structure -> conditional_structure .

    SEMICOLON       reduce using rule 104 (control_structure -> conditional_structure .)
    PRINT           reduce using rule 104 (control_structure -> conditional_structure .)
    PRINTF          reduce using rule 104 (control_structure -> conditional_structure .)
    INPUT           reduce using rule 104 (control_structure -> conditional_structure .)
    LPAREN          reduce using rule 104 (control_structure -> conditional_structure .)
    FUNCTION        reduce using rule 104 (control_structure -> conditional_structure .)
    VAR             reduce using rule 104 (control_structure -> conditional_structure .)
    VARIABLE        reduce using rule 104 (control_structure -> conditional_structure .)
    CONST           reduce using rule 104 (control_structure -> conditional_structure .)
    RETURN          reduce using rule 104 (control_structure -> conditional_structure .)
    TYPE            reduce using rule 104 (control_structure -> conditional_structure .)
    IF              reduce using rule 104 (control_structure -> conditional_structure .)
    SWITCH          reduce using rule 104 (control_structure -> conditional_structure .)
    CHARSTRING      reduce using rule 104 (control_structure -> conditional_structure .)
    FOR             reduce using rule 104 (control_structure -> conditional_structure .)
    INT             reduce using rule 104 (control_structure -> conditional_structure .)
    FLOAT           reduce using rule 104 (control_structure -> conditional_structure .)
    $end            reduce using rule 104 (control_structure -> conditional_structure .)
    RBRACE          reduce using rule 104 (control_structure -> conditional_structure .)
    CASE            reduce using rule 104 (control_structure -> conditional_structure .)
    DEFAULT         reduce using rule 104 (control_structure -> conditional_structure .)


state 32

    (105) control_structure -> for_estructure .

    SEMICOLON       reduce using rule 105 (control_structure -> for_estructure .)
    PRINT           reduce using rule 105 (control_structure -> for_estructure .)
    PRINTF          reduce using rule 105 (control_structure -> for_estructure .)
    INPUT           reduce using rule 105 (control_structure -> for_estructure .)
    LPAREN          reduce using rule 105 (control_structure -> for_estructure .)
    FUNCTION        reduce using rule 105 (control_structure -> for_estructure .)
    VAR             reduce using rule 105 (control_structure -> for_estructure .)
    VARIABLE        reduce using rule 105 (control_structure -> for_estructure .)
    CONST           reduce using rule 105 (control_structure -> for_estructure .)
    RETURN          reduce using rule 105 (control_structure -> for_estructure .)
    TYPE            reduce using rule 105 (control_structure -> for_estructure .)
    IF              reduce using rule 105 (control_structure -> for_estructure .)
    SWITCH          reduce using rule 105 (control_structure -> for_estructure .)
    CHARSTRING      reduce using rule 105 (control_structure -> for_estructure .)
    FOR             reduce using rule 105 (control_structure -> for_estructure .)
    INT             reduce using rule 105 (control_structure -> for_estructure .)
    FLOAT           reduce using rule 105 (control_structure -> for_estructure .)
    $end            reduce using rule 105 (control_structure -> for_estructure .)
    RBRACE          reduce using rule 105 (control_structure -> for_estructure .)
    CASE            reduce using rule 105 (control_structure -> for_estructure .)
    DEFAULT         reduce using rule 105 (control_structure -> for_estructure .)


state 33

    (106) control_structure -> switch_structure .

    SEMICOLON       reduce using rule 106 (control_structure -> switch_structure .)
    PRINT           reduce using rule 106 (control_structure -> switch_structure .)
    PRINTF          reduce using rule 106 (control_structure -> switch_structure .)
    INPUT           reduce using rule 106 (control_structure -> switch_structure .)
    LPAREN          reduce using rule 106 (control_structure -> switch_structure .)
    FUNCTION        reduce using rule 106 (control_structure -> switch_structure .)
    VAR             reduce using rule 106 (control_structure -> switch_structure .)
    VARIABLE        reduce using rule 106 (control_structure -> switch_structure .)
    CONST           reduce using rule 106 (control_structure -> switch_structure .)
    RETURN          reduce using rule 106 (control_structure -> switch_structure .)
    TYPE            reduce using rule 106 (control_structure -> switch_structure .)
    IF              reduce using rule 106 (control_structure -> switch_structure .)
    SWITCH          reduce using rule 106 (control_structure -> switch_structure .)
    CHARSTRING      reduce using rule 106 (control_structure -> switch_structure .)
    FOR             reduce using rule 106 (control_structure -> switch_structure .)
    INT             reduce using rule 106 (control_structure -> switch_structure .)
    FLOAT           reduce using rule 106 (control_structure -> switch_structure .)
    $end            reduce using rule 106 (control_structure -> switch_structure .)
    RBRACE          reduce using rule 106 (control_structure -> switch_structure .)
    CASE            reduce using rule 106 (control_structure -> switch_structure .)
    DEFAULT         reduce using rule 106 (control_structure -> switch_structure .)


state 34

    (93) parameters -> parameter .
    (94) parameters -> parameter . COMMA parameters

    SEMICOLON       reduce using rule 93 (parameters -> parameter .)
    PRINT           reduce using rule 93 (parameters -> parameter .)
    PRINTF          reduce using rule 93 (parameters -> parameter .)
    INPUT           reduce using rule 93 (parameters -> parameter .)
    LPAREN          reduce using rule 93 (parameters -> parameter .)
    FUNCTION        reduce using rule 93 (parameters -> parameter .)
    VAR             reduce using rule 93 (parameters -> parameter .)
    VARIABLE        reduce using rule 93 (parameters -> parameter .)
    CONST           reduce using rule 93 (parameters -> parameter .)
    RETURN          reduce using rule 93 (parameters -> parameter .)
    TYPE            reduce using rule 93 (parameters -> parameter .)
    IF              reduce using rule 93 (parameters -> parameter .)
    SWITCH          reduce using rule 93 (parameters -> parameter .)
    CHARSTRING      reduce using rule 93 (parameters -> parameter .)
    FOR             reduce using rule 93 (parameters -> parameter .)
    INT             reduce using rule 93 (parameters -> parameter .)
    FLOAT           reduce using rule 93 (parameters -> parameter .)
    $end            reduce using rule 93 (parameters -> parameter .)
    RBRACE          reduce using rule 93 (parameters -> parameter .)
    CASE            reduce using rule 93 (parameters -> parameter .)
    DEFAULT         reduce using rule 93 (parameters -> parameter .)
    RPAREN          reduce using rule 93 (parameters -> parameter .)
    COMMA           shift and go to state 101


state 35

    (30) variable_declaration -> VAR . VARIABLE type
    (31) variable_declaration -> VAR . VARIABLE type ASSIGN value
    (34) variable_declaration -> VAR . variables type
    (35) variable_declaration -> VAR . variables type ASSIGN value
    (147) array_structure -> VAR . VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> VAR . VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> VAR . VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (158) slice_structure -> VAR . VARIABLE LBRACKET RBRACKET type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables

    VARIABLE        shift and go to state 102

    variables                      shift and go to state 103

state 36

    (40) variable_assignation -> variables . assignation value
    (45) assignation -> . ASSIGN
    (46) assignation -> . PLUSASSIGN
    (47) assignation -> . MINUSASSIGN
    (48) assignation -> . TIMESASSIGN
    (49) assignation -> . DIVIDEASSIGN
    (50) assignation -> . MODASSIGN

    ASSIGN          shift and go to state 105
    PLUSASSIGN      shift and go to state 75
    MINUSASSIGN     shift and go to state 76
    TIMESASSIGN     shift and go to state 77
    DIVIDEASSIGN    shift and go to state 78
    MODASSIGN       shift and go to state 79

    assignation                    shift and go to state 104

state 37

    (36) variable_declaration -> CONST . VARIABLE ASSIGN value

    VARIABLE        shift and go to state 106


state 38

    (41) variable_assignation -> map_assign .

    SEMICOLON       reduce using rule 41 (variable_assignation -> map_assign .)
    PRINT           reduce using rule 41 (variable_assignation -> map_assign .)
    PRINTF          reduce using rule 41 (variable_assignation -> map_assign .)
    INPUT           reduce using rule 41 (variable_assignation -> map_assign .)
    LPAREN          reduce using rule 41 (variable_assignation -> map_assign .)
    FUNCTION        reduce using rule 41 (variable_assignation -> map_assign .)
    VAR             reduce using rule 41 (variable_assignation -> map_assign .)
    VARIABLE        reduce using rule 41 (variable_assignation -> map_assign .)
    CONST           reduce using rule 41 (variable_assignation -> map_assign .)
    RETURN          reduce using rule 41 (variable_assignation -> map_assign .)
    TYPE            reduce using rule 41 (variable_assignation -> map_assign .)
    IF              reduce using rule 41 (variable_assignation -> map_assign .)
    SWITCH          reduce using rule 41 (variable_assignation -> map_assign .)
    CHARSTRING      reduce using rule 41 (variable_assignation -> map_assign .)
    FOR             reduce using rule 41 (variable_assignation -> map_assign .)
    INT             reduce using rule 41 (variable_assignation -> map_assign .)
    FLOAT           reduce using rule 41 (variable_assignation -> map_assign .)
    $end            reduce using rule 41 (variable_assignation -> map_assign .)
    RBRACE          reduce using rule 41 (variable_assignation -> map_assign .)
    CASE            reduce using rule 41 (variable_assignation -> map_assign .)
    DEFAULT         reduce using rule 41 (variable_assignation -> map_assign .)


state 39

    (42) variable_assignation -> array_assign .

    SEMICOLON       reduce using rule 42 (variable_assignation -> array_assign .)
    PRINT           reduce using rule 42 (variable_assignation -> array_assign .)
    PRINTF          reduce using rule 42 (variable_assignation -> array_assign .)
    INPUT           reduce using rule 42 (variable_assignation -> array_assign .)
    LPAREN          reduce using rule 42 (variable_assignation -> array_assign .)
    FUNCTION        reduce using rule 42 (variable_assignation -> array_assign .)
    VAR             reduce using rule 42 (variable_assignation -> array_assign .)
    VARIABLE        reduce using rule 42 (variable_assignation -> array_assign .)
    CONST           reduce using rule 42 (variable_assignation -> array_assign .)
    RETURN          reduce using rule 42 (variable_assignation -> array_assign .)
    TYPE            reduce using rule 42 (variable_assignation -> array_assign .)
    IF              reduce using rule 42 (variable_assignation -> array_assign .)
    SWITCH          reduce using rule 42 (variable_assignation -> array_assign .)
    CHARSTRING      reduce using rule 42 (variable_assignation -> array_assign .)
    FOR             reduce using rule 42 (variable_assignation -> array_assign .)
    INT             reduce using rule 42 (variable_assignation -> array_assign .)
    FLOAT           reduce using rule 42 (variable_assignation -> array_assign .)
    $end            reduce using rule 42 (variable_assignation -> array_assign .)
    RBRACE          reduce using rule 42 (variable_assignation -> array_assign .)
    CASE            reduce using rule 42 (variable_assignation -> array_assign .)
    DEFAULT         reduce using rule 42 (variable_assignation -> array_assign .)


state 40

    (55) return -> RETURN . value
    (56) return -> RETURN . value LBRACKET value RBRACKET
    (57) return -> RETURN . value PERIOD value
    (58) return -> RETURN . TRUE
    (59) return -> RETURN . FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    TRUE            shift and go to state 108
    FALSE           shift and go to state 109
    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 107
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 41

    (65) value -> not_variable_value .

    PLUS            reduce using rule 65 (value -> not_variable_value .)
    MINUS           reduce using rule 65 (value -> not_variable_value .)
    TIMES           reduce using rule 65 (value -> not_variable_value .)
    DIVIDE          reduce using rule 65 (value -> not_variable_value .)
    ASSIGN          reduce using rule 65 (value -> not_variable_value .)
    INCREMENT       reduce using rule 65 (value -> not_variable_value .)
    DECREMENT       reduce using rule 65 (value -> not_variable_value .)
    RPAREN          reduce using rule 65 (value -> not_variable_value .)
    LBRACKET        reduce using rule 65 (value -> not_variable_value .)
    PERIOD          reduce using rule 65 (value -> not_variable_value .)
    SEMICOLON       reduce using rule 65 (value -> not_variable_value .)
    PRINT           reduce using rule 65 (value -> not_variable_value .)
    PRINTF          reduce using rule 65 (value -> not_variable_value .)
    INPUT           reduce using rule 65 (value -> not_variable_value .)
    LPAREN          reduce using rule 65 (value -> not_variable_value .)
    FUNCTION        reduce using rule 65 (value -> not_variable_value .)
    VAR             reduce using rule 65 (value -> not_variable_value .)
    VARIABLE        reduce using rule 65 (value -> not_variable_value .)
    CONST           reduce using rule 65 (value -> not_variable_value .)
    RETURN          reduce using rule 65 (value -> not_variable_value .)
    TYPE            reduce using rule 65 (value -> not_variable_value .)
    IF              reduce using rule 65 (value -> not_variable_value .)
    SWITCH          reduce using rule 65 (value -> not_variable_value .)
    CHARSTRING      reduce using rule 65 (value -> not_variable_value .)
    FOR             reduce using rule 65 (value -> not_variable_value .)
    INT             reduce using rule 65 (value -> not_variable_value .)
    FLOAT           reduce using rule 65 (value -> not_variable_value .)
    $end            reduce using rule 65 (value -> not_variable_value .)
    RBRACE          reduce using rule 65 (value -> not_variable_value .)
    CASE            reduce using rule 65 (value -> not_variable_value .)
    DEFAULT         reduce using rule 65 (value -> not_variable_value .)
    GREATER         reduce using rule 65 (value -> not_variable_value .)
    LESS            reduce using rule 65 (value -> not_variable_value .)
    GREATEREQUALS   reduce using rule 65 (value -> not_variable_value .)
    LESSEQUALS      reduce using rule 65 (value -> not_variable_value .)
    EQUALS          reduce using rule 65 (value -> not_variable_value .)
    DIFFERENT       reduce using rule 65 (value -> not_variable_value .)
    RBRACKET        reduce using rule 65 (value -> not_variable_value .)
    COMMA           reduce using rule 65 (value -> not_variable_value .)
    AND             reduce using rule 65 (value -> not_variable_value .)
    OR              reduce using rule 65 (value -> not_variable_value .)
    NOT             reduce using rule 65 (value -> not_variable_value .)
    LBRACE          reduce using rule 65 (value -> not_variable_value .)
    COLON           reduce using rule 65 (value -> not_variable_value .)


state 42

    (68) number -> INT .

    PLUS            reduce using rule 68 (number -> INT .)
    MINUS           reduce using rule 68 (number -> INT .)
    TIMES           reduce using rule 68 (number -> INT .)
    DIVIDE          reduce using rule 68 (number -> INT .)
    ASSIGN          reduce using rule 68 (number -> INT .)
    INCREMENT       reduce using rule 68 (number -> INT .)
    DECREMENT       reduce using rule 68 (number -> INT .)
    RPAREN          reduce using rule 68 (number -> INT .)
    LBRACKET        reduce using rule 68 (number -> INT .)
    PERIOD          reduce using rule 68 (number -> INT .)
    SEMICOLON       reduce using rule 68 (number -> INT .)
    PRINT           reduce using rule 68 (number -> INT .)
    PRINTF          reduce using rule 68 (number -> INT .)
    INPUT           reduce using rule 68 (number -> INT .)
    LPAREN          reduce using rule 68 (number -> INT .)
    FUNCTION        reduce using rule 68 (number -> INT .)
    VAR             reduce using rule 68 (number -> INT .)
    VARIABLE        reduce using rule 68 (number -> INT .)
    CONST           reduce using rule 68 (number -> INT .)
    RETURN          reduce using rule 68 (number -> INT .)
    TYPE            reduce using rule 68 (number -> INT .)
    IF              reduce using rule 68 (number -> INT .)
    SWITCH          reduce using rule 68 (number -> INT .)
    CHARSTRING      reduce using rule 68 (number -> INT .)
    FOR             reduce using rule 68 (number -> INT .)
    INT             reduce using rule 68 (number -> INT .)
    FLOAT           reduce using rule 68 (number -> INT .)
    $end            reduce using rule 68 (number -> INT .)
    RBRACE          reduce using rule 68 (number -> INT .)
    CASE            reduce using rule 68 (number -> INT .)
    DEFAULT         reduce using rule 68 (number -> INT .)
    GREATER         reduce using rule 68 (number -> INT .)
    LESS            reduce using rule 68 (number -> INT .)
    GREATEREQUALS   reduce using rule 68 (number -> INT .)
    LESSEQUALS      reduce using rule 68 (number -> INT .)
    EQUALS          reduce using rule 68 (number -> INT .)
    DIFFERENT       reduce using rule 68 (number -> INT .)
    COMMA           reduce using rule 68 (number -> INT .)
    RBRACKET        reduce using rule 68 (number -> INT .)
    AND             reduce using rule 68 (number -> INT .)
    OR              reduce using rule 68 (number -> INT .)
    NOT             reduce using rule 68 (number -> INT .)
    LBRACE          reduce using rule 68 (number -> INT .)
    COLON           reduce using rule 68 (number -> INT .)


state 43

    (143) struct_structure -> TYPE . VARIABLE STRUCT LBRACE struct_fields RBRACE

    VARIABLE        shift and go to state 110


state 44

    (107) conditional_structure -> IF . conditions conditional_body
    (108) conditional_structure -> IF . conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> IF . conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (113) conditions -> . condition
    (114) conditions -> . condition logical_operator conditions
    (115) condition -> . value relational_operator value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    conditions                     shift and go to state 111
    condition                      shift and go to state 112
    value                          shift and go to state 113
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 45

    (125) for_estructure -> for_initialization .

    SEMICOLON       reduce using rule 125 (for_estructure -> for_initialization .)
    PRINT           reduce using rule 125 (for_estructure -> for_initialization .)
    PRINTF          reduce using rule 125 (for_estructure -> for_initialization .)
    INPUT           reduce using rule 125 (for_estructure -> for_initialization .)
    LPAREN          reduce using rule 125 (for_estructure -> for_initialization .)
    FUNCTION        reduce using rule 125 (for_estructure -> for_initialization .)
    VAR             reduce using rule 125 (for_estructure -> for_initialization .)
    VARIABLE        reduce using rule 125 (for_estructure -> for_initialization .)
    CONST           reduce using rule 125 (for_estructure -> for_initialization .)
    RETURN          reduce using rule 125 (for_estructure -> for_initialization .)
    TYPE            reduce using rule 125 (for_estructure -> for_initialization .)
    IF              reduce using rule 125 (for_estructure -> for_initialization .)
    SWITCH          reduce using rule 125 (for_estructure -> for_initialization .)
    CHARSTRING      reduce using rule 125 (for_estructure -> for_initialization .)
    FOR             reduce using rule 125 (for_estructure -> for_initialization .)
    INT             reduce using rule 125 (for_estructure -> for_initialization .)
    FLOAT           reduce using rule 125 (for_estructure -> for_initialization .)
    $end            reduce using rule 125 (for_estructure -> for_initialization .)
    RBRACE          reduce using rule 125 (for_estructure -> for_initialization .)
    CASE            reduce using rule 125 (for_estructure -> for_initialization .)
    DEFAULT         reduce using rule 125 (for_estructure -> for_initialization .)


state 46

    (126) for_estructure -> for_infinite_bucle .

    SEMICOLON       reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    PRINT           reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    PRINTF          reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    INPUT           reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    LPAREN          reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    FUNCTION        reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    VAR             reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    VARIABLE        reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    CONST           reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    RETURN          reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    TYPE            reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    IF              reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    SWITCH          reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    CHARSTRING      reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    FOR             reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    INT             reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    FLOAT           reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    $end            reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    RBRACE          reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    CASE            reduce using rule 126 (for_estructure -> for_infinite_bucle .)
    DEFAULT         reduce using rule 126 (for_estructure -> for_infinite_bucle .)


state 47

    (127) for_estructure -> for_iterator .

    SEMICOLON       reduce using rule 127 (for_estructure -> for_iterator .)
    PRINT           reduce using rule 127 (for_estructure -> for_iterator .)
    PRINTF          reduce using rule 127 (for_estructure -> for_iterator .)
    INPUT           reduce using rule 127 (for_estructure -> for_iterator .)
    LPAREN          reduce using rule 127 (for_estructure -> for_iterator .)
    FUNCTION        reduce using rule 127 (for_estructure -> for_iterator .)
    VAR             reduce using rule 127 (for_estructure -> for_iterator .)
    VARIABLE        reduce using rule 127 (for_estructure -> for_iterator .)
    CONST           reduce using rule 127 (for_estructure -> for_iterator .)
    RETURN          reduce using rule 127 (for_estructure -> for_iterator .)
    TYPE            reduce using rule 127 (for_estructure -> for_iterator .)
    IF              reduce using rule 127 (for_estructure -> for_iterator .)
    SWITCH          reduce using rule 127 (for_estructure -> for_iterator .)
    CHARSTRING      reduce using rule 127 (for_estructure -> for_iterator .)
    FOR             reduce using rule 127 (for_estructure -> for_iterator .)
    INT             reduce using rule 127 (for_estructure -> for_iterator .)
    FLOAT           reduce using rule 127 (for_estructure -> for_iterator .)
    $end            reduce using rule 127 (for_estructure -> for_iterator .)
    RBRACE          reduce using rule 127 (for_estructure -> for_iterator .)
    CASE            reduce using rule 127 (for_estructure -> for_iterator .)
    DEFAULT         reduce using rule 127 (for_estructure -> for_iterator .)


state 48

    (131) switch_structure -> SWITCH . switch_expression LBRACE case_blocks RBRACE
    (132) switch_expression -> . VARIABLE SHORTASSIGN value
    (133) switch_expression -> . empty
    (138) empty -> .

    VARIABLE        shift and go to state 115
    LBRACE          reduce using rule 138 (empty -> .)

    switch_expression              shift and go to state 114
    empty                          shift and go to state 116

state 49

    (67) not_variable_value -> number .

    PLUS            reduce using rule 67 (not_variable_value -> number .)
    MINUS           reduce using rule 67 (not_variable_value -> number .)
    TIMES           reduce using rule 67 (not_variable_value -> number .)
    DIVIDE          reduce using rule 67 (not_variable_value -> number .)
    ASSIGN          reduce using rule 67 (not_variable_value -> number .)
    INCREMENT       reduce using rule 67 (not_variable_value -> number .)
    DECREMENT       reduce using rule 67 (not_variable_value -> number .)
    RPAREN          reduce using rule 67 (not_variable_value -> number .)
    LBRACKET        reduce using rule 67 (not_variable_value -> number .)
    PERIOD          reduce using rule 67 (not_variable_value -> number .)
    SEMICOLON       reduce using rule 67 (not_variable_value -> number .)
    PRINT           reduce using rule 67 (not_variable_value -> number .)
    PRINTF          reduce using rule 67 (not_variable_value -> number .)
    INPUT           reduce using rule 67 (not_variable_value -> number .)
    LPAREN          reduce using rule 67 (not_variable_value -> number .)
    FUNCTION        reduce using rule 67 (not_variable_value -> number .)
    VAR             reduce using rule 67 (not_variable_value -> number .)
    VARIABLE        reduce using rule 67 (not_variable_value -> number .)
    CONST           reduce using rule 67 (not_variable_value -> number .)
    RETURN          reduce using rule 67 (not_variable_value -> number .)
    TYPE            reduce using rule 67 (not_variable_value -> number .)
    IF              reduce using rule 67 (not_variable_value -> number .)
    SWITCH          reduce using rule 67 (not_variable_value -> number .)
    CHARSTRING      reduce using rule 67 (not_variable_value -> number .)
    FOR             reduce using rule 67 (not_variable_value -> number .)
    INT             reduce using rule 67 (not_variable_value -> number .)
    FLOAT           reduce using rule 67 (not_variable_value -> number .)
    $end            reduce using rule 67 (not_variable_value -> number .)
    RBRACE          reduce using rule 67 (not_variable_value -> number .)
    CASE            reduce using rule 67 (not_variable_value -> number .)
    DEFAULT         reduce using rule 67 (not_variable_value -> number .)
    GREATER         reduce using rule 67 (not_variable_value -> number .)
    LESS            reduce using rule 67 (not_variable_value -> number .)
    GREATEREQUALS   reduce using rule 67 (not_variable_value -> number .)
    LESSEQUALS      reduce using rule 67 (not_variable_value -> number .)
    EQUALS          reduce using rule 67 (not_variable_value -> number .)
    DIFFERENT       reduce using rule 67 (not_variable_value -> number .)
    RBRACKET        reduce using rule 67 (not_variable_value -> number .)
    COMMA           reduce using rule 67 (not_variable_value -> number .)
    AND             reduce using rule 67 (not_variable_value -> number .)
    OR              reduce using rule 67 (not_variable_value -> number .)
    NOT             reduce using rule 67 (not_variable_value -> number .)
    LBRACE          reduce using rule 67 (not_variable_value -> number .)
    COLON           reduce using rule 67 (not_variable_value -> number .)


state 50

    (128) for_initialization -> FOR . VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> FOR . LBRACE statement RBRACE
    (130) for_iterator -> FOR . VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 117
    LBRACE          shift and go to state 118


state 51

    (69) number -> FLOAT .

    PLUS            reduce using rule 69 (number -> FLOAT .)
    MINUS           reduce using rule 69 (number -> FLOAT .)
    TIMES           reduce using rule 69 (number -> FLOAT .)
    DIVIDE          reduce using rule 69 (number -> FLOAT .)
    ASSIGN          reduce using rule 69 (number -> FLOAT .)
    INCREMENT       reduce using rule 69 (number -> FLOAT .)
    DECREMENT       reduce using rule 69 (number -> FLOAT .)
    RPAREN          reduce using rule 69 (number -> FLOAT .)
    LBRACKET        reduce using rule 69 (number -> FLOAT .)
    PERIOD          reduce using rule 69 (number -> FLOAT .)
    SEMICOLON       reduce using rule 69 (number -> FLOAT .)
    PRINT           reduce using rule 69 (number -> FLOAT .)
    PRINTF          reduce using rule 69 (number -> FLOAT .)
    INPUT           reduce using rule 69 (number -> FLOAT .)
    LPAREN          reduce using rule 69 (number -> FLOAT .)
    FUNCTION        reduce using rule 69 (number -> FLOAT .)
    VAR             reduce using rule 69 (number -> FLOAT .)
    VARIABLE        reduce using rule 69 (number -> FLOAT .)
    CONST           reduce using rule 69 (number -> FLOAT .)
    RETURN          reduce using rule 69 (number -> FLOAT .)
    TYPE            reduce using rule 69 (number -> FLOAT .)
    IF              reduce using rule 69 (number -> FLOAT .)
    SWITCH          reduce using rule 69 (number -> FLOAT .)
    CHARSTRING      reduce using rule 69 (number -> FLOAT .)
    FOR             reduce using rule 69 (number -> FLOAT .)
    INT             reduce using rule 69 (number -> FLOAT .)
    FLOAT           reduce using rule 69 (number -> FLOAT .)
    $end            reduce using rule 69 (number -> FLOAT .)
    RBRACE          reduce using rule 69 (number -> FLOAT .)
    CASE            reduce using rule 69 (number -> FLOAT .)
    DEFAULT         reduce using rule 69 (number -> FLOAT .)
    GREATER         reduce using rule 69 (number -> FLOAT .)
    LESS            reduce using rule 69 (number -> FLOAT .)
    GREATEREQUALS   reduce using rule 69 (number -> FLOAT .)
    LESSEQUALS      reduce using rule 69 (number -> FLOAT .)
    EQUALS          reduce using rule 69 (number -> FLOAT .)
    DIFFERENT       reduce using rule 69 (number -> FLOAT .)
    RBRACKET        reduce using rule 69 (number -> FLOAT .)
    COMMA           reduce using rule 69 (number -> FLOAT .)
    AND             reduce using rule 69 (number -> FLOAT .)
    OR              reduce using rule 69 (number -> FLOAT .)
    NOT             reduce using rule 69 (number -> FLOAT .)
    LBRACE          reduce using rule 69 (number -> FLOAT .)
    COLON           reduce using rule 69 (number -> FLOAT .)


state 52

    (2) statement -> import blocks .

    $end            reduce using rule 2 (statement -> import blocks .)
    RBRACE          reduce using rule 2 (statement -> import blocks .)
    CASE            reduce using rule 2 (statement -> import blocks .)
    DEFAULT         reduce using rule 2 (statement -> import blocks .)


state 53

    (7) statement -> import main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 119


state 54

    (3) statement -> package blocks .

    $end            reduce using rule 3 (statement -> package blocks .)
    RBRACE          reduce using rule 3 (statement -> package blocks .)
    CASE            reduce using rule 3 (statement -> package blocks .)
    DEFAULT         reduce using rule 3 (statement -> package blocks .)


state 55

    (4) statement -> package import . blocks
    (8) statement -> package import . main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    blocks                         shift and go to state 120
    main                           shift and go to state 121
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 56

    (6) statement -> package main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 122


state 57

    (5) statement -> main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 60
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    blocks                         shift and go to state 123
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 58

    (18) blocks -> block blocks .

    $end            reduce using rule 18 (blocks -> block blocks .)
    RBRACE          reduce using rule 18 (blocks -> block blocks .)
    CASE            reduce using rule 18 (blocks -> block blocks .)
    DEFAULT         reduce using rule 18 (blocks -> block blocks .)


state 59

    (19) blocks -> block SEMICOLON . blocks
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 60
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    block                          shift and go to state 6
    blocks                         shift and go to state 124
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 60

    (51) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE

    VARIABLE        shift and go to state 90


state 61

    (10) import -> IMPORT CHARSTRING .

    FUNCTION        reduce using rule 10 (import -> IMPORT CHARSTRING .)
    PRINT           reduce using rule 10 (import -> IMPORT CHARSTRING .)
    PRINTF          reduce using rule 10 (import -> IMPORT CHARSTRING .)
    INPUT           reduce using rule 10 (import -> IMPORT CHARSTRING .)
    LPAREN          reduce using rule 10 (import -> IMPORT CHARSTRING .)
    VAR             reduce using rule 10 (import -> IMPORT CHARSTRING .)
    VARIABLE        reduce using rule 10 (import -> IMPORT CHARSTRING .)
    CONST           reduce using rule 10 (import -> IMPORT CHARSTRING .)
    RETURN          reduce using rule 10 (import -> IMPORT CHARSTRING .)
    TYPE            reduce using rule 10 (import -> IMPORT CHARSTRING .)
    IF              reduce using rule 10 (import -> IMPORT CHARSTRING .)
    SWITCH          reduce using rule 10 (import -> IMPORT CHARSTRING .)
    CHARSTRING      reduce using rule 10 (import -> IMPORT CHARSTRING .)
    FOR             reduce using rule 10 (import -> IMPORT CHARSTRING .)
    INT             reduce using rule 10 (import -> IMPORT CHARSTRING .)
    FLOAT           reduce using rule 10 (import -> IMPORT CHARSTRING .)


state 62

    (11) import -> IMPORT LPAREN . values_for_import RPAREN
    (12) values_for_import -> . CHARSTRING
    (13) values_for_import -> . CHARSTRING values_for_import

    CHARSTRING      shift and go to state 126

    values_for_import              shift and go to state 125

state 63

    (79) operation -> LPAREN value . RPAREN operator value
    (80) operation -> LPAREN value . operator value RPAREN
    (82) operation -> LPAREN value . operator operation RPAREN
    (83) operation -> LPAREN value . RPAREN operator operation
    (86) operator -> . PLUS
    (87) operator -> . MINUS
    (88) operator -> . TIMES
    (89) operator -> . DIVIDE
    (90) operator -> . ASSIGN

    RPAREN          shift and go to state 127
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97
    TIMES           shift and go to state 98
    DIVIDE          shift and go to state 99
    ASSIGN          shift and go to state 100

    operator                       shift and go to state 128

state 64

    (62) value -> VARIABLE .
    (63) value -> VARIABLE . LBRACKET RBRACKET
    (64) value -> VARIABLE . LBRACKET value RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    RPAREN          reduce using rule 62 (value -> VARIABLE .)
    PLUS            reduce using rule 62 (value -> VARIABLE .)
    MINUS           reduce using rule 62 (value -> VARIABLE .)
    TIMES           reduce using rule 62 (value -> VARIABLE .)
    DIVIDE          reduce using rule 62 (value -> VARIABLE .)
    ASSIGN          reduce using rule 62 (value -> VARIABLE .)
    PERIOD          reduce using rule 62 (value -> VARIABLE .)
    SEMICOLON       reduce using rule 62 (value -> VARIABLE .)
    PRINT           reduce using rule 62 (value -> VARIABLE .)
    PRINTF          reduce using rule 62 (value -> VARIABLE .)
    INPUT           reduce using rule 62 (value -> VARIABLE .)
    LPAREN          reduce using rule 62 (value -> VARIABLE .)
    FUNCTION        reduce using rule 62 (value -> VARIABLE .)
    VAR             reduce using rule 62 (value -> VARIABLE .)
    VARIABLE        reduce using rule 62 (value -> VARIABLE .)
    CONST           reduce using rule 62 (value -> VARIABLE .)
    RETURN          reduce using rule 62 (value -> VARIABLE .)
    TYPE            reduce using rule 62 (value -> VARIABLE .)
    IF              reduce using rule 62 (value -> VARIABLE .)
    SWITCH          reduce using rule 62 (value -> VARIABLE .)
    CHARSTRING      reduce using rule 62 (value -> VARIABLE .)
    FOR             reduce using rule 62 (value -> VARIABLE .)
    INT             reduce using rule 62 (value -> VARIABLE .)
    FLOAT           reduce using rule 62 (value -> VARIABLE .)
    $end            reduce using rule 62 (value -> VARIABLE .)
    RBRACE          reduce using rule 62 (value -> VARIABLE .)
    CASE            reduce using rule 62 (value -> VARIABLE .)
    DEFAULT         reduce using rule 62 (value -> VARIABLE .)
    GREATER         reduce using rule 62 (value -> VARIABLE .)
    LESS            reduce using rule 62 (value -> VARIABLE .)
    GREATEREQUALS   reduce using rule 62 (value -> VARIABLE .)
    LESSEQUALS      reduce using rule 62 (value -> VARIABLE .)
    EQUALS          reduce using rule 62 (value -> VARIABLE .)
    DIFFERENT       reduce using rule 62 (value -> VARIABLE .)
    INCREMENT       reduce using rule 62 (value -> VARIABLE .)
    DECREMENT       reduce using rule 62 (value -> VARIABLE .)
    RBRACKET        reduce using rule 62 (value -> VARIABLE .)
    COMMA           reduce using rule 62 (value -> VARIABLE .)
    AND             reduce using rule 62 (value -> VARIABLE .)
    OR              reduce using rule 62 (value -> VARIABLE .)
    NOT             reduce using rule 62 (value -> VARIABLE .)
    LBRACE          reduce using rule 62 (value -> VARIABLE .)
    COLON           reduce using rule 62 (value -> VARIABLE .)
    LBRACKET        shift and go to state 129

  ! LBRACKET        [ reduce using rule 62 (value -> VARIABLE .) ]


state 65

    (14) package -> PACKAGE VARIABLE .

    IMPORT          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    FUNCTION        reduce using rule 14 (package -> PACKAGE VARIABLE .)
    PRINT           reduce using rule 14 (package -> PACKAGE VARIABLE .)
    PRINTF          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    INPUT           reduce using rule 14 (package -> PACKAGE VARIABLE .)
    LPAREN          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    VAR             reduce using rule 14 (package -> PACKAGE VARIABLE .)
    VARIABLE        reduce using rule 14 (package -> PACKAGE VARIABLE .)
    CONST           reduce using rule 14 (package -> PACKAGE VARIABLE .)
    RETURN          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    TYPE            reduce using rule 14 (package -> PACKAGE VARIABLE .)
    IF              reduce using rule 14 (package -> PACKAGE VARIABLE .)
    SWITCH          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    CHARSTRING      reduce using rule 14 (package -> PACKAGE VARIABLE .)
    FOR             reduce using rule 14 (package -> PACKAGE VARIABLE .)
    INT             reduce using rule 14 (package -> PACKAGE VARIABLE .)
    FLOAT           reduce using rule 14 (package -> PACKAGE VARIABLE .)


state 66

    (15) package -> PACKAGE MAIN .

    IMPORT          reduce using rule 15 (package -> PACKAGE MAIN .)
    FUNCTION        reduce using rule 15 (package -> PACKAGE MAIN .)
    PRINT           reduce using rule 15 (package -> PACKAGE MAIN .)
    PRINTF          reduce using rule 15 (package -> PACKAGE MAIN .)
    INPUT           reduce using rule 15 (package -> PACKAGE MAIN .)
    LPAREN          reduce using rule 15 (package -> PACKAGE MAIN .)
    VAR             reduce using rule 15 (package -> PACKAGE MAIN .)
    VARIABLE        reduce using rule 15 (package -> PACKAGE MAIN .)
    CONST           reduce using rule 15 (package -> PACKAGE MAIN .)
    RETURN          reduce using rule 15 (package -> PACKAGE MAIN .)
    TYPE            reduce using rule 15 (package -> PACKAGE MAIN .)
    IF              reduce using rule 15 (package -> PACKAGE MAIN .)
    SWITCH          reduce using rule 15 (package -> PACKAGE MAIN .)
    CHARSTRING      reduce using rule 15 (package -> PACKAGE MAIN .)
    FOR             reduce using rule 15 (package -> PACKAGE MAIN .)
    INT             reduce using rule 15 (package -> PACKAGE MAIN .)
    FLOAT           reduce using rule 15 (package -> PACKAGE MAIN .)


state 67

    (32) variable_declaration -> VARIABLE SHORTASSIGN . value
    (33) variable_declaration -> VARIABLE SHORTASSIGN . operation
    (151) map_structure -> VARIABLE SHORTASSIGN . MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> VARIABLE SHORTASSIGN . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> VARIABLE SHORTASSIGN . LBRACKET RBRACKET type LBRACE values RBRACE
    (159) slice_structure -> VARIABLE SHORTASSIGN . LBRACKET RBRACKET type
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    MAP             shift and go to state 132
    MAKE            shift and go to state 134
    LBRACKET        shift and go to state 133
    VARIABLE        shift and go to state 64
    LPAREN          shift and go to state 9
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 130
    operation                      shift and go to state 131
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 68

    (37) variable_assignation -> VARIABLE assignation . value
    (38) variable_assignation -> VARIABLE assignation . operation
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    LPAREN          shift and go to state 9
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 135
    operation                      shift and go to state 136
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 69

    (39) variable_assignation -> VARIABLE double_operator .

    SEMICOLON       reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    PRINT           reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    PRINTF          reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    INPUT           reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    LPAREN          reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    FUNCTION        reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    VAR             reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    VARIABLE        reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    CONST           reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    RETURN          reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    TYPE            reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    IF              reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    SWITCH          reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    CHARSTRING      reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    FOR             reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    INT             reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    FLOAT           reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    $end            reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    RBRACE          reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    CASE            reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)
    DEFAULT         reduce using rule 39 (variable_assignation -> VARIABLE double_operator .)


state 70

    (63) value -> VARIABLE LBRACKET . RBRACKET
    (64) value -> VARIABLE LBRACKET . value RBRACKET
    (156) map_assign -> VARIABLE LBRACKET . value RBRACKET ASSIGN value
    (150) array_assign -> VARIABLE LBRACKET . INT RBRACKET ASSIGN value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    RBRACKET        shift and go to state 137
    INT             shift and go to state 139
    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    FLOAT           shift and go to state 51

    value                          shift and go to state 138
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 71

    (95) parameter -> VARIABLE type .

    COMMA           reduce using rule 95 (parameter -> VARIABLE type .)
    SEMICOLON       reduce using rule 95 (parameter -> VARIABLE type .)
    PRINT           reduce using rule 95 (parameter -> VARIABLE type .)
    PRINTF          reduce using rule 95 (parameter -> VARIABLE type .)
    INPUT           reduce using rule 95 (parameter -> VARIABLE type .)
    LPAREN          reduce using rule 95 (parameter -> VARIABLE type .)
    FUNCTION        reduce using rule 95 (parameter -> VARIABLE type .)
    VAR             reduce using rule 95 (parameter -> VARIABLE type .)
    VARIABLE        reduce using rule 95 (parameter -> VARIABLE type .)
    CONST           reduce using rule 95 (parameter -> VARIABLE type .)
    RETURN          reduce using rule 95 (parameter -> VARIABLE type .)
    TYPE            reduce using rule 95 (parameter -> VARIABLE type .)
    IF              reduce using rule 95 (parameter -> VARIABLE type .)
    SWITCH          reduce using rule 95 (parameter -> VARIABLE type .)
    CHARSTRING      reduce using rule 95 (parameter -> VARIABLE type .)
    FOR             reduce using rule 95 (parameter -> VARIABLE type .)
    INT             reduce using rule 95 (parameter -> VARIABLE type .)
    FLOAT           reduce using rule 95 (parameter -> VARIABLE type .)
    $end            reduce using rule 95 (parameter -> VARIABLE type .)
    RBRACE          reduce using rule 95 (parameter -> VARIABLE type .)
    CASE            reduce using rule 95 (parameter -> VARIABLE type .)
    DEFAULT         reduce using rule 95 (parameter -> VARIABLE type .)
    RPAREN          reduce using rule 95 (parameter -> VARIABLE type .)


state 72

    (160) slice_structure -> VARIABLE ASSIGN . append_statement
    (45) assignation -> ASSIGN .
    (161) append_statement -> . APPEND LPAREN VARIABLE COMMA values RPAREN
    (162) append_statement -> . APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN

    VARIABLE        reduce using rule 45 (assignation -> ASSIGN .)
    LPAREN          reduce using rule 45 (assignation -> ASSIGN .)
    CHARSTRING      reduce using rule 45 (assignation -> ASSIGN .)
    INT             reduce using rule 45 (assignation -> ASSIGN .)
    FLOAT           reduce using rule 45 (assignation -> ASSIGN .)
    APPEND          shift and go to state 141

    append_statement               shift and go to state 140

state 73

    (44) variables -> VARIABLE COMMA . variables
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables

    VARIABLE        shift and go to state 142

    variables                      shift and go to state 143

state 74

    (96) type -> INT .

    COMMA           reduce using rule 96 (type -> INT .)
    SEMICOLON       reduce using rule 96 (type -> INT .)
    PRINT           reduce using rule 96 (type -> INT .)
    PRINTF          reduce using rule 96 (type -> INT .)
    INPUT           reduce using rule 96 (type -> INT .)
    LPAREN          reduce using rule 96 (type -> INT .)
    FUNCTION        reduce using rule 96 (type -> INT .)
    VAR             reduce using rule 96 (type -> INT .)
    VARIABLE        reduce using rule 96 (type -> INT .)
    CONST           reduce using rule 96 (type -> INT .)
    RETURN          reduce using rule 96 (type -> INT .)
    TYPE            reduce using rule 96 (type -> INT .)
    IF              reduce using rule 96 (type -> INT .)
    SWITCH          reduce using rule 96 (type -> INT .)
    CHARSTRING      reduce using rule 96 (type -> INT .)
    FOR             reduce using rule 96 (type -> INT .)
    INT             reduce using rule 96 (type -> INT .)
    FLOAT           reduce using rule 96 (type -> INT .)
    $end            reduce using rule 96 (type -> INT .)
    RBRACE          reduce using rule 96 (type -> INT .)
    CASE            reduce using rule 96 (type -> INT .)
    DEFAULT         reduce using rule 96 (type -> INT .)
    ASSIGN          reduce using rule 96 (type -> INT .)
    RPAREN          reduce using rule 96 (type -> INT .)
    RBRACKET        reduce using rule 96 (type -> INT .)
    LBRACE          reduce using rule 96 (type -> INT .)


state 75

    (46) assignation -> PLUSASSIGN .

    VARIABLE        reduce using rule 46 (assignation -> PLUSASSIGN .)
    LPAREN          reduce using rule 46 (assignation -> PLUSASSIGN .)
    CHARSTRING      reduce using rule 46 (assignation -> PLUSASSIGN .)
    INT             reduce using rule 46 (assignation -> PLUSASSIGN .)
    FLOAT           reduce using rule 46 (assignation -> PLUSASSIGN .)


state 76

    (47) assignation -> MINUSASSIGN .

    VARIABLE        reduce using rule 47 (assignation -> MINUSASSIGN .)
    LPAREN          reduce using rule 47 (assignation -> MINUSASSIGN .)
    CHARSTRING      reduce using rule 47 (assignation -> MINUSASSIGN .)
    INT             reduce using rule 47 (assignation -> MINUSASSIGN .)
    FLOAT           reduce using rule 47 (assignation -> MINUSASSIGN .)


state 77

    (48) assignation -> TIMESASSIGN .

    VARIABLE        reduce using rule 48 (assignation -> TIMESASSIGN .)
    LPAREN          reduce using rule 48 (assignation -> TIMESASSIGN .)
    CHARSTRING      reduce using rule 48 (assignation -> TIMESASSIGN .)
    INT             reduce using rule 48 (assignation -> TIMESASSIGN .)
    FLOAT           reduce using rule 48 (assignation -> TIMESASSIGN .)


state 78

    (49) assignation -> DIVIDEASSIGN .

    VARIABLE        reduce using rule 49 (assignation -> DIVIDEASSIGN .)
    LPAREN          reduce using rule 49 (assignation -> DIVIDEASSIGN .)
    CHARSTRING      reduce using rule 49 (assignation -> DIVIDEASSIGN .)
    INT             reduce using rule 49 (assignation -> DIVIDEASSIGN .)
    FLOAT           reduce using rule 49 (assignation -> DIVIDEASSIGN .)


state 79

    (50) assignation -> MODASSIGN .

    VARIABLE        reduce using rule 50 (assignation -> MODASSIGN .)
    LPAREN          reduce using rule 50 (assignation -> MODASSIGN .)
    CHARSTRING      reduce using rule 50 (assignation -> MODASSIGN .)
    INT             reduce using rule 50 (assignation -> MODASSIGN .)
    FLOAT           reduce using rule 50 (assignation -> MODASSIGN .)


state 80

    (91) double_operator -> INCREMENT .

    SEMICOLON       reduce using rule 91 (double_operator -> INCREMENT .)
    PRINT           reduce using rule 91 (double_operator -> INCREMENT .)
    PRINTF          reduce using rule 91 (double_operator -> INCREMENT .)
    INPUT           reduce using rule 91 (double_operator -> INCREMENT .)
    LPAREN          reduce using rule 91 (double_operator -> INCREMENT .)
    FUNCTION        reduce using rule 91 (double_operator -> INCREMENT .)
    VAR             reduce using rule 91 (double_operator -> INCREMENT .)
    VARIABLE        reduce using rule 91 (double_operator -> INCREMENT .)
    CONST           reduce using rule 91 (double_operator -> INCREMENT .)
    RETURN          reduce using rule 91 (double_operator -> INCREMENT .)
    TYPE            reduce using rule 91 (double_operator -> INCREMENT .)
    IF              reduce using rule 91 (double_operator -> INCREMENT .)
    SWITCH          reduce using rule 91 (double_operator -> INCREMENT .)
    CHARSTRING      reduce using rule 91 (double_operator -> INCREMENT .)
    FOR             reduce using rule 91 (double_operator -> INCREMENT .)
    INT             reduce using rule 91 (double_operator -> INCREMENT .)
    FLOAT           reduce using rule 91 (double_operator -> INCREMENT .)
    $end            reduce using rule 91 (double_operator -> INCREMENT .)
    RBRACE          reduce using rule 91 (double_operator -> INCREMENT .)
    CASE            reduce using rule 91 (double_operator -> INCREMENT .)
    DEFAULT         reduce using rule 91 (double_operator -> INCREMENT .)
    RPAREN          reduce using rule 91 (double_operator -> INCREMENT .)
    LBRACE          reduce using rule 91 (double_operator -> INCREMENT .)


state 81

    (92) double_operator -> DECREMENT .

    SEMICOLON       reduce using rule 92 (double_operator -> DECREMENT .)
    PRINT           reduce using rule 92 (double_operator -> DECREMENT .)
    PRINTF          reduce using rule 92 (double_operator -> DECREMENT .)
    INPUT           reduce using rule 92 (double_operator -> DECREMENT .)
    LPAREN          reduce using rule 92 (double_operator -> DECREMENT .)
    FUNCTION        reduce using rule 92 (double_operator -> DECREMENT .)
    VAR             reduce using rule 92 (double_operator -> DECREMENT .)
    VARIABLE        reduce using rule 92 (double_operator -> DECREMENT .)
    CONST           reduce using rule 92 (double_operator -> DECREMENT .)
    RETURN          reduce using rule 92 (double_operator -> DECREMENT .)
    TYPE            reduce using rule 92 (double_operator -> DECREMENT .)
    IF              reduce using rule 92 (double_operator -> DECREMENT .)
    SWITCH          reduce using rule 92 (double_operator -> DECREMENT .)
    CHARSTRING      reduce using rule 92 (double_operator -> DECREMENT .)
    FOR             reduce using rule 92 (double_operator -> DECREMENT .)
    INT             reduce using rule 92 (double_operator -> DECREMENT .)
    FLOAT           reduce using rule 92 (double_operator -> DECREMENT .)
    $end            reduce using rule 92 (double_operator -> DECREMENT .)
    RBRACE          reduce using rule 92 (double_operator -> DECREMENT .)
    CASE            reduce using rule 92 (double_operator -> DECREMENT .)
    DEFAULT         reduce using rule 92 (double_operator -> DECREMENT .)
    RPAREN          reduce using rule 92 (double_operator -> DECREMENT .)
    LBRACE          reduce using rule 92 (double_operator -> DECREMENT .)


state 82

    (97) type -> INT32 .

    COMMA           reduce using rule 97 (type -> INT32 .)
    SEMICOLON       reduce using rule 97 (type -> INT32 .)
    PRINT           reduce using rule 97 (type -> INT32 .)
    PRINTF          reduce using rule 97 (type -> INT32 .)
    INPUT           reduce using rule 97 (type -> INT32 .)
    LPAREN          reduce using rule 97 (type -> INT32 .)
    FUNCTION        reduce using rule 97 (type -> INT32 .)
    VAR             reduce using rule 97 (type -> INT32 .)
    VARIABLE        reduce using rule 97 (type -> INT32 .)
    CONST           reduce using rule 97 (type -> INT32 .)
    RETURN          reduce using rule 97 (type -> INT32 .)
    TYPE            reduce using rule 97 (type -> INT32 .)
    IF              reduce using rule 97 (type -> INT32 .)
    SWITCH          reduce using rule 97 (type -> INT32 .)
    CHARSTRING      reduce using rule 97 (type -> INT32 .)
    FOR             reduce using rule 97 (type -> INT32 .)
    INT             reduce using rule 97 (type -> INT32 .)
    FLOAT           reduce using rule 97 (type -> INT32 .)
    $end            reduce using rule 97 (type -> INT32 .)
    RBRACE          reduce using rule 97 (type -> INT32 .)
    CASE            reduce using rule 97 (type -> INT32 .)
    DEFAULT         reduce using rule 97 (type -> INT32 .)
    ASSIGN          reduce using rule 97 (type -> INT32 .)
    RPAREN          reduce using rule 97 (type -> INT32 .)
    RBRACKET        reduce using rule 97 (type -> INT32 .)
    LBRACE          reduce using rule 97 (type -> INT32 .)


state 83

    (98) type -> INT64 .

    COMMA           reduce using rule 98 (type -> INT64 .)
    SEMICOLON       reduce using rule 98 (type -> INT64 .)
    PRINT           reduce using rule 98 (type -> INT64 .)
    PRINTF          reduce using rule 98 (type -> INT64 .)
    INPUT           reduce using rule 98 (type -> INT64 .)
    LPAREN          reduce using rule 98 (type -> INT64 .)
    FUNCTION        reduce using rule 98 (type -> INT64 .)
    VAR             reduce using rule 98 (type -> INT64 .)
    VARIABLE        reduce using rule 98 (type -> INT64 .)
    CONST           reduce using rule 98 (type -> INT64 .)
    RETURN          reduce using rule 98 (type -> INT64 .)
    TYPE            reduce using rule 98 (type -> INT64 .)
    IF              reduce using rule 98 (type -> INT64 .)
    SWITCH          reduce using rule 98 (type -> INT64 .)
    CHARSTRING      reduce using rule 98 (type -> INT64 .)
    FOR             reduce using rule 98 (type -> INT64 .)
    INT             reduce using rule 98 (type -> INT64 .)
    FLOAT           reduce using rule 98 (type -> INT64 .)
    $end            reduce using rule 98 (type -> INT64 .)
    RBRACE          reduce using rule 98 (type -> INT64 .)
    CASE            reduce using rule 98 (type -> INT64 .)
    DEFAULT         reduce using rule 98 (type -> INT64 .)
    ASSIGN          reduce using rule 98 (type -> INT64 .)
    RPAREN          reduce using rule 98 (type -> INT64 .)
    RBRACKET        reduce using rule 98 (type -> INT64 .)
    LBRACE          reduce using rule 98 (type -> INT64 .)


state 84

    (99) type -> STRING .

    COMMA           reduce using rule 99 (type -> STRING .)
    SEMICOLON       reduce using rule 99 (type -> STRING .)
    PRINT           reduce using rule 99 (type -> STRING .)
    PRINTF          reduce using rule 99 (type -> STRING .)
    INPUT           reduce using rule 99 (type -> STRING .)
    LPAREN          reduce using rule 99 (type -> STRING .)
    FUNCTION        reduce using rule 99 (type -> STRING .)
    VAR             reduce using rule 99 (type -> STRING .)
    VARIABLE        reduce using rule 99 (type -> STRING .)
    CONST           reduce using rule 99 (type -> STRING .)
    RETURN          reduce using rule 99 (type -> STRING .)
    TYPE            reduce using rule 99 (type -> STRING .)
    IF              reduce using rule 99 (type -> STRING .)
    SWITCH          reduce using rule 99 (type -> STRING .)
    CHARSTRING      reduce using rule 99 (type -> STRING .)
    FOR             reduce using rule 99 (type -> STRING .)
    INT             reduce using rule 99 (type -> STRING .)
    FLOAT           reduce using rule 99 (type -> STRING .)
    $end            reduce using rule 99 (type -> STRING .)
    RBRACE          reduce using rule 99 (type -> STRING .)
    CASE            reduce using rule 99 (type -> STRING .)
    DEFAULT         reduce using rule 99 (type -> STRING .)
    ASSIGN          reduce using rule 99 (type -> STRING .)
    RPAREN          reduce using rule 99 (type -> STRING .)
    RBRACKET        reduce using rule 99 (type -> STRING .)
    LBRACE          reduce using rule 99 (type -> STRING .)


state 85

    (100) type -> FLOAT .

    COMMA           reduce using rule 100 (type -> FLOAT .)
    SEMICOLON       reduce using rule 100 (type -> FLOAT .)
    PRINT           reduce using rule 100 (type -> FLOAT .)
    PRINTF          reduce using rule 100 (type -> FLOAT .)
    INPUT           reduce using rule 100 (type -> FLOAT .)
    LPAREN          reduce using rule 100 (type -> FLOAT .)
    FUNCTION        reduce using rule 100 (type -> FLOAT .)
    VAR             reduce using rule 100 (type -> FLOAT .)
    VARIABLE        reduce using rule 100 (type -> FLOAT .)
    CONST           reduce using rule 100 (type -> FLOAT .)
    RETURN          reduce using rule 100 (type -> FLOAT .)
    TYPE            reduce using rule 100 (type -> FLOAT .)
    IF              reduce using rule 100 (type -> FLOAT .)
    SWITCH          reduce using rule 100 (type -> FLOAT .)
    CHARSTRING      reduce using rule 100 (type -> FLOAT .)
    FOR             reduce using rule 100 (type -> FLOAT .)
    INT             reduce using rule 100 (type -> FLOAT .)
    FLOAT           reduce using rule 100 (type -> FLOAT .)
    $end            reduce using rule 100 (type -> FLOAT .)
    RBRACE          reduce using rule 100 (type -> FLOAT .)
    CASE            reduce using rule 100 (type -> FLOAT .)
    DEFAULT         reduce using rule 100 (type -> FLOAT .)
    ASSIGN          reduce using rule 100 (type -> FLOAT .)
    RPAREN          reduce using rule 100 (type -> FLOAT .)
    RBRACKET        reduce using rule 100 (type -> FLOAT .)
    LBRACE          reduce using rule 100 (type -> FLOAT .)


state 86

    (101) type -> FLOAT32 .

    COMMA           reduce using rule 101 (type -> FLOAT32 .)
    SEMICOLON       reduce using rule 101 (type -> FLOAT32 .)
    PRINT           reduce using rule 101 (type -> FLOAT32 .)
    PRINTF          reduce using rule 101 (type -> FLOAT32 .)
    INPUT           reduce using rule 101 (type -> FLOAT32 .)
    LPAREN          reduce using rule 101 (type -> FLOAT32 .)
    FUNCTION        reduce using rule 101 (type -> FLOAT32 .)
    VAR             reduce using rule 101 (type -> FLOAT32 .)
    VARIABLE        reduce using rule 101 (type -> FLOAT32 .)
    CONST           reduce using rule 101 (type -> FLOAT32 .)
    RETURN          reduce using rule 101 (type -> FLOAT32 .)
    TYPE            reduce using rule 101 (type -> FLOAT32 .)
    IF              reduce using rule 101 (type -> FLOAT32 .)
    SWITCH          reduce using rule 101 (type -> FLOAT32 .)
    CHARSTRING      reduce using rule 101 (type -> FLOAT32 .)
    FOR             reduce using rule 101 (type -> FLOAT32 .)
    INT             reduce using rule 101 (type -> FLOAT32 .)
    FLOAT           reduce using rule 101 (type -> FLOAT32 .)
    $end            reduce using rule 101 (type -> FLOAT32 .)
    RBRACE          reduce using rule 101 (type -> FLOAT32 .)
    CASE            reduce using rule 101 (type -> FLOAT32 .)
    DEFAULT         reduce using rule 101 (type -> FLOAT32 .)
    ASSIGN          reduce using rule 101 (type -> FLOAT32 .)
    RPAREN          reduce using rule 101 (type -> FLOAT32 .)
    RBRACKET        reduce using rule 101 (type -> FLOAT32 .)
    LBRACE          reduce using rule 101 (type -> FLOAT32 .)


state 87

    (102) type -> FLOAT64 .

    COMMA           reduce using rule 102 (type -> FLOAT64 .)
    SEMICOLON       reduce using rule 102 (type -> FLOAT64 .)
    PRINT           reduce using rule 102 (type -> FLOAT64 .)
    PRINTF          reduce using rule 102 (type -> FLOAT64 .)
    INPUT           reduce using rule 102 (type -> FLOAT64 .)
    LPAREN          reduce using rule 102 (type -> FLOAT64 .)
    FUNCTION        reduce using rule 102 (type -> FLOAT64 .)
    VAR             reduce using rule 102 (type -> FLOAT64 .)
    VARIABLE        reduce using rule 102 (type -> FLOAT64 .)
    CONST           reduce using rule 102 (type -> FLOAT64 .)
    RETURN          reduce using rule 102 (type -> FLOAT64 .)
    TYPE            reduce using rule 102 (type -> FLOAT64 .)
    IF              reduce using rule 102 (type -> FLOAT64 .)
    SWITCH          reduce using rule 102 (type -> FLOAT64 .)
    CHARSTRING      reduce using rule 102 (type -> FLOAT64 .)
    FOR             reduce using rule 102 (type -> FLOAT64 .)
    INT             reduce using rule 102 (type -> FLOAT64 .)
    FLOAT           reduce using rule 102 (type -> FLOAT64 .)
    $end            reduce using rule 102 (type -> FLOAT64 .)
    RBRACE          reduce using rule 102 (type -> FLOAT64 .)
    CASE            reduce using rule 102 (type -> FLOAT64 .)
    DEFAULT         reduce using rule 102 (type -> FLOAT64 .)
    ASSIGN          reduce using rule 102 (type -> FLOAT64 .)
    RPAREN          reduce using rule 102 (type -> FLOAT64 .)
    RBRACKET        reduce using rule 102 (type -> FLOAT64 .)
    LBRACE          reduce using rule 102 (type -> FLOAT64 .)


state 88

    (103) type -> BOOL .

    COMMA           reduce using rule 103 (type -> BOOL .)
    SEMICOLON       reduce using rule 103 (type -> BOOL .)
    PRINT           reduce using rule 103 (type -> BOOL .)
    PRINTF          reduce using rule 103 (type -> BOOL .)
    INPUT           reduce using rule 103 (type -> BOOL .)
    LPAREN          reduce using rule 103 (type -> BOOL .)
    FUNCTION        reduce using rule 103 (type -> BOOL .)
    VAR             reduce using rule 103 (type -> BOOL .)
    VARIABLE        reduce using rule 103 (type -> BOOL .)
    CONST           reduce using rule 103 (type -> BOOL .)
    RETURN          reduce using rule 103 (type -> BOOL .)
    TYPE            reduce using rule 103 (type -> BOOL .)
    IF              reduce using rule 103 (type -> BOOL .)
    SWITCH          reduce using rule 103 (type -> BOOL .)
    CHARSTRING      reduce using rule 103 (type -> BOOL .)
    FOR             reduce using rule 103 (type -> BOOL .)
    INT             reduce using rule 103 (type -> BOOL .)
    FLOAT           reduce using rule 103 (type -> BOOL .)
    $end            reduce using rule 103 (type -> BOOL .)
    RBRACE          reduce using rule 103 (type -> BOOL .)
    CASE            reduce using rule 103 (type -> BOOL .)
    DEFAULT         reduce using rule 103 (type -> BOOL .)
    ASSIGN          reduce using rule 103 (type -> BOOL .)
    RPAREN          reduce using rule 103 (type -> BOOL .)
    RBRACKET        reduce using rule 103 (type -> BOOL .)
    LBRACE          reduce using rule 103 (type -> BOOL .)


state 89

    (16) main -> FUNCTION MAIN . LPAREN RPAREN

    LPAREN          shift and go to state 144


state 90

    (51) function -> FUNCTION VARIABLE . LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> FUNCTION VARIABLE . LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN type LBRACE blocks RBRACE

    LPAREN          shift and go to state 145


state 91

    (70) print_statement -> PRINT LPAREN . values RPAREN
    (72) print_statement -> PRINT LPAREN . operation RPAREN
    (73) print_statement -> PRINT LPAREN . RPAREN
    (60) values -> . value
    (61) values -> . value COMMA values
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    RPAREN          shift and go to state 147
    LPAREN          shift and go to state 9
    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    values                         shift and go to state 146
    operation                      shift and go to state 148
    value                          shift and go to state 149
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 92

    (71) print_statement -> PRINTF LPAREN . FORMATSTRING COMMA values RPAREN

    FORMATSTRING    shift and go to state 150


state 93

    (74) input_statement -> INPUT LPAREN . values RPAREN
    (75) input_statement -> INPUT LPAREN . operation RPAREN
    (76) input_statement -> INPUT LPAREN . RPAREN
    (60) values -> . value
    (61) values -> . value COMMA values
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    RPAREN          shift and go to state 152
    LPAREN          shift and go to state 9
    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    values                         shift and go to state 151
    operation                      shift and go to state 153
    value                          shift and go to state 149
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 94

    (77) operation -> value operator . value
    (78) operation -> value operator . LPAREN value RPAREN
    (81) operation -> value operator . operation
    (84) operation -> value operator . LPAREN operation RPAREN
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    LPAREN          shift and go to state 155
    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 154
    operation                      shift and go to state 156
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 95

    (85) operation -> value double_operator .

    SEMICOLON       reduce using rule 85 (operation -> value double_operator .)
    PRINT           reduce using rule 85 (operation -> value double_operator .)
    PRINTF          reduce using rule 85 (operation -> value double_operator .)
    INPUT           reduce using rule 85 (operation -> value double_operator .)
    LPAREN          reduce using rule 85 (operation -> value double_operator .)
    FUNCTION        reduce using rule 85 (operation -> value double_operator .)
    VAR             reduce using rule 85 (operation -> value double_operator .)
    VARIABLE        reduce using rule 85 (operation -> value double_operator .)
    CONST           reduce using rule 85 (operation -> value double_operator .)
    RETURN          reduce using rule 85 (operation -> value double_operator .)
    TYPE            reduce using rule 85 (operation -> value double_operator .)
    IF              reduce using rule 85 (operation -> value double_operator .)
    SWITCH          reduce using rule 85 (operation -> value double_operator .)
    CHARSTRING      reduce using rule 85 (operation -> value double_operator .)
    FOR             reduce using rule 85 (operation -> value double_operator .)
    INT             reduce using rule 85 (operation -> value double_operator .)
    FLOAT           reduce using rule 85 (operation -> value double_operator .)
    $end            reduce using rule 85 (operation -> value double_operator .)
    RBRACE          reduce using rule 85 (operation -> value double_operator .)
    CASE            reduce using rule 85 (operation -> value double_operator .)
    DEFAULT         reduce using rule 85 (operation -> value double_operator .)
    RPAREN          reduce using rule 85 (operation -> value double_operator .)


state 96

    (86) operator -> PLUS .

    LPAREN          reduce using rule 86 (operator -> PLUS .)
    VARIABLE        reduce using rule 86 (operator -> PLUS .)
    CHARSTRING      reduce using rule 86 (operator -> PLUS .)
    INT             reduce using rule 86 (operator -> PLUS .)
    FLOAT           reduce using rule 86 (operator -> PLUS .)


state 97

    (87) operator -> MINUS .

    LPAREN          reduce using rule 87 (operator -> MINUS .)
    VARIABLE        reduce using rule 87 (operator -> MINUS .)
    CHARSTRING      reduce using rule 87 (operator -> MINUS .)
    INT             reduce using rule 87 (operator -> MINUS .)
    FLOAT           reduce using rule 87 (operator -> MINUS .)


state 98

    (88) operator -> TIMES .

    LPAREN          reduce using rule 88 (operator -> TIMES .)
    VARIABLE        reduce using rule 88 (operator -> TIMES .)
    CHARSTRING      reduce using rule 88 (operator -> TIMES .)
    INT             reduce using rule 88 (operator -> TIMES .)
    FLOAT           reduce using rule 88 (operator -> TIMES .)


state 99

    (89) operator -> DIVIDE .

    LPAREN          reduce using rule 89 (operator -> DIVIDE .)
    VARIABLE        reduce using rule 89 (operator -> DIVIDE .)
    CHARSTRING      reduce using rule 89 (operator -> DIVIDE .)
    INT             reduce using rule 89 (operator -> DIVIDE .)
    FLOAT           reduce using rule 89 (operator -> DIVIDE .)


state 100

    (90) operator -> ASSIGN .

    LPAREN          reduce using rule 90 (operator -> ASSIGN .)
    VARIABLE        reduce using rule 90 (operator -> ASSIGN .)
    CHARSTRING      reduce using rule 90 (operator -> ASSIGN .)
    INT             reduce using rule 90 (operator -> ASSIGN .)
    FLOAT           reduce using rule 90 (operator -> ASSIGN .)


state 101

    (94) parameters -> parameter COMMA . parameters
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (95) parameter -> . VARIABLE type

    VARIABLE        shift and go to state 158

    parameter                      shift and go to state 34
    parameters                     shift and go to state 157

state 102

    (30) variable_declaration -> VAR VARIABLE . type
    (31) variable_declaration -> VAR VARIABLE . type ASSIGN value
    (147) array_structure -> VAR VARIABLE . LBRACKET INT RBRACKET type
    (148) array_structure -> VAR VARIABLE . ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> VAR VARIABLE . LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (158) slice_structure -> VAR VARIABLE . LBRACKET RBRACKET type
    (43) variables -> VARIABLE .
    (44) variables -> VARIABLE . COMMA variables
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for INT32 resolved as shift
  ! shift/reduce conflict for INT64 resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for FLOAT32 resolved as shift
  ! shift/reduce conflict for FLOAT64 resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
    LBRACKET        shift and go to state 161
    ASSIGN          shift and go to state 160
    COMMA           shift and go to state 73
    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

  ! INT             [ reduce using rule 43 (variables -> VARIABLE .) ]
  ! INT32           [ reduce using rule 43 (variables -> VARIABLE .) ]
  ! INT64           [ reduce using rule 43 (variables -> VARIABLE .) ]
  ! STRING          [ reduce using rule 43 (variables -> VARIABLE .) ]
  ! FLOAT           [ reduce using rule 43 (variables -> VARIABLE .) ]
  ! FLOAT32         [ reduce using rule 43 (variables -> VARIABLE .) ]
  ! FLOAT64         [ reduce using rule 43 (variables -> VARIABLE .) ]
  ! BOOL            [ reduce using rule 43 (variables -> VARIABLE .) ]

    type                           shift and go to state 159

state 103

    (34) variable_declaration -> VAR variables . type
    (35) variable_declaration -> VAR variables . type ASSIGN value
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

    type                           shift and go to state 162

state 104

    (40) variable_assignation -> variables assignation . value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 163
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 105

    (45) assignation -> ASSIGN .

    VARIABLE        reduce using rule 45 (assignation -> ASSIGN .)
    CHARSTRING      reduce using rule 45 (assignation -> ASSIGN .)
    INT             reduce using rule 45 (assignation -> ASSIGN .)
    FLOAT           reduce using rule 45 (assignation -> ASSIGN .)


state 106

    (36) variable_declaration -> CONST VARIABLE . ASSIGN value

    ASSIGN          shift and go to state 164


state 107

    (55) return -> RETURN value .
    (56) return -> RETURN value . LBRACKET value RBRACKET
    (57) return -> RETURN value . PERIOD value

    SEMICOLON       reduce using rule 55 (return -> RETURN value .)
    PRINT           reduce using rule 55 (return -> RETURN value .)
    PRINTF          reduce using rule 55 (return -> RETURN value .)
    INPUT           reduce using rule 55 (return -> RETURN value .)
    LPAREN          reduce using rule 55 (return -> RETURN value .)
    FUNCTION        reduce using rule 55 (return -> RETURN value .)
    VAR             reduce using rule 55 (return -> RETURN value .)
    VARIABLE        reduce using rule 55 (return -> RETURN value .)
    CONST           reduce using rule 55 (return -> RETURN value .)
    RETURN          reduce using rule 55 (return -> RETURN value .)
    TYPE            reduce using rule 55 (return -> RETURN value .)
    IF              reduce using rule 55 (return -> RETURN value .)
    SWITCH          reduce using rule 55 (return -> RETURN value .)
    CHARSTRING      reduce using rule 55 (return -> RETURN value .)
    FOR             reduce using rule 55 (return -> RETURN value .)
    INT             reduce using rule 55 (return -> RETURN value .)
    FLOAT           reduce using rule 55 (return -> RETURN value .)
    $end            reduce using rule 55 (return -> RETURN value .)
    RBRACE          reduce using rule 55 (return -> RETURN value .)
    CASE            reduce using rule 55 (return -> RETURN value .)
    DEFAULT         reduce using rule 55 (return -> RETURN value .)
    LBRACKET        shift and go to state 165
    PERIOD          shift and go to state 166


state 108

    (58) return -> RETURN TRUE .

    SEMICOLON       reduce using rule 58 (return -> RETURN TRUE .)
    PRINT           reduce using rule 58 (return -> RETURN TRUE .)
    PRINTF          reduce using rule 58 (return -> RETURN TRUE .)
    INPUT           reduce using rule 58 (return -> RETURN TRUE .)
    LPAREN          reduce using rule 58 (return -> RETURN TRUE .)
    FUNCTION        reduce using rule 58 (return -> RETURN TRUE .)
    VAR             reduce using rule 58 (return -> RETURN TRUE .)
    VARIABLE        reduce using rule 58 (return -> RETURN TRUE .)
    CONST           reduce using rule 58 (return -> RETURN TRUE .)
    RETURN          reduce using rule 58 (return -> RETURN TRUE .)
    TYPE            reduce using rule 58 (return -> RETURN TRUE .)
    IF              reduce using rule 58 (return -> RETURN TRUE .)
    SWITCH          reduce using rule 58 (return -> RETURN TRUE .)
    CHARSTRING      reduce using rule 58 (return -> RETURN TRUE .)
    FOR             reduce using rule 58 (return -> RETURN TRUE .)
    INT             reduce using rule 58 (return -> RETURN TRUE .)
    FLOAT           reduce using rule 58 (return -> RETURN TRUE .)
    $end            reduce using rule 58 (return -> RETURN TRUE .)
    RBRACE          reduce using rule 58 (return -> RETURN TRUE .)
    CASE            reduce using rule 58 (return -> RETURN TRUE .)
    DEFAULT         reduce using rule 58 (return -> RETURN TRUE .)


state 109

    (59) return -> RETURN FALSE .

    SEMICOLON       reduce using rule 59 (return -> RETURN FALSE .)
    PRINT           reduce using rule 59 (return -> RETURN FALSE .)
    PRINTF          reduce using rule 59 (return -> RETURN FALSE .)
    INPUT           reduce using rule 59 (return -> RETURN FALSE .)
    LPAREN          reduce using rule 59 (return -> RETURN FALSE .)
    FUNCTION        reduce using rule 59 (return -> RETURN FALSE .)
    VAR             reduce using rule 59 (return -> RETURN FALSE .)
    VARIABLE        reduce using rule 59 (return -> RETURN FALSE .)
    CONST           reduce using rule 59 (return -> RETURN FALSE .)
    RETURN          reduce using rule 59 (return -> RETURN FALSE .)
    TYPE            reduce using rule 59 (return -> RETURN FALSE .)
    IF              reduce using rule 59 (return -> RETURN FALSE .)
    SWITCH          reduce using rule 59 (return -> RETURN FALSE .)
    CHARSTRING      reduce using rule 59 (return -> RETURN FALSE .)
    FOR             reduce using rule 59 (return -> RETURN FALSE .)
    INT             reduce using rule 59 (return -> RETURN FALSE .)
    FLOAT           reduce using rule 59 (return -> RETURN FALSE .)
    $end            reduce using rule 59 (return -> RETURN FALSE .)
    RBRACE          reduce using rule 59 (return -> RETURN FALSE .)
    CASE            reduce using rule 59 (return -> RETURN FALSE .)
    DEFAULT         reduce using rule 59 (return -> RETURN FALSE .)


state 110

    (143) struct_structure -> TYPE VARIABLE . STRUCT LBRACE struct_fields RBRACE

    STRUCT          shift and go to state 167


state 111

    (107) conditional_structure -> IF conditions . conditional_body
    (108) conditional_structure -> IF conditions . conditional_body ELSE conditional_body
    (109) conditional_structure -> IF conditions . conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) conditional_body -> . LBRACE statement RBRACE
    (111) conditional_body -> . LBRACE BREAK RBRACE
    (112) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 169

    conditional_body               shift and go to state 168

state 112

    (113) conditions -> condition .
    (114) conditions -> condition . logical_operator conditions
    (116) logical_operator -> . AND
    (117) logical_operator -> . OR
    (118) logical_operator -> . NOT

    LBRACE          reduce using rule 113 (conditions -> condition .)
    AND             shift and go to state 171
    OR              shift and go to state 172
    NOT             shift and go to state 173

    logical_operator               shift and go to state 170

state 113

    (115) condition -> value . relational_operator value
    (119) relational_operator -> . GREATER
    (120) relational_operator -> . LESS
    (121) relational_operator -> . GREATEREQUALS
    (122) relational_operator -> . LESSEQUALS
    (123) relational_operator -> . EQUALS
    (124) relational_operator -> . DIFFERENT

    GREATER         shift and go to state 175
    LESS            shift and go to state 176
    GREATEREQUALS   shift and go to state 177
    LESSEQUALS      shift and go to state 178
    EQUALS          shift and go to state 179
    DIFFERENT       shift and go to state 180

    relational_operator            shift and go to state 174

state 114

    (131) switch_structure -> SWITCH switch_expression . LBRACE case_blocks RBRACE

    LBRACE          shift and go to state 181


state 115

    (132) switch_expression -> VARIABLE . SHORTASSIGN value

    SHORTASSIGN     shift and go to state 182


state 116

    (133) switch_expression -> empty .

    LBRACE          reduce using rule 133 (switch_expression -> empty .)


state 117

    (128) for_initialization -> FOR VARIABLE . SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (130) for_iterator -> FOR VARIABLE . COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 183
    COMMA           shift and go to state 184


state 118

    (129) for_infinite_bucle -> FOR LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! LPAREN          [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 185
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 119

    (7) statement -> import main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 60
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    blocks                         shift and go to state 186
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 120

    (4) statement -> package import blocks .

    $end            reduce using rule 4 (statement -> package import blocks .)
    RBRACE          reduce using rule 4 (statement -> package import blocks .)
    CASE            reduce using rule 4 (statement -> package import blocks .)
    DEFAULT         reduce using rule 4 (statement -> package import blocks .)


state 121

    (8) statement -> package import main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 187


state 122

    (6) statement -> package main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 60
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    blocks                         shift and go to state 188
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 123

    (5) statement -> main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 189


state 124

    (19) blocks -> block SEMICOLON blocks .

    $end            reduce using rule 19 (blocks -> block SEMICOLON blocks .)
    RBRACE          reduce using rule 19 (blocks -> block SEMICOLON blocks .)
    CASE            reduce using rule 19 (blocks -> block SEMICOLON blocks .)
    DEFAULT         reduce using rule 19 (blocks -> block SEMICOLON blocks .)


state 125

    (11) import -> IMPORT LPAREN values_for_import . RPAREN

    RPAREN          shift and go to state 190


state 126

    (12) values_for_import -> CHARSTRING .
    (13) values_for_import -> CHARSTRING . values_for_import
    (12) values_for_import -> . CHARSTRING
    (13) values_for_import -> . CHARSTRING values_for_import

    RPAREN          reduce using rule 12 (values_for_import -> CHARSTRING .)
    CHARSTRING      shift and go to state 126

    values_for_import              shift and go to state 191

state 127

    (79) operation -> LPAREN value RPAREN . operator value
    (83) operation -> LPAREN value RPAREN . operator operation
    (86) operator -> . PLUS
    (87) operator -> . MINUS
    (88) operator -> . TIMES
    (89) operator -> . DIVIDE
    (90) operator -> . ASSIGN

    PLUS            shift and go to state 96
    MINUS           shift and go to state 97
    TIMES           shift and go to state 98
    DIVIDE          shift and go to state 99
    ASSIGN          shift and go to state 100

    operator                       shift and go to state 192

state 128

    (80) operation -> LPAREN value operator . value RPAREN
    (82) operation -> LPAREN value operator . operation RPAREN
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    LPAREN          shift and go to state 9
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 193
    operation                      shift and go to state 194
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 129

    (63) value -> VARIABLE LBRACKET . RBRACKET
    (64) value -> VARIABLE LBRACKET . value RBRACKET
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    RBRACKET        shift and go to state 137
    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 195
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 130

    (32) variable_declaration -> VARIABLE SHORTASSIGN value .
    (77) operation -> value . operator value
    (78) operation -> value . operator LPAREN value RPAREN
    (81) operation -> value . operator operation
    (84) operation -> value . operator LPAREN operation RPAREN
    (85) operation -> value . double_operator
    (86) operator -> . PLUS
    (87) operator -> . MINUS
    (88) operator -> . TIMES
    (89) operator -> . DIVIDE
    (90) operator -> . ASSIGN
    (91) double_operator -> . INCREMENT
    (92) double_operator -> . DECREMENT

    SEMICOLON       reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    PRINT           reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    PRINTF          reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INPUT           reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    LPAREN          reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FUNCTION        reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VAR             reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VARIABLE        reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CONST           reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    RETURN          reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    TYPE            reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    IF              reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    SWITCH          reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CHARSTRING      reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FOR             reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INT             reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FLOAT           reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    $end            reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    RBRACE          reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CASE            reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    DEFAULT         reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97
    TIMES           shift and go to state 98
    DIVIDE          shift and go to state 99
    ASSIGN          shift and go to state 100
    INCREMENT       shift and go to state 80
    DECREMENT       shift and go to state 81

    operator                       shift and go to state 94
    double_operator                shift and go to state 95

state 131

    (33) variable_declaration -> VARIABLE SHORTASSIGN operation .

    SEMICOLON       reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    PRINT           reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    PRINTF          reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    INPUT           reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    LPAREN          reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FUNCTION        reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    VAR             reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    VARIABLE        reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CONST           reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    RETURN          reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    TYPE            reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    IF              reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    SWITCH          reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CHARSTRING      reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FOR             reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    INT             reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FLOAT           reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    $end            reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    RBRACE          reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CASE            reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    DEFAULT         reduce using rule 33 (variable_declaration -> VARIABLE SHORTASSIGN operation .)


state 132

    (151) map_structure -> VARIABLE SHORTASSIGN MAP . LBRACKET type RBRACKET type LBRACE map_values RBRACE

    LBRACKET        shift and go to state 196


state 133

    (157) slice_structure -> VARIABLE SHORTASSIGN LBRACKET . RBRACKET type LBRACE values RBRACE
    (159) slice_structure -> VARIABLE SHORTASSIGN LBRACKET . RBRACKET type

    RBRACKET        shift and go to state 197


state 134

    (152) map_structure -> VARIABLE SHORTASSIGN MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN

    LPAREN          shift and go to state 198


state 135

    (37) variable_assignation -> VARIABLE assignation value .
    (77) operation -> value . operator value
    (78) operation -> value . operator LPAREN value RPAREN
    (81) operation -> value . operator operation
    (84) operation -> value . operator LPAREN operation RPAREN
    (85) operation -> value . double_operator
    (86) operator -> . PLUS
    (87) operator -> . MINUS
    (88) operator -> . TIMES
    (89) operator -> . DIVIDE
    (90) operator -> . ASSIGN
    (91) double_operator -> . INCREMENT
    (92) double_operator -> . DECREMENT

    SEMICOLON       reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    PRINT           reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    PRINTF          reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    INPUT           reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    LPAREN          reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    FUNCTION        reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    VAR             reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    VARIABLE        reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    CONST           reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    RETURN          reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    TYPE            reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    IF              reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    SWITCH          reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    CHARSTRING      reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    FOR             reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    INT             reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    FLOAT           reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    $end            reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    RBRACE          reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    CASE            reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    DEFAULT         reduce using rule 37 (variable_assignation -> VARIABLE assignation value .)
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97
    TIMES           shift and go to state 98
    DIVIDE          shift and go to state 99
    ASSIGN          shift and go to state 100
    INCREMENT       shift and go to state 80
    DECREMENT       shift and go to state 81

    operator                       shift and go to state 94
    double_operator                shift and go to state 95

state 136

    (38) variable_assignation -> VARIABLE assignation operation .

    SEMICOLON       reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    PRINT           reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    PRINTF          reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    INPUT           reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    LPAREN          reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    FUNCTION        reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    VAR             reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    VARIABLE        reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    CONST           reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    RETURN          reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    TYPE            reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    IF              reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    SWITCH          reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    CHARSTRING      reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    FOR             reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    INT             reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    FLOAT           reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    $end            reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    RBRACE          reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    CASE            reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)
    DEFAULT         reduce using rule 38 (variable_assignation -> VARIABLE assignation operation .)


state 137

    (63) value -> VARIABLE LBRACKET RBRACKET .

    PLUS            reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    MINUS           reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    TIMES           reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    DIVIDE          reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    ASSIGN          reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    INCREMENT       reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    DECREMENT       reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    RPAREN          reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    LBRACKET        reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    PERIOD          reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    PRINT           reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    PRINTF          reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    INPUT           reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    LPAREN          reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    FUNCTION        reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    VAR             reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    VARIABLE        reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    CONST           reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    RETURN          reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    TYPE            reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    IF              reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    SWITCH          reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    CHARSTRING      reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    FOR             reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    INT             reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    FLOAT           reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    $end            reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    RBRACE          reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    CASE            reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    DEFAULT         reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    GREATER         reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    LESS            reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    GREATEREQUALS   reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    LESSEQUALS      reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    EQUALS          reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    DIFFERENT       reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    COMMA           reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    AND             reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    OR              reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    NOT             reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    LBRACE          reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)
    COLON           reduce using rule 63 (value -> VARIABLE LBRACKET RBRACKET .)


state 138

    (64) value -> VARIABLE LBRACKET value . RBRACKET
    (156) map_assign -> VARIABLE LBRACKET value . RBRACKET ASSIGN value

    RBRACKET        shift and go to state 199


state 139

    (150) array_assign -> VARIABLE LBRACKET INT . RBRACKET ASSIGN value
    (68) number -> INT .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 200

  ! RBRACKET        [ reduce using rule 68 (number -> INT .) ]


state 140

    (160) slice_structure -> VARIABLE ASSIGN append_statement .

    SEMICOLON       reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    PRINT           reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    PRINTF          reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    INPUT           reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    LPAREN          reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FUNCTION        reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    VAR             reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    VARIABLE        reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CONST           reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    RETURN          reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    TYPE            reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    IF              reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    SWITCH          reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CHARSTRING      reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FOR             reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    INT             reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FLOAT           reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    $end            reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    RBRACE          reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CASE            reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)
    DEFAULT         reduce using rule 160 (slice_structure -> VARIABLE ASSIGN append_statement .)


state 141

    (161) append_statement -> APPEND . LPAREN VARIABLE COMMA values RPAREN
    (162) append_statement -> APPEND . LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN

    LPAREN          shift and go to state 201


state 142

    (43) variables -> VARIABLE .
    (44) variables -> VARIABLE . COMMA variables

    ASSIGN          reduce using rule 43 (variables -> VARIABLE .)
    PLUSASSIGN      reduce using rule 43 (variables -> VARIABLE .)
    MINUSASSIGN     reduce using rule 43 (variables -> VARIABLE .)
    TIMESASSIGN     reduce using rule 43 (variables -> VARIABLE .)
    DIVIDEASSIGN    reduce using rule 43 (variables -> VARIABLE .)
    MODASSIGN       reduce using rule 43 (variables -> VARIABLE .)
    INT             reduce using rule 43 (variables -> VARIABLE .)
    INT32           reduce using rule 43 (variables -> VARIABLE .)
    INT64           reduce using rule 43 (variables -> VARIABLE .)
    STRING          reduce using rule 43 (variables -> VARIABLE .)
    FLOAT           reduce using rule 43 (variables -> VARIABLE .)
    FLOAT32         reduce using rule 43 (variables -> VARIABLE .)
    FLOAT64         reduce using rule 43 (variables -> VARIABLE .)
    BOOL            reduce using rule 43 (variables -> VARIABLE .)
    COMMA           shift and go to state 73


state 143

    (44) variables -> VARIABLE COMMA variables .

    ASSIGN          reduce using rule 44 (variables -> VARIABLE COMMA variables .)
    PLUSASSIGN      reduce using rule 44 (variables -> VARIABLE COMMA variables .)
    MINUSASSIGN     reduce using rule 44 (variables -> VARIABLE COMMA variables .)
    TIMESASSIGN     reduce using rule 44 (variables -> VARIABLE COMMA variables .)
    DIVIDEASSIGN    reduce using rule 44 (variables -> VARIABLE COMMA variables .)
    MODASSIGN       reduce using rule 44 (variables -> VARIABLE COMMA variables .)
    INT             reduce using rule 44 (variables -> VARIABLE COMMA variables .)
    INT32           reduce using rule 44 (variables -> VARIABLE COMMA variables .)
    INT64           reduce using rule 44 (variables -> VARIABLE COMMA variables .)
    STRING          reduce using rule 44 (variables -> VARIABLE COMMA variables .)
    FLOAT           reduce using rule 44 (variables -> VARIABLE COMMA variables .)
    FLOAT32         reduce using rule 44 (variables -> VARIABLE COMMA variables .)
    FLOAT64         reduce using rule 44 (variables -> VARIABLE COMMA variables .)
    BOOL            reduce using rule 44 (variables -> VARIABLE COMMA variables .)


state 144

    (16) main -> FUNCTION MAIN LPAREN . RPAREN

    RPAREN          shift and go to state 202


state 145

    (51) function -> FUNCTION VARIABLE LPAREN . RPAREN LBRACE blocks RBRACE
    (52) function -> FUNCTION VARIABLE LPAREN . RPAREN type LBRACE blocks RBRACE
    (53) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN LBRACE blocks RBRACE
    (54) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (95) parameter -> . VARIABLE type

    RPAREN          shift and go to state 203
    VARIABLE        shift and go to state 158

    parameters                     shift and go to state 204
    parameter                      shift and go to state 34

state 146

    (70) print_statement -> PRINT LPAREN values . RPAREN

    RPAREN          shift and go to state 205


state 147

    (73) print_statement -> PRINT LPAREN RPAREN .

    SEMICOLON       reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    PRINT           reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    PRINTF          reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    INPUT           reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    LPAREN          reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    FUNCTION        reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    VAR             reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    VARIABLE        reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    CONST           reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    RETURN          reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    TYPE            reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    IF              reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    SWITCH          reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    CHARSTRING      reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    FOR             reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    INT             reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    FLOAT           reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    $end            reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    RBRACE          reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    CASE            reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)
    DEFAULT         reduce using rule 73 (print_statement -> PRINT LPAREN RPAREN .)


state 148

    (72) print_statement -> PRINT LPAREN operation . RPAREN

    RPAREN          shift and go to state 206


state 149

    (60) values -> value .
    (61) values -> value . COMMA values
    (77) operation -> value . operator value
    (78) operation -> value . operator LPAREN value RPAREN
    (81) operation -> value . operator operation
    (84) operation -> value . operator LPAREN operation RPAREN
    (85) operation -> value . double_operator
    (86) operator -> . PLUS
    (87) operator -> . MINUS
    (88) operator -> . TIMES
    (89) operator -> . DIVIDE
    (90) operator -> . ASSIGN
    (91) double_operator -> . INCREMENT
    (92) double_operator -> . DECREMENT

    RPAREN          reduce using rule 60 (values -> value .)
    COMMA           shift and go to state 207
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97
    TIMES           shift and go to state 98
    DIVIDE          shift and go to state 99
    ASSIGN          shift and go to state 100
    INCREMENT       shift and go to state 80
    DECREMENT       shift and go to state 81

    operator                       shift and go to state 94
    double_operator                shift and go to state 95

state 150

    (71) print_statement -> PRINTF LPAREN FORMATSTRING . COMMA values RPAREN

    COMMA           shift and go to state 208


state 151

    (74) input_statement -> INPUT LPAREN values . RPAREN

    RPAREN          shift and go to state 209


state 152

    (76) input_statement -> INPUT LPAREN RPAREN .

    SEMICOLON       reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    PRINT           reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    PRINTF          reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    LPAREN          reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    FUNCTION        reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    VAR             reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    VARIABLE        reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    CONST           reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    RETURN          reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    TYPE            reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    IF              reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    SWITCH          reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    CHARSTRING      reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    INT             reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    FLOAT           reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    $end            reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    CASE            reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)
    DEFAULT         reduce using rule 76 (input_statement -> INPUT LPAREN RPAREN .)


state 153

    (75) input_statement -> INPUT LPAREN operation . RPAREN

    RPAREN          shift and go to state 210


state 154

    (77) operation -> value operator value .
    (77) operation -> value . operator value
    (78) operation -> value . operator LPAREN value RPAREN
    (81) operation -> value . operator operation
    (84) operation -> value . operator LPAREN operation RPAREN
    (85) operation -> value . double_operator
    (86) operator -> . PLUS
    (87) operator -> . MINUS
    (88) operator -> . TIMES
    (89) operator -> . DIVIDE
    (90) operator -> . ASSIGN
    (91) double_operator -> . INCREMENT
    (92) double_operator -> . DECREMENT

    SEMICOLON       reduce using rule 77 (operation -> value operator value .)
    PRINT           reduce using rule 77 (operation -> value operator value .)
    PRINTF          reduce using rule 77 (operation -> value operator value .)
    INPUT           reduce using rule 77 (operation -> value operator value .)
    LPAREN          reduce using rule 77 (operation -> value operator value .)
    FUNCTION        reduce using rule 77 (operation -> value operator value .)
    VAR             reduce using rule 77 (operation -> value operator value .)
    VARIABLE        reduce using rule 77 (operation -> value operator value .)
    CONST           reduce using rule 77 (operation -> value operator value .)
    RETURN          reduce using rule 77 (operation -> value operator value .)
    TYPE            reduce using rule 77 (operation -> value operator value .)
    IF              reduce using rule 77 (operation -> value operator value .)
    SWITCH          reduce using rule 77 (operation -> value operator value .)
    CHARSTRING      reduce using rule 77 (operation -> value operator value .)
    FOR             reduce using rule 77 (operation -> value operator value .)
    INT             reduce using rule 77 (operation -> value operator value .)
    FLOAT           reduce using rule 77 (operation -> value operator value .)
    $end            reduce using rule 77 (operation -> value operator value .)
    RBRACE          reduce using rule 77 (operation -> value operator value .)
    CASE            reduce using rule 77 (operation -> value operator value .)
    DEFAULT         reduce using rule 77 (operation -> value operator value .)
    RPAREN          reduce using rule 77 (operation -> value operator value .)
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97
    TIMES           shift and go to state 98
    DIVIDE          shift and go to state 99
    ASSIGN          shift and go to state 100
    INCREMENT       shift and go to state 80
    DECREMENT       shift and go to state 81

    operator                       shift and go to state 94
    double_operator                shift and go to state 95

state 155

    (78) operation -> value operator LPAREN . value RPAREN
    (84) operation -> value operator LPAREN . operation RPAREN
    (79) operation -> LPAREN . value RPAREN operator value
    (80) operation -> LPAREN . value operator value RPAREN
    (82) operation -> LPAREN . value operator operation RPAREN
    (83) operation -> LPAREN . value RPAREN operator operation
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    LPAREN          shift and go to state 9
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 211
    operation                      shift and go to state 212
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 156

    (81) operation -> value operator operation .

    SEMICOLON       reduce using rule 81 (operation -> value operator operation .)
    PRINT           reduce using rule 81 (operation -> value operator operation .)
    PRINTF          reduce using rule 81 (operation -> value operator operation .)
    INPUT           reduce using rule 81 (operation -> value operator operation .)
    LPAREN          reduce using rule 81 (operation -> value operator operation .)
    FUNCTION        reduce using rule 81 (operation -> value operator operation .)
    VAR             reduce using rule 81 (operation -> value operator operation .)
    VARIABLE        reduce using rule 81 (operation -> value operator operation .)
    CONST           reduce using rule 81 (operation -> value operator operation .)
    RETURN          reduce using rule 81 (operation -> value operator operation .)
    TYPE            reduce using rule 81 (operation -> value operator operation .)
    IF              reduce using rule 81 (operation -> value operator operation .)
    SWITCH          reduce using rule 81 (operation -> value operator operation .)
    CHARSTRING      reduce using rule 81 (operation -> value operator operation .)
    FOR             reduce using rule 81 (operation -> value operator operation .)
    INT             reduce using rule 81 (operation -> value operator operation .)
    FLOAT           reduce using rule 81 (operation -> value operator operation .)
    $end            reduce using rule 81 (operation -> value operator operation .)
    RBRACE          reduce using rule 81 (operation -> value operator operation .)
    CASE            reduce using rule 81 (operation -> value operator operation .)
    DEFAULT         reduce using rule 81 (operation -> value operator operation .)
    RPAREN          reduce using rule 81 (operation -> value operator operation .)


state 157

    (94) parameters -> parameter COMMA parameters .

    SEMICOLON       reduce using rule 94 (parameters -> parameter COMMA parameters .)
    PRINT           reduce using rule 94 (parameters -> parameter COMMA parameters .)
    PRINTF          reduce using rule 94 (parameters -> parameter COMMA parameters .)
    INPUT           reduce using rule 94 (parameters -> parameter COMMA parameters .)
    LPAREN          reduce using rule 94 (parameters -> parameter COMMA parameters .)
    FUNCTION        reduce using rule 94 (parameters -> parameter COMMA parameters .)
    VAR             reduce using rule 94 (parameters -> parameter COMMA parameters .)
    VARIABLE        reduce using rule 94 (parameters -> parameter COMMA parameters .)
    CONST           reduce using rule 94 (parameters -> parameter COMMA parameters .)
    RETURN          reduce using rule 94 (parameters -> parameter COMMA parameters .)
    TYPE            reduce using rule 94 (parameters -> parameter COMMA parameters .)
    IF              reduce using rule 94 (parameters -> parameter COMMA parameters .)
    SWITCH          reduce using rule 94 (parameters -> parameter COMMA parameters .)
    CHARSTRING      reduce using rule 94 (parameters -> parameter COMMA parameters .)
    FOR             reduce using rule 94 (parameters -> parameter COMMA parameters .)
    INT             reduce using rule 94 (parameters -> parameter COMMA parameters .)
    FLOAT           reduce using rule 94 (parameters -> parameter COMMA parameters .)
    $end            reduce using rule 94 (parameters -> parameter COMMA parameters .)
    RBRACE          reduce using rule 94 (parameters -> parameter COMMA parameters .)
    CASE            reduce using rule 94 (parameters -> parameter COMMA parameters .)
    DEFAULT         reduce using rule 94 (parameters -> parameter COMMA parameters .)
    RPAREN          reduce using rule 94 (parameters -> parameter COMMA parameters .)


state 158

    (95) parameter -> VARIABLE . type
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

    type                           shift and go to state 71

state 159

    (30) variable_declaration -> VAR VARIABLE type .
    (31) variable_declaration -> VAR VARIABLE type . ASSIGN value

    SEMICOLON       reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    PRINT           reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    PRINTF          reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    INPUT           reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    LPAREN          reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    FUNCTION        reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    VAR             reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    VARIABLE        reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    CONST           reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    RETURN          reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    TYPE            reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    IF              reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    SWITCH          reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    CHARSTRING      reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    FOR             reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    INT             reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    FLOAT           reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    $end            reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    RBRACE          reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    CASE            reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    DEFAULT         reduce using rule 30 (variable_declaration -> VAR VARIABLE type .)
    ASSIGN          shift and go to state 213


state 160

    (148) array_structure -> VAR VARIABLE ASSIGN . LBRACKET INT RBRACKET type LBRACE values RBRACE

    LBRACKET        shift and go to state 214


state 161

    (147) array_structure -> VAR VARIABLE LBRACKET . INT RBRACKET type
    (149) array_structure -> VAR VARIABLE LBRACKET . INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (158) slice_structure -> VAR VARIABLE LBRACKET . RBRACKET type

    INT             shift and go to state 215
    RBRACKET        shift and go to state 216


state 162

    (34) variable_declaration -> VAR variables type .
    (35) variable_declaration -> VAR variables type . ASSIGN value

    SEMICOLON       reduce using rule 34 (variable_declaration -> VAR variables type .)
    PRINT           reduce using rule 34 (variable_declaration -> VAR variables type .)
    PRINTF          reduce using rule 34 (variable_declaration -> VAR variables type .)
    INPUT           reduce using rule 34 (variable_declaration -> VAR variables type .)
    LPAREN          reduce using rule 34 (variable_declaration -> VAR variables type .)
    FUNCTION        reduce using rule 34 (variable_declaration -> VAR variables type .)
    VAR             reduce using rule 34 (variable_declaration -> VAR variables type .)
    VARIABLE        reduce using rule 34 (variable_declaration -> VAR variables type .)
    CONST           reduce using rule 34 (variable_declaration -> VAR variables type .)
    RETURN          reduce using rule 34 (variable_declaration -> VAR variables type .)
    TYPE            reduce using rule 34 (variable_declaration -> VAR variables type .)
    IF              reduce using rule 34 (variable_declaration -> VAR variables type .)
    SWITCH          reduce using rule 34 (variable_declaration -> VAR variables type .)
    CHARSTRING      reduce using rule 34 (variable_declaration -> VAR variables type .)
    FOR             reduce using rule 34 (variable_declaration -> VAR variables type .)
    INT             reduce using rule 34 (variable_declaration -> VAR variables type .)
    FLOAT           reduce using rule 34 (variable_declaration -> VAR variables type .)
    $end            reduce using rule 34 (variable_declaration -> VAR variables type .)
    RBRACE          reduce using rule 34 (variable_declaration -> VAR variables type .)
    CASE            reduce using rule 34 (variable_declaration -> VAR variables type .)
    DEFAULT         reduce using rule 34 (variable_declaration -> VAR variables type .)
    ASSIGN          shift and go to state 217


state 163

    (40) variable_assignation -> variables assignation value .

    SEMICOLON       reduce using rule 40 (variable_assignation -> variables assignation value .)
    PRINT           reduce using rule 40 (variable_assignation -> variables assignation value .)
    PRINTF          reduce using rule 40 (variable_assignation -> variables assignation value .)
    INPUT           reduce using rule 40 (variable_assignation -> variables assignation value .)
    LPAREN          reduce using rule 40 (variable_assignation -> variables assignation value .)
    FUNCTION        reduce using rule 40 (variable_assignation -> variables assignation value .)
    VAR             reduce using rule 40 (variable_assignation -> variables assignation value .)
    VARIABLE        reduce using rule 40 (variable_assignation -> variables assignation value .)
    CONST           reduce using rule 40 (variable_assignation -> variables assignation value .)
    RETURN          reduce using rule 40 (variable_assignation -> variables assignation value .)
    TYPE            reduce using rule 40 (variable_assignation -> variables assignation value .)
    IF              reduce using rule 40 (variable_assignation -> variables assignation value .)
    SWITCH          reduce using rule 40 (variable_assignation -> variables assignation value .)
    CHARSTRING      reduce using rule 40 (variable_assignation -> variables assignation value .)
    FOR             reduce using rule 40 (variable_assignation -> variables assignation value .)
    INT             reduce using rule 40 (variable_assignation -> variables assignation value .)
    FLOAT           reduce using rule 40 (variable_assignation -> variables assignation value .)
    $end            reduce using rule 40 (variable_assignation -> variables assignation value .)
    RBRACE          reduce using rule 40 (variable_assignation -> variables assignation value .)
    CASE            reduce using rule 40 (variable_assignation -> variables assignation value .)
    DEFAULT         reduce using rule 40 (variable_assignation -> variables assignation value .)


state 164

    (36) variable_declaration -> CONST VARIABLE ASSIGN . value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 218
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 165

    (56) return -> RETURN value LBRACKET . value RBRACKET
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 219
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 166

    (57) return -> RETURN value PERIOD . value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 220
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 167

    (143) struct_structure -> TYPE VARIABLE STRUCT . LBRACE struct_fields RBRACE

    LBRACE          shift and go to state 221


state 168

    (107) conditional_structure -> IF conditions conditional_body .
    (108) conditional_structure -> IF conditions conditional_body . ELSE conditional_body
    (109) conditional_structure -> IF conditions conditional_body . ELSE IF conditions conditional_body ELSE conditional_body

    SEMICOLON       reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    PRINT           reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    PRINTF          reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    INPUT           reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    LPAREN          reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    FUNCTION        reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    VAR             reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    VARIABLE        reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    CONST           reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    RETURN          reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    TYPE            reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    IF              reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    SWITCH          reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    CHARSTRING      reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    FOR             reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    INT             reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    FLOAT           reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    $end            reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    RBRACE          reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    CASE            reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    DEFAULT         reduce using rule 107 (conditional_structure -> IF conditions conditional_body .)
    ELSE            shift and go to state 222


state 169

    (110) conditional_body -> LBRACE . statement RBRACE
    (111) conditional_body -> LBRACE . BREAK RBRACE
    (112) conditional_body -> LBRACE . CONTINUE RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    BREAK           shift and go to state 224
    CONTINUE        shift and go to state 225
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! LPAREN          [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 223
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 170

    (114) conditions -> condition logical_operator . conditions
    (113) conditions -> . condition
    (114) conditions -> . condition logical_operator conditions
    (115) condition -> . value relational_operator value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    condition                      shift and go to state 112
    conditions                     shift and go to state 226
    value                          shift and go to state 113
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 171

    (116) logical_operator -> AND .

    VARIABLE        reduce using rule 116 (logical_operator -> AND .)
    CHARSTRING      reduce using rule 116 (logical_operator -> AND .)
    INT             reduce using rule 116 (logical_operator -> AND .)
    FLOAT           reduce using rule 116 (logical_operator -> AND .)


state 172

    (117) logical_operator -> OR .

    VARIABLE        reduce using rule 117 (logical_operator -> OR .)
    CHARSTRING      reduce using rule 117 (logical_operator -> OR .)
    INT             reduce using rule 117 (logical_operator -> OR .)
    FLOAT           reduce using rule 117 (logical_operator -> OR .)


state 173

    (118) logical_operator -> NOT .

    VARIABLE        reduce using rule 118 (logical_operator -> NOT .)
    CHARSTRING      reduce using rule 118 (logical_operator -> NOT .)
    INT             reduce using rule 118 (logical_operator -> NOT .)
    FLOAT           reduce using rule 118 (logical_operator -> NOT .)


state 174

    (115) condition -> value relational_operator . value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 227
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 175

    (119) relational_operator -> GREATER .

    VARIABLE        reduce using rule 119 (relational_operator -> GREATER .)
    CHARSTRING      reduce using rule 119 (relational_operator -> GREATER .)
    INT             reduce using rule 119 (relational_operator -> GREATER .)
    FLOAT           reduce using rule 119 (relational_operator -> GREATER .)


state 176

    (120) relational_operator -> LESS .

    VARIABLE        reduce using rule 120 (relational_operator -> LESS .)
    CHARSTRING      reduce using rule 120 (relational_operator -> LESS .)
    INT             reduce using rule 120 (relational_operator -> LESS .)
    FLOAT           reduce using rule 120 (relational_operator -> LESS .)


state 177

    (121) relational_operator -> GREATEREQUALS .

    VARIABLE        reduce using rule 121 (relational_operator -> GREATEREQUALS .)
    CHARSTRING      reduce using rule 121 (relational_operator -> GREATEREQUALS .)
    INT             reduce using rule 121 (relational_operator -> GREATEREQUALS .)
    FLOAT           reduce using rule 121 (relational_operator -> GREATEREQUALS .)


state 178

    (122) relational_operator -> LESSEQUALS .

    VARIABLE        reduce using rule 122 (relational_operator -> LESSEQUALS .)
    CHARSTRING      reduce using rule 122 (relational_operator -> LESSEQUALS .)
    INT             reduce using rule 122 (relational_operator -> LESSEQUALS .)
    FLOAT           reduce using rule 122 (relational_operator -> LESSEQUALS .)


state 179

    (123) relational_operator -> EQUALS .

    VARIABLE        reduce using rule 123 (relational_operator -> EQUALS .)
    CHARSTRING      reduce using rule 123 (relational_operator -> EQUALS .)
    INT             reduce using rule 123 (relational_operator -> EQUALS .)
    FLOAT           reduce using rule 123 (relational_operator -> EQUALS .)


state 180

    (124) relational_operator -> DIFFERENT .

    VARIABLE        reduce using rule 124 (relational_operator -> DIFFERENT .)
    CHARSTRING      reduce using rule 124 (relational_operator -> DIFFERENT .)
    INT             reduce using rule 124 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 124 (relational_operator -> DIFFERENT .)


state 181

    (131) switch_structure -> SWITCH switch_expression LBRACE . case_blocks RBRACE
    (134) case_blocks -> . case_block
    (135) case_blocks -> . case_block case_blocks
    (136) case_block -> . CASE values COLON statement
    (137) case_block -> . DEFAULT COLON statement

    CASE            shift and go to state 230
    DEFAULT         shift and go to state 231

    case_blocks                    shift and go to state 228
    case_block                     shift and go to state 229

state 182

    (132) switch_expression -> VARIABLE SHORTASSIGN . value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 232
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 183

    (128) for_initialization -> FOR VARIABLE SHORTASSIGN . value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 233
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 184

    (130) for_iterator -> FOR VARIABLE COMMA . VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 234


state 185

    (129) for_infinite_bucle -> FOR LBRACE statement . RBRACE

    RBRACE          shift and go to state 235


state 186

    (7) statement -> import main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 236


state 187

    (8) statement -> package import main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 60
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    blocks                         shift and go to state 237
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 188

    (6) statement -> package main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 238


state 189

    (5) statement -> main LBRACE blocks RBRACE .

    $end            reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)
    CASE            reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)


state 190

    (11) import -> IMPORT LPAREN values_for_import RPAREN .

    FUNCTION        reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    PRINT           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    PRINTF          reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    INPUT           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    LPAREN          reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    VAR             reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    VARIABLE        reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    CONST           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    RETURN          reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    TYPE            reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    IF              reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    SWITCH          reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    CHARSTRING      reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    FOR             reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    INT             reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    FLOAT           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)


state 191

    (13) values_for_import -> CHARSTRING values_for_import .

    RPAREN          reduce using rule 13 (values_for_import -> CHARSTRING values_for_import .)


state 192

    (79) operation -> LPAREN value RPAREN operator . value
    (83) operation -> LPAREN value RPAREN operator . operation
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    LPAREN          shift and go to state 9
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 239
    operation                      shift and go to state 240
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 193

    (80) operation -> LPAREN value operator value . RPAREN
    (77) operation -> value . operator value
    (78) operation -> value . operator LPAREN value RPAREN
    (81) operation -> value . operator operation
    (84) operation -> value . operator LPAREN operation RPAREN
    (85) operation -> value . double_operator
    (86) operator -> . PLUS
    (87) operator -> . MINUS
    (88) operator -> . TIMES
    (89) operator -> . DIVIDE
    (90) operator -> . ASSIGN
    (91) double_operator -> . INCREMENT
    (92) double_operator -> . DECREMENT

    RPAREN          shift and go to state 241
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97
    TIMES           shift and go to state 98
    DIVIDE          shift and go to state 99
    ASSIGN          shift and go to state 100
    INCREMENT       shift and go to state 80
    DECREMENT       shift and go to state 81

    operator                       shift and go to state 94
    double_operator                shift and go to state 95

state 194

    (82) operation -> LPAREN value operator operation . RPAREN

    RPAREN          shift and go to state 242


state 195

    (64) value -> VARIABLE LBRACKET value . RBRACKET

    RBRACKET        shift and go to state 243


state 196

    (151) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET . type RBRACKET type LBRACE map_values RBRACE
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

    type                           shift and go to state 244

state 197

    (157) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET . type LBRACE values RBRACE
    (159) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET . type
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

    type                           shift and go to state 245

state 198

    (152) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN

    MAP             shift and go to state 246


state 199

    (64) value -> VARIABLE LBRACKET value RBRACKET .
    (156) map_assign -> VARIABLE LBRACKET value RBRACKET . ASSIGN value

  ! shift/reduce conflict for ASSIGN resolved as shift
    PLUS            reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    MINUS           reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    TIMES           reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    DIVIDE          reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    INCREMENT       reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    DECREMENT       reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    ASSIGN          shift and go to state 247

  ! ASSIGN          [ reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .) ]


state 200

    (150) array_assign -> VARIABLE LBRACKET INT RBRACKET . ASSIGN value

    ASSIGN          shift and go to state 248


state 201

    (161) append_statement -> APPEND LPAREN . VARIABLE COMMA values RPAREN
    (162) append_statement -> APPEND LPAREN . VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN

    VARIABLE        shift and go to state 249


state 202

    (16) main -> FUNCTION MAIN LPAREN RPAREN .

    LBRACE          reduce using rule 16 (main -> FUNCTION MAIN LPAREN RPAREN .)


state 203

    (51) function -> FUNCTION VARIABLE LPAREN RPAREN . LBRACE blocks RBRACE
    (52) function -> FUNCTION VARIABLE LPAREN RPAREN . type LBRACE blocks RBRACE
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

    LBRACE          shift and go to state 250
    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

    type                           shift and go to state 251

state 204

    (53) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN LBRACE blocks RBRACE
    (54) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN type LBRACE blocks RBRACE

    RPAREN          shift and go to state 252


state 205

    (70) print_statement -> PRINT LPAREN values RPAREN .

    SEMICOLON       reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    PRINT           reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    PRINTF          reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    INPUT           reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    LPAREN          reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    VAR             reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    CONST           reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    RETURN          reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    TYPE            reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    IF              reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    SWITCH          reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    CHARSTRING      reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    FOR             reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    INT             reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    FLOAT           reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    $end            reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    RBRACE          reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    CASE            reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)
    DEFAULT         reduce using rule 70 (print_statement -> PRINT LPAREN values RPAREN .)


state 206

    (72) print_statement -> PRINT LPAREN operation RPAREN .

    SEMICOLON       reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    PRINT           reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    PRINTF          reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    INPUT           reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    LPAREN          reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    VAR             reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    CONST           reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    RETURN          reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    TYPE            reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    IF              reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    SWITCH          reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    FOR             reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    INT             reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    $end            reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    CASE            reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 72 (print_statement -> PRINT LPAREN operation RPAREN .)


state 207

    (61) values -> value COMMA . values
    (60) values -> . value
    (61) values -> . value COMMA values
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 253
    values                         shift and go to state 254
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 208

    (71) print_statement -> PRINTF LPAREN FORMATSTRING COMMA . values RPAREN
    (60) values -> . value
    (61) values -> . value COMMA values
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    values                         shift and go to state 255
    value                          shift and go to state 253
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 209

    (74) input_statement -> INPUT LPAREN values RPAREN .

    SEMICOLON       reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    PRINT           reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    PRINTF          reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    INPUT           reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    LPAREN          reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    VAR             reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    CONST           reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    RETURN          reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    TYPE            reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    IF              reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    SWITCH          reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    CHARSTRING      reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    FOR             reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    INT             reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    FLOAT           reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    $end            reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    RBRACE          reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    CASE            reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)
    DEFAULT         reduce using rule 74 (input_statement -> INPUT LPAREN values RPAREN .)


state 210

    (75) input_statement -> INPUT LPAREN operation RPAREN .

    SEMICOLON       reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    PRINT           reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    PRINTF          reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    INPUT           reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    LPAREN          reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    VAR             reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    CONST           reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    RETURN          reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    TYPE            reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    IF              reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    SWITCH          reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    FOR             reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    INT             reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    $end            reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    CASE            reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 75 (input_statement -> INPUT LPAREN operation RPAREN .)


state 211

    (78) operation -> value operator LPAREN value . RPAREN
    (79) operation -> LPAREN value . RPAREN operator value
    (80) operation -> LPAREN value . operator value RPAREN
    (82) operation -> LPAREN value . operator operation RPAREN
    (83) operation -> LPAREN value . RPAREN operator operation
    (77) operation -> value . operator value
    (78) operation -> value . operator LPAREN value RPAREN
    (81) operation -> value . operator operation
    (84) operation -> value . operator LPAREN operation RPAREN
    (85) operation -> value . double_operator
    (86) operator -> . PLUS
    (87) operator -> . MINUS
    (88) operator -> . TIMES
    (89) operator -> . DIVIDE
    (90) operator -> . ASSIGN
    (91) double_operator -> . INCREMENT
    (92) double_operator -> . DECREMENT

    RPAREN          shift and go to state 257
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97
    TIMES           shift and go to state 98
    DIVIDE          shift and go to state 99
    ASSIGN          shift and go to state 100
    INCREMENT       shift and go to state 80
    DECREMENT       shift and go to state 81

    operator                       shift and go to state 256
    double_operator                shift and go to state 95

state 212

    (84) operation -> value operator LPAREN operation . RPAREN

    RPAREN          shift and go to state 258


state 213

    (31) variable_declaration -> VAR VARIABLE type ASSIGN . value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 259
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 214

    (148) array_structure -> VAR VARIABLE ASSIGN LBRACKET . INT RBRACKET type LBRACE values RBRACE

    INT             shift and go to state 260


state 215

    (147) array_structure -> VAR VARIABLE LBRACKET INT . RBRACKET type
    (149) array_structure -> VAR VARIABLE LBRACKET INT . RBRACKET type ASSIGN LBRACKET values RBRACKET

    RBRACKET        shift and go to state 261


state 216

    (158) slice_structure -> VAR VARIABLE LBRACKET RBRACKET . type
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

    type                           shift and go to state 262

state 217

    (35) variable_declaration -> VAR variables type ASSIGN . value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 263
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 218

    (36) variable_declaration -> CONST VARIABLE ASSIGN value .

    SEMICOLON       reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    PRINT           reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    PRINTF          reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    INPUT           reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    LPAREN          reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    FUNCTION        reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    VAR             reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    VARIABLE        reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    CONST           reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    RETURN          reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    TYPE            reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    IF              reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    SWITCH          reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    CHARSTRING      reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    FOR             reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    INT             reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    FLOAT           reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    $end            reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    RBRACE          reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    CASE            reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    DEFAULT         reduce using rule 36 (variable_declaration -> CONST VARIABLE ASSIGN value .)


state 219

    (56) return -> RETURN value LBRACKET value . RBRACKET

    RBRACKET        shift and go to state 264


state 220

    (57) return -> RETURN value PERIOD value .

    SEMICOLON       reduce using rule 57 (return -> RETURN value PERIOD value .)
    PRINT           reduce using rule 57 (return -> RETURN value PERIOD value .)
    PRINTF          reduce using rule 57 (return -> RETURN value PERIOD value .)
    INPUT           reduce using rule 57 (return -> RETURN value PERIOD value .)
    LPAREN          reduce using rule 57 (return -> RETURN value PERIOD value .)
    FUNCTION        reduce using rule 57 (return -> RETURN value PERIOD value .)
    VAR             reduce using rule 57 (return -> RETURN value PERIOD value .)
    VARIABLE        reduce using rule 57 (return -> RETURN value PERIOD value .)
    CONST           reduce using rule 57 (return -> RETURN value PERIOD value .)
    RETURN          reduce using rule 57 (return -> RETURN value PERIOD value .)
    TYPE            reduce using rule 57 (return -> RETURN value PERIOD value .)
    IF              reduce using rule 57 (return -> RETURN value PERIOD value .)
    SWITCH          reduce using rule 57 (return -> RETURN value PERIOD value .)
    CHARSTRING      reduce using rule 57 (return -> RETURN value PERIOD value .)
    FOR             reduce using rule 57 (return -> RETURN value PERIOD value .)
    INT             reduce using rule 57 (return -> RETURN value PERIOD value .)
    FLOAT           reduce using rule 57 (return -> RETURN value PERIOD value .)
    $end            reduce using rule 57 (return -> RETURN value PERIOD value .)
    RBRACE          reduce using rule 57 (return -> RETURN value PERIOD value .)
    CASE            reduce using rule 57 (return -> RETURN value PERIOD value .)
    DEFAULT         reduce using rule 57 (return -> RETURN value PERIOD value .)


state 221

    (143) struct_structure -> TYPE VARIABLE STRUCT LBRACE . struct_fields RBRACE
    (144) struct_fields -> . struct_field
    (145) struct_fields -> . struct_field struct_fields
    (146) struct_field -> . VARIABLE type

    VARIABLE        shift and go to state 265

    struct_fields                  shift and go to state 266
    struct_field                   shift and go to state 267

state 222

    (108) conditional_structure -> IF conditions conditional_body ELSE . conditional_body
    (109) conditional_structure -> IF conditions conditional_body ELSE . IF conditions conditional_body ELSE conditional_body
    (110) conditional_body -> . LBRACE statement RBRACE
    (111) conditional_body -> . LBRACE BREAK RBRACE
    (112) conditional_body -> . LBRACE CONTINUE RBRACE

    IF              shift and go to state 268
    LBRACE          shift and go to state 169

    conditional_body               shift and go to state 269

state 223

    (110) conditional_body -> LBRACE statement . RBRACE

    RBRACE          shift and go to state 270


state 224

    (111) conditional_body -> LBRACE BREAK . RBRACE

    RBRACE          shift and go to state 271


state 225

    (112) conditional_body -> LBRACE CONTINUE . RBRACE

    RBRACE          shift and go to state 272


state 226

    (114) conditions -> condition logical_operator conditions .

    LBRACE          reduce using rule 114 (conditions -> condition logical_operator conditions .)


state 227

    (115) condition -> value relational_operator value .

    AND             reduce using rule 115 (condition -> value relational_operator value .)
    OR              reduce using rule 115 (condition -> value relational_operator value .)
    NOT             reduce using rule 115 (condition -> value relational_operator value .)
    LBRACE          reduce using rule 115 (condition -> value relational_operator value .)
    SEMICOLON       reduce using rule 115 (condition -> value relational_operator value .)


state 228

    (131) switch_structure -> SWITCH switch_expression LBRACE case_blocks . RBRACE

    RBRACE          shift and go to state 273


state 229

    (134) case_blocks -> case_block .
    (135) case_blocks -> case_block . case_blocks
    (134) case_blocks -> . case_block
    (135) case_blocks -> . case_block case_blocks
    (136) case_block -> . CASE values COLON statement
    (137) case_block -> . DEFAULT COLON statement

    RBRACE          reduce using rule 134 (case_blocks -> case_block .)
    CASE            shift and go to state 230
    DEFAULT         shift and go to state 231

    case_block                     shift and go to state 229
    case_blocks                    shift and go to state 274

state 230

    (136) case_block -> CASE . values COLON statement
    (60) values -> . value
    (61) values -> . value COMMA values
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    values                         shift and go to state 275
    value                          shift and go to state 253
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 231

    (137) case_block -> DEFAULT . COLON statement

    COLON           shift and go to state 276


state 232

    (132) switch_expression -> VARIABLE SHORTASSIGN value .

    LBRACE          reduce using rule 132 (switch_expression -> VARIABLE SHORTASSIGN value .)


state 233

    (128) for_initialization -> FOR VARIABLE SHORTASSIGN value . SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 277


state 234

    (130) for_iterator -> FOR VARIABLE COMMA VARIABLE . SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 278


state 235

    (129) for_infinite_bucle -> FOR LBRACE statement RBRACE .

    SEMICOLON       reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    PRINT           reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    PRINTF          reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INPUT           reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    LPAREN          reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VAR             reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CONST           reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RETURN          reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    TYPE            reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    IF              reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    SWITCH          reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FOR             reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INT             reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FLOAT           reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    $end            reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RBRACE          reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CASE            reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 129 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)


state 236

    (7) statement -> import main LBRACE blocks RBRACE .

    $end            reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)
    CASE            reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)


state 237

    (8) statement -> package import main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 279


state 238

    (6) statement -> package main LBRACE blocks RBRACE .

    $end            reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)
    CASE            reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)


state 239

    (79) operation -> LPAREN value RPAREN operator value .
    (77) operation -> value . operator value
    (78) operation -> value . operator LPAREN value RPAREN
    (81) operation -> value . operator operation
    (84) operation -> value . operator LPAREN operation RPAREN
    (85) operation -> value . double_operator
    (86) operator -> . PLUS
    (87) operator -> . MINUS
    (88) operator -> . TIMES
    (89) operator -> . DIVIDE
    (90) operator -> . ASSIGN
    (91) double_operator -> . INCREMENT
    (92) double_operator -> . DECREMENT

    SEMICOLON       reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    PRINT           reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    PRINTF          reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    INPUT           reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    LPAREN          reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    FUNCTION        reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    VAR             reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    VARIABLE        reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    CONST           reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    RETURN          reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    TYPE            reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    IF              reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    SWITCH          reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    CHARSTRING      reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    FOR             reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    INT             reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    FLOAT           reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    $end            reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    RBRACE          reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    CASE            reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    DEFAULT         reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    RPAREN          reduce using rule 79 (operation -> LPAREN value RPAREN operator value .)
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97
    TIMES           shift and go to state 98
    DIVIDE          shift and go to state 99
    ASSIGN          shift and go to state 100
    INCREMENT       shift and go to state 80
    DECREMENT       shift and go to state 81

    operator                       shift and go to state 94
    double_operator                shift and go to state 95

state 240

    (83) operation -> LPAREN value RPAREN operator operation .

    SEMICOLON       reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    PRINT           reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    PRINTF          reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    INPUT           reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    LPAREN          reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    FUNCTION        reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    VAR             reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    VARIABLE        reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    CONST           reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    RETURN          reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    TYPE            reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    IF              reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    SWITCH          reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    CHARSTRING      reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    FOR             reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    INT             reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    FLOAT           reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    $end            reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    RBRACE          reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    CASE            reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    DEFAULT         reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)
    RPAREN          reduce using rule 83 (operation -> LPAREN value RPAREN operator operation .)


state 241

    (80) operation -> LPAREN value operator value RPAREN .

    SEMICOLON       reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    PRINT           reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    PRINTF          reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    INPUT           reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    LPAREN          reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    FUNCTION        reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    VAR             reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    VARIABLE        reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    CONST           reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    RETURN          reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    TYPE            reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    IF              reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    SWITCH          reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    CHARSTRING      reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    FOR             reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    INT             reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    FLOAT           reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    $end            reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    RBRACE          reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    CASE            reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    DEFAULT         reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)
    RPAREN          reduce using rule 80 (operation -> LPAREN value operator value RPAREN .)


state 242

    (82) operation -> LPAREN value operator operation RPAREN .

    SEMICOLON       reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    PRINT           reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    PRINTF          reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    INPUT           reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    LPAREN          reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    FUNCTION        reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    VAR             reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    VARIABLE        reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    CONST           reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    RETURN          reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    TYPE            reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    IF              reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    SWITCH          reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    CHARSTRING      reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    FOR             reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    INT             reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    FLOAT           reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    $end            reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    RBRACE          reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    CASE            reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    DEFAULT         reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)
    RPAREN          reduce using rule 82 (operation -> LPAREN value operator operation RPAREN .)


state 243

    (64) value -> VARIABLE LBRACKET value RBRACKET .

    RPAREN          reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    PLUS            reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    MINUS           reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    TIMES           reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    DIVIDE          reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    ASSIGN          reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    LBRACKET        reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    PERIOD          reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    SEMICOLON       reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    PRINT           reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    PRINTF          reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    INPUT           reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    LPAREN          reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    FUNCTION        reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    VAR             reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    VARIABLE        reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    CONST           reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    RETURN          reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    TYPE            reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    IF              reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    SWITCH          reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    CHARSTRING      reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    FOR             reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    INT             reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    FLOAT           reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    $end            reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    RBRACE          reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    CASE            reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    DEFAULT         reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    GREATER         reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    LESS            reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    GREATEREQUALS   reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    LESSEQUALS      reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    EQUALS          reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    DIFFERENT       reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    INCREMENT       reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    DECREMENT       reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    RBRACKET        reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    COMMA           reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    AND             reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    OR              reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    NOT             reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    LBRACE          reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)
    COLON           reduce using rule 64 (value -> VARIABLE LBRACKET value RBRACKET .)


state 244

    (151) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type . RBRACKET type LBRACE map_values RBRACE

    RBRACKET        shift and go to state 280


state 245

    (157) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type . LBRACE values RBRACE
    (159) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .

    LBRACE          shift and go to state 281
    SEMICOLON       reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    PRINT           reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    PRINTF          reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    INPUT           reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    LPAREN          reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FUNCTION        reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    VAR             reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CONST           reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    RETURN          reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    TYPE            reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    IF              reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CHARSTRING      reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FOR             reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    INT             reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FLOAT           reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    $end            reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CASE            reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 159 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)


state 246

    (152) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN

    LBRACKET        shift and go to state 282


state 247

    (156) map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN . value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 283
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 248

    (150) array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN . value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 284
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 249

    (161) append_statement -> APPEND LPAREN VARIABLE . COMMA values RPAREN
    (162) append_statement -> APPEND LPAREN VARIABLE . COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN

    COMMA           shift and go to state 285


state 250

    (51) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 60
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    blocks                         shift and go to state 286
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 251

    (52) function -> FUNCTION VARIABLE LPAREN RPAREN type . LBRACE blocks RBRACE

    LBRACE          shift and go to state 287


state 252

    (53) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . LBRACE blocks RBRACE
    (54) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . type LBRACE blocks RBRACE
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

    LBRACE          shift and go to state 288
    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

    type                           shift and go to state 289

state 253

    (60) values -> value .
    (61) values -> value . COMMA values

    RPAREN          reduce using rule 60 (values -> value .)
    COLON           reduce using rule 60 (values -> value .)
    RBRACE          reduce using rule 60 (values -> value .)
    RBRACKET        reduce using rule 60 (values -> value .)
    COMMA           shift and go to state 207


state 254

    (61) values -> value COMMA values .

    RPAREN          reduce using rule 61 (values -> value COMMA values .)
    COLON           reduce using rule 61 (values -> value COMMA values .)
    RBRACE          reduce using rule 61 (values -> value COMMA values .)
    RBRACKET        reduce using rule 61 (values -> value COMMA values .)


state 255

    (71) print_statement -> PRINTF LPAREN FORMATSTRING COMMA values . RPAREN

    RPAREN          shift and go to state 290


state 256

    (80) operation -> LPAREN value operator . value RPAREN
    (82) operation -> LPAREN value operator . operation RPAREN
    (77) operation -> value operator . value
    (78) operation -> value operator . LPAREN value RPAREN
    (81) operation -> value operator . operation
    (84) operation -> value operator . LPAREN operation RPAREN
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    LPAREN          shift and go to state 155
    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 291
    operation                      shift and go to state 292
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 257

    (78) operation -> value operator LPAREN value RPAREN .
    (79) operation -> LPAREN value RPAREN . operator value
    (83) operation -> LPAREN value RPAREN . operator operation
    (86) operator -> . PLUS
    (87) operator -> . MINUS
    (88) operator -> . TIMES
    (89) operator -> . DIVIDE
    (90) operator -> . ASSIGN

    SEMICOLON       reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    PRINT           reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    PRINTF          reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    INPUT           reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    LPAREN          reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    FUNCTION        reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    VAR             reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    VARIABLE        reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    CONST           reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    RETURN          reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    TYPE            reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    IF              reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    SWITCH          reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    CHARSTRING      reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    FOR             reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    INT             reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    FLOAT           reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    $end            reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    RBRACE          reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    CASE            reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    DEFAULT         reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    RPAREN          reduce using rule 78 (operation -> value operator LPAREN value RPAREN .)
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97
    TIMES           shift and go to state 98
    DIVIDE          shift and go to state 99
    ASSIGN          shift and go to state 100

    operator                       shift and go to state 192

state 258

    (84) operation -> value operator LPAREN operation RPAREN .

    SEMICOLON       reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    PRINT           reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    PRINTF          reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    INPUT           reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    LPAREN          reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    VAR             reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    CONST           reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    RETURN          reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    TYPE            reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    IF              reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    SWITCH          reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    FOR             reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    INT             reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    FLOAT           reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    $end            reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    RBRACE          reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    CASE            reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)
    RPAREN          reduce using rule 84 (operation -> value operator LPAREN operation RPAREN .)


state 259

    (31) variable_declaration -> VAR VARIABLE type ASSIGN value .

    SEMICOLON       reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    PRINT           reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    PRINTF          reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    INPUT           reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    LPAREN          reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    FUNCTION        reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    VAR             reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    VARIABLE        reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    CONST           reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    RETURN          reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    TYPE            reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    IF              reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    SWITCH          reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    CHARSTRING      reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    FOR             reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    INT             reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    FLOAT           reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    $end            reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    RBRACE          reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    CASE            reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    DEFAULT         reduce using rule 31 (variable_declaration -> VAR VARIABLE type ASSIGN value .)


state 260

    (148) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT . RBRACKET type LBRACE values RBRACE

    RBRACKET        shift and go to state 293


state 261

    (147) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET . type
    (149) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET . type ASSIGN LBRACKET values RBRACKET
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

    type                           shift and go to state 294

state 262

    (158) slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .

    SEMICOLON       reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    PRINT           reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    PRINTF          reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    INPUT           reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    LPAREN          reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FUNCTION        reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    VAR             reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CONST           reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    RETURN          reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    TYPE            reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    IF              reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CHARSTRING      reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FOR             reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    INT             reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FLOAT           reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    $end            reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CASE            reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 158 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)


state 263

    (35) variable_declaration -> VAR variables type ASSIGN value .

    SEMICOLON       reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    PRINT           reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    PRINTF          reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    INPUT           reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    LPAREN          reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    FUNCTION        reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    VAR             reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    VARIABLE        reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    CONST           reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    RETURN          reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    TYPE            reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    IF              reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    SWITCH          reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    CHARSTRING      reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    FOR             reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    INT             reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    FLOAT           reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    $end            reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    RBRACE          reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    CASE            reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)
    DEFAULT         reduce using rule 35 (variable_declaration -> VAR variables type ASSIGN value .)


state 264

    (56) return -> RETURN value LBRACKET value RBRACKET .

    SEMICOLON       reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    PRINT           reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    PRINTF          reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    INPUT           reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    LPAREN          reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    FUNCTION        reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    VAR             reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    VARIABLE        reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    CONST           reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    RETURN          reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    TYPE            reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    IF              reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    SWITCH          reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    CHARSTRING      reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    FOR             reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    INT             reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    FLOAT           reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    $end            reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    RBRACE          reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    CASE            reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)
    DEFAULT         reduce using rule 56 (return -> RETURN value LBRACKET value RBRACKET .)


state 265

    (146) struct_field -> VARIABLE . type
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

    type                           shift and go to state 295

state 266

    (143) struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields . RBRACE

    RBRACE          shift and go to state 296


state 267

    (144) struct_fields -> struct_field .
    (145) struct_fields -> struct_field . struct_fields
    (144) struct_fields -> . struct_field
    (145) struct_fields -> . struct_field struct_fields
    (146) struct_field -> . VARIABLE type

    RBRACE          reduce using rule 144 (struct_fields -> struct_field .)
    VARIABLE        shift and go to state 265

    struct_field                   shift and go to state 267
    struct_fields                  shift and go to state 297

state 268

    (109) conditional_structure -> IF conditions conditional_body ELSE IF . conditions conditional_body ELSE conditional_body
    (113) conditions -> . condition
    (114) conditions -> . condition logical_operator conditions
    (115) condition -> . value relational_operator value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    conditions                     shift and go to state 298
    condition                      shift and go to state 112
    value                          shift and go to state 113
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 269

    (108) conditional_structure -> IF conditions conditional_body ELSE conditional_body .

    SEMICOLON       reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    PRINT           reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    PRINTF          reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    LPAREN          reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CONST           reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RETURN          reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    SWITCH          reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CHARSTRING      reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CASE            reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    DEFAULT         reduce using rule 108 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)


state 270

    (110) conditional_body -> LBRACE statement RBRACE .

    ELSE            reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    SEMICOLON       reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    PRINT           reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    PRINTF          reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    INPUT           reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    LPAREN          reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    VAR             reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    CONST           reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    RETURN          reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    TYPE            reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    IF              reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    SWITCH          reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    FOR             reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    INT             reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    FLOAT           reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    $end            reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    RBRACE          reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    CASE            reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 110 (conditional_body -> LBRACE statement RBRACE .)


state 271

    (111) conditional_body -> LBRACE BREAK RBRACE .

    ELSE            reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    SEMICOLON       reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    PRINT           reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    PRINTF          reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    INPUT           reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    LPAREN          reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    FUNCTION        reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    VAR             reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    VARIABLE        reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    CONST           reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    RETURN          reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    TYPE            reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    IF              reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    SWITCH          reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    CHARSTRING      reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    FOR             reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    INT             reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    FLOAT           reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    $end            reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    RBRACE          reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    CASE            reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)
    DEFAULT         reduce using rule 111 (conditional_body -> LBRACE BREAK RBRACE .)


state 272

    (112) conditional_body -> LBRACE CONTINUE RBRACE .

    ELSE            reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    SEMICOLON       reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    PRINT           reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    PRINTF          reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INPUT           reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    LPAREN          reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FUNCTION        reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VAR             reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VARIABLE        reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CONST           reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RETURN          reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    TYPE            reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    IF              reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    SWITCH          reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CHARSTRING      reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FOR             reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INT             reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FLOAT           reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    $end            reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RBRACE          reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CASE            reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)
    DEFAULT         reduce using rule 112 (conditional_body -> LBRACE CONTINUE RBRACE .)


state 273

    (131) switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .

    SEMICOLON       reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    PRINT           reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    PRINTF          reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    INPUT           reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    LPAREN          reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FUNCTION        reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    VAR             reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    VARIABLE        reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CONST           reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    RETURN          reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    TYPE            reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    IF              reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    SWITCH          reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CHARSTRING      reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FOR             reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    INT             reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FLOAT           reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    $end            reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    RBRACE          reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CASE            reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    DEFAULT         reduce using rule 131 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)


state 274

    (135) case_blocks -> case_block case_blocks .

    RBRACE          reduce using rule 135 (case_blocks -> case_block case_blocks .)


state 275

    (136) case_block -> CASE values . COLON statement

    COLON           shift and go to state 299


state 276

    (137) case_block -> DEFAULT COLON . statement
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! LPAREN          [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 300
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 277

    (128) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON . condition SEMICOLON value double_operator LBRACE statement RBRACE
    (115) condition -> . value relational_operator value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 113
    condition                      shift and go to state 301
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 278

    (130) for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN . RANGE VARIABLE LBRACE statement RBRACE

    RANGE           shift and go to state 302


state 279

    (8) statement -> package import main LBRACE blocks RBRACE .

    $end            reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)
    CASE            reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)


state 280

    (151) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET . type LBRACE map_values RBRACE
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

    type                           shift and go to state 303

state 281

    (157) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE . values RBRACE
    (60) values -> . value
    (61) values -> . value COMMA values
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    values                         shift and go to state 304
    value                          shift and go to state 253
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 282

    (152) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

    type                           shift and go to state 305

state 283

    (156) map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .

    SEMICOLON       reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    PRINT           reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    PRINTF          reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    INPUT           reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    LPAREN          reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    FUNCTION        reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    VAR             reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    VARIABLE        reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    CONST           reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    RETURN          reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    TYPE            reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    IF              reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    SWITCH          reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    CHARSTRING      reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    FOR             reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    INT             reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    FLOAT           reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    $end            reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    RBRACE          reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    CASE            reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    DEFAULT         reduce using rule 156 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)


state 284

    (150) array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .

    SEMICOLON       reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    PRINT           reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    PRINTF          reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    INPUT           reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    LPAREN          reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    FUNCTION        reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    VAR             reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    VARIABLE        reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    CONST           reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    RETURN          reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    TYPE            reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    IF              reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    SWITCH          reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    CHARSTRING      reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    FOR             reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    INT             reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    FLOAT           reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    $end            reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    RBRACE          reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    CASE            reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    DEFAULT         reduce using rule 150 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)


state 285

    (161) append_statement -> APPEND LPAREN VARIABLE COMMA . values RPAREN
    (162) append_statement -> APPEND LPAREN VARIABLE COMMA . LBRACKET RBRACKET type LBRACE values RBRACE RPAREN
    (60) values -> . value
    (61) values -> . value COMMA values
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    LBRACKET        shift and go to state 307
    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    values                         shift and go to state 306
    value                          shift and go to state 253
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 286

    (51) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 308


state 287

    (52) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 60
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    blocks                         shift and go to state 309
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 288

    (53) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 60
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    parameters                     shift and go to state 19
    blocks                         shift and go to state 310
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 289

    (54) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type . LBRACE blocks RBRACE

    LBRACE          shift and go to state 311


state 290

    (71) print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .

    SEMICOLON       reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    PRINT           reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    PRINTF          reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    INPUT           reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    LPAREN          reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FUNCTION        reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    VAR             reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    VARIABLE        reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CONST           reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    RETURN          reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    TYPE            reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    IF              reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    SWITCH          reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CHARSTRING      reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FOR             reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    INT             reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FLOAT           reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    $end            reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    RBRACE          reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CASE            reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    DEFAULT         reduce using rule 71 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)


state 291

    (80) operation -> LPAREN value operator value . RPAREN
    (77) operation -> value operator value .
    (77) operation -> value . operator value
    (78) operation -> value . operator LPAREN value RPAREN
    (81) operation -> value . operator operation
    (84) operation -> value . operator LPAREN operation RPAREN
    (85) operation -> value . double_operator
    (86) operator -> . PLUS
    (87) operator -> . MINUS
    (88) operator -> . TIMES
    (89) operator -> . DIVIDE
    (90) operator -> . ASSIGN
    (91) double_operator -> . INCREMENT
    (92) double_operator -> . DECREMENT

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 241
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97
    TIMES           shift and go to state 98
    DIVIDE          shift and go to state 99
    ASSIGN          shift and go to state 100
    INCREMENT       shift and go to state 80
    DECREMENT       shift and go to state 81

  ! RPAREN          [ reduce using rule 77 (operation -> value operator value .) ]

    operator                       shift and go to state 94
    double_operator                shift and go to state 95

state 292

    (82) operation -> LPAREN value operator operation . RPAREN
    (81) operation -> value operator operation .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 242

  ! RPAREN          [ reduce using rule 81 (operation -> value operator operation .) ]


state 293

    (148) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET . type LBRACE values RBRACE
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

    type                           shift and go to state 312

state 294

    (147) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .
    (149) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type . ASSIGN LBRACKET values RBRACKET

    SEMICOLON       reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    PRINT           reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    PRINTF          reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    INPUT           reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    LPAREN          reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    FUNCTION        reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    VAR             reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    VARIABLE        reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    CONST           reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    RETURN          reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    TYPE            reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    IF              reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    SWITCH          reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    CHARSTRING      reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    FOR             reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    INT             reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    FLOAT           reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    $end            reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    RBRACE          reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    CASE            reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    DEFAULT         reduce using rule 147 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    ASSIGN          shift and go to state 313


state 295

    (146) struct_field -> VARIABLE type .

    VARIABLE        reduce using rule 146 (struct_field -> VARIABLE type .)
    RBRACE          reduce using rule 146 (struct_field -> VARIABLE type .)


state 296

    (143) struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .

    SEMICOLON       reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    PRINT           reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    PRINTF          reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    INPUT           reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    LPAREN          reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FUNCTION        reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    VAR             reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    VARIABLE        reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CONST           reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    RETURN          reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    TYPE            reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    IF              reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    SWITCH          reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CHARSTRING      reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FOR             reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    INT             reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FLOAT           reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    $end            reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    RBRACE          reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CASE            reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    DEFAULT         reduce using rule 143 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)


state 297

    (145) struct_fields -> struct_field struct_fields .

    RBRACE          reduce using rule 145 (struct_fields -> struct_field struct_fields .)


state 298

    (109) conditional_structure -> IF conditions conditional_body ELSE IF conditions . conditional_body ELSE conditional_body
    (110) conditional_body -> . LBRACE statement RBRACE
    (111) conditional_body -> . LBRACE BREAK RBRACE
    (112) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 169

    conditional_body               shift and go to state 314

state 299

    (136) case_block -> CASE values COLON . statement
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! LPAREN          [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 315
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 300

    (137) case_block -> DEFAULT COLON statement .

    CASE            reduce using rule 137 (case_block -> DEFAULT COLON statement .)
    DEFAULT         reduce using rule 137 (case_block -> DEFAULT COLON statement .)
    RBRACE          reduce using rule 137 (case_block -> DEFAULT COLON statement .)


state 301

    (128) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition . SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 316


state 302

    (130) for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE . VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 317


state 303

    (151) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type . LBRACE map_values RBRACE

    LBRACE          shift and go to state 318


state 304

    (157) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values . RBRACE

    RBRACE          shift and go to state 319


state 305

    (152) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN

    RBRACKET        shift and go to state 320


state 306

    (161) append_statement -> APPEND LPAREN VARIABLE COMMA values . RPAREN

    RPAREN          shift and go to state 321


state 307

    (162) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET . RBRACKET type LBRACE values RBRACE RPAREN

    RBRACKET        shift and go to state 322


state 308

    (51) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .

    SEMICOLON       reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    PRINT           reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    LPAREN          reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CONST           reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    RETURN          reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CASE            reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)


state 309

    (52) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks . RBRACE

    RBRACE          shift and go to state 323


state 310

    (53) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 324


state 311

    (54) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    FUNCTION        shift and go to state 60
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    parameters                     shift and go to state 19
    blocks                         shift and go to state 325
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 312

    (148) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type . LBRACE values RBRACE

    LBRACE          shift and go to state 326


state 313

    (149) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN . LBRACKET values RBRACKET

    LBRACKET        shift and go to state 327


state 314

    (109) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body . ELSE conditional_body

    ELSE            shift and go to state 328


state 315

    (136) case_block -> CASE values COLON statement .

    CASE            reduce using rule 136 (case_block -> CASE values COLON statement .)
    DEFAULT         reduce using rule 136 (case_block -> CASE values COLON statement .)
    RBRACE          reduce using rule 136 (case_block -> CASE values COLON statement .)


state 316

    (128) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON . value double_operator LBRACE statement RBRACE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 329
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 317

    (130) for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE . LBRACE statement RBRACE

    LBRACE          shift and go to state 330


state 318

    (151) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE . map_values RBRACE
    (153) map_values -> . map_value
    (154) map_values -> . map_value COMMA map_values
    (155) map_value -> . value COLON value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    map_values                     shift and go to state 331
    map_value                      shift and go to state 332
    value                          shift and go to state 333
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 319

    (157) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .

    SEMICOLON       reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    PRINT           reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    PRINTF          reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    INPUT           reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    LPAREN          reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FUNCTION        reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    VAR             reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    VARIABLE        reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CONST           reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    RETURN          reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    TYPE            reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    IF              reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    SWITCH          reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FOR             reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    INT             reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FLOAT           reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    $end            reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    RBRACE          reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CASE            reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    DEFAULT         reduce using rule 157 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)


state 320

    (152) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

    type                           shift and go to state 334

state 321

    (161) append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .

    SEMICOLON       reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    PRINT           reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    PRINTF          reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    INPUT           reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    LPAREN          reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FUNCTION        reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    VAR             reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    VARIABLE        reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CONST           reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    RETURN          reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    TYPE            reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    IF              reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    SWITCH          reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CHARSTRING      reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FOR             reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    INT             reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FLOAT           reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    $end            reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    RBRACE          reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CASE            reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    DEFAULT         reduce using rule 161 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)


state 322

    (162) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET . type LBRACE values RBRACE RPAREN
    (96) type -> . INT
    (97) type -> . INT32
    (98) type -> . INT64
    (99) type -> . STRING
    (100) type -> . FLOAT
    (101) type -> . FLOAT32
    (102) type -> . FLOAT64
    (103) type -> . BOOL

    INT             shift and go to state 74
    INT32           shift and go to state 82
    INT64           shift and go to state 83
    STRING          shift and go to state 84
    FLOAT           shift and go to state 85
    FLOAT32         shift and go to state 86
    FLOAT64         shift and go to state 87
    BOOL            shift and go to state 88

    type                           shift and go to state 335

state 323

    (52) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .

    SEMICOLON       reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    PRINT           reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    INPUT           reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    LPAREN          reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    VAR             reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    CONST           reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    RETURN          reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    TYPE            reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    IF              reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    FOR             reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    INT             reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    $end            reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    CASE            reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)


state 324

    (53) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .

    SEMICOLON       reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    PRINT           reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    LPAREN          reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CONST           reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    RETURN          reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CASE            reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 53 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)


state 325

    (54) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks . RBRACE

    RBRACE          shift and go to state 336


state 326

    (148) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE . values RBRACE
    (60) values -> . value
    (61) values -> . value COMMA values
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    values                         shift and go to state 337
    value                          shift and go to state 253
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 327

    (149) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET . values RBRACKET
    (60) values -> . value
    (61) values -> . value COMMA values
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    values                         shift and go to state 338
    value                          shift and go to state 253
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 328

    (109) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE . conditional_body
    (110) conditional_body -> . LBRACE statement RBRACE
    (111) conditional_body -> . LBRACE BREAK RBRACE
    (112) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 169

    conditional_body               shift and go to state 339

state 329

    (128) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value . double_operator LBRACE statement RBRACE
    (91) double_operator -> . INCREMENT
    (92) double_operator -> . DECREMENT

    INCREMENT       shift and go to state 80
    DECREMENT       shift and go to state 81

    double_operator                shift and go to state 340

state 330

    (130) for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! LPAREN          [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 341
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    value                          shift and go to state 26
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 331

    (151) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values . RBRACE

    RBRACE          shift and go to state 342


state 332

    (153) map_values -> map_value .
    (154) map_values -> map_value . COMMA map_values

    RBRACE          reduce using rule 153 (map_values -> map_value .)
    COMMA           shift and go to state 343


state 333

    (155) map_value -> value . COLON value

    COLON           shift and go to state 344


state 334

    (152) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN

    RPAREN          shift and go to state 345


state 335

    (162) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type . LBRACE values RBRACE RPAREN

    LBRACE          shift and go to state 346


state 336

    (54) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .

    SEMICOLON       reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    PRINT           reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    INPUT           reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    LPAREN          reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    VAR             reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    CONST           reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    RETURN          reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    TYPE            reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    IF              reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    FOR             reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    INT             reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    $end            reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    CASE            reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 54 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)


state 337

    (148) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values . RBRACE

    RBRACE          shift and go to state 347


state 338

    (149) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values . RBRACKET

    RBRACKET        shift and go to state 348


state 339

    (109) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .

    SEMICOLON       reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    PRINT           reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    PRINTF          reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    LPAREN          reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CONST           reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RETURN          reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    SWITCH          reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CHARSTRING      reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CASE            reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    DEFAULT         reduce using rule 109 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)


state 340

    (128) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator . LBRACE statement RBRACE

    LBRACE          shift and go to state 349


state 341

    (130) for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement . RBRACE

    RBRACE          shift and go to state 350


state 342

    (151) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .

    SEMICOLON       reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    PRINT           reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    PRINTF          reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INPUT           reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    LPAREN          reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FUNCTION        reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VAR             reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VARIABLE        reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CONST           reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RETURN          reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    TYPE            reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    IF              reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    SWITCH          reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CHARSTRING      reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FOR             reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INT             reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FLOAT           reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    $end            reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RBRACE          reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CASE            reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    DEFAULT         reduce using rule 151 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)


state 343

    (154) map_values -> map_value COMMA . map_values
    (153) map_values -> . map_value
    (154) map_values -> . map_value COMMA map_values
    (155) map_value -> . value COLON value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    map_value                      shift and go to state 332
    map_values                     shift and go to state 351
    value                          shift and go to state 333
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 344

    (155) map_value -> value COLON . value
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    value                          shift and go to state 352
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 345

    (152) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .

    SEMICOLON       reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    PRINT           reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    PRINTF          reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INPUT           reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LPAREN          reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FUNCTION        reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VAR             reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CONST           reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RETURN          reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TYPE            reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    IF              reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SWITCH          reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CHARSTRING      reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FOR             reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INT             reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FLOAT           reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    $end            reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RBRACE          reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CASE            reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 152 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)


state 346

    (162) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE . values RBRACE RPAREN
    (60) values -> . value
    (61) values -> . value COMMA values
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (68) number -> . INT
    (69) number -> . FLOAT

    VARIABLE        shift and go to state 64
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

    values                         shift and go to state 353
    value                          shift and go to state 253
    not_variable_value             shift and go to state 41
    number                         shift and go to state 49

state 347

    (148) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .

    SEMICOLON       reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    PRINT           reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    PRINTF          reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    INPUT           reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    LPAREN          reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    FUNCTION        reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    VAR             reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    VARIABLE        reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    CONST           reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    RETURN          reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    TYPE            reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    IF              reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    SWITCH          reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    FOR             reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    INT             reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    FLOAT           reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    $end            reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    RBRACE          reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    CASE            reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    DEFAULT         reduce using rule 148 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)


state 348

    (149) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .

    SEMICOLON       reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    PRINT           reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    PRINTF          reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    INPUT           reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    LPAREN          reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    FUNCTION        reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    VAR             reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    VARIABLE        reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    CONST           reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    RETURN          reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    TYPE            reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    IF              reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    SWITCH          reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    CHARSTRING      reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    FOR             reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    INT             reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    FLOAT           reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    $end            reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    RBRACE          reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    CASE            reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)
    DEFAULT         reduce using rule 149 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET .)


state 349

    (128) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) blocks -> . block SEMICOLON blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (20) block -> . print_statement
    (21) block -> . input_statement
    (22) block -> . operation
    (23) block -> . data_structure
    (24) block -> . control_structure
    (25) block -> . function
    (26) block -> . parameters
    (27) block -> . variable_declaration
    (28) block -> . variable_assignation
    (29) block -> . return
    (70) print_statement -> . PRINT LPAREN values RPAREN
    (71) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (72) print_statement -> . PRINT LPAREN operation RPAREN
    (73) print_statement -> . PRINT LPAREN RPAREN
    (74) input_statement -> . INPUT LPAREN values RPAREN
    (75) input_statement -> . INPUT LPAREN operation RPAREN
    (76) input_statement -> . INPUT LPAREN RPAREN
    (77) operation -> . value operator value
    (78) operation -> . value operator LPAREN value RPAREN
    (79) operation -> . LPAREN value RPAREN operator value
    (80) operation -> . LPAREN value operator value RPAREN
    (81) operation -> . value operator operation
    (82) operation -> . LPAREN value operator operation RPAREN
    (83) operation -> . LPAREN value RPAREN operator operation
    (84) operation -> . value operator LPAREN operation RPAREN
    (85) operation -> . value double_operator
    (139) data_structure -> . array_structure
    (140) data_structure -> . map_structure
    (141) data_structure -> . slice_structure
    (142) data_structure -> . struct_structure
    (104) control_structure -> . conditional_structure
    (105) control_structure -> . for_estructure
    (106) control_structure -> . switch_structure
    (51) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (53) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (54) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (93) parameters -> . parameter
    (94) parameters -> . parameter COMMA parameters
    (30) variable_declaration -> . VAR VARIABLE type
    (31) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN value
    (33) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (34) variable_declaration -> . VAR variables type
    (35) variable_declaration -> . VAR variables type ASSIGN value
    (36) variable_declaration -> . CONST VARIABLE ASSIGN value
    (37) variable_assignation -> . VARIABLE assignation value
    (38) variable_assignation -> . VARIABLE assignation operation
    (39) variable_assignation -> . VARIABLE double_operator
    (40) variable_assignation -> . variables assignation value
    (41) variable_assignation -> . map_assign
    (42) variable_assignation -> . array_assign
    (55) return -> . RETURN value
    (56) return -> . RETURN value LBRACKET value RBRACKET
    (57) return -> . RETURN value PERIOD value
    (58) return -> . RETURN TRUE
    (59) return -> . RETURN FALSE
    (62) value -> . VARIABLE
    (63) value -> . VARIABLE LBRACKET RBRACKET
    (64) value -> . VARIABLE LBRACKET value RBRACKET
    (65) value -> . not_variable_value
    (147) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (148) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (149) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type ASSIGN LBRACKET values RBRACKET
    (151) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (152) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (157) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (158) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (159) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (160) slice_structure -> . VARIABLE ASSIGN append_statement
    (143) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (107) conditional_structure -> . IF conditions conditional_body
    (108) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (109) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (125) for_estructure -> . for_initialization
    (126) for_estructure -> . for_infinite_bucle
    (127) for_estructure -> . for_iterator
    (131) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (95) parameter -> . VARIABLE type
    (43) variables -> . VARIABLE
    (44) variables -> . VARIABLE COMMA variables
    (156) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (150) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (66) not_variable_value -> . CHARSTRING
    (67) not_variable_value -> . number
    (128) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (129) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (130) for_iterator -> . FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (68) number -> . INT
    (69) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 23
    PRINTF          shift and go to state 24
    INPUT           shift and go to state 25
    LPAREN          shift and go to state 9
    VAR             shift and go to state 35
    VARIABLE        shift and go to state 11
    CONST           shift and go to state 37
    RETURN          shift and go to state 40
    TYPE            shift and go to state 43
    IF              shift and go to state 44
    SWITCH          shift and go to state 48
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 51

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! LPAREN          [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    value                          shift and go to state 26
    statement                      shift and go to state 354
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    operation                      shift and go to state 15
    data_structure                 shift and go to state 16
    control_structure              shift and go to state 17
    function                       shift and go to state 18
    parameters                     shift and go to state 19
    variable_declaration           shift and go to state 20
    variable_assignation           shift and go to state 21
    return                         shift and go to state 22
    array_structure                shift and go to state 27
    map_structure                  shift and go to state 28
    slice_structure                shift and go to state 29
    struct_structure               shift and go to state 30
    conditional_structure          shift and go to state 31
    for_estructure                 shift and go to state 32
    switch_structure               shift and go to state 33
    parameter                      shift and go to state 34
    variables                      shift and go to state 36
    map_assign                     shift and go to state 38
    array_assign                   shift and go to state 39
    not_variable_value             shift and go to state 41
    for_initialization             shift and go to state 45
    for_infinite_bucle             shift and go to state 46
    for_iterator                   shift and go to state 47
    number                         shift and go to state 49

state 350

    (130) for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .

    SEMICOLON       reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    PRINT           reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    PRINTF          reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INPUT           reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    LPAREN          reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VAR             reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CONST           reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RETURN          reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    TYPE            reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    IF              reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    SWITCH          reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FOR             reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INT             reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FLOAT           reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    $end            reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RBRACE          reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CASE            reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 130 (for_iterator -> FOR VARIABLE COMMA VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)


state 351

    (154) map_values -> map_value COMMA map_values .

    RBRACE          reduce using rule 154 (map_values -> map_value COMMA map_values .)


state 352

    (155) map_value -> value COLON value .

    COMMA           reduce using rule 155 (map_value -> value COLON value .)
    RBRACE          reduce using rule 155 (map_value -> value COLON value .)


state 353

    (162) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values . RBRACE RPAREN

    RBRACE          shift and go to state 355


state 354

    (128) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement . RBRACE

    RBRACE          shift and go to state 356


state 355

    (162) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE . RPAREN

    RPAREN          shift and go to state 357


state 356

    (128) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .

    SEMICOLON       reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    PRINT           reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    PRINTF          reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INPUT           reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    LPAREN          reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VAR             reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CONST           reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RETURN          reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    TYPE            reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    IF              reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    SWITCH          reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FOR             reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INT             reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FLOAT           reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    $end            reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RBRACE          reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CASE            reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 128 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)


state 357

    (162) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .

    SEMICOLON       reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    PRINT           reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    PRINTF          reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    INPUT           reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    LPAREN          reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    FUNCTION        reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    VAR             reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    VARIABLE        reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    CONST           reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    RETURN          reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    TYPE            reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    IF              reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    SWITCH          reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    CHARSTRING      reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    FOR             reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    INT             reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    FLOAT           reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    $end            reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    RBRACE          reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    CASE            reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    DEFAULT         reduce using rule 162 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FUNCTION in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 0 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 0 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 0 resolved as shift
WARNING: shift/reduce conflict for VAR in state 0 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 0 resolved as shift
WARNING: shift/reduce conflict for CONST in state 0 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 0 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 0 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 4 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 4 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 4 resolved as shift
WARNING: shift/reduce conflict for VAR in state 4 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 4 resolved as shift
WARNING: shift/reduce conflict for CONST in state 4 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 4 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 4 resolved as shift
WARNING: shift/reduce conflict for IF in state 4 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 4 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 4 resolved as shift
WARNING: shift/reduce conflict for FOR in state 4 resolved as shift
WARNING: shift/reduce conflict for INT in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 11 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 11 resolved as shift
WARNING: shift/reduce conflict for PLUSASSIGN in state 11 resolved as shift
WARNING: shift/reduce conflict for MINUSASSIGN in state 11 resolved as shift
WARNING: shift/reduce conflict for TIMESASSIGN in state 11 resolved as shift
WARNING: shift/reduce conflict for DIVIDEASSIGN in state 11 resolved as shift
WARNING: shift/reduce conflict for MODASSIGN in state 11 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 11 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 11 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 64 resolved as shift
WARNING: shift/reduce conflict for INT in state 102 resolved as shift
WARNING: shift/reduce conflict for INT32 in state 102 resolved as shift
WARNING: shift/reduce conflict for INT64 in state 102 resolved as shift
WARNING: shift/reduce conflict for STRING in state 102 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 102 resolved as shift
WARNING: shift/reduce conflict for FLOAT32 in state 102 resolved as shift
WARNING: shift/reduce conflict for FLOAT64 in state 102 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 102 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 118 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 118 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 118 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 118 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 118 resolved as shift
WARNING: shift/reduce conflict for VAR in state 118 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 118 resolved as shift
WARNING: shift/reduce conflict for CONST in state 118 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 118 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 118 resolved as shift
WARNING: shift/reduce conflict for IF in state 118 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 118 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 118 resolved as shift
WARNING: shift/reduce conflict for FOR in state 118 resolved as shift
WARNING: shift/reduce conflict for INT in state 118 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 118 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 139 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 169 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 169 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 169 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 169 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 169 resolved as shift
WARNING: shift/reduce conflict for VAR in state 169 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 169 resolved as shift
WARNING: shift/reduce conflict for CONST in state 169 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 169 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 169 resolved as shift
WARNING: shift/reduce conflict for IF in state 169 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 169 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 169 resolved as shift
WARNING: shift/reduce conflict for FOR in state 169 resolved as shift
WARNING: shift/reduce conflict for INT in state 169 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 169 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 199 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 276 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 276 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 276 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 276 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 276 resolved as shift
WARNING: shift/reduce conflict for VAR in state 276 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 276 resolved as shift
WARNING: shift/reduce conflict for CONST in state 276 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 276 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 276 resolved as shift
WARNING: shift/reduce conflict for IF in state 276 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 276 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 276 resolved as shift
WARNING: shift/reduce conflict for FOR in state 276 resolved as shift
WARNING: shift/reduce conflict for INT in state 276 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 276 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 291 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 292 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 299 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 299 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 299 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 299 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 299 resolved as shift
WARNING: shift/reduce conflict for VAR in state 299 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 299 resolved as shift
WARNING: shift/reduce conflict for CONST in state 299 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 299 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 299 resolved as shift
WARNING: shift/reduce conflict for IF in state 299 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 299 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 299 resolved as shift
WARNING: shift/reduce conflict for FOR in state 299 resolved as shift
WARNING: shift/reduce conflict for INT in state 299 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 299 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 330 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 330 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 330 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 330 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 330 resolved as shift
WARNING: shift/reduce conflict for VAR in state 330 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 330 resolved as shift
WARNING: shift/reduce conflict for CONST in state 330 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 330 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 330 resolved as shift
WARNING: shift/reduce conflict for IF in state 330 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 330 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 330 resolved as shift
WARNING: shift/reduce conflict for FOR in state 330 resolved as shift
WARNING: shift/reduce conflict for INT in state 330 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 330 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 349 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 349 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 349 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 349 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 349 resolved as shift
WARNING: shift/reduce conflict for VAR in state 349 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 349 resolved as shift
WARNING: shift/reduce conflict for CONST in state 349 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 349 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 349 resolved as shift
WARNING: shift/reduce conflict for IF in state 349 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 349 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 349 resolved as shift
WARNING: shift/reduce conflict for FOR in state 349 resolved as shift
WARNING: shift/reduce conflict for INT in state 349 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 349 resolved as shift
