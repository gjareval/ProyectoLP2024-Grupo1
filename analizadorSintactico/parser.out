Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    CONST
    DIVIDEASSIGN
    FALSE
    IDENTIFIER
    IMPORT
    MINUSASSIGN
    MOD
    MODASSIGN
    PLUSASSIGN
    TEXT
    TIMESASSIGN
    TRUE

Grammar

Rule 0     S' -> statement
Rule 1     statement -> blocks
Rule 2     statement -> package blocks
Rule 3     statement -> main LBRACE blocks RBRACE
Rule 4     statement -> package main LBRACE blocks RBRACE
Rule 5     package -> PACKAGE VARIABLE
Rule 6     main -> FUNCTION MAIN LPAREN RPAREN
Rule 7     blocks -> block
Rule 8     blocks -> block blocks
Rule 9     block -> print_statement
Rule 10    block -> input_statement
Rule 11    block -> conditional_structure
Rule 12    block -> operation
Rule 13    block -> list_structure
Rule 14    block -> map_estructure
Rule 15    block -> map_assign
Rule 16    block -> for_estructure
Rule 17    block -> structure
Rule 18    block -> function
Rule 19    block -> parameters
Rule 20    block -> variable_declaration
Rule 21    block -> switch_structure
Rule 22    block -> slice_structure
Rule 23    variable_declaration -> VAR VARIABLE type
Rule 24    variable_declaration -> VAR VARIABLE ASSIGN value
Rule 25    variable_declaration -> VARIABLE SHORTASSIGN value
Rule 26    variable_declaration -> VARIABLE SHORTASSIGN operation
Rule 27    structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE
Rule 28    function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
Rule 29    function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
Rule 30    function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
Rule 31    function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
Rule 32    values -> value
Rule 33    values -> value COMMA values
Rule 34    string_value -> value
Rule 35    string_value -> CHARSTRING
Rule 36    value -> VARIABLE
Rule 37    value -> number
Rule 38    value -> CHARSTRING
Rule 39    number -> INT
Rule 40    number -> FLOAT
Rule 41    print_statement -> PRINT LPAREN values RPAREN
Rule 42    print_statement -> PRINT LPAREN string_value RPAREN
Rule 43    print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN
Rule 44    print_statement -> PRINT LPAREN string_value COMMA values RPAREN
Rule 45    print_statement -> PRINT LPAREN operation RPAREN
Rule 46    print_statement -> PRINT LPAREN RPAREN
Rule 47    input_statement -> INPUT LPAREN values RPAREN
Rule 48    input_statement -> INPUT LPAREN operation RPAREN
Rule 49    input_statement -> INPUT LPAREN RPAREN
Rule 50    operation -> value operator value
Rule 51    operation -> value operator operation
Rule 52    operation -> value double_operator
Rule 53    operator -> PLUS
Rule 54    operator -> MINUS
Rule 55    operator -> TIMES
Rule 56    operator -> DIVIDE
Rule 57    operator -> ASSIGN
Rule 58    double_operator -> INCREMENT
Rule 59    double_operator -> DECREMENT
Rule 60    parameters -> parameter
Rule 61    parameters -> parameter parameters
Rule 62    parameters -> parameter COMMA parameters
Rule 63    parameter -> VARIABLE type
Rule 64    type -> INT
Rule 65    type -> INT32
Rule 66    type -> INT64
Rule 67    type -> STRING
Rule 68    type -> FLOAT
Rule 69    type -> FLOAT32
Rule 70    type -> FLOAT64
Rule 71    type -> BOOL
Rule 72    conditional_structure -> IF conditions conditional_body
Rule 73    conditional_structure -> IF conditions conditional_body ELSE conditional_body
Rule 74    conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
Rule 75    conditional_body -> LBRACE statement RBRACE
Rule 76    conditional_body -> LBRACE BREAK RBRACE
Rule 77    conditional_body -> LBRACE CONTINUE RBRACE
Rule 78    conditions -> condition
Rule 79    conditions -> condition logical_operator conditions
Rule 80    condition -> value relational_operator value
Rule 81    logical_operator -> AND
Rule 82    logical_operator -> OR
Rule 83    logical_operator -> NOT
Rule 84    relational_operator -> GREATER
Rule 85    relational_operator -> LESS
Rule 86    relational_operator -> GREATEREQUALS
Rule 87    relational_operator -> LESSEQUALS
Rule 88    relational_operator -> EQUALS
Rule 89    relational_operator -> DIFFERENT
Rule 90    for_estructure -> for_initialization
Rule 91    for_estructure -> for_infinite_bucle
Rule 92    for_estructure -> for_iterator
Rule 93    for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
Rule 94    for_infinite_bucle -> FOR LBRACE statement RBRACE
Rule 95    for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
Rule 96    switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE
Rule 97    switch_expression -> value
Rule 98    switch_expression -> empty
Rule 99    case_blocks -> case_block
Rule 100   case_blocks -> case_block case_blocks
Rule 101   case_block -> CASE values COLON statement
Rule 102   case_block -> DEFAULT COLON statement
Rule 103   empty -> <empty>
Rule 104   list_structure -> empty_list
Rule 105   list_structure -> list_with_data
Rule 106   list_structure -> defined_list
Rule 107   empty_list -> LBRACE RBRACE
Rule 108   list_with_data -> LBRACE values RBRACE
Rule 109   defined_list -> TYPE VARIABLE LBRACE values RBRACE
Rule 110   map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
Rule 111   map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
Rule 112   map_values -> map_value
Rule 113   map_values -> map_value COMMA map_values
Rule 114   map_value -> string_value COLON string_value
Rule 115   map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
Rule 116   slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
Rule 117   slice_structure -> VAR VARIABLE LBRACKET RBRACKET type
Rule 118   slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type
Rule 119   slice_structure -> VARIABLE ASSIGN append_statement
Rule 120   append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 81
APPEND               : 120
ASSIGN               : 24 57 115 119
BOOL                 : 71
BREAK                : 76
CASE                 : 101
CHARSTRING           : 35 38
COLON                : 101 102 114
COMMA                : 33 43 44 62 113 120
CONST                : 
CONTINUE             : 77
DECREMENT            : 59
DEFAULT              : 102
DIFFERENT            : 89
DIVIDE               : 56
DIVIDEASSIGN         : 
ELSE                 : 73 74 74
EQUALS               : 88
FALSE                : 
FLOAT                : 40 68
FLOAT32              : 69
FLOAT64              : 70
FOR                  : 93 94 95
FORMATSTRING         : 43
FUNCTION             : 6 28 29 30 31
GREATER              : 84
GREATEREQUALS        : 86
IDENTIFIER           : 
IF                   : 72 73 74 74
IMPORT               : 
INCREMENT            : 58
INPUT                : 47 48 49
INT                  : 39 64
INT32                : 65
INT64                : 66
LBRACE               : 3 4 27 28 29 30 31 75 76 77 93 94 95 96 107 108 109 110 116
LBRACKET             : 110 111 115 116 117 118
LESS                 : 85
LESSEQUALS           : 87
LPAREN               : 6 28 29 30 31 41 42 43 44 45 46 47 48 49 111 120
MAIN                 : 6
MAKE                 : 111
MAP                  : 110 111
MINUS                : 54
MINUSASSIGN          : 
MOD                  : 
MODASSIGN            : 
NOT                  : 83
OR                   : 82
PACKAGE              : 5
PLUS                 : 53
PLUSASSIGN           : 
PRINT                : 41 42 44 45 46
PRINTF               : 43
RANGE                : 95
RBRACE               : 3 4 27 28 29 30 31 75 76 77 93 94 95 96 107 108 109 110 116
RBRACKET             : 110 111 115 116 117 118
RETURN               : 30 31
RPAREN               : 6 28 29 30 31 41 42 43 44 45 46 47 48 49 111 120
SEMICOLON            : 93 93 95
SHORTASSIGN          : 25 26 93 95 110 111 116 118
STRING               : 67
STRUCT               : 27
SWITCH               : 96
TEXT                 : 
TIMES                : 55
TIMESASSIGN          : 
TRUE                 : 
TYPE                 : 27 109
VAR                  : 23 24 117
VARIABLE             : 5 23 24 25 26 27 28 29 30 31 36 63 93 95 95 95 109 110 111 115 116 117 118 119 120
error                : 

Nonterminals, with rules where they appear

append_statement     : 119
block                : 7 8
blocks               : 1 2 3 4 8 28 29
case_block           : 99 100
case_blocks          : 96 100
condition            : 78 79 93
conditional_body     : 72 73 73 74 74 74
conditional_structure : 11
conditions           : 72 73 74 74 79
defined_list         : 106
double_operator      : 52 93
empty                : 98
empty_list           : 104
for_estructure       : 16
for_infinite_bucle   : 91
for_initialization   : 90
for_iterator         : 92
function             : 18
input_statement      : 10
list_structure       : 13
list_with_data       : 105
logical_operator     : 79
main                 : 3 4
map_assign           : 15
map_estructure       : 14
map_value            : 112 113
map_values           : 110 113
number               : 37
operation            : 12 26 45 48 51
operator             : 50 51
package              : 2 4
parameter            : 60 61 62
parameters           : 19 29 31 61 62
print_statement      : 9
relational_operator  : 80
slice_structure      : 22
statement            : 27 75 93 94 95 101 102 0
string_value         : 42 44 114 114 115 115
structure            : 17
switch_expression    : 96
switch_structure     : 21
type                 : 23 30 31 63 110 110 111 111 116 117 118
value                : 24 25 30 31 32 33 34 50 50 51 52 80 80 93 93 97
values               : 33 41 43 44 47 101 108 109 116 120
variable_declaration : 20

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . blocks
    (2) statement -> . package blocks
    (3) statement -> . main LBRACE blocks RBRACE
    (4) statement -> . package main LBRACE blocks RBRACE
    (7) blocks -> . block
    (8) blocks -> . block blocks
    (5) package -> . PACKAGE VARIABLE
    (6) main -> . FUNCTION MAIN LPAREN RPAREN
    (9) block -> . print_statement
    (10) block -> . input_statement
    (11) block -> . conditional_structure
    (12) block -> . operation
    (13) block -> . list_structure
    (14) block -> . map_estructure
    (15) block -> . map_assign
    (16) block -> . for_estructure
    (17) block -> . structure
    (18) block -> . function
    (19) block -> . parameters
    (20) block -> . variable_declaration
    (21) block -> . switch_structure
    (22) block -> . slice_structure
    (41) print_statement -> . PRINT LPAREN values RPAREN
    (42) print_statement -> . PRINT LPAREN string_value RPAREN
    (43) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (44) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (45) print_statement -> . PRINT LPAREN operation RPAREN
    (46) print_statement -> . PRINT LPAREN RPAREN
    (47) input_statement -> . INPUT LPAREN values RPAREN
    (48) input_statement -> . INPUT LPAREN operation RPAREN
    (49) input_statement -> . INPUT LPAREN RPAREN
    (72) conditional_structure -> . IF conditions conditional_body
    (73) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (74) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (104) list_structure -> . empty_list
    (105) list_structure -> . list_with_data
    (106) list_structure -> . defined_list
    (110) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (115) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (90) for_estructure -> . for_initialization
    (91) for_estructure -> . for_infinite_bucle
    (92) for_estructure -> . for_iterator
    (27) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (28) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (23) variable_declaration -> . VAR VARIABLE type
    (24) variable_declaration -> . VAR VARIABLE ASSIGN value
    (25) variable_declaration -> . VARIABLE SHORTASSIGN value
    (26) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (96) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (116) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (117) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (118) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (119) slice_structure -> . VARIABLE ASSIGN append_statement
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (107) empty_list -> . LBRACE RBRACE
    (108) list_with_data -> . LBRACE values RBRACE
    (109) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (93) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (94) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (95) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (63) parameter -> . VARIABLE type
    (39) number -> . INT
    (40) number -> . FLOAT

    PACKAGE         shift and go to state 7
    FUNCTION        shift and go to state 9
    PRINT           shift and go to state 24
    PRINTF          shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 27
    VARIABLE        shift and go to state 8
    TYPE            shift and go to state 35
    VAR             shift and go to state 37
    SWITCH          shift and go to state 38
    CHARSTRING      shift and go to state 40
    LBRACE          shift and go to state 5
    FOR             shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    statement                      shift and go to state 1
    blocks                         shift and go to state 2
    package                        shift and go to state 3
    main                           shift and go to state 4
    block                          shift and go to state 6
    print_statement                shift and go to state 10
    input_statement                shift and go to state 11
    conditional_structure          shift and go to state 12
    operation                      shift and go to state 13
    list_structure                 shift and go to state 14
    map_estructure                 shift and go to state 15
    map_assign                     shift and go to state 16
    for_estructure                 shift and go to state 17
    structure                      shift and go to state 18
    function                       shift and go to state 19
    parameters                     shift and go to state 20
    variable_declaration           shift and go to state 21
    switch_structure               shift and go to state 22
    slice_structure                shift and go to state 23
    value                          shift and go to state 28
    empty_list                     shift and go to state 29
    list_with_data                 shift and go to state 30
    defined_list                   shift and go to state 31
    for_initialization             shift and go to state 32
    for_infinite_bucle             shift and go to state 33
    for_iterator                   shift and go to state 34
    parameter                      shift and go to state 36
    number                         shift and go to state 39

state 1

    (0) S' -> statement .



state 2

    (1) statement -> blocks .

    $end            reduce using rule 1 (statement -> blocks .)
    RBRACE          reduce using rule 1 (statement -> blocks .)
    CASE            reduce using rule 1 (statement -> blocks .)
    DEFAULT         reduce using rule 1 (statement -> blocks .)


state 3

    (2) statement -> package . blocks
    (4) statement -> package . main LBRACE blocks RBRACE
    (7) blocks -> . block
    (8) blocks -> . block blocks
    (6) main -> . FUNCTION MAIN LPAREN RPAREN
    (9) block -> . print_statement
    (10) block -> . input_statement
    (11) block -> . conditional_structure
    (12) block -> . operation
    (13) block -> . list_structure
    (14) block -> . map_estructure
    (15) block -> . map_assign
    (16) block -> . for_estructure
    (17) block -> . structure
    (18) block -> . function
    (19) block -> . parameters
    (20) block -> . variable_declaration
    (21) block -> . switch_structure
    (22) block -> . slice_structure
    (41) print_statement -> . PRINT LPAREN values RPAREN
    (42) print_statement -> . PRINT LPAREN string_value RPAREN
    (43) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (44) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (45) print_statement -> . PRINT LPAREN operation RPAREN
    (46) print_statement -> . PRINT LPAREN RPAREN
    (47) input_statement -> . INPUT LPAREN values RPAREN
    (48) input_statement -> . INPUT LPAREN operation RPAREN
    (49) input_statement -> . INPUT LPAREN RPAREN
    (72) conditional_structure -> . IF conditions conditional_body
    (73) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (74) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (104) list_structure -> . empty_list
    (105) list_structure -> . list_with_data
    (106) list_structure -> . defined_list
    (110) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (115) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (90) for_estructure -> . for_initialization
    (91) for_estructure -> . for_infinite_bucle
    (92) for_estructure -> . for_iterator
    (27) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (28) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (23) variable_declaration -> . VAR VARIABLE type
    (24) variable_declaration -> . VAR VARIABLE ASSIGN value
    (25) variable_declaration -> . VARIABLE SHORTASSIGN value
    (26) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (96) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (116) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (117) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (118) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (119) slice_structure -> . VARIABLE ASSIGN append_statement
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (107) empty_list -> . LBRACE RBRACE
    (108) list_with_data -> . LBRACE values RBRACE
    (109) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (93) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (94) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (95) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (63) parameter -> . VARIABLE type
    (39) number -> . INT
    (40) number -> . FLOAT

    FUNCTION        shift and go to state 9
    PRINT           shift and go to state 24
    PRINTF          shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 27
    VARIABLE        shift and go to state 8
    TYPE            shift and go to state 35
    VAR             shift and go to state 37
    SWITCH          shift and go to state 38
    CHARSTRING      shift and go to state 40
    LBRACE          shift and go to state 5
    FOR             shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    blocks                         shift and go to state 44
    main                           shift and go to state 45
    block                          shift and go to state 6
    print_statement                shift and go to state 10
    input_statement                shift and go to state 11
    conditional_structure          shift and go to state 12
    operation                      shift and go to state 13
    list_structure                 shift and go to state 14
    map_estructure                 shift and go to state 15
    map_assign                     shift and go to state 16
    for_estructure                 shift and go to state 17
    structure                      shift and go to state 18
    function                       shift and go to state 19
    parameters                     shift and go to state 20
    variable_declaration           shift and go to state 21
    switch_structure               shift and go to state 22
    slice_structure                shift and go to state 23
    value                          shift and go to state 28
    empty_list                     shift and go to state 29
    list_with_data                 shift and go to state 30
    defined_list                   shift and go to state 31
    for_initialization             shift and go to state 32
    for_infinite_bucle             shift and go to state 33
    for_iterator                   shift and go to state 34
    parameter                      shift and go to state 36
    number                         shift and go to state 39

state 4

    (3) statement -> main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 46


state 5

    (107) empty_list -> LBRACE . RBRACE
    (108) list_with_data -> LBRACE . values RBRACE
    (32) values -> . value
    (33) values -> . value COMMA values
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    RBRACE          shift and go to state 47
    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    values                         shift and go to state 48
    value                          shift and go to state 49
    number                         shift and go to state 39

state 6

    (7) blocks -> block .
    (8) blocks -> block . blocks
    (7) blocks -> . block
    (8) blocks -> . block blocks
    (9) block -> . print_statement
    (10) block -> . input_statement
    (11) block -> . conditional_structure
    (12) block -> . operation
    (13) block -> . list_structure
    (14) block -> . map_estructure
    (15) block -> . map_assign
    (16) block -> . for_estructure
    (17) block -> . structure
    (18) block -> . function
    (19) block -> . parameters
    (20) block -> . variable_declaration
    (21) block -> . switch_structure
    (22) block -> . slice_structure
    (41) print_statement -> . PRINT LPAREN values RPAREN
    (42) print_statement -> . PRINT LPAREN string_value RPAREN
    (43) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (44) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (45) print_statement -> . PRINT LPAREN operation RPAREN
    (46) print_statement -> . PRINT LPAREN RPAREN
    (47) input_statement -> . INPUT LPAREN values RPAREN
    (48) input_statement -> . INPUT LPAREN operation RPAREN
    (49) input_statement -> . INPUT LPAREN RPAREN
    (72) conditional_structure -> . IF conditions conditional_body
    (73) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (74) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (104) list_structure -> . empty_list
    (105) list_structure -> . list_with_data
    (106) list_structure -> . defined_list
    (110) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (115) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (90) for_estructure -> . for_initialization
    (91) for_estructure -> . for_infinite_bucle
    (92) for_estructure -> . for_iterator
    (27) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (28) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (23) variable_declaration -> . VAR VARIABLE type
    (24) variable_declaration -> . VAR VARIABLE ASSIGN value
    (25) variable_declaration -> . VARIABLE SHORTASSIGN value
    (26) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (96) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (116) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (117) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (118) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (119) slice_structure -> . VARIABLE ASSIGN append_statement
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (107) empty_list -> . LBRACE RBRACE
    (108) list_with_data -> . LBRACE values RBRACE
    (109) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (93) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (94) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (95) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (63) parameter -> . VARIABLE type
    (39) number -> . INT
    (40) number -> . FLOAT

    $end            reduce using rule 7 (blocks -> block .)
    RBRACE          reduce using rule 7 (blocks -> block .)
    CASE            reduce using rule 7 (blocks -> block .)
    DEFAULT         reduce using rule 7 (blocks -> block .)
    PRINT           shift and go to state 24
    PRINTF          shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 27
    VARIABLE        shift and go to state 8
    TYPE            shift and go to state 35
    FUNCTION        shift and go to state 52
    VAR             shift and go to state 37
    SWITCH          shift and go to state 38
    CHARSTRING      shift and go to state 40
    LBRACE          shift and go to state 5
    FOR             shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    block                          shift and go to state 6
    blocks                         shift and go to state 51
    print_statement                shift and go to state 10
    input_statement                shift and go to state 11
    conditional_structure          shift and go to state 12
    operation                      shift and go to state 13
    list_structure                 shift and go to state 14
    map_estructure                 shift and go to state 15
    map_assign                     shift and go to state 16
    for_estructure                 shift and go to state 17
    structure                      shift and go to state 18
    function                       shift and go to state 19
    parameters                     shift and go to state 20
    variable_declaration           shift and go to state 21
    switch_structure               shift and go to state 22
    slice_structure                shift and go to state 23
    value                          shift and go to state 28
    empty_list                     shift and go to state 29
    list_with_data                 shift and go to state 30
    defined_list                   shift and go to state 31
    for_initialization             shift and go to state 32
    for_infinite_bucle             shift and go to state 33
    for_iterator                   shift and go to state 34
    parameter                      shift and go to state 36
    number                         shift and go to state 39

state 7

    (5) package -> PACKAGE . VARIABLE

    VARIABLE        shift and go to state 53


state 8

    (110) map_estructure -> VARIABLE . SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> VARIABLE . SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (115) map_assign -> VARIABLE . LBRACKET string_value RBRACKET ASSIGN string_value
    (25) variable_declaration -> VARIABLE . SHORTASSIGN value
    (26) variable_declaration -> VARIABLE . SHORTASSIGN operation
    (116) slice_structure -> VARIABLE . SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (118) slice_structure -> VARIABLE . SHORTASSIGN LBRACKET RBRACKET type
    (119) slice_structure -> VARIABLE . ASSIGN append_statement
    (36) value -> VARIABLE .
    (63) parameter -> VARIABLE . type
    (64) type -> . INT
    (65) type -> . INT32
    (66) type -> . INT64
    (67) type -> . STRING
    (68) type -> . FLOAT
    (69) type -> . FLOAT32
    (70) type -> . FLOAT64
    (71) type -> . BOOL

  ! shift/reduce conflict for ASSIGN resolved as shift
    SHORTASSIGN     shift and go to state 54
    LBRACKET        shift and go to state 55
    ASSIGN          shift and go to state 57
    PLUS            reduce using rule 36 (value -> VARIABLE .)
    MINUS           reduce using rule 36 (value -> VARIABLE .)
    TIMES           reduce using rule 36 (value -> VARIABLE .)
    DIVIDE          reduce using rule 36 (value -> VARIABLE .)
    INCREMENT       reduce using rule 36 (value -> VARIABLE .)
    DECREMENT       reduce using rule 36 (value -> VARIABLE .)
    INT             shift and go to state 58
    INT32           shift and go to state 59
    INT64           shift and go to state 60
    STRING          shift and go to state 61
    FLOAT           shift and go to state 62
    FLOAT32         shift and go to state 63
    FLOAT64         shift and go to state 64
    BOOL            shift and go to state 65

  ! ASSIGN          [ reduce using rule 36 (value -> VARIABLE .) ]

    type                           shift and go to state 56

state 9

    (6) main -> FUNCTION . MAIN LPAREN RPAREN
    (28) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE

    MAIN            shift and go to state 66
    VARIABLE        shift and go to state 67


state 10

    (9) block -> print_statement .

    PRINT           reduce using rule 9 (block -> print_statement .)
    PRINTF          reduce using rule 9 (block -> print_statement .)
    INPUT           reduce using rule 9 (block -> print_statement .)
    IF              reduce using rule 9 (block -> print_statement .)
    VARIABLE        reduce using rule 9 (block -> print_statement .)
    TYPE            reduce using rule 9 (block -> print_statement .)
    FUNCTION        reduce using rule 9 (block -> print_statement .)
    VAR             reduce using rule 9 (block -> print_statement .)
    SWITCH          reduce using rule 9 (block -> print_statement .)
    CHARSTRING      reduce using rule 9 (block -> print_statement .)
    LBRACE          reduce using rule 9 (block -> print_statement .)
    FOR             reduce using rule 9 (block -> print_statement .)
    INT             reduce using rule 9 (block -> print_statement .)
    FLOAT           reduce using rule 9 (block -> print_statement .)
    $end            reduce using rule 9 (block -> print_statement .)
    RBRACE          reduce using rule 9 (block -> print_statement .)
    CASE            reduce using rule 9 (block -> print_statement .)
    DEFAULT         reduce using rule 9 (block -> print_statement .)


state 11

    (10) block -> input_statement .

    PRINT           reduce using rule 10 (block -> input_statement .)
    PRINTF          reduce using rule 10 (block -> input_statement .)
    INPUT           reduce using rule 10 (block -> input_statement .)
    IF              reduce using rule 10 (block -> input_statement .)
    VARIABLE        reduce using rule 10 (block -> input_statement .)
    TYPE            reduce using rule 10 (block -> input_statement .)
    FUNCTION        reduce using rule 10 (block -> input_statement .)
    VAR             reduce using rule 10 (block -> input_statement .)
    SWITCH          reduce using rule 10 (block -> input_statement .)
    CHARSTRING      reduce using rule 10 (block -> input_statement .)
    LBRACE          reduce using rule 10 (block -> input_statement .)
    FOR             reduce using rule 10 (block -> input_statement .)
    INT             reduce using rule 10 (block -> input_statement .)
    FLOAT           reduce using rule 10 (block -> input_statement .)
    $end            reduce using rule 10 (block -> input_statement .)
    RBRACE          reduce using rule 10 (block -> input_statement .)
    CASE            reduce using rule 10 (block -> input_statement .)
    DEFAULT         reduce using rule 10 (block -> input_statement .)


state 12

    (11) block -> conditional_structure .

    PRINT           reduce using rule 11 (block -> conditional_structure .)
    PRINTF          reduce using rule 11 (block -> conditional_structure .)
    INPUT           reduce using rule 11 (block -> conditional_structure .)
    IF              reduce using rule 11 (block -> conditional_structure .)
    VARIABLE        reduce using rule 11 (block -> conditional_structure .)
    TYPE            reduce using rule 11 (block -> conditional_structure .)
    FUNCTION        reduce using rule 11 (block -> conditional_structure .)
    VAR             reduce using rule 11 (block -> conditional_structure .)
    SWITCH          reduce using rule 11 (block -> conditional_structure .)
    CHARSTRING      reduce using rule 11 (block -> conditional_structure .)
    LBRACE          reduce using rule 11 (block -> conditional_structure .)
    FOR             reduce using rule 11 (block -> conditional_structure .)
    INT             reduce using rule 11 (block -> conditional_structure .)
    FLOAT           reduce using rule 11 (block -> conditional_structure .)
    $end            reduce using rule 11 (block -> conditional_structure .)
    RBRACE          reduce using rule 11 (block -> conditional_structure .)
    CASE            reduce using rule 11 (block -> conditional_structure .)
    DEFAULT         reduce using rule 11 (block -> conditional_structure .)


state 13

    (12) block -> operation .

    PRINT           reduce using rule 12 (block -> operation .)
    PRINTF          reduce using rule 12 (block -> operation .)
    INPUT           reduce using rule 12 (block -> operation .)
    IF              reduce using rule 12 (block -> operation .)
    VARIABLE        reduce using rule 12 (block -> operation .)
    TYPE            reduce using rule 12 (block -> operation .)
    FUNCTION        reduce using rule 12 (block -> operation .)
    VAR             reduce using rule 12 (block -> operation .)
    SWITCH          reduce using rule 12 (block -> operation .)
    CHARSTRING      reduce using rule 12 (block -> operation .)
    LBRACE          reduce using rule 12 (block -> operation .)
    FOR             reduce using rule 12 (block -> operation .)
    INT             reduce using rule 12 (block -> operation .)
    FLOAT           reduce using rule 12 (block -> operation .)
    $end            reduce using rule 12 (block -> operation .)
    RBRACE          reduce using rule 12 (block -> operation .)
    CASE            reduce using rule 12 (block -> operation .)
    DEFAULT         reduce using rule 12 (block -> operation .)


state 14

    (13) block -> list_structure .

    PRINT           reduce using rule 13 (block -> list_structure .)
    PRINTF          reduce using rule 13 (block -> list_structure .)
    INPUT           reduce using rule 13 (block -> list_structure .)
    IF              reduce using rule 13 (block -> list_structure .)
    VARIABLE        reduce using rule 13 (block -> list_structure .)
    TYPE            reduce using rule 13 (block -> list_structure .)
    FUNCTION        reduce using rule 13 (block -> list_structure .)
    VAR             reduce using rule 13 (block -> list_structure .)
    SWITCH          reduce using rule 13 (block -> list_structure .)
    CHARSTRING      reduce using rule 13 (block -> list_structure .)
    LBRACE          reduce using rule 13 (block -> list_structure .)
    FOR             reduce using rule 13 (block -> list_structure .)
    INT             reduce using rule 13 (block -> list_structure .)
    FLOAT           reduce using rule 13 (block -> list_structure .)
    $end            reduce using rule 13 (block -> list_structure .)
    RBRACE          reduce using rule 13 (block -> list_structure .)
    CASE            reduce using rule 13 (block -> list_structure .)
    DEFAULT         reduce using rule 13 (block -> list_structure .)


state 15

    (14) block -> map_estructure .

    PRINT           reduce using rule 14 (block -> map_estructure .)
    PRINTF          reduce using rule 14 (block -> map_estructure .)
    INPUT           reduce using rule 14 (block -> map_estructure .)
    IF              reduce using rule 14 (block -> map_estructure .)
    VARIABLE        reduce using rule 14 (block -> map_estructure .)
    TYPE            reduce using rule 14 (block -> map_estructure .)
    FUNCTION        reduce using rule 14 (block -> map_estructure .)
    VAR             reduce using rule 14 (block -> map_estructure .)
    SWITCH          reduce using rule 14 (block -> map_estructure .)
    CHARSTRING      reduce using rule 14 (block -> map_estructure .)
    LBRACE          reduce using rule 14 (block -> map_estructure .)
    FOR             reduce using rule 14 (block -> map_estructure .)
    INT             reduce using rule 14 (block -> map_estructure .)
    FLOAT           reduce using rule 14 (block -> map_estructure .)
    $end            reduce using rule 14 (block -> map_estructure .)
    RBRACE          reduce using rule 14 (block -> map_estructure .)
    CASE            reduce using rule 14 (block -> map_estructure .)
    DEFAULT         reduce using rule 14 (block -> map_estructure .)


state 16

    (15) block -> map_assign .

    PRINT           reduce using rule 15 (block -> map_assign .)
    PRINTF          reduce using rule 15 (block -> map_assign .)
    INPUT           reduce using rule 15 (block -> map_assign .)
    IF              reduce using rule 15 (block -> map_assign .)
    VARIABLE        reduce using rule 15 (block -> map_assign .)
    TYPE            reduce using rule 15 (block -> map_assign .)
    FUNCTION        reduce using rule 15 (block -> map_assign .)
    VAR             reduce using rule 15 (block -> map_assign .)
    SWITCH          reduce using rule 15 (block -> map_assign .)
    CHARSTRING      reduce using rule 15 (block -> map_assign .)
    LBRACE          reduce using rule 15 (block -> map_assign .)
    FOR             reduce using rule 15 (block -> map_assign .)
    INT             reduce using rule 15 (block -> map_assign .)
    FLOAT           reduce using rule 15 (block -> map_assign .)
    $end            reduce using rule 15 (block -> map_assign .)
    RBRACE          reduce using rule 15 (block -> map_assign .)
    CASE            reduce using rule 15 (block -> map_assign .)
    DEFAULT         reduce using rule 15 (block -> map_assign .)


state 17

    (16) block -> for_estructure .

    PRINT           reduce using rule 16 (block -> for_estructure .)
    PRINTF          reduce using rule 16 (block -> for_estructure .)
    INPUT           reduce using rule 16 (block -> for_estructure .)
    IF              reduce using rule 16 (block -> for_estructure .)
    VARIABLE        reduce using rule 16 (block -> for_estructure .)
    TYPE            reduce using rule 16 (block -> for_estructure .)
    FUNCTION        reduce using rule 16 (block -> for_estructure .)
    VAR             reduce using rule 16 (block -> for_estructure .)
    SWITCH          reduce using rule 16 (block -> for_estructure .)
    CHARSTRING      reduce using rule 16 (block -> for_estructure .)
    LBRACE          reduce using rule 16 (block -> for_estructure .)
    FOR             reduce using rule 16 (block -> for_estructure .)
    INT             reduce using rule 16 (block -> for_estructure .)
    FLOAT           reduce using rule 16 (block -> for_estructure .)
    $end            reduce using rule 16 (block -> for_estructure .)
    RBRACE          reduce using rule 16 (block -> for_estructure .)
    CASE            reduce using rule 16 (block -> for_estructure .)
    DEFAULT         reduce using rule 16 (block -> for_estructure .)


state 18

    (17) block -> structure .

    PRINT           reduce using rule 17 (block -> structure .)
    PRINTF          reduce using rule 17 (block -> structure .)
    INPUT           reduce using rule 17 (block -> structure .)
    IF              reduce using rule 17 (block -> structure .)
    VARIABLE        reduce using rule 17 (block -> structure .)
    TYPE            reduce using rule 17 (block -> structure .)
    FUNCTION        reduce using rule 17 (block -> structure .)
    VAR             reduce using rule 17 (block -> structure .)
    SWITCH          reduce using rule 17 (block -> structure .)
    CHARSTRING      reduce using rule 17 (block -> structure .)
    LBRACE          reduce using rule 17 (block -> structure .)
    FOR             reduce using rule 17 (block -> structure .)
    INT             reduce using rule 17 (block -> structure .)
    FLOAT           reduce using rule 17 (block -> structure .)
    $end            reduce using rule 17 (block -> structure .)
    RBRACE          reduce using rule 17 (block -> structure .)
    CASE            reduce using rule 17 (block -> structure .)
    DEFAULT         reduce using rule 17 (block -> structure .)


state 19

    (18) block -> function .

    PRINT           reduce using rule 18 (block -> function .)
    PRINTF          reduce using rule 18 (block -> function .)
    INPUT           reduce using rule 18 (block -> function .)
    IF              reduce using rule 18 (block -> function .)
    VARIABLE        reduce using rule 18 (block -> function .)
    TYPE            reduce using rule 18 (block -> function .)
    FUNCTION        reduce using rule 18 (block -> function .)
    VAR             reduce using rule 18 (block -> function .)
    SWITCH          reduce using rule 18 (block -> function .)
    CHARSTRING      reduce using rule 18 (block -> function .)
    LBRACE          reduce using rule 18 (block -> function .)
    FOR             reduce using rule 18 (block -> function .)
    INT             reduce using rule 18 (block -> function .)
    FLOAT           reduce using rule 18 (block -> function .)
    $end            reduce using rule 18 (block -> function .)
    RBRACE          reduce using rule 18 (block -> function .)
    CASE            reduce using rule 18 (block -> function .)
    DEFAULT         reduce using rule 18 (block -> function .)


state 20

    (19) block -> parameters .

    PRINT           reduce using rule 19 (block -> parameters .)
    PRINTF          reduce using rule 19 (block -> parameters .)
    INPUT           reduce using rule 19 (block -> parameters .)
    IF              reduce using rule 19 (block -> parameters .)
    VARIABLE        reduce using rule 19 (block -> parameters .)
    TYPE            reduce using rule 19 (block -> parameters .)
    FUNCTION        reduce using rule 19 (block -> parameters .)
    VAR             reduce using rule 19 (block -> parameters .)
    SWITCH          reduce using rule 19 (block -> parameters .)
    CHARSTRING      reduce using rule 19 (block -> parameters .)
    LBRACE          reduce using rule 19 (block -> parameters .)
    FOR             reduce using rule 19 (block -> parameters .)
    INT             reduce using rule 19 (block -> parameters .)
    FLOAT           reduce using rule 19 (block -> parameters .)
    $end            reduce using rule 19 (block -> parameters .)
    RBRACE          reduce using rule 19 (block -> parameters .)
    CASE            reduce using rule 19 (block -> parameters .)
    DEFAULT         reduce using rule 19 (block -> parameters .)


state 21

    (20) block -> variable_declaration .

    PRINT           reduce using rule 20 (block -> variable_declaration .)
    PRINTF          reduce using rule 20 (block -> variable_declaration .)
    INPUT           reduce using rule 20 (block -> variable_declaration .)
    IF              reduce using rule 20 (block -> variable_declaration .)
    VARIABLE        reduce using rule 20 (block -> variable_declaration .)
    TYPE            reduce using rule 20 (block -> variable_declaration .)
    FUNCTION        reduce using rule 20 (block -> variable_declaration .)
    VAR             reduce using rule 20 (block -> variable_declaration .)
    SWITCH          reduce using rule 20 (block -> variable_declaration .)
    CHARSTRING      reduce using rule 20 (block -> variable_declaration .)
    LBRACE          reduce using rule 20 (block -> variable_declaration .)
    FOR             reduce using rule 20 (block -> variable_declaration .)
    INT             reduce using rule 20 (block -> variable_declaration .)
    FLOAT           reduce using rule 20 (block -> variable_declaration .)
    $end            reduce using rule 20 (block -> variable_declaration .)
    RBRACE          reduce using rule 20 (block -> variable_declaration .)
    CASE            reduce using rule 20 (block -> variable_declaration .)
    DEFAULT         reduce using rule 20 (block -> variable_declaration .)


state 22

    (21) block -> switch_structure .

    PRINT           reduce using rule 21 (block -> switch_structure .)
    PRINTF          reduce using rule 21 (block -> switch_structure .)
    INPUT           reduce using rule 21 (block -> switch_structure .)
    IF              reduce using rule 21 (block -> switch_structure .)
    VARIABLE        reduce using rule 21 (block -> switch_structure .)
    TYPE            reduce using rule 21 (block -> switch_structure .)
    FUNCTION        reduce using rule 21 (block -> switch_structure .)
    VAR             reduce using rule 21 (block -> switch_structure .)
    SWITCH          reduce using rule 21 (block -> switch_structure .)
    CHARSTRING      reduce using rule 21 (block -> switch_structure .)
    LBRACE          reduce using rule 21 (block -> switch_structure .)
    FOR             reduce using rule 21 (block -> switch_structure .)
    INT             reduce using rule 21 (block -> switch_structure .)
    FLOAT           reduce using rule 21 (block -> switch_structure .)
    $end            reduce using rule 21 (block -> switch_structure .)
    RBRACE          reduce using rule 21 (block -> switch_structure .)
    CASE            reduce using rule 21 (block -> switch_structure .)
    DEFAULT         reduce using rule 21 (block -> switch_structure .)


state 23

    (22) block -> slice_structure .

    PRINT           reduce using rule 22 (block -> slice_structure .)
    PRINTF          reduce using rule 22 (block -> slice_structure .)
    INPUT           reduce using rule 22 (block -> slice_structure .)
    IF              reduce using rule 22 (block -> slice_structure .)
    VARIABLE        reduce using rule 22 (block -> slice_structure .)
    TYPE            reduce using rule 22 (block -> slice_structure .)
    FUNCTION        reduce using rule 22 (block -> slice_structure .)
    VAR             reduce using rule 22 (block -> slice_structure .)
    SWITCH          reduce using rule 22 (block -> slice_structure .)
    CHARSTRING      reduce using rule 22 (block -> slice_structure .)
    LBRACE          reduce using rule 22 (block -> slice_structure .)
    FOR             reduce using rule 22 (block -> slice_structure .)
    INT             reduce using rule 22 (block -> slice_structure .)
    FLOAT           reduce using rule 22 (block -> slice_structure .)
    $end            reduce using rule 22 (block -> slice_structure .)
    RBRACE          reduce using rule 22 (block -> slice_structure .)
    CASE            reduce using rule 22 (block -> slice_structure .)
    DEFAULT         reduce using rule 22 (block -> slice_structure .)


state 24

    (41) print_statement -> PRINT . LPAREN values RPAREN
    (42) print_statement -> PRINT . LPAREN string_value RPAREN
    (44) print_statement -> PRINT . LPAREN string_value COMMA values RPAREN
    (45) print_statement -> PRINT . LPAREN operation RPAREN
    (46) print_statement -> PRINT . LPAREN RPAREN

    LPAREN          shift and go to state 68


state 25

    (43) print_statement -> PRINTF . LPAREN FORMATSTRING COMMA values RPAREN

    LPAREN          shift and go to state 69


state 26

    (47) input_statement -> INPUT . LPAREN values RPAREN
    (48) input_statement -> INPUT . LPAREN operation RPAREN
    (49) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 70


state 27

    (72) conditional_structure -> IF . conditions conditional_body
    (73) conditional_structure -> IF . conditions conditional_body ELSE conditional_body
    (74) conditional_structure -> IF . conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (78) conditions -> . condition
    (79) conditions -> . condition logical_operator conditions
    (80) condition -> . value relational_operator value
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    conditions                     shift and go to state 71
    condition                      shift and go to state 72
    value                          shift and go to state 73
    number                         shift and go to state 39

state 28

    (50) operation -> value . operator value
    (51) operation -> value . operator operation
    (52) operation -> value . double_operator
    (53) operator -> . PLUS
    (54) operator -> . MINUS
    (55) operator -> . TIMES
    (56) operator -> . DIVIDE
    (57) operator -> . ASSIGN
    (58) double_operator -> . INCREMENT
    (59) double_operator -> . DECREMENT

    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 79
    ASSIGN          shift and go to state 80
    INCREMENT       shift and go to state 81
    DECREMENT       shift and go to state 82

    operator                       shift and go to state 74
    double_operator                shift and go to state 75

state 29

    (104) list_structure -> empty_list .

    PRINT           reduce using rule 104 (list_structure -> empty_list .)
    PRINTF          reduce using rule 104 (list_structure -> empty_list .)
    INPUT           reduce using rule 104 (list_structure -> empty_list .)
    IF              reduce using rule 104 (list_structure -> empty_list .)
    VARIABLE        reduce using rule 104 (list_structure -> empty_list .)
    TYPE            reduce using rule 104 (list_structure -> empty_list .)
    FUNCTION        reduce using rule 104 (list_structure -> empty_list .)
    VAR             reduce using rule 104 (list_structure -> empty_list .)
    SWITCH          reduce using rule 104 (list_structure -> empty_list .)
    CHARSTRING      reduce using rule 104 (list_structure -> empty_list .)
    LBRACE          reduce using rule 104 (list_structure -> empty_list .)
    FOR             reduce using rule 104 (list_structure -> empty_list .)
    INT             reduce using rule 104 (list_structure -> empty_list .)
    FLOAT           reduce using rule 104 (list_structure -> empty_list .)
    $end            reduce using rule 104 (list_structure -> empty_list .)
    RBRACE          reduce using rule 104 (list_structure -> empty_list .)
    CASE            reduce using rule 104 (list_structure -> empty_list .)
    DEFAULT         reduce using rule 104 (list_structure -> empty_list .)


state 30

    (105) list_structure -> list_with_data .

    PRINT           reduce using rule 105 (list_structure -> list_with_data .)
    PRINTF          reduce using rule 105 (list_structure -> list_with_data .)
    INPUT           reduce using rule 105 (list_structure -> list_with_data .)
    IF              reduce using rule 105 (list_structure -> list_with_data .)
    VARIABLE        reduce using rule 105 (list_structure -> list_with_data .)
    TYPE            reduce using rule 105 (list_structure -> list_with_data .)
    FUNCTION        reduce using rule 105 (list_structure -> list_with_data .)
    VAR             reduce using rule 105 (list_structure -> list_with_data .)
    SWITCH          reduce using rule 105 (list_structure -> list_with_data .)
    CHARSTRING      reduce using rule 105 (list_structure -> list_with_data .)
    LBRACE          reduce using rule 105 (list_structure -> list_with_data .)
    FOR             reduce using rule 105 (list_structure -> list_with_data .)
    INT             reduce using rule 105 (list_structure -> list_with_data .)
    FLOAT           reduce using rule 105 (list_structure -> list_with_data .)
    $end            reduce using rule 105 (list_structure -> list_with_data .)
    RBRACE          reduce using rule 105 (list_structure -> list_with_data .)
    CASE            reduce using rule 105 (list_structure -> list_with_data .)
    DEFAULT         reduce using rule 105 (list_structure -> list_with_data .)


state 31

    (106) list_structure -> defined_list .

    PRINT           reduce using rule 106 (list_structure -> defined_list .)
    PRINTF          reduce using rule 106 (list_structure -> defined_list .)
    INPUT           reduce using rule 106 (list_structure -> defined_list .)
    IF              reduce using rule 106 (list_structure -> defined_list .)
    VARIABLE        reduce using rule 106 (list_structure -> defined_list .)
    TYPE            reduce using rule 106 (list_structure -> defined_list .)
    FUNCTION        reduce using rule 106 (list_structure -> defined_list .)
    VAR             reduce using rule 106 (list_structure -> defined_list .)
    SWITCH          reduce using rule 106 (list_structure -> defined_list .)
    CHARSTRING      reduce using rule 106 (list_structure -> defined_list .)
    LBRACE          reduce using rule 106 (list_structure -> defined_list .)
    FOR             reduce using rule 106 (list_structure -> defined_list .)
    INT             reduce using rule 106 (list_structure -> defined_list .)
    FLOAT           reduce using rule 106 (list_structure -> defined_list .)
    $end            reduce using rule 106 (list_structure -> defined_list .)
    RBRACE          reduce using rule 106 (list_structure -> defined_list .)
    CASE            reduce using rule 106 (list_structure -> defined_list .)
    DEFAULT         reduce using rule 106 (list_structure -> defined_list .)


state 32

    (90) for_estructure -> for_initialization .

    PRINT           reduce using rule 90 (for_estructure -> for_initialization .)
    PRINTF          reduce using rule 90 (for_estructure -> for_initialization .)
    INPUT           reduce using rule 90 (for_estructure -> for_initialization .)
    IF              reduce using rule 90 (for_estructure -> for_initialization .)
    VARIABLE        reduce using rule 90 (for_estructure -> for_initialization .)
    TYPE            reduce using rule 90 (for_estructure -> for_initialization .)
    FUNCTION        reduce using rule 90 (for_estructure -> for_initialization .)
    VAR             reduce using rule 90 (for_estructure -> for_initialization .)
    SWITCH          reduce using rule 90 (for_estructure -> for_initialization .)
    CHARSTRING      reduce using rule 90 (for_estructure -> for_initialization .)
    LBRACE          reduce using rule 90 (for_estructure -> for_initialization .)
    FOR             reduce using rule 90 (for_estructure -> for_initialization .)
    INT             reduce using rule 90 (for_estructure -> for_initialization .)
    FLOAT           reduce using rule 90 (for_estructure -> for_initialization .)
    $end            reduce using rule 90 (for_estructure -> for_initialization .)
    RBRACE          reduce using rule 90 (for_estructure -> for_initialization .)
    CASE            reduce using rule 90 (for_estructure -> for_initialization .)
    DEFAULT         reduce using rule 90 (for_estructure -> for_initialization .)


state 33

    (91) for_estructure -> for_infinite_bucle .

    PRINT           reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    PRINTF          reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    INPUT           reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    IF              reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    VARIABLE        reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    TYPE            reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    FUNCTION        reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    VAR             reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    SWITCH          reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    CHARSTRING      reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    LBRACE          reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    FOR             reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    INT             reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    FLOAT           reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    $end            reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    RBRACE          reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    CASE            reduce using rule 91 (for_estructure -> for_infinite_bucle .)
    DEFAULT         reduce using rule 91 (for_estructure -> for_infinite_bucle .)


state 34

    (92) for_estructure -> for_iterator .

    PRINT           reduce using rule 92 (for_estructure -> for_iterator .)
    PRINTF          reduce using rule 92 (for_estructure -> for_iterator .)
    INPUT           reduce using rule 92 (for_estructure -> for_iterator .)
    IF              reduce using rule 92 (for_estructure -> for_iterator .)
    VARIABLE        reduce using rule 92 (for_estructure -> for_iterator .)
    TYPE            reduce using rule 92 (for_estructure -> for_iterator .)
    FUNCTION        reduce using rule 92 (for_estructure -> for_iterator .)
    VAR             reduce using rule 92 (for_estructure -> for_iterator .)
    SWITCH          reduce using rule 92 (for_estructure -> for_iterator .)
    CHARSTRING      reduce using rule 92 (for_estructure -> for_iterator .)
    LBRACE          reduce using rule 92 (for_estructure -> for_iterator .)
    FOR             reduce using rule 92 (for_estructure -> for_iterator .)
    INT             reduce using rule 92 (for_estructure -> for_iterator .)
    FLOAT           reduce using rule 92 (for_estructure -> for_iterator .)
    $end            reduce using rule 92 (for_estructure -> for_iterator .)
    RBRACE          reduce using rule 92 (for_estructure -> for_iterator .)
    CASE            reduce using rule 92 (for_estructure -> for_iterator .)
    DEFAULT         reduce using rule 92 (for_estructure -> for_iterator .)


state 35

    (27) structure -> TYPE . VARIABLE STRUCT LBRACE statement RBRACE
    (109) defined_list -> TYPE . VARIABLE LBRACE values RBRACE

    VARIABLE        shift and go to state 83


state 36

    (60) parameters -> parameter .
    (61) parameters -> parameter . parameters
    (62) parameters -> parameter . COMMA parameters
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (63) parameter -> . VARIABLE type

  ! shift/reduce conflict for VARIABLE resolved as shift
    PRINT           reduce using rule 60 (parameters -> parameter .)
    PRINTF          reduce using rule 60 (parameters -> parameter .)
    INPUT           reduce using rule 60 (parameters -> parameter .)
    IF              reduce using rule 60 (parameters -> parameter .)
    TYPE            reduce using rule 60 (parameters -> parameter .)
    FUNCTION        reduce using rule 60 (parameters -> parameter .)
    VAR             reduce using rule 60 (parameters -> parameter .)
    SWITCH          reduce using rule 60 (parameters -> parameter .)
    CHARSTRING      reduce using rule 60 (parameters -> parameter .)
    LBRACE          reduce using rule 60 (parameters -> parameter .)
    FOR             reduce using rule 60 (parameters -> parameter .)
    INT             reduce using rule 60 (parameters -> parameter .)
    FLOAT           reduce using rule 60 (parameters -> parameter .)
    $end            reduce using rule 60 (parameters -> parameter .)
    RBRACE          reduce using rule 60 (parameters -> parameter .)
    CASE            reduce using rule 60 (parameters -> parameter .)
    DEFAULT         reduce using rule 60 (parameters -> parameter .)
    RPAREN          reduce using rule 60 (parameters -> parameter .)
    COMMA           shift and go to state 85
    VARIABLE        shift and go to state 86

  ! VARIABLE        [ reduce using rule 60 (parameters -> parameter .) ]

    parameter                      shift and go to state 36
    parameters                     shift and go to state 84

state 37

    (23) variable_declaration -> VAR . VARIABLE type
    (24) variable_declaration -> VAR . VARIABLE ASSIGN value
    (117) slice_structure -> VAR . VARIABLE LBRACKET RBRACKET type

    VARIABLE        shift and go to state 87


state 38

    (96) switch_structure -> SWITCH . switch_expression LBRACE case_blocks RBRACE
    (97) switch_expression -> . value
    (98) switch_expression -> . empty
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (103) empty -> .
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    LBRACE          reduce using rule 103 (empty -> .)
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    switch_expression              shift and go to state 88
    value                          shift and go to state 89
    empty                          shift and go to state 90
    number                         shift and go to state 39

state 39

    (37) value -> number .

    PLUS            reduce using rule 37 (value -> number .)
    MINUS           reduce using rule 37 (value -> number .)
    TIMES           reduce using rule 37 (value -> number .)
    DIVIDE          reduce using rule 37 (value -> number .)
    ASSIGN          reduce using rule 37 (value -> number .)
    INCREMENT       reduce using rule 37 (value -> number .)
    DECREMENT       reduce using rule 37 (value -> number .)
    COMMA           reduce using rule 37 (value -> number .)
    RBRACE          reduce using rule 37 (value -> number .)
    GREATER         reduce using rule 37 (value -> number .)
    LESS            reduce using rule 37 (value -> number .)
    GREATEREQUALS   reduce using rule 37 (value -> number .)
    LESSEQUALS      reduce using rule 37 (value -> number .)
    EQUALS          reduce using rule 37 (value -> number .)
    DIFFERENT       reduce using rule 37 (value -> number .)
    LBRACE          reduce using rule 37 (value -> number .)
    PRINT           reduce using rule 37 (value -> number .)
    PRINTF          reduce using rule 37 (value -> number .)
    INPUT           reduce using rule 37 (value -> number .)
    IF              reduce using rule 37 (value -> number .)
    VARIABLE        reduce using rule 37 (value -> number .)
    TYPE            reduce using rule 37 (value -> number .)
    FUNCTION        reduce using rule 37 (value -> number .)
    VAR             reduce using rule 37 (value -> number .)
    SWITCH          reduce using rule 37 (value -> number .)
    CHARSTRING      reduce using rule 37 (value -> number .)
    FOR             reduce using rule 37 (value -> number .)
    INT             reduce using rule 37 (value -> number .)
    FLOAT           reduce using rule 37 (value -> number .)
    $end            reduce using rule 37 (value -> number .)
    CASE            reduce using rule 37 (value -> number .)
    DEFAULT         reduce using rule 37 (value -> number .)
    RBRACKET        reduce using rule 37 (value -> number .)
    RPAREN          reduce using rule 37 (value -> number .)
    COLON           reduce using rule 37 (value -> number .)
    AND             reduce using rule 37 (value -> number .)
    OR              reduce using rule 37 (value -> number .)
    NOT             reduce using rule 37 (value -> number .)
    SEMICOLON       reduce using rule 37 (value -> number .)


state 40

    (38) value -> CHARSTRING .

    PLUS            reduce using rule 38 (value -> CHARSTRING .)
    MINUS           reduce using rule 38 (value -> CHARSTRING .)
    TIMES           reduce using rule 38 (value -> CHARSTRING .)
    DIVIDE          reduce using rule 38 (value -> CHARSTRING .)
    ASSIGN          reduce using rule 38 (value -> CHARSTRING .)
    INCREMENT       reduce using rule 38 (value -> CHARSTRING .)
    DECREMENT       reduce using rule 38 (value -> CHARSTRING .)
    COMMA           reduce using rule 38 (value -> CHARSTRING .)
    RBRACE          reduce using rule 38 (value -> CHARSTRING .)
    GREATER         reduce using rule 38 (value -> CHARSTRING .)
    LESS            reduce using rule 38 (value -> CHARSTRING .)
    GREATEREQUALS   reduce using rule 38 (value -> CHARSTRING .)
    LESSEQUALS      reduce using rule 38 (value -> CHARSTRING .)
    EQUALS          reduce using rule 38 (value -> CHARSTRING .)
    DIFFERENT       reduce using rule 38 (value -> CHARSTRING .)
    LBRACE          reduce using rule 38 (value -> CHARSTRING .)
    PRINT           reduce using rule 38 (value -> CHARSTRING .)
    PRINTF          reduce using rule 38 (value -> CHARSTRING .)
    INPUT           reduce using rule 38 (value -> CHARSTRING .)
    IF              reduce using rule 38 (value -> CHARSTRING .)
    VARIABLE        reduce using rule 38 (value -> CHARSTRING .)
    TYPE            reduce using rule 38 (value -> CHARSTRING .)
    FUNCTION        reduce using rule 38 (value -> CHARSTRING .)
    VAR             reduce using rule 38 (value -> CHARSTRING .)
    SWITCH          reduce using rule 38 (value -> CHARSTRING .)
    CHARSTRING      reduce using rule 38 (value -> CHARSTRING .)
    FOR             reduce using rule 38 (value -> CHARSTRING .)
    INT             reduce using rule 38 (value -> CHARSTRING .)
    FLOAT           reduce using rule 38 (value -> CHARSTRING .)
    $end            reduce using rule 38 (value -> CHARSTRING .)
    CASE            reduce using rule 38 (value -> CHARSTRING .)
    DEFAULT         reduce using rule 38 (value -> CHARSTRING .)
    RPAREN          reduce using rule 38 (value -> CHARSTRING .)
    COLON           reduce using rule 38 (value -> CHARSTRING .)
    AND             reduce using rule 38 (value -> CHARSTRING .)
    OR              reduce using rule 38 (value -> CHARSTRING .)
    NOT             reduce using rule 38 (value -> CHARSTRING .)
    SEMICOLON       reduce using rule 38 (value -> CHARSTRING .)


state 41

    (93) for_initialization -> FOR . VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (94) for_infinite_bucle -> FOR . LBRACE statement RBRACE
    (95) for_iterator -> FOR . VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 91
    LBRACE          shift and go to state 92


state 42

    (39) number -> INT .

    PLUS            reduce using rule 39 (number -> INT .)
    MINUS           reduce using rule 39 (number -> INT .)
    TIMES           reduce using rule 39 (number -> INT .)
    DIVIDE          reduce using rule 39 (number -> INT .)
    ASSIGN          reduce using rule 39 (number -> INT .)
    INCREMENT       reduce using rule 39 (number -> INT .)
    DECREMENT       reduce using rule 39 (number -> INT .)
    COMMA           reduce using rule 39 (number -> INT .)
    RBRACE          reduce using rule 39 (number -> INT .)
    GREATER         reduce using rule 39 (number -> INT .)
    LESS            reduce using rule 39 (number -> INT .)
    GREATEREQUALS   reduce using rule 39 (number -> INT .)
    LESSEQUALS      reduce using rule 39 (number -> INT .)
    EQUALS          reduce using rule 39 (number -> INT .)
    DIFFERENT       reduce using rule 39 (number -> INT .)
    LBRACE          reduce using rule 39 (number -> INT .)
    PRINT           reduce using rule 39 (number -> INT .)
    PRINTF          reduce using rule 39 (number -> INT .)
    INPUT           reduce using rule 39 (number -> INT .)
    IF              reduce using rule 39 (number -> INT .)
    VARIABLE        reduce using rule 39 (number -> INT .)
    TYPE            reduce using rule 39 (number -> INT .)
    FUNCTION        reduce using rule 39 (number -> INT .)
    VAR             reduce using rule 39 (number -> INT .)
    SWITCH          reduce using rule 39 (number -> INT .)
    CHARSTRING      reduce using rule 39 (number -> INT .)
    FOR             reduce using rule 39 (number -> INT .)
    INT             reduce using rule 39 (number -> INT .)
    FLOAT           reduce using rule 39 (number -> INT .)
    $end            reduce using rule 39 (number -> INT .)
    CASE            reduce using rule 39 (number -> INT .)
    DEFAULT         reduce using rule 39 (number -> INT .)
    RBRACKET        reduce using rule 39 (number -> INT .)
    RPAREN          reduce using rule 39 (number -> INT .)
    COLON           reduce using rule 39 (number -> INT .)
    AND             reduce using rule 39 (number -> INT .)
    OR              reduce using rule 39 (number -> INT .)
    NOT             reduce using rule 39 (number -> INT .)
    SEMICOLON       reduce using rule 39 (number -> INT .)


state 43

    (40) number -> FLOAT .

    PLUS            reduce using rule 40 (number -> FLOAT .)
    MINUS           reduce using rule 40 (number -> FLOAT .)
    TIMES           reduce using rule 40 (number -> FLOAT .)
    DIVIDE          reduce using rule 40 (number -> FLOAT .)
    ASSIGN          reduce using rule 40 (number -> FLOAT .)
    INCREMENT       reduce using rule 40 (number -> FLOAT .)
    DECREMENT       reduce using rule 40 (number -> FLOAT .)
    COMMA           reduce using rule 40 (number -> FLOAT .)
    RBRACE          reduce using rule 40 (number -> FLOAT .)
    GREATER         reduce using rule 40 (number -> FLOAT .)
    LESS            reduce using rule 40 (number -> FLOAT .)
    GREATEREQUALS   reduce using rule 40 (number -> FLOAT .)
    LESSEQUALS      reduce using rule 40 (number -> FLOAT .)
    EQUALS          reduce using rule 40 (number -> FLOAT .)
    DIFFERENT       reduce using rule 40 (number -> FLOAT .)
    LBRACE          reduce using rule 40 (number -> FLOAT .)
    PRINT           reduce using rule 40 (number -> FLOAT .)
    PRINTF          reduce using rule 40 (number -> FLOAT .)
    INPUT           reduce using rule 40 (number -> FLOAT .)
    IF              reduce using rule 40 (number -> FLOAT .)
    VARIABLE        reduce using rule 40 (number -> FLOAT .)
    TYPE            reduce using rule 40 (number -> FLOAT .)
    FUNCTION        reduce using rule 40 (number -> FLOAT .)
    VAR             reduce using rule 40 (number -> FLOAT .)
    SWITCH          reduce using rule 40 (number -> FLOAT .)
    CHARSTRING      reduce using rule 40 (number -> FLOAT .)
    FOR             reduce using rule 40 (number -> FLOAT .)
    INT             reduce using rule 40 (number -> FLOAT .)
    FLOAT           reduce using rule 40 (number -> FLOAT .)
    $end            reduce using rule 40 (number -> FLOAT .)
    CASE            reduce using rule 40 (number -> FLOAT .)
    DEFAULT         reduce using rule 40 (number -> FLOAT .)
    RBRACKET        reduce using rule 40 (number -> FLOAT .)
    RPAREN          reduce using rule 40 (number -> FLOAT .)
    COLON           reduce using rule 40 (number -> FLOAT .)
    AND             reduce using rule 40 (number -> FLOAT .)
    OR              reduce using rule 40 (number -> FLOAT .)
    NOT             reduce using rule 40 (number -> FLOAT .)
    SEMICOLON       reduce using rule 40 (number -> FLOAT .)


state 44

    (2) statement -> package blocks .

    $end            reduce using rule 2 (statement -> package blocks .)
    RBRACE          reduce using rule 2 (statement -> package blocks .)
    CASE            reduce using rule 2 (statement -> package blocks .)
    DEFAULT         reduce using rule 2 (statement -> package blocks .)


state 45

    (4) statement -> package main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 93


state 46

    (3) statement -> main LBRACE . blocks RBRACE
    (7) blocks -> . block
    (8) blocks -> . block blocks
    (9) block -> . print_statement
    (10) block -> . input_statement
    (11) block -> . conditional_structure
    (12) block -> . operation
    (13) block -> . list_structure
    (14) block -> . map_estructure
    (15) block -> . map_assign
    (16) block -> . for_estructure
    (17) block -> . structure
    (18) block -> . function
    (19) block -> . parameters
    (20) block -> . variable_declaration
    (21) block -> . switch_structure
    (22) block -> . slice_structure
    (41) print_statement -> . PRINT LPAREN values RPAREN
    (42) print_statement -> . PRINT LPAREN string_value RPAREN
    (43) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (44) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (45) print_statement -> . PRINT LPAREN operation RPAREN
    (46) print_statement -> . PRINT LPAREN RPAREN
    (47) input_statement -> . INPUT LPAREN values RPAREN
    (48) input_statement -> . INPUT LPAREN operation RPAREN
    (49) input_statement -> . INPUT LPAREN RPAREN
    (72) conditional_structure -> . IF conditions conditional_body
    (73) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (74) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (104) list_structure -> . empty_list
    (105) list_structure -> . list_with_data
    (106) list_structure -> . defined_list
    (110) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (115) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (90) for_estructure -> . for_initialization
    (91) for_estructure -> . for_infinite_bucle
    (92) for_estructure -> . for_iterator
    (27) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (28) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (23) variable_declaration -> . VAR VARIABLE type
    (24) variable_declaration -> . VAR VARIABLE ASSIGN value
    (25) variable_declaration -> . VARIABLE SHORTASSIGN value
    (26) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (96) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (116) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (117) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (118) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (119) slice_structure -> . VARIABLE ASSIGN append_statement
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (107) empty_list -> . LBRACE RBRACE
    (108) list_with_data -> . LBRACE values RBRACE
    (109) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (93) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (94) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (95) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (63) parameter -> . VARIABLE type
    (39) number -> . INT
    (40) number -> . FLOAT

    PRINT           shift and go to state 24
    PRINTF          shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 27
    VARIABLE        shift and go to state 8
    TYPE            shift and go to state 35
    FUNCTION        shift and go to state 52
    VAR             shift and go to state 37
    SWITCH          shift and go to state 38
    CHARSTRING      shift and go to state 40
    LBRACE          shift and go to state 5
    FOR             shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    blocks                         shift and go to state 94
    block                          shift and go to state 6
    print_statement                shift and go to state 10
    input_statement                shift and go to state 11
    conditional_structure          shift and go to state 12
    operation                      shift and go to state 13
    list_structure                 shift and go to state 14
    map_estructure                 shift and go to state 15
    map_assign                     shift and go to state 16
    for_estructure                 shift and go to state 17
    structure                      shift and go to state 18
    function                       shift and go to state 19
    parameters                     shift and go to state 20
    variable_declaration           shift and go to state 21
    switch_structure               shift and go to state 22
    slice_structure                shift and go to state 23
    value                          shift and go to state 28
    empty_list                     shift and go to state 29
    list_with_data                 shift and go to state 30
    defined_list                   shift and go to state 31
    for_initialization             shift and go to state 32
    for_infinite_bucle             shift and go to state 33
    for_iterator                   shift and go to state 34
    parameter                      shift and go to state 36
    number                         shift and go to state 39

state 47

    (107) empty_list -> LBRACE RBRACE .

    PRINT           reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    PRINTF          reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    INPUT           reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    IF              reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    VARIABLE        reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    TYPE            reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    FUNCTION        reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    VAR             reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    SWITCH          reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    CHARSTRING      reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    LBRACE          reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    FOR             reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    INT             reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    FLOAT           reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    $end            reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    RBRACE          reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    CASE            reduce using rule 107 (empty_list -> LBRACE RBRACE .)
    DEFAULT         reduce using rule 107 (empty_list -> LBRACE RBRACE .)


state 48

    (108) list_with_data -> LBRACE values . RBRACE

    RBRACE          shift and go to state 95


state 49

    (32) values -> value .
    (33) values -> value . COMMA values

    RBRACE          reduce using rule 32 (values -> value .)
    RPAREN          reduce using rule 32 (values -> value .)
    COLON           reduce using rule 32 (values -> value .)
    COMMA           shift and go to state 96


state 50

    (36) value -> VARIABLE .

    COMMA           reduce using rule 36 (value -> VARIABLE .)
    RBRACE          reduce using rule 36 (value -> VARIABLE .)
    GREATER         reduce using rule 36 (value -> VARIABLE .)
    LESS            reduce using rule 36 (value -> VARIABLE .)
    GREATEREQUALS   reduce using rule 36 (value -> VARIABLE .)
    LESSEQUALS      reduce using rule 36 (value -> VARIABLE .)
    EQUALS          reduce using rule 36 (value -> VARIABLE .)
    DIFFERENT       reduce using rule 36 (value -> VARIABLE .)
    LBRACE          reduce using rule 36 (value -> VARIABLE .)
    PLUS            reduce using rule 36 (value -> VARIABLE .)
    MINUS           reduce using rule 36 (value -> VARIABLE .)
    TIMES           reduce using rule 36 (value -> VARIABLE .)
    DIVIDE          reduce using rule 36 (value -> VARIABLE .)
    ASSIGN          reduce using rule 36 (value -> VARIABLE .)
    INCREMENT       reduce using rule 36 (value -> VARIABLE .)
    DECREMENT       reduce using rule 36 (value -> VARIABLE .)
    PRINT           reduce using rule 36 (value -> VARIABLE .)
    PRINTF          reduce using rule 36 (value -> VARIABLE .)
    INPUT           reduce using rule 36 (value -> VARIABLE .)
    IF              reduce using rule 36 (value -> VARIABLE .)
    VARIABLE        reduce using rule 36 (value -> VARIABLE .)
    TYPE            reduce using rule 36 (value -> VARIABLE .)
    FUNCTION        reduce using rule 36 (value -> VARIABLE .)
    VAR             reduce using rule 36 (value -> VARIABLE .)
    SWITCH          reduce using rule 36 (value -> VARIABLE .)
    CHARSTRING      reduce using rule 36 (value -> VARIABLE .)
    FOR             reduce using rule 36 (value -> VARIABLE .)
    INT             reduce using rule 36 (value -> VARIABLE .)
    FLOAT           reduce using rule 36 (value -> VARIABLE .)
    $end            reduce using rule 36 (value -> VARIABLE .)
    CASE            reduce using rule 36 (value -> VARIABLE .)
    DEFAULT         reduce using rule 36 (value -> VARIABLE .)
    RBRACKET        reduce using rule 36 (value -> VARIABLE .)
    RPAREN          reduce using rule 36 (value -> VARIABLE .)
    COLON           reduce using rule 36 (value -> VARIABLE .)
    AND             reduce using rule 36 (value -> VARIABLE .)
    OR              reduce using rule 36 (value -> VARIABLE .)
    NOT             reduce using rule 36 (value -> VARIABLE .)
    SEMICOLON       reduce using rule 36 (value -> VARIABLE .)


state 51

    (8) blocks -> block blocks .

    $end            reduce using rule 8 (blocks -> block blocks .)
    RBRACE          reduce using rule 8 (blocks -> block blocks .)
    CASE            reduce using rule 8 (blocks -> block blocks .)
    DEFAULT         reduce using rule 8 (blocks -> block blocks .)


state 52

    (28) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE

    VARIABLE        shift and go to state 67


state 53

    (5) package -> PACKAGE VARIABLE .

    FUNCTION        reduce using rule 5 (package -> PACKAGE VARIABLE .)
    PRINT           reduce using rule 5 (package -> PACKAGE VARIABLE .)
    PRINTF          reduce using rule 5 (package -> PACKAGE VARIABLE .)
    INPUT           reduce using rule 5 (package -> PACKAGE VARIABLE .)
    IF              reduce using rule 5 (package -> PACKAGE VARIABLE .)
    VARIABLE        reduce using rule 5 (package -> PACKAGE VARIABLE .)
    TYPE            reduce using rule 5 (package -> PACKAGE VARIABLE .)
    VAR             reduce using rule 5 (package -> PACKAGE VARIABLE .)
    SWITCH          reduce using rule 5 (package -> PACKAGE VARIABLE .)
    CHARSTRING      reduce using rule 5 (package -> PACKAGE VARIABLE .)
    LBRACE          reduce using rule 5 (package -> PACKAGE VARIABLE .)
    FOR             reduce using rule 5 (package -> PACKAGE VARIABLE .)
    INT             reduce using rule 5 (package -> PACKAGE VARIABLE .)
    FLOAT           reduce using rule 5 (package -> PACKAGE VARIABLE .)


state 54

    (110) map_estructure -> VARIABLE SHORTASSIGN . MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> VARIABLE SHORTASSIGN . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (25) variable_declaration -> VARIABLE SHORTASSIGN . value
    (26) variable_declaration -> VARIABLE SHORTASSIGN . operation
    (116) slice_structure -> VARIABLE SHORTASSIGN . LBRACKET RBRACKET type LBRACE values RBRACE
    (118) slice_structure -> VARIABLE SHORTASSIGN . LBRACKET RBRACKET type
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (39) number -> . INT
    (40) number -> . FLOAT

    MAP             shift and go to state 97
    MAKE            shift and go to state 99
    LBRACKET        shift and go to state 98
    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    value                          shift and go to state 100
    operation                      shift and go to state 101
    number                         shift and go to state 39

state 55

    (115) map_assign -> VARIABLE LBRACKET . string_value RBRACKET ASSIGN string_value
    (34) string_value -> . value
    (35) string_value -> . CHARSTRING
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    CHARSTRING      shift and go to state 104
    VARIABLE        shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    string_value                   shift and go to state 102
    value                          shift and go to state 103
    number                         shift and go to state 39

state 56

    (63) parameter -> VARIABLE type .

    COMMA           reduce using rule 63 (parameter -> VARIABLE type .)
    VARIABLE        reduce using rule 63 (parameter -> VARIABLE type .)
    PRINT           reduce using rule 63 (parameter -> VARIABLE type .)
    PRINTF          reduce using rule 63 (parameter -> VARIABLE type .)
    INPUT           reduce using rule 63 (parameter -> VARIABLE type .)
    IF              reduce using rule 63 (parameter -> VARIABLE type .)
    TYPE            reduce using rule 63 (parameter -> VARIABLE type .)
    FUNCTION        reduce using rule 63 (parameter -> VARIABLE type .)
    VAR             reduce using rule 63 (parameter -> VARIABLE type .)
    SWITCH          reduce using rule 63 (parameter -> VARIABLE type .)
    CHARSTRING      reduce using rule 63 (parameter -> VARIABLE type .)
    LBRACE          reduce using rule 63 (parameter -> VARIABLE type .)
    FOR             reduce using rule 63 (parameter -> VARIABLE type .)
    INT             reduce using rule 63 (parameter -> VARIABLE type .)
    FLOAT           reduce using rule 63 (parameter -> VARIABLE type .)
    $end            reduce using rule 63 (parameter -> VARIABLE type .)
    RBRACE          reduce using rule 63 (parameter -> VARIABLE type .)
    CASE            reduce using rule 63 (parameter -> VARIABLE type .)
    DEFAULT         reduce using rule 63 (parameter -> VARIABLE type .)
    RPAREN          reduce using rule 63 (parameter -> VARIABLE type .)


state 57

    (119) slice_structure -> VARIABLE ASSIGN . append_statement
    (120) append_statement -> . APPEND LPAREN VARIABLE COMMA values RPAREN

    APPEND          shift and go to state 106

    append_statement               shift and go to state 105

state 58

    (64) type -> INT .

    COMMA           reduce using rule 64 (type -> INT .)
    VARIABLE        reduce using rule 64 (type -> INT .)
    PRINT           reduce using rule 64 (type -> INT .)
    PRINTF          reduce using rule 64 (type -> INT .)
    INPUT           reduce using rule 64 (type -> INT .)
    IF              reduce using rule 64 (type -> INT .)
    TYPE            reduce using rule 64 (type -> INT .)
    FUNCTION        reduce using rule 64 (type -> INT .)
    VAR             reduce using rule 64 (type -> INT .)
    SWITCH          reduce using rule 64 (type -> INT .)
    CHARSTRING      reduce using rule 64 (type -> INT .)
    LBRACE          reduce using rule 64 (type -> INT .)
    FOR             reduce using rule 64 (type -> INT .)
    INT             reduce using rule 64 (type -> INT .)
    FLOAT           reduce using rule 64 (type -> INT .)
    $end            reduce using rule 64 (type -> INT .)
    RBRACE          reduce using rule 64 (type -> INT .)
    CASE            reduce using rule 64 (type -> INT .)
    DEFAULT         reduce using rule 64 (type -> INT .)
    RPAREN          reduce using rule 64 (type -> INT .)
    RBRACKET        reduce using rule 64 (type -> INT .)


state 59

    (65) type -> INT32 .

    COMMA           reduce using rule 65 (type -> INT32 .)
    VARIABLE        reduce using rule 65 (type -> INT32 .)
    PRINT           reduce using rule 65 (type -> INT32 .)
    PRINTF          reduce using rule 65 (type -> INT32 .)
    INPUT           reduce using rule 65 (type -> INT32 .)
    IF              reduce using rule 65 (type -> INT32 .)
    TYPE            reduce using rule 65 (type -> INT32 .)
    FUNCTION        reduce using rule 65 (type -> INT32 .)
    VAR             reduce using rule 65 (type -> INT32 .)
    SWITCH          reduce using rule 65 (type -> INT32 .)
    CHARSTRING      reduce using rule 65 (type -> INT32 .)
    LBRACE          reduce using rule 65 (type -> INT32 .)
    FOR             reduce using rule 65 (type -> INT32 .)
    INT             reduce using rule 65 (type -> INT32 .)
    FLOAT           reduce using rule 65 (type -> INT32 .)
    $end            reduce using rule 65 (type -> INT32 .)
    RBRACE          reduce using rule 65 (type -> INT32 .)
    CASE            reduce using rule 65 (type -> INT32 .)
    DEFAULT         reduce using rule 65 (type -> INT32 .)
    RPAREN          reduce using rule 65 (type -> INT32 .)
    RBRACKET        reduce using rule 65 (type -> INT32 .)


state 60

    (66) type -> INT64 .

    COMMA           reduce using rule 66 (type -> INT64 .)
    VARIABLE        reduce using rule 66 (type -> INT64 .)
    PRINT           reduce using rule 66 (type -> INT64 .)
    PRINTF          reduce using rule 66 (type -> INT64 .)
    INPUT           reduce using rule 66 (type -> INT64 .)
    IF              reduce using rule 66 (type -> INT64 .)
    TYPE            reduce using rule 66 (type -> INT64 .)
    FUNCTION        reduce using rule 66 (type -> INT64 .)
    VAR             reduce using rule 66 (type -> INT64 .)
    SWITCH          reduce using rule 66 (type -> INT64 .)
    CHARSTRING      reduce using rule 66 (type -> INT64 .)
    LBRACE          reduce using rule 66 (type -> INT64 .)
    FOR             reduce using rule 66 (type -> INT64 .)
    INT             reduce using rule 66 (type -> INT64 .)
    FLOAT           reduce using rule 66 (type -> INT64 .)
    $end            reduce using rule 66 (type -> INT64 .)
    RBRACE          reduce using rule 66 (type -> INT64 .)
    CASE            reduce using rule 66 (type -> INT64 .)
    DEFAULT         reduce using rule 66 (type -> INT64 .)
    RPAREN          reduce using rule 66 (type -> INT64 .)
    RBRACKET        reduce using rule 66 (type -> INT64 .)


state 61

    (67) type -> STRING .

    COMMA           reduce using rule 67 (type -> STRING .)
    VARIABLE        reduce using rule 67 (type -> STRING .)
    PRINT           reduce using rule 67 (type -> STRING .)
    PRINTF          reduce using rule 67 (type -> STRING .)
    INPUT           reduce using rule 67 (type -> STRING .)
    IF              reduce using rule 67 (type -> STRING .)
    TYPE            reduce using rule 67 (type -> STRING .)
    FUNCTION        reduce using rule 67 (type -> STRING .)
    VAR             reduce using rule 67 (type -> STRING .)
    SWITCH          reduce using rule 67 (type -> STRING .)
    CHARSTRING      reduce using rule 67 (type -> STRING .)
    LBRACE          reduce using rule 67 (type -> STRING .)
    FOR             reduce using rule 67 (type -> STRING .)
    INT             reduce using rule 67 (type -> STRING .)
    FLOAT           reduce using rule 67 (type -> STRING .)
    $end            reduce using rule 67 (type -> STRING .)
    RBRACE          reduce using rule 67 (type -> STRING .)
    CASE            reduce using rule 67 (type -> STRING .)
    DEFAULT         reduce using rule 67 (type -> STRING .)
    RPAREN          reduce using rule 67 (type -> STRING .)
    RBRACKET        reduce using rule 67 (type -> STRING .)


state 62

    (68) type -> FLOAT .

    COMMA           reduce using rule 68 (type -> FLOAT .)
    VARIABLE        reduce using rule 68 (type -> FLOAT .)
    PRINT           reduce using rule 68 (type -> FLOAT .)
    PRINTF          reduce using rule 68 (type -> FLOAT .)
    INPUT           reduce using rule 68 (type -> FLOAT .)
    IF              reduce using rule 68 (type -> FLOAT .)
    TYPE            reduce using rule 68 (type -> FLOAT .)
    FUNCTION        reduce using rule 68 (type -> FLOAT .)
    VAR             reduce using rule 68 (type -> FLOAT .)
    SWITCH          reduce using rule 68 (type -> FLOAT .)
    CHARSTRING      reduce using rule 68 (type -> FLOAT .)
    LBRACE          reduce using rule 68 (type -> FLOAT .)
    FOR             reduce using rule 68 (type -> FLOAT .)
    INT             reduce using rule 68 (type -> FLOAT .)
    FLOAT           reduce using rule 68 (type -> FLOAT .)
    $end            reduce using rule 68 (type -> FLOAT .)
    RBRACE          reduce using rule 68 (type -> FLOAT .)
    CASE            reduce using rule 68 (type -> FLOAT .)
    DEFAULT         reduce using rule 68 (type -> FLOAT .)
    RPAREN          reduce using rule 68 (type -> FLOAT .)
    RBRACKET        reduce using rule 68 (type -> FLOAT .)


state 63

    (69) type -> FLOAT32 .

    COMMA           reduce using rule 69 (type -> FLOAT32 .)
    VARIABLE        reduce using rule 69 (type -> FLOAT32 .)
    PRINT           reduce using rule 69 (type -> FLOAT32 .)
    PRINTF          reduce using rule 69 (type -> FLOAT32 .)
    INPUT           reduce using rule 69 (type -> FLOAT32 .)
    IF              reduce using rule 69 (type -> FLOAT32 .)
    TYPE            reduce using rule 69 (type -> FLOAT32 .)
    FUNCTION        reduce using rule 69 (type -> FLOAT32 .)
    VAR             reduce using rule 69 (type -> FLOAT32 .)
    SWITCH          reduce using rule 69 (type -> FLOAT32 .)
    CHARSTRING      reduce using rule 69 (type -> FLOAT32 .)
    LBRACE          reduce using rule 69 (type -> FLOAT32 .)
    FOR             reduce using rule 69 (type -> FLOAT32 .)
    INT             reduce using rule 69 (type -> FLOAT32 .)
    FLOAT           reduce using rule 69 (type -> FLOAT32 .)
    $end            reduce using rule 69 (type -> FLOAT32 .)
    RBRACE          reduce using rule 69 (type -> FLOAT32 .)
    CASE            reduce using rule 69 (type -> FLOAT32 .)
    DEFAULT         reduce using rule 69 (type -> FLOAT32 .)
    RPAREN          reduce using rule 69 (type -> FLOAT32 .)
    RBRACKET        reduce using rule 69 (type -> FLOAT32 .)


state 64

    (70) type -> FLOAT64 .

    COMMA           reduce using rule 70 (type -> FLOAT64 .)
    VARIABLE        reduce using rule 70 (type -> FLOAT64 .)
    PRINT           reduce using rule 70 (type -> FLOAT64 .)
    PRINTF          reduce using rule 70 (type -> FLOAT64 .)
    INPUT           reduce using rule 70 (type -> FLOAT64 .)
    IF              reduce using rule 70 (type -> FLOAT64 .)
    TYPE            reduce using rule 70 (type -> FLOAT64 .)
    FUNCTION        reduce using rule 70 (type -> FLOAT64 .)
    VAR             reduce using rule 70 (type -> FLOAT64 .)
    SWITCH          reduce using rule 70 (type -> FLOAT64 .)
    CHARSTRING      reduce using rule 70 (type -> FLOAT64 .)
    LBRACE          reduce using rule 70 (type -> FLOAT64 .)
    FOR             reduce using rule 70 (type -> FLOAT64 .)
    INT             reduce using rule 70 (type -> FLOAT64 .)
    FLOAT           reduce using rule 70 (type -> FLOAT64 .)
    $end            reduce using rule 70 (type -> FLOAT64 .)
    RBRACE          reduce using rule 70 (type -> FLOAT64 .)
    CASE            reduce using rule 70 (type -> FLOAT64 .)
    DEFAULT         reduce using rule 70 (type -> FLOAT64 .)
    RPAREN          reduce using rule 70 (type -> FLOAT64 .)
    RBRACKET        reduce using rule 70 (type -> FLOAT64 .)


state 65

    (71) type -> BOOL .

    COMMA           reduce using rule 71 (type -> BOOL .)
    VARIABLE        reduce using rule 71 (type -> BOOL .)
    PRINT           reduce using rule 71 (type -> BOOL .)
    PRINTF          reduce using rule 71 (type -> BOOL .)
    INPUT           reduce using rule 71 (type -> BOOL .)
    IF              reduce using rule 71 (type -> BOOL .)
    TYPE            reduce using rule 71 (type -> BOOL .)
    FUNCTION        reduce using rule 71 (type -> BOOL .)
    VAR             reduce using rule 71 (type -> BOOL .)
    SWITCH          reduce using rule 71 (type -> BOOL .)
    CHARSTRING      reduce using rule 71 (type -> BOOL .)
    LBRACE          reduce using rule 71 (type -> BOOL .)
    FOR             reduce using rule 71 (type -> BOOL .)
    INT             reduce using rule 71 (type -> BOOL .)
    FLOAT           reduce using rule 71 (type -> BOOL .)
    $end            reduce using rule 71 (type -> BOOL .)
    RBRACE          reduce using rule 71 (type -> BOOL .)
    CASE            reduce using rule 71 (type -> BOOL .)
    DEFAULT         reduce using rule 71 (type -> BOOL .)
    RPAREN          reduce using rule 71 (type -> BOOL .)
    RBRACKET        reduce using rule 71 (type -> BOOL .)


state 66

    (6) main -> FUNCTION MAIN . LPAREN RPAREN

    LPAREN          shift and go to state 107


state 67

    (28) function -> FUNCTION VARIABLE . LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> FUNCTION VARIABLE . LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN type LBRACE RETURN value RBRACE

    LPAREN          shift and go to state 108


state 68

    (41) print_statement -> PRINT LPAREN . values RPAREN
    (42) print_statement -> PRINT LPAREN . string_value RPAREN
    (44) print_statement -> PRINT LPAREN . string_value COMMA values RPAREN
    (45) print_statement -> PRINT LPAREN . operation RPAREN
    (46) print_statement -> PRINT LPAREN . RPAREN
    (32) values -> . value
    (33) values -> . value COMMA values
    (34) string_value -> . value
    (35) string_value -> . CHARSTRING
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    RPAREN          shift and go to state 110
    CHARSTRING      shift and go to state 104
    VARIABLE        shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    values                         shift and go to state 109
    string_value                   shift and go to state 111
    operation                      shift and go to state 112
    value                          shift and go to state 113
    number                         shift and go to state 39

state 69

    (43) print_statement -> PRINTF LPAREN . FORMATSTRING COMMA values RPAREN

    FORMATSTRING    shift and go to state 114


state 70

    (47) input_statement -> INPUT LPAREN . values RPAREN
    (48) input_statement -> INPUT LPAREN . operation RPAREN
    (49) input_statement -> INPUT LPAREN . RPAREN
    (32) values -> . value
    (33) values -> . value COMMA values
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    RPAREN          shift and go to state 116
    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    values                         shift and go to state 115
    operation                      shift and go to state 117
    value                          shift and go to state 118
    number                         shift and go to state 39

state 71

    (72) conditional_structure -> IF conditions . conditional_body
    (73) conditional_structure -> IF conditions . conditional_body ELSE conditional_body
    (74) conditional_structure -> IF conditions . conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (75) conditional_body -> . LBRACE statement RBRACE
    (76) conditional_body -> . LBRACE BREAK RBRACE
    (77) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 120

    conditional_body               shift and go to state 119

state 72

    (78) conditions -> condition .
    (79) conditions -> condition . logical_operator conditions
    (81) logical_operator -> . AND
    (82) logical_operator -> . OR
    (83) logical_operator -> . NOT

    LBRACE          reduce using rule 78 (conditions -> condition .)
    AND             shift and go to state 122
    OR              shift and go to state 123
    NOT             shift and go to state 124

    logical_operator               shift and go to state 121

state 73

    (80) condition -> value . relational_operator value
    (84) relational_operator -> . GREATER
    (85) relational_operator -> . LESS
    (86) relational_operator -> . GREATEREQUALS
    (87) relational_operator -> . LESSEQUALS
    (88) relational_operator -> . EQUALS
    (89) relational_operator -> . DIFFERENT

    GREATER         shift and go to state 126
    LESS            shift and go to state 127
    GREATEREQUALS   shift and go to state 128
    LESSEQUALS      shift and go to state 129
    EQUALS          shift and go to state 130
    DIFFERENT       shift and go to state 131

    relational_operator            shift and go to state 125

state 74

    (50) operation -> value operator . value
    (51) operation -> value operator . operation
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    value                          shift and go to state 132
    operation                      shift and go to state 133
    number                         shift and go to state 39

state 75

    (52) operation -> value double_operator .

    PRINT           reduce using rule 52 (operation -> value double_operator .)
    PRINTF          reduce using rule 52 (operation -> value double_operator .)
    INPUT           reduce using rule 52 (operation -> value double_operator .)
    IF              reduce using rule 52 (operation -> value double_operator .)
    VARIABLE        reduce using rule 52 (operation -> value double_operator .)
    TYPE            reduce using rule 52 (operation -> value double_operator .)
    FUNCTION        reduce using rule 52 (operation -> value double_operator .)
    VAR             reduce using rule 52 (operation -> value double_operator .)
    SWITCH          reduce using rule 52 (operation -> value double_operator .)
    CHARSTRING      reduce using rule 52 (operation -> value double_operator .)
    LBRACE          reduce using rule 52 (operation -> value double_operator .)
    FOR             reduce using rule 52 (operation -> value double_operator .)
    INT             reduce using rule 52 (operation -> value double_operator .)
    FLOAT           reduce using rule 52 (operation -> value double_operator .)
    $end            reduce using rule 52 (operation -> value double_operator .)
    RBRACE          reduce using rule 52 (operation -> value double_operator .)
    CASE            reduce using rule 52 (operation -> value double_operator .)
    DEFAULT         reduce using rule 52 (operation -> value double_operator .)
    RPAREN          reduce using rule 52 (operation -> value double_operator .)


state 76

    (53) operator -> PLUS .

    VARIABLE        reduce using rule 53 (operator -> PLUS .)
    CHARSTRING      reduce using rule 53 (operator -> PLUS .)
    INT             reduce using rule 53 (operator -> PLUS .)
    FLOAT           reduce using rule 53 (operator -> PLUS .)


state 77

    (54) operator -> MINUS .

    VARIABLE        reduce using rule 54 (operator -> MINUS .)
    CHARSTRING      reduce using rule 54 (operator -> MINUS .)
    INT             reduce using rule 54 (operator -> MINUS .)
    FLOAT           reduce using rule 54 (operator -> MINUS .)


state 78

    (55) operator -> TIMES .

    VARIABLE        reduce using rule 55 (operator -> TIMES .)
    CHARSTRING      reduce using rule 55 (operator -> TIMES .)
    INT             reduce using rule 55 (operator -> TIMES .)
    FLOAT           reduce using rule 55 (operator -> TIMES .)


state 79

    (56) operator -> DIVIDE .

    VARIABLE        reduce using rule 56 (operator -> DIVIDE .)
    CHARSTRING      reduce using rule 56 (operator -> DIVIDE .)
    INT             reduce using rule 56 (operator -> DIVIDE .)
    FLOAT           reduce using rule 56 (operator -> DIVIDE .)


state 80

    (57) operator -> ASSIGN .

    VARIABLE        reduce using rule 57 (operator -> ASSIGN .)
    CHARSTRING      reduce using rule 57 (operator -> ASSIGN .)
    INT             reduce using rule 57 (operator -> ASSIGN .)
    FLOAT           reduce using rule 57 (operator -> ASSIGN .)


state 81

    (58) double_operator -> INCREMENT .

    PRINT           reduce using rule 58 (double_operator -> INCREMENT .)
    PRINTF          reduce using rule 58 (double_operator -> INCREMENT .)
    INPUT           reduce using rule 58 (double_operator -> INCREMENT .)
    IF              reduce using rule 58 (double_operator -> INCREMENT .)
    VARIABLE        reduce using rule 58 (double_operator -> INCREMENT .)
    TYPE            reduce using rule 58 (double_operator -> INCREMENT .)
    FUNCTION        reduce using rule 58 (double_operator -> INCREMENT .)
    VAR             reduce using rule 58 (double_operator -> INCREMENT .)
    SWITCH          reduce using rule 58 (double_operator -> INCREMENT .)
    CHARSTRING      reduce using rule 58 (double_operator -> INCREMENT .)
    LBRACE          reduce using rule 58 (double_operator -> INCREMENT .)
    FOR             reduce using rule 58 (double_operator -> INCREMENT .)
    INT             reduce using rule 58 (double_operator -> INCREMENT .)
    FLOAT           reduce using rule 58 (double_operator -> INCREMENT .)
    $end            reduce using rule 58 (double_operator -> INCREMENT .)
    RBRACE          reduce using rule 58 (double_operator -> INCREMENT .)
    CASE            reduce using rule 58 (double_operator -> INCREMENT .)
    DEFAULT         reduce using rule 58 (double_operator -> INCREMENT .)
    RPAREN          reduce using rule 58 (double_operator -> INCREMENT .)


state 82

    (59) double_operator -> DECREMENT .

    PRINT           reduce using rule 59 (double_operator -> DECREMENT .)
    PRINTF          reduce using rule 59 (double_operator -> DECREMENT .)
    INPUT           reduce using rule 59 (double_operator -> DECREMENT .)
    IF              reduce using rule 59 (double_operator -> DECREMENT .)
    VARIABLE        reduce using rule 59 (double_operator -> DECREMENT .)
    TYPE            reduce using rule 59 (double_operator -> DECREMENT .)
    FUNCTION        reduce using rule 59 (double_operator -> DECREMENT .)
    VAR             reduce using rule 59 (double_operator -> DECREMENT .)
    SWITCH          reduce using rule 59 (double_operator -> DECREMENT .)
    CHARSTRING      reduce using rule 59 (double_operator -> DECREMENT .)
    LBRACE          reduce using rule 59 (double_operator -> DECREMENT .)
    FOR             reduce using rule 59 (double_operator -> DECREMENT .)
    INT             reduce using rule 59 (double_operator -> DECREMENT .)
    FLOAT           reduce using rule 59 (double_operator -> DECREMENT .)
    $end            reduce using rule 59 (double_operator -> DECREMENT .)
    RBRACE          reduce using rule 59 (double_operator -> DECREMENT .)
    CASE            reduce using rule 59 (double_operator -> DECREMENT .)
    DEFAULT         reduce using rule 59 (double_operator -> DECREMENT .)
    RPAREN          reduce using rule 59 (double_operator -> DECREMENT .)


state 83

    (27) structure -> TYPE VARIABLE . STRUCT LBRACE statement RBRACE
    (109) defined_list -> TYPE VARIABLE . LBRACE values RBRACE

    STRUCT          shift and go to state 134
    LBRACE          shift and go to state 135


state 84

    (61) parameters -> parameter parameters .

    PRINT           reduce using rule 61 (parameters -> parameter parameters .)
    PRINTF          reduce using rule 61 (parameters -> parameter parameters .)
    INPUT           reduce using rule 61 (parameters -> parameter parameters .)
    IF              reduce using rule 61 (parameters -> parameter parameters .)
    VARIABLE        reduce using rule 61 (parameters -> parameter parameters .)
    TYPE            reduce using rule 61 (parameters -> parameter parameters .)
    FUNCTION        reduce using rule 61 (parameters -> parameter parameters .)
    VAR             reduce using rule 61 (parameters -> parameter parameters .)
    SWITCH          reduce using rule 61 (parameters -> parameter parameters .)
    CHARSTRING      reduce using rule 61 (parameters -> parameter parameters .)
    LBRACE          reduce using rule 61 (parameters -> parameter parameters .)
    FOR             reduce using rule 61 (parameters -> parameter parameters .)
    INT             reduce using rule 61 (parameters -> parameter parameters .)
    FLOAT           reduce using rule 61 (parameters -> parameter parameters .)
    $end            reduce using rule 61 (parameters -> parameter parameters .)
    RBRACE          reduce using rule 61 (parameters -> parameter parameters .)
    CASE            reduce using rule 61 (parameters -> parameter parameters .)
    DEFAULT         reduce using rule 61 (parameters -> parameter parameters .)
    RPAREN          reduce using rule 61 (parameters -> parameter parameters .)


state 85

    (62) parameters -> parameter COMMA . parameters
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (63) parameter -> . VARIABLE type

    VARIABLE        shift and go to state 86

    parameter                      shift and go to state 36
    parameters                     shift and go to state 136

state 86

    (63) parameter -> VARIABLE . type
    (64) type -> . INT
    (65) type -> . INT32
    (66) type -> . INT64
    (67) type -> . STRING
    (68) type -> . FLOAT
    (69) type -> . FLOAT32
    (70) type -> . FLOAT64
    (71) type -> . BOOL

    INT             shift and go to state 58
    INT32           shift and go to state 59
    INT64           shift and go to state 60
    STRING          shift and go to state 61
    FLOAT           shift and go to state 62
    FLOAT32         shift and go to state 63
    FLOAT64         shift and go to state 64
    BOOL            shift and go to state 65

    type                           shift and go to state 56

state 87

    (23) variable_declaration -> VAR VARIABLE . type
    (24) variable_declaration -> VAR VARIABLE . ASSIGN value
    (117) slice_structure -> VAR VARIABLE . LBRACKET RBRACKET type
    (64) type -> . INT
    (65) type -> . INT32
    (66) type -> . INT64
    (67) type -> . STRING
    (68) type -> . FLOAT
    (69) type -> . FLOAT32
    (70) type -> . FLOAT64
    (71) type -> . BOOL

    ASSIGN          shift and go to state 138
    LBRACKET        shift and go to state 139
    INT             shift and go to state 58
    INT32           shift and go to state 59
    INT64           shift and go to state 60
    STRING          shift and go to state 61
    FLOAT           shift and go to state 62
    FLOAT32         shift and go to state 63
    FLOAT64         shift and go to state 64
    BOOL            shift and go to state 65

    type                           shift and go to state 137

state 88

    (96) switch_structure -> SWITCH switch_expression . LBRACE case_blocks RBRACE

    LBRACE          shift and go to state 140


state 89

    (97) switch_expression -> value .

    LBRACE          reduce using rule 97 (switch_expression -> value .)


state 90

    (98) switch_expression -> empty .

    LBRACE          reduce using rule 98 (switch_expression -> empty .)


state 91

    (93) for_initialization -> FOR VARIABLE . SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (95) for_iterator -> FOR VARIABLE . SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 141
    SEMICOLON       shift and go to state 142


state 92

    (94) for_infinite_bucle -> FOR LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . package blocks
    (3) statement -> . main LBRACE blocks RBRACE
    (4) statement -> . package main LBRACE blocks RBRACE
    (7) blocks -> . block
    (8) blocks -> . block blocks
    (5) package -> . PACKAGE VARIABLE
    (6) main -> . FUNCTION MAIN LPAREN RPAREN
    (9) block -> . print_statement
    (10) block -> . input_statement
    (11) block -> . conditional_structure
    (12) block -> . operation
    (13) block -> . list_structure
    (14) block -> . map_estructure
    (15) block -> . map_assign
    (16) block -> . for_estructure
    (17) block -> . structure
    (18) block -> . function
    (19) block -> . parameters
    (20) block -> . variable_declaration
    (21) block -> . switch_structure
    (22) block -> . slice_structure
    (41) print_statement -> . PRINT LPAREN values RPAREN
    (42) print_statement -> . PRINT LPAREN string_value RPAREN
    (43) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (44) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (45) print_statement -> . PRINT LPAREN operation RPAREN
    (46) print_statement -> . PRINT LPAREN RPAREN
    (47) input_statement -> . INPUT LPAREN values RPAREN
    (48) input_statement -> . INPUT LPAREN operation RPAREN
    (49) input_statement -> . INPUT LPAREN RPAREN
    (72) conditional_structure -> . IF conditions conditional_body
    (73) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (74) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (104) list_structure -> . empty_list
    (105) list_structure -> . list_with_data
    (106) list_structure -> . defined_list
    (110) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (115) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (90) for_estructure -> . for_initialization
    (91) for_estructure -> . for_infinite_bucle
    (92) for_estructure -> . for_iterator
    (27) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (28) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (23) variable_declaration -> . VAR VARIABLE type
    (24) variable_declaration -> . VAR VARIABLE ASSIGN value
    (25) variable_declaration -> . VARIABLE SHORTASSIGN value
    (26) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (96) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (116) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (117) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (118) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (119) slice_structure -> . VARIABLE ASSIGN append_statement
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (107) empty_list -> . LBRACE RBRACE
    (108) list_with_data -> . LBRACE values RBRACE
    (109) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (93) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (94) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (95) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (63) parameter -> . VARIABLE type
    (39) number -> . INT
    (40) number -> . FLOAT

    PACKAGE         shift and go to state 7
    FUNCTION        shift and go to state 9
    PRINT           shift and go to state 24
    PRINTF          shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 27
    VARIABLE        shift and go to state 8
    TYPE            shift and go to state 35
    VAR             shift and go to state 37
    SWITCH          shift and go to state 38
    CHARSTRING      shift and go to state 40
    LBRACE          shift and go to state 5
    FOR             shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    statement                      shift and go to state 143
    blocks                         shift and go to state 2
    package                        shift and go to state 3
    main                           shift and go to state 4
    block                          shift and go to state 6
    print_statement                shift and go to state 10
    input_statement                shift and go to state 11
    conditional_structure          shift and go to state 12
    operation                      shift and go to state 13
    list_structure                 shift and go to state 14
    map_estructure                 shift and go to state 15
    map_assign                     shift and go to state 16
    for_estructure                 shift and go to state 17
    structure                      shift and go to state 18
    function                       shift and go to state 19
    parameters                     shift and go to state 20
    variable_declaration           shift and go to state 21
    switch_structure               shift and go to state 22
    slice_structure                shift and go to state 23
    value                          shift and go to state 28
    empty_list                     shift and go to state 29
    list_with_data                 shift and go to state 30
    defined_list                   shift and go to state 31
    for_initialization             shift and go to state 32
    for_infinite_bucle             shift and go to state 33
    for_iterator                   shift and go to state 34
    parameter                      shift and go to state 36
    number                         shift and go to state 39

state 93

    (4) statement -> package main LBRACE . blocks RBRACE
    (7) blocks -> . block
    (8) blocks -> . block blocks
    (9) block -> . print_statement
    (10) block -> . input_statement
    (11) block -> . conditional_structure
    (12) block -> . operation
    (13) block -> . list_structure
    (14) block -> . map_estructure
    (15) block -> . map_assign
    (16) block -> . for_estructure
    (17) block -> . structure
    (18) block -> . function
    (19) block -> . parameters
    (20) block -> . variable_declaration
    (21) block -> . switch_structure
    (22) block -> . slice_structure
    (41) print_statement -> . PRINT LPAREN values RPAREN
    (42) print_statement -> . PRINT LPAREN string_value RPAREN
    (43) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (44) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (45) print_statement -> . PRINT LPAREN operation RPAREN
    (46) print_statement -> . PRINT LPAREN RPAREN
    (47) input_statement -> . INPUT LPAREN values RPAREN
    (48) input_statement -> . INPUT LPAREN operation RPAREN
    (49) input_statement -> . INPUT LPAREN RPAREN
    (72) conditional_structure -> . IF conditions conditional_body
    (73) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (74) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (104) list_structure -> . empty_list
    (105) list_structure -> . list_with_data
    (106) list_structure -> . defined_list
    (110) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (115) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (90) for_estructure -> . for_initialization
    (91) for_estructure -> . for_infinite_bucle
    (92) for_estructure -> . for_iterator
    (27) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (28) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (23) variable_declaration -> . VAR VARIABLE type
    (24) variable_declaration -> . VAR VARIABLE ASSIGN value
    (25) variable_declaration -> . VARIABLE SHORTASSIGN value
    (26) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (96) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (116) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (117) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (118) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (119) slice_structure -> . VARIABLE ASSIGN append_statement
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (107) empty_list -> . LBRACE RBRACE
    (108) list_with_data -> . LBRACE values RBRACE
    (109) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (93) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (94) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (95) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (63) parameter -> . VARIABLE type
    (39) number -> . INT
    (40) number -> . FLOAT

    PRINT           shift and go to state 24
    PRINTF          shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 27
    VARIABLE        shift and go to state 8
    TYPE            shift and go to state 35
    FUNCTION        shift and go to state 52
    VAR             shift and go to state 37
    SWITCH          shift and go to state 38
    CHARSTRING      shift and go to state 40
    LBRACE          shift and go to state 5
    FOR             shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    blocks                         shift and go to state 144
    block                          shift and go to state 6
    print_statement                shift and go to state 10
    input_statement                shift and go to state 11
    conditional_structure          shift and go to state 12
    operation                      shift and go to state 13
    list_structure                 shift and go to state 14
    map_estructure                 shift and go to state 15
    map_assign                     shift and go to state 16
    for_estructure                 shift and go to state 17
    structure                      shift and go to state 18
    function                       shift and go to state 19
    parameters                     shift and go to state 20
    variable_declaration           shift and go to state 21
    switch_structure               shift and go to state 22
    slice_structure                shift and go to state 23
    value                          shift and go to state 28
    empty_list                     shift and go to state 29
    list_with_data                 shift and go to state 30
    defined_list                   shift and go to state 31
    for_initialization             shift and go to state 32
    for_infinite_bucle             shift and go to state 33
    for_iterator                   shift and go to state 34
    parameter                      shift and go to state 36
    number                         shift and go to state 39

state 94

    (3) statement -> main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 145


state 95

    (108) list_with_data -> LBRACE values RBRACE .

    PRINT           reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    PRINTF          reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    INPUT           reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    IF              reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    VARIABLE        reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    TYPE            reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    FUNCTION        reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    VAR             reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    SWITCH          reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    LBRACE          reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    FOR             reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    INT             reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    FLOAT           reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    $end            reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    RBRACE          reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    CASE            reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)
    DEFAULT         reduce using rule 108 (list_with_data -> LBRACE values RBRACE .)


state 96

    (33) values -> value COMMA . values
    (32) values -> . value
    (33) values -> . value COMMA values
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    value                          shift and go to state 49
    values                         shift and go to state 146
    number                         shift and go to state 39

state 97

    (110) map_estructure -> VARIABLE SHORTASSIGN MAP . LBRACKET type RBRACKET type LBRACE map_values RBRACE

    LBRACKET        shift and go to state 147


state 98

    (116) slice_structure -> VARIABLE SHORTASSIGN LBRACKET . RBRACKET type LBRACE values RBRACE
    (118) slice_structure -> VARIABLE SHORTASSIGN LBRACKET . RBRACKET type

    RBRACKET        shift and go to state 148


state 99

    (111) map_estructure -> VARIABLE SHORTASSIGN MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN

    LPAREN          shift and go to state 149


state 100

    (25) variable_declaration -> VARIABLE SHORTASSIGN value .
    (50) operation -> value . operator value
    (51) operation -> value . operator operation
    (52) operation -> value . double_operator
    (53) operator -> . PLUS
    (54) operator -> . MINUS
    (55) operator -> . TIMES
    (56) operator -> . DIVIDE
    (57) operator -> . ASSIGN
    (58) double_operator -> . INCREMENT
    (59) double_operator -> . DECREMENT

    PRINT           reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    PRINTF          reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INPUT           reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    IF              reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VARIABLE        reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    TYPE            reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FUNCTION        reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VAR             reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    SWITCH          reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CHARSTRING      reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    LBRACE          reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FOR             reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INT             reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FLOAT           reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    $end            reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    RBRACE          reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CASE            reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    DEFAULT         reduce using rule 25 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 79
    ASSIGN          shift and go to state 80
    INCREMENT       shift and go to state 81
    DECREMENT       shift and go to state 82

    operator                       shift and go to state 74
    double_operator                shift and go to state 75

state 101

    (26) variable_declaration -> VARIABLE SHORTASSIGN operation .

    PRINT           reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    PRINTF          reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    INPUT           reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    IF              reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    VARIABLE        reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    TYPE            reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FUNCTION        reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    VAR             reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    SWITCH          reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CHARSTRING      reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    LBRACE          reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FOR             reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    INT             reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FLOAT           reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    $end            reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    RBRACE          reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CASE            reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    DEFAULT         reduce using rule 26 (variable_declaration -> VARIABLE SHORTASSIGN operation .)


state 102

    (115) map_assign -> VARIABLE LBRACKET string_value . RBRACKET ASSIGN string_value

    RBRACKET        shift and go to state 150


state 103

    (34) string_value -> value .

    RBRACKET        reduce using rule 34 (string_value -> value .)
    PRINT           reduce using rule 34 (string_value -> value .)
    PRINTF          reduce using rule 34 (string_value -> value .)
    INPUT           reduce using rule 34 (string_value -> value .)
    IF              reduce using rule 34 (string_value -> value .)
    VARIABLE        reduce using rule 34 (string_value -> value .)
    TYPE            reduce using rule 34 (string_value -> value .)
    FUNCTION        reduce using rule 34 (string_value -> value .)
    VAR             reduce using rule 34 (string_value -> value .)
    SWITCH          reduce using rule 34 (string_value -> value .)
    CHARSTRING      reduce using rule 34 (string_value -> value .)
    LBRACE          reduce using rule 34 (string_value -> value .)
    FOR             reduce using rule 34 (string_value -> value .)
    INT             reduce using rule 34 (string_value -> value .)
    FLOAT           reduce using rule 34 (string_value -> value .)
    $end            reduce using rule 34 (string_value -> value .)
    RBRACE          reduce using rule 34 (string_value -> value .)
    CASE            reduce using rule 34 (string_value -> value .)
    DEFAULT         reduce using rule 34 (string_value -> value .)
    COLON           reduce using rule 34 (string_value -> value .)
    COMMA           reduce using rule 34 (string_value -> value .)


state 104

    (35) string_value -> CHARSTRING .
    (38) value -> CHARSTRING .

  ! reduce/reduce conflict for RBRACKET resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for COMMA resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for RPAREN resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for PRINT resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for PRINTF resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for INPUT resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for IF resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for TYPE resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for VAR resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for SWITCH resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for CHARSTRING resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for LBRACE resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for FOR resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for INT resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for FLOAT resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for $end resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for RBRACE resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for CASE resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 35 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for COLON resolved using rule 35 (string_value -> CHARSTRING .)
    RBRACKET        reduce using rule 35 (string_value -> CHARSTRING .)
    RPAREN          reduce using rule 35 (string_value -> CHARSTRING .)
    COMMA           reduce using rule 35 (string_value -> CHARSTRING .)
    PRINT           reduce using rule 35 (string_value -> CHARSTRING .)
    PRINTF          reduce using rule 35 (string_value -> CHARSTRING .)
    INPUT           reduce using rule 35 (string_value -> CHARSTRING .)
    IF              reduce using rule 35 (string_value -> CHARSTRING .)
    VARIABLE        reduce using rule 35 (string_value -> CHARSTRING .)
    TYPE            reduce using rule 35 (string_value -> CHARSTRING .)
    FUNCTION        reduce using rule 35 (string_value -> CHARSTRING .)
    VAR             reduce using rule 35 (string_value -> CHARSTRING .)
    SWITCH          reduce using rule 35 (string_value -> CHARSTRING .)
    CHARSTRING      reduce using rule 35 (string_value -> CHARSTRING .)
    LBRACE          reduce using rule 35 (string_value -> CHARSTRING .)
    FOR             reduce using rule 35 (string_value -> CHARSTRING .)
    INT             reduce using rule 35 (string_value -> CHARSTRING .)
    FLOAT           reduce using rule 35 (string_value -> CHARSTRING .)
    $end            reduce using rule 35 (string_value -> CHARSTRING .)
    RBRACE          reduce using rule 35 (string_value -> CHARSTRING .)
    CASE            reduce using rule 35 (string_value -> CHARSTRING .)
    DEFAULT         reduce using rule 35 (string_value -> CHARSTRING .)
    COLON           reduce using rule 35 (string_value -> CHARSTRING .)
    PLUS            reduce using rule 38 (value -> CHARSTRING .)
    MINUS           reduce using rule 38 (value -> CHARSTRING .)
    TIMES           reduce using rule 38 (value -> CHARSTRING .)
    DIVIDE          reduce using rule 38 (value -> CHARSTRING .)
    ASSIGN          reduce using rule 38 (value -> CHARSTRING .)
    INCREMENT       reduce using rule 38 (value -> CHARSTRING .)
    DECREMENT       reduce using rule 38 (value -> CHARSTRING .)

  ! RBRACKET        [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! COMMA           [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! RPAREN          [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! PRINT           [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! PRINTF          [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! INPUT           [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! IF              [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! VARIABLE        [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! TYPE            [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! FUNCTION        [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! VAR             [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! SWITCH          [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! CHARSTRING      [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! LBRACE          [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! FOR             [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! INT             [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! FLOAT           [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! $end            [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! RBRACE          [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! CASE            [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! DEFAULT         [ reduce using rule 38 (value -> CHARSTRING .) ]
  ! COLON           [ reduce using rule 38 (value -> CHARSTRING .) ]


state 105

    (119) slice_structure -> VARIABLE ASSIGN append_statement .

    PRINT           reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    PRINTF          reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    INPUT           reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    IF              reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    VARIABLE        reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    TYPE            reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FUNCTION        reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    VAR             reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    SWITCH          reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CHARSTRING      reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    LBRACE          reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FOR             reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    INT             reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FLOAT           reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    $end            reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    RBRACE          reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CASE            reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)
    DEFAULT         reduce using rule 119 (slice_structure -> VARIABLE ASSIGN append_statement .)


state 106

    (120) append_statement -> APPEND . LPAREN VARIABLE COMMA values RPAREN

    LPAREN          shift and go to state 151


state 107

    (6) main -> FUNCTION MAIN LPAREN . RPAREN

    RPAREN          shift and go to state 152


state 108

    (28) function -> FUNCTION VARIABLE LPAREN . RPAREN LBRACE blocks RBRACE
    (29) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN LBRACE blocks RBRACE
    (30) function -> FUNCTION VARIABLE LPAREN . RPAREN type LBRACE RETURN value RBRACE
    (31) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN type LBRACE RETURN value RBRACE
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (63) parameter -> . VARIABLE type

    RPAREN          shift and go to state 153
    VARIABLE        shift and go to state 86

    parameters                     shift and go to state 154
    parameter                      shift and go to state 36

state 109

    (41) print_statement -> PRINT LPAREN values . RPAREN

    RPAREN          shift and go to state 155


state 110

    (46) print_statement -> PRINT LPAREN RPAREN .

    PRINT           reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    PRINTF          reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    INPUT           reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    IF              reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    VARIABLE        reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    TYPE            reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    FUNCTION        reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    VAR             reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    SWITCH          reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    CHARSTRING      reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    LBRACE          reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    FOR             reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    INT             reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    FLOAT           reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    $end            reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    RBRACE          reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    CASE            reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)
    DEFAULT         reduce using rule 46 (print_statement -> PRINT LPAREN RPAREN .)


state 111

    (42) print_statement -> PRINT LPAREN string_value . RPAREN
    (44) print_statement -> PRINT LPAREN string_value . COMMA values RPAREN

    RPAREN          shift and go to state 156
    COMMA           shift and go to state 157


state 112

    (45) print_statement -> PRINT LPAREN operation . RPAREN

    RPAREN          shift and go to state 158


state 113

    (32) values -> value .
    (33) values -> value . COMMA values
    (34) string_value -> value .
    (50) operation -> value . operator value
    (51) operation -> value . operator operation
    (52) operation -> value . double_operator
    (53) operator -> . PLUS
    (54) operator -> . MINUS
    (55) operator -> . TIMES
    (56) operator -> . DIVIDE
    (57) operator -> . ASSIGN
    (58) double_operator -> . INCREMENT
    (59) double_operator -> . DECREMENT

  ! reduce/reduce conflict for RPAREN resolved using rule 32 (values -> value .)
  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 32 (values -> value .)
    COMMA           shift and go to state 96
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 79
    ASSIGN          shift and go to state 80
    INCREMENT       shift and go to state 81
    DECREMENT       shift and go to state 82

  ! RPAREN          [ reduce using rule 34 (string_value -> value .) ]
  ! COMMA           [ reduce using rule 34 (string_value -> value .) ]

    operator                       shift and go to state 74
    double_operator                shift and go to state 75

state 114

    (43) print_statement -> PRINTF LPAREN FORMATSTRING . COMMA values RPAREN

    COMMA           shift and go to state 159


state 115

    (47) input_statement -> INPUT LPAREN values . RPAREN

    RPAREN          shift and go to state 160


state 116

    (49) input_statement -> INPUT LPAREN RPAREN .

    PRINT           reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    PRINTF          reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    IF              reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    VARIABLE        reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    TYPE            reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    FUNCTION        reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    VAR             reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    SWITCH          reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    CHARSTRING      reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    LBRACE          reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    INT             reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    FLOAT           reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    $end            reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    CASE            reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)
    DEFAULT         reduce using rule 49 (input_statement -> INPUT LPAREN RPAREN .)


state 117

    (48) input_statement -> INPUT LPAREN operation . RPAREN

    RPAREN          shift and go to state 161


state 118

    (32) values -> value .
    (33) values -> value . COMMA values
    (50) operation -> value . operator value
    (51) operation -> value . operator operation
    (52) operation -> value . double_operator
    (53) operator -> . PLUS
    (54) operator -> . MINUS
    (55) operator -> . TIMES
    (56) operator -> . DIVIDE
    (57) operator -> . ASSIGN
    (58) double_operator -> . INCREMENT
    (59) double_operator -> . DECREMENT

    RPAREN          reduce using rule 32 (values -> value .)
    COMMA           shift and go to state 96
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 79
    ASSIGN          shift and go to state 80
    INCREMENT       shift and go to state 81
    DECREMENT       shift and go to state 82

    operator                       shift and go to state 74
    double_operator                shift and go to state 75

state 119

    (72) conditional_structure -> IF conditions conditional_body .
    (73) conditional_structure -> IF conditions conditional_body . ELSE conditional_body
    (74) conditional_structure -> IF conditions conditional_body . ELSE IF conditions conditional_body ELSE conditional_body

    PRINT           reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    PRINTF          reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    INPUT           reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    IF              reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    VARIABLE        reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    TYPE            reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    FUNCTION        reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    VAR             reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    SWITCH          reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    CHARSTRING      reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    LBRACE          reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    FOR             reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    INT             reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    FLOAT           reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    $end            reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    RBRACE          reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    CASE            reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    DEFAULT         reduce using rule 72 (conditional_structure -> IF conditions conditional_body .)
    ELSE            shift and go to state 162


state 120

    (75) conditional_body -> LBRACE . statement RBRACE
    (76) conditional_body -> LBRACE . BREAK RBRACE
    (77) conditional_body -> LBRACE . CONTINUE RBRACE
    (1) statement -> . blocks
    (2) statement -> . package blocks
    (3) statement -> . main LBRACE blocks RBRACE
    (4) statement -> . package main LBRACE blocks RBRACE
    (7) blocks -> . block
    (8) blocks -> . block blocks
    (5) package -> . PACKAGE VARIABLE
    (6) main -> . FUNCTION MAIN LPAREN RPAREN
    (9) block -> . print_statement
    (10) block -> . input_statement
    (11) block -> . conditional_structure
    (12) block -> . operation
    (13) block -> . list_structure
    (14) block -> . map_estructure
    (15) block -> . map_assign
    (16) block -> . for_estructure
    (17) block -> . structure
    (18) block -> . function
    (19) block -> . parameters
    (20) block -> . variable_declaration
    (21) block -> . switch_structure
    (22) block -> . slice_structure
    (41) print_statement -> . PRINT LPAREN values RPAREN
    (42) print_statement -> . PRINT LPAREN string_value RPAREN
    (43) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (44) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (45) print_statement -> . PRINT LPAREN operation RPAREN
    (46) print_statement -> . PRINT LPAREN RPAREN
    (47) input_statement -> . INPUT LPAREN values RPAREN
    (48) input_statement -> . INPUT LPAREN operation RPAREN
    (49) input_statement -> . INPUT LPAREN RPAREN
    (72) conditional_structure -> . IF conditions conditional_body
    (73) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (74) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (104) list_structure -> . empty_list
    (105) list_structure -> . list_with_data
    (106) list_structure -> . defined_list
    (110) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (115) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (90) for_estructure -> . for_initialization
    (91) for_estructure -> . for_infinite_bucle
    (92) for_estructure -> . for_iterator
    (27) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (28) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (23) variable_declaration -> . VAR VARIABLE type
    (24) variable_declaration -> . VAR VARIABLE ASSIGN value
    (25) variable_declaration -> . VARIABLE SHORTASSIGN value
    (26) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (96) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (116) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (117) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (118) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (119) slice_structure -> . VARIABLE ASSIGN append_statement
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (107) empty_list -> . LBRACE RBRACE
    (108) list_with_data -> . LBRACE values RBRACE
    (109) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (93) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (94) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (95) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (63) parameter -> . VARIABLE type
    (39) number -> . INT
    (40) number -> . FLOAT

    BREAK           shift and go to state 164
    CONTINUE        shift and go to state 165
    PACKAGE         shift and go to state 7
    FUNCTION        shift and go to state 9
    PRINT           shift and go to state 24
    PRINTF          shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 27
    VARIABLE        shift and go to state 8
    TYPE            shift and go to state 35
    VAR             shift and go to state 37
    SWITCH          shift and go to state 38
    CHARSTRING      shift and go to state 40
    LBRACE          shift and go to state 5
    FOR             shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    statement                      shift and go to state 163
    blocks                         shift and go to state 2
    package                        shift and go to state 3
    main                           shift and go to state 4
    block                          shift and go to state 6
    print_statement                shift and go to state 10
    input_statement                shift and go to state 11
    conditional_structure          shift and go to state 12
    operation                      shift and go to state 13
    list_structure                 shift and go to state 14
    map_estructure                 shift and go to state 15
    map_assign                     shift and go to state 16
    for_estructure                 shift and go to state 17
    structure                      shift and go to state 18
    function                       shift and go to state 19
    parameters                     shift and go to state 20
    variable_declaration           shift and go to state 21
    switch_structure               shift and go to state 22
    slice_structure                shift and go to state 23
    value                          shift and go to state 28
    empty_list                     shift and go to state 29
    list_with_data                 shift and go to state 30
    defined_list                   shift and go to state 31
    for_initialization             shift and go to state 32
    for_infinite_bucle             shift and go to state 33
    for_iterator                   shift and go to state 34
    parameter                      shift and go to state 36
    number                         shift and go to state 39

state 121

    (79) conditions -> condition logical_operator . conditions
    (78) conditions -> . condition
    (79) conditions -> . condition logical_operator conditions
    (80) condition -> . value relational_operator value
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    condition                      shift and go to state 72
    conditions                     shift and go to state 166
    value                          shift and go to state 73
    number                         shift and go to state 39

state 122

    (81) logical_operator -> AND .

    VARIABLE        reduce using rule 81 (logical_operator -> AND .)
    CHARSTRING      reduce using rule 81 (logical_operator -> AND .)
    INT             reduce using rule 81 (logical_operator -> AND .)
    FLOAT           reduce using rule 81 (logical_operator -> AND .)


state 123

    (82) logical_operator -> OR .

    VARIABLE        reduce using rule 82 (logical_operator -> OR .)
    CHARSTRING      reduce using rule 82 (logical_operator -> OR .)
    INT             reduce using rule 82 (logical_operator -> OR .)
    FLOAT           reduce using rule 82 (logical_operator -> OR .)


state 124

    (83) logical_operator -> NOT .

    VARIABLE        reduce using rule 83 (logical_operator -> NOT .)
    CHARSTRING      reduce using rule 83 (logical_operator -> NOT .)
    INT             reduce using rule 83 (logical_operator -> NOT .)
    FLOAT           reduce using rule 83 (logical_operator -> NOT .)


state 125

    (80) condition -> value relational_operator . value
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    value                          shift and go to state 167
    number                         shift and go to state 39

state 126

    (84) relational_operator -> GREATER .

    VARIABLE        reduce using rule 84 (relational_operator -> GREATER .)
    CHARSTRING      reduce using rule 84 (relational_operator -> GREATER .)
    INT             reduce using rule 84 (relational_operator -> GREATER .)
    FLOAT           reduce using rule 84 (relational_operator -> GREATER .)


state 127

    (85) relational_operator -> LESS .

    VARIABLE        reduce using rule 85 (relational_operator -> LESS .)
    CHARSTRING      reduce using rule 85 (relational_operator -> LESS .)
    INT             reduce using rule 85 (relational_operator -> LESS .)
    FLOAT           reduce using rule 85 (relational_operator -> LESS .)


state 128

    (86) relational_operator -> GREATEREQUALS .

    VARIABLE        reduce using rule 86 (relational_operator -> GREATEREQUALS .)
    CHARSTRING      reduce using rule 86 (relational_operator -> GREATEREQUALS .)
    INT             reduce using rule 86 (relational_operator -> GREATEREQUALS .)
    FLOAT           reduce using rule 86 (relational_operator -> GREATEREQUALS .)


state 129

    (87) relational_operator -> LESSEQUALS .

    VARIABLE        reduce using rule 87 (relational_operator -> LESSEQUALS .)
    CHARSTRING      reduce using rule 87 (relational_operator -> LESSEQUALS .)
    INT             reduce using rule 87 (relational_operator -> LESSEQUALS .)
    FLOAT           reduce using rule 87 (relational_operator -> LESSEQUALS .)


state 130

    (88) relational_operator -> EQUALS .

    VARIABLE        reduce using rule 88 (relational_operator -> EQUALS .)
    CHARSTRING      reduce using rule 88 (relational_operator -> EQUALS .)
    INT             reduce using rule 88 (relational_operator -> EQUALS .)
    FLOAT           reduce using rule 88 (relational_operator -> EQUALS .)


state 131

    (89) relational_operator -> DIFFERENT .

    VARIABLE        reduce using rule 89 (relational_operator -> DIFFERENT .)
    CHARSTRING      reduce using rule 89 (relational_operator -> DIFFERENT .)
    INT             reduce using rule 89 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 89 (relational_operator -> DIFFERENT .)


state 132

    (50) operation -> value operator value .
    (50) operation -> value . operator value
    (51) operation -> value . operator operation
    (52) operation -> value . double_operator
    (53) operator -> . PLUS
    (54) operator -> . MINUS
    (55) operator -> . TIMES
    (56) operator -> . DIVIDE
    (57) operator -> . ASSIGN
    (58) double_operator -> . INCREMENT
    (59) double_operator -> . DECREMENT

    PRINT           reduce using rule 50 (operation -> value operator value .)
    PRINTF          reduce using rule 50 (operation -> value operator value .)
    INPUT           reduce using rule 50 (operation -> value operator value .)
    IF              reduce using rule 50 (operation -> value operator value .)
    VARIABLE        reduce using rule 50 (operation -> value operator value .)
    TYPE            reduce using rule 50 (operation -> value operator value .)
    FUNCTION        reduce using rule 50 (operation -> value operator value .)
    VAR             reduce using rule 50 (operation -> value operator value .)
    SWITCH          reduce using rule 50 (operation -> value operator value .)
    CHARSTRING      reduce using rule 50 (operation -> value operator value .)
    LBRACE          reduce using rule 50 (operation -> value operator value .)
    FOR             reduce using rule 50 (operation -> value operator value .)
    INT             reduce using rule 50 (operation -> value operator value .)
    FLOAT           reduce using rule 50 (operation -> value operator value .)
    $end            reduce using rule 50 (operation -> value operator value .)
    RBRACE          reduce using rule 50 (operation -> value operator value .)
    CASE            reduce using rule 50 (operation -> value operator value .)
    DEFAULT         reduce using rule 50 (operation -> value operator value .)
    RPAREN          reduce using rule 50 (operation -> value operator value .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 79
    ASSIGN          shift and go to state 80
    INCREMENT       shift and go to state 81
    DECREMENT       shift and go to state 82

    operator                       shift and go to state 74
    double_operator                shift and go to state 75

state 133

    (51) operation -> value operator operation .

    PRINT           reduce using rule 51 (operation -> value operator operation .)
    PRINTF          reduce using rule 51 (operation -> value operator operation .)
    INPUT           reduce using rule 51 (operation -> value operator operation .)
    IF              reduce using rule 51 (operation -> value operator operation .)
    VARIABLE        reduce using rule 51 (operation -> value operator operation .)
    TYPE            reduce using rule 51 (operation -> value operator operation .)
    FUNCTION        reduce using rule 51 (operation -> value operator operation .)
    VAR             reduce using rule 51 (operation -> value operator operation .)
    SWITCH          reduce using rule 51 (operation -> value operator operation .)
    CHARSTRING      reduce using rule 51 (operation -> value operator operation .)
    LBRACE          reduce using rule 51 (operation -> value operator operation .)
    FOR             reduce using rule 51 (operation -> value operator operation .)
    INT             reduce using rule 51 (operation -> value operator operation .)
    FLOAT           reduce using rule 51 (operation -> value operator operation .)
    $end            reduce using rule 51 (operation -> value operator operation .)
    RBRACE          reduce using rule 51 (operation -> value operator operation .)
    CASE            reduce using rule 51 (operation -> value operator operation .)
    DEFAULT         reduce using rule 51 (operation -> value operator operation .)
    RPAREN          reduce using rule 51 (operation -> value operator operation .)


state 134

    (27) structure -> TYPE VARIABLE STRUCT . LBRACE statement RBRACE

    LBRACE          shift and go to state 168


state 135

    (109) defined_list -> TYPE VARIABLE LBRACE . values RBRACE
    (32) values -> . value
    (33) values -> . value COMMA values
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    values                         shift and go to state 169
    value                          shift and go to state 49
    number                         shift and go to state 39

state 136

    (62) parameters -> parameter COMMA parameters .

    PRINT           reduce using rule 62 (parameters -> parameter COMMA parameters .)
    PRINTF          reduce using rule 62 (parameters -> parameter COMMA parameters .)
    INPUT           reduce using rule 62 (parameters -> parameter COMMA parameters .)
    IF              reduce using rule 62 (parameters -> parameter COMMA parameters .)
    VARIABLE        reduce using rule 62 (parameters -> parameter COMMA parameters .)
    TYPE            reduce using rule 62 (parameters -> parameter COMMA parameters .)
    FUNCTION        reduce using rule 62 (parameters -> parameter COMMA parameters .)
    VAR             reduce using rule 62 (parameters -> parameter COMMA parameters .)
    SWITCH          reduce using rule 62 (parameters -> parameter COMMA parameters .)
    CHARSTRING      reduce using rule 62 (parameters -> parameter COMMA parameters .)
    LBRACE          reduce using rule 62 (parameters -> parameter COMMA parameters .)
    FOR             reduce using rule 62 (parameters -> parameter COMMA parameters .)
    INT             reduce using rule 62 (parameters -> parameter COMMA parameters .)
    FLOAT           reduce using rule 62 (parameters -> parameter COMMA parameters .)
    $end            reduce using rule 62 (parameters -> parameter COMMA parameters .)
    RBRACE          reduce using rule 62 (parameters -> parameter COMMA parameters .)
    CASE            reduce using rule 62 (parameters -> parameter COMMA parameters .)
    DEFAULT         reduce using rule 62 (parameters -> parameter COMMA parameters .)
    RPAREN          reduce using rule 62 (parameters -> parameter COMMA parameters .)


state 137

    (23) variable_declaration -> VAR VARIABLE type .

    PRINT           reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    PRINTF          reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    INPUT           reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    IF              reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    VARIABLE        reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    TYPE            reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    FUNCTION        reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    VAR             reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    SWITCH          reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    CHARSTRING      reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    LBRACE          reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    FOR             reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    INT             reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    FLOAT           reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    $end            reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    RBRACE          reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    CASE            reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)
    DEFAULT         reduce using rule 23 (variable_declaration -> VAR VARIABLE type .)


state 138

    (24) variable_declaration -> VAR VARIABLE ASSIGN . value
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    value                          shift and go to state 170
    number                         shift and go to state 39

state 139

    (117) slice_structure -> VAR VARIABLE LBRACKET . RBRACKET type

    RBRACKET        shift and go to state 171


state 140

    (96) switch_structure -> SWITCH switch_expression LBRACE . case_blocks RBRACE
    (99) case_blocks -> . case_block
    (100) case_blocks -> . case_block case_blocks
    (101) case_block -> . CASE values COLON statement
    (102) case_block -> . DEFAULT COLON statement

    CASE            shift and go to state 174
    DEFAULT         shift and go to state 175

    case_blocks                    shift and go to state 172
    case_block                     shift and go to state 173

state 141

    (93) for_initialization -> FOR VARIABLE SHORTASSIGN . value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    value                          shift and go to state 176
    number                         shift and go to state 39

state 142

    (95) for_iterator -> FOR VARIABLE SEMICOLON . VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 177


state 143

    (94) for_infinite_bucle -> FOR LBRACE statement . RBRACE

    RBRACE          shift and go to state 178


state 144

    (4) statement -> package main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 179


state 145

    (3) statement -> main LBRACE blocks RBRACE .

    $end            reduce using rule 3 (statement -> main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 3 (statement -> main LBRACE blocks RBRACE .)
    CASE            reduce using rule 3 (statement -> main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 3 (statement -> main LBRACE blocks RBRACE .)


state 146

    (33) values -> value COMMA values .

    RBRACE          reduce using rule 33 (values -> value COMMA values .)
    RPAREN          reduce using rule 33 (values -> value COMMA values .)
    COLON           reduce using rule 33 (values -> value COMMA values .)


state 147

    (110) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET . type RBRACKET type LBRACE map_values RBRACE
    (64) type -> . INT
    (65) type -> . INT32
    (66) type -> . INT64
    (67) type -> . STRING
    (68) type -> . FLOAT
    (69) type -> . FLOAT32
    (70) type -> . FLOAT64
    (71) type -> . BOOL

    INT             shift and go to state 58
    INT32           shift and go to state 59
    INT64           shift and go to state 60
    STRING          shift and go to state 61
    FLOAT           shift and go to state 62
    FLOAT32         shift and go to state 63
    FLOAT64         shift and go to state 64
    BOOL            shift and go to state 65

    type                           shift and go to state 180

state 148

    (116) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET . type LBRACE values RBRACE
    (118) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET . type
    (64) type -> . INT
    (65) type -> . INT32
    (66) type -> . INT64
    (67) type -> . STRING
    (68) type -> . FLOAT
    (69) type -> . FLOAT32
    (70) type -> . FLOAT64
    (71) type -> . BOOL

    INT             shift and go to state 58
    INT32           shift and go to state 59
    INT64           shift and go to state 60
    STRING          shift and go to state 61
    FLOAT           shift and go to state 62
    FLOAT32         shift and go to state 63
    FLOAT64         shift and go to state 64
    BOOL            shift and go to state 65

    type                           shift and go to state 181

state 149

    (111) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN

    MAP             shift and go to state 182


state 150

    (115) map_assign -> VARIABLE LBRACKET string_value RBRACKET . ASSIGN string_value

    ASSIGN          shift and go to state 183


state 151

    (120) append_statement -> APPEND LPAREN . VARIABLE COMMA values RPAREN

    VARIABLE        shift and go to state 184


state 152

    (6) main -> FUNCTION MAIN LPAREN RPAREN .

    LBRACE          reduce using rule 6 (main -> FUNCTION MAIN LPAREN RPAREN .)


state 153

    (28) function -> FUNCTION VARIABLE LPAREN RPAREN . LBRACE blocks RBRACE
    (30) function -> FUNCTION VARIABLE LPAREN RPAREN . type LBRACE RETURN value RBRACE
    (64) type -> . INT
    (65) type -> . INT32
    (66) type -> . INT64
    (67) type -> . STRING
    (68) type -> . FLOAT
    (69) type -> . FLOAT32
    (70) type -> . FLOAT64
    (71) type -> . BOOL

    LBRACE          shift and go to state 185
    INT             shift and go to state 58
    INT32           shift and go to state 59
    INT64           shift and go to state 60
    STRING          shift and go to state 61
    FLOAT           shift and go to state 62
    FLOAT32         shift and go to state 63
    FLOAT64         shift and go to state 64
    BOOL            shift and go to state 65

    type                           shift and go to state 186

state 154

    (29) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN LBRACE blocks RBRACE
    (31) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN type LBRACE RETURN value RBRACE

    RPAREN          shift and go to state 187


state 155

    (41) print_statement -> PRINT LPAREN values RPAREN .

    PRINT           reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    PRINTF          reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    INPUT           reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    IF              reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    TYPE            reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    VAR             reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    SWITCH          reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    CHARSTRING      reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    LBRACE          reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    FOR             reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    INT             reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    FLOAT           reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    $end            reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    RBRACE          reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    CASE            reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)
    DEFAULT         reduce using rule 41 (print_statement -> PRINT LPAREN values RPAREN .)


state 156

    (42) print_statement -> PRINT LPAREN string_value RPAREN .

    PRINT           reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    PRINTF          reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    INPUT           reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    IF              reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    VARIABLE        reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    TYPE            reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    FUNCTION        reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    VAR             reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    SWITCH          reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    CHARSTRING      reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    LBRACE          reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    FOR             reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    INT             reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    FLOAT           reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    $end            reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    RBRACE          reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    CASE            reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)
    DEFAULT         reduce using rule 42 (print_statement -> PRINT LPAREN string_value RPAREN .)


state 157

    (44) print_statement -> PRINT LPAREN string_value COMMA . values RPAREN
    (32) values -> . value
    (33) values -> . value COMMA values
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    values                         shift and go to state 188
    value                          shift and go to state 49
    number                         shift and go to state 39

state 158

    (45) print_statement -> PRINT LPAREN operation RPAREN .

    PRINT           reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    PRINTF          reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    INPUT           reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    IF              reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    TYPE            reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    VAR             reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    SWITCH          reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    LBRACE          reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    FOR             reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    INT             reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    $end            reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    CASE            reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 45 (print_statement -> PRINT LPAREN operation RPAREN .)


state 159

    (43) print_statement -> PRINTF LPAREN FORMATSTRING COMMA . values RPAREN
    (32) values -> . value
    (33) values -> . value COMMA values
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    values                         shift and go to state 189
    value                          shift and go to state 49
    number                         shift and go to state 39

state 160

    (47) input_statement -> INPUT LPAREN values RPAREN .

    PRINT           reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    PRINTF          reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    INPUT           reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    IF              reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    TYPE            reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    VAR             reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    SWITCH          reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    CHARSTRING      reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    LBRACE          reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    FOR             reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    INT             reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    FLOAT           reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    $end            reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    RBRACE          reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    CASE            reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)
    DEFAULT         reduce using rule 47 (input_statement -> INPUT LPAREN values RPAREN .)


state 161

    (48) input_statement -> INPUT LPAREN operation RPAREN .

    PRINT           reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    PRINTF          reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    INPUT           reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    IF              reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    TYPE            reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    VAR             reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    SWITCH          reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    LBRACE          reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    FOR             reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    INT             reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    $end            reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    CASE            reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 48 (input_statement -> INPUT LPAREN operation RPAREN .)


state 162

    (73) conditional_structure -> IF conditions conditional_body ELSE . conditional_body
    (74) conditional_structure -> IF conditions conditional_body ELSE . IF conditions conditional_body ELSE conditional_body
    (75) conditional_body -> . LBRACE statement RBRACE
    (76) conditional_body -> . LBRACE BREAK RBRACE
    (77) conditional_body -> . LBRACE CONTINUE RBRACE

    IF              shift and go to state 190
    LBRACE          shift and go to state 120

    conditional_body               shift and go to state 191

state 163

    (75) conditional_body -> LBRACE statement . RBRACE

    RBRACE          shift and go to state 192


state 164

    (76) conditional_body -> LBRACE BREAK . RBRACE

    RBRACE          shift and go to state 193


state 165

    (77) conditional_body -> LBRACE CONTINUE . RBRACE

    RBRACE          shift and go to state 194


state 166

    (79) conditions -> condition logical_operator conditions .

    LBRACE          reduce using rule 79 (conditions -> condition logical_operator conditions .)


state 167

    (80) condition -> value relational_operator value .

    AND             reduce using rule 80 (condition -> value relational_operator value .)
    OR              reduce using rule 80 (condition -> value relational_operator value .)
    NOT             reduce using rule 80 (condition -> value relational_operator value .)
    LBRACE          reduce using rule 80 (condition -> value relational_operator value .)
    SEMICOLON       reduce using rule 80 (condition -> value relational_operator value .)


state 168

    (27) structure -> TYPE VARIABLE STRUCT LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . package blocks
    (3) statement -> . main LBRACE blocks RBRACE
    (4) statement -> . package main LBRACE blocks RBRACE
    (7) blocks -> . block
    (8) blocks -> . block blocks
    (5) package -> . PACKAGE VARIABLE
    (6) main -> . FUNCTION MAIN LPAREN RPAREN
    (9) block -> . print_statement
    (10) block -> . input_statement
    (11) block -> . conditional_structure
    (12) block -> . operation
    (13) block -> . list_structure
    (14) block -> . map_estructure
    (15) block -> . map_assign
    (16) block -> . for_estructure
    (17) block -> . structure
    (18) block -> . function
    (19) block -> . parameters
    (20) block -> . variable_declaration
    (21) block -> . switch_structure
    (22) block -> . slice_structure
    (41) print_statement -> . PRINT LPAREN values RPAREN
    (42) print_statement -> . PRINT LPAREN string_value RPAREN
    (43) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (44) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (45) print_statement -> . PRINT LPAREN operation RPAREN
    (46) print_statement -> . PRINT LPAREN RPAREN
    (47) input_statement -> . INPUT LPAREN values RPAREN
    (48) input_statement -> . INPUT LPAREN operation RPAREN
    (49) input_statement -> . INPUT LPAREN RPAREN
    (72) conditional_structure -> . IF conditions conditional_body
    (73) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (74) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (104) list_structure -> . empty_list
    (105) list_structure -> . list_with_data
    (106) list_structure -> . defined_list
    (110) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (115) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (90) for_estructure -> . for_initialization
    (91) for_estructure -> . for_infinite_bucle
    (92) for_estructure -> . for_iterator
    (27) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (28) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (23) variable_declaration -> . VAR VARIABLE type
    (24) variable_declaration -> . VAR VARIABLE ASSIGN value
    (25) variable_declaration -> . VARIABLE SHORTASSIGN value
    (26) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (96) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (116) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (117) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (118) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (119) slice_structure -> . VARIABLE ASSIGN append_statement
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (107) empty_list -> . LBRACE RBRACE
    (108) list_with_data -> . LBRACE values RBRACE
    (109) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (93) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (94) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (95) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (63) parameter -> . VARIABLE type
    (39) number -> . INT
    (40) number -> . FLOAT

    PACKAGE         shift and go to state 7
    FUNCTION        shift and go to state 9
    PRINT           shift and go to state 24
    PRINTF          shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 27
    VARIABLE        shift and go to state 8
    TYPE            shift and go to state 35
    VAR             shift and go to state 37
    SWITCH          shift and go to state 38
    CHARSTRING      shift and go to state 40
    LBRACE          shift and go to state 5
    FOR             shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    statement                      shift and go to state 195
    blocks                         shift and go to state 2
    package                        shift and go to state 3
    main                           shift and go to state 4
    block                          shift and go to state 6
    print_statement                shift and go to state 10
    input_statement                shift and go to state 11
    conditional_structure          shift and go to state 12
    operation                      shift and go to state 13
    list_structure                 shift and go to state 14
    map_estructure                 shift and go to state 15
    map_assign                     shift and go to state 16
    for_estructure                 shift and go to state 17
    structure                      shift and go to state 18
    function                       shift and go to state 19
    parameters                     shift and go to state 20
    variable_declaration           shift and go to state 21
    switch_structure               shift and go to state 22
    slice_structure                shift and go to state 23
    value                          shift and go to state 28
    empty_list                     shift and go to state 29
    list_with_data                 shift and go to state 30
    defined_list                   shift and go to state 31
    for_initialization             shift and go to state 32
    for_infinite_bucle             shift and go to state 33
    for_iterator                   shift and go to state 34
    parameter                      shift and go to state 36
    number                         shift and go to state 39

state 169

    (109) defined_list -> TYPE VARIABLE LBRACE values . RBRACE

    RBRACE          shift and go to state 196


state 170

    (24) variable_declaration -> VAR VARIABLE ASSIGN value .

    PRINT           reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    PRINTF          reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    INPUT           reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    IF              reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    VARIABLE        reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    TYPE            reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    FUNCTION        reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    VAR             reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    SWITCH          reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    CHARSTRING      reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    LBRACE          reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    FOR             reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    INT             reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    FLOAT           reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    $end            reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    RBRACE          reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    CASE            reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    DEFAULT         reduce using rule 24 (variable_declaration -> VAR VARIABLE ASSIGN value .)


state 171

    (117) slice_structure -> VAR VARIABLE LBRACKET RBRACKET . type
    (64) type -> . INT
    (65) type -> . INT32
    (66) type -> . INT64
    (67) type -> . STRING
    (68) type -> . FLOAT
    (69) type -> . FLOAT32
    (70) type -> . FLOAT64
    (71) type -> . BOOL

    INT             shift and go to state 58
    INT32           shift and go to state 59
    INT64           shift and go to state 60
    STRING          shift and go to state 61
    FLOAT           shift and go to state 62
    FLOAT32         shift and go to state 63
    FLOAT64         shift and go to state 64
    BOOL            shift and go to state 65

    type                           shift and go to state 197

state 172

    (96) switch_structure -> SWITCH switch_expression LBRACE case_blocks . RBRACE

    RBRACE          shift and go to state 198


state 173

    (99) case_blocks -> case_block .
    (100) case_blocks -> case_block . case_blocks
    (99) case_blocks -> . case_block
    (100) case_blocks -> . case_block case_blocks
    (101) case_block -> . CASE values COLON statement
    (102) case_block -> . DEFAULT COLON statement

    RBRACE          reduce using rule 99 (case_blocks -> case_block .)
    CASE            shift and go to state 174
    DEFAULT         shift and go to state 175

    case_block                     shift and go to state 173
    case_blocks                    shift and go to state 199

state 174

    (101) case_block -> CASE . values COLON statement
    (32) values -> . value
    (33) values -> . value COMMA values
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    values                         shift and go to state 200
    value                          shift and go to state 49
    number                         shift and go to state 39

state 175

    (102) case_block -> DEFAULT . COLON statement

    COLON           shift and go to state 201


state 176

    (93) for_initialization -> FOR VARIABLE SHORTASSIGN value . SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 202


state 177

    (95) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE . SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 203


state 178

    (94) for_infinite_bucle -> FOR LBRACE statement RBRACE .

    PRINT           reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    PRINTF          reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INPUT           reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    IF              reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    TYPE            reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VAR             reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    SWITCH          reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    LBRACE          reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FOR             reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INT             reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FLOAT           reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    $end            reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RBRACE          reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CASE            reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 94 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)


state 179

    (4) statement -> package main LBRACE blocks RBRACE .

    $end            reduce using rule 4 (statement -> package main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 4 (statement -> package main LBRACE blocks RBRACE .)
    CASE            reduce using rule 4 (statement -> package main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 4 (statement -> package main LBRACE blocks RBRACE .)


state 180

    (110) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type . RBRACKET type LBRACE map_values RBRACE

    RBRACKET        shift and go to state 204


state 181

    (116) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type . LBRACE values RBRACE
    (118) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .

  ! shift/reduce conflict for LBRACE resolved as shift
    LBRACE          shift and go to state 205
    PRINT           reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    PRINTF          reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    INPUT           reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    IF              reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    TYPE            reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FUNCTION        reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    VAR             reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CHARSTRING      reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FOR             reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    INT             reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FLOAT           reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    $end            reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CASE            reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)

  ! LBRACE          [ reduce using rule 118 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .) ]


state 182

    (111) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN

    LBRACKET        shift and go to state 206


state 183

    (115) map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN . string_value
    (34) string_value -> . value
    (35) string_value -> . CHARSTRING
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    CHARSTRING      shift and go to state 104
    VARIABLE        shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    string_value                   shift and go to state 207
    value                          shift and go to state 103
    number                         shift and go to state 39

state 184

    (120) append_statement -> APPEND LPAREN VARIABLE . COMMA values RPAREN

    COMMA           shift and go to state 208


state 185

    (28) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE . blocks RBRACE
    (7) blocks -> . block
    (8) blocks -> . block blocks
    (9) block -> . print_statement
    (10) block -> . input_statement
    (11) block -> . conditional_structure
    (12) block -> . operation
    (13) block -> . list_structure
    (14) block -> . map_estructure
    (15) block -> . map_assign
    (16) block -> . for_estructure
    (17) block -> . structure
    (18) block -> . function
    (19) block -> . parameters
    (20) block -> . variable_declaration
    (21) block -> . switch_structure
    (22) block -> . slice_structure
    (41) print_statement -> . PRINT LPAREN values RPAREN
    (42) print_statement -> . PRINT LPAREN string_value RPAREN
    (43) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (44) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (45) print_statement -> . PRINT LPAREN operation RPAREN
    (46) print_statement -> . PRINT LPAREN RPAREN
    (47) input_statement -> . INPUT LPAREN values RPAREN
    (48) input_statement -> . INPUT LPAREN operation RPAREN
    (49) input_statement -> . INPUT LPAREN RPAREN
    (72) conditional_structure -> . IF conditions conditional_body
    (73) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (74) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (104) list_structure -> . empty_list
    (105) list_structure -> . list_with_data
    (106) list_structure -> . defined_list
    (110) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (115) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (90) for_estructure -> . for_initialization
    (91) for_estructure -> . for_infinite_bucle
    (92) for_estructure -> . for_iterator
    (27) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (28) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (23) variable_declaration -> . VAR VARIABLE type
    (24) variable_declaration -> . VAR VARIABLE ASSIGN value
    (25) variable_declaration -> . VARIABLE SHORTASSIGN value
    (26) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (96) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (116) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (117) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (118) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (119) slice_structure -> . VARIABLE ASSIGN append_statement
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (107) empty_list -> . LBRACE RBRACE
    (108) list_with_data -> . LBRACE values RBRACE
    (109) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (93) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (94) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (95) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (63) parameter -> . VARIABLE type
    (39) number -> . INT
    (40) number -> . FLOAT

    PRINT           shift and go to state 24
    PRINTF          shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 27
    VARIABLE        shift and go to state 8
    TYPE            shift and go to state 35
    FUNCTION        shift and go to state 52
    VAR             shift and go to state 37
    SWITCH          shift and go to state 38
    CHARSTRING      shift and go to state 40
    LBRACE          shift and go to state 5
    FOR             shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    blocks                         shift and go to state 209
    block                          shift and go to state 6
    print_statement                shift and go to state 10
    input_statement                shift and go to state 11
    conditional_structure          shift and go to state 12
    operation                      shift and go to state 13
    list_structure                 shift and go to state 14
    map_estructure                 shift and go to state 15
    map_assign                     shift and go to state 16
    for_estructure                 shift and go to state 17
    structure                      shift and go to state 18
    function                       shift and go to state 19
    parameters                     shift and go to state 20
    variable_declaration           shift and go to state 21
    switch_structure               shift and go to state 22
    slice_structure                shift and go to state 23
    value                          shift and go to state 28
    empty_list                     shift and go to state 29
    list_with_data                 shift and go to state 30
    defined_list                   shift and go to state 31
    for_initialization             shift and go to state 32
    for_infinite_bucle             shift and go to state 33
    for_iterator                   shift and go to state 34
    parameter                      shift and go to state 36
    number                         shift and go to state 39

state 186

    (30) function -> FUNCTION VARIABLE LPAREN RPAREN type . LBRACE RETURN value RBRACE

    LBRACE          shift and go to state 210


state 187

    (29) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . LBRACE blocks RBRACE
    (31) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . type LBRACE RETURN value RBRACE
    (64) type -> . INT
    (65) type -> . INT32
    (66) type -> . INT64
    (67) type -> . STRING
    (68) type -> . FLOAT
    (69) type -> . FLOAT32
    (70) type -> . FLOAT64
    (71) type -> . BOOL

    LBRACE          shift and go to state 211
    INT             shift and go to state 58
    INT32           shift and go to state 59
    INT64           shift and go to state 60
    STRING          shift and go to state 61
    FLOAT           shift and go to state 62
    FLOAT32         shift and go to state 63
    FLOAT64         shift and go to state 64
    BOOL            shift and go to state 65

    type                           shift and go to state 212

state 188

    (44) print_statement -> PRINT LPAREN string_value COMMA values . RPAREN

    RPAREN          shift and go to state 213


state 189

    (43) print_statement -> PRINTF LPAREN FORMATSTRING COMMA values . RPAREN

    RPAREN          shift and go to state 214


state 190

    (74) conditional_structure -> IF conditions conditional_body ELSE IF . conditions conditional_body ELSE conditional_body
    (78) conditions -> . condition
    (79) conditions -> . condition logical_operator conditions
    (80) condition -> . value relational_operator value
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    conditions                     shift and go to state 215
    condition                      shift and go to state 72
    value                          shift and go to state 73
    number                         shift and go to state 39

state 191

    (73) conditional_structure -> IF conditions conditional_body ELSE conditional_body .

    PRINT           reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    PRINTF          reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    SWITCH          reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CHARSTRING      reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    LBRACE          reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CASE            reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    DEFAULT         reduce using rule 73 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)


state 192

    (75) conditional_body -> LBRACE statement RBRACE .

    ELSE            reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    PRINT           reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    PRINTF          reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    INPUT           reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    IF              reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    TYPE            reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    VAR             reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    SWITCH          reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    LBRACE          reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    FOR             reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    INT             reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    FLOAT           reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    $end            reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    RBRACE          reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    CASE            reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 75 (conditional_body -> LBRACE statement RBRACE .)


state 193

    (76) conditional_body -> LBRACE BREAK RBRACE .

    ELSE            reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    PRINT           reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    PRINTF          reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    INPUT           reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    IF              reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    VARIABLE        reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    TYPE            reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    FUNCTION        reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    VAR             reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    SWITCH          reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    CHARSTRING      reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    LBRACE          reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    FOR             reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    INT             reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    FLOAT           reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    $end            reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    RBRACE          reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    CASE            reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)
    DEFAULT         reduce using rule 76 (conditional_body -> LBRACE BREAK RBRACE .)


state 194

    (77) conditional_body -> LBRACE CONTINUE RBRACE .

    ELSE            reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    PRINT           reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    PRINTF          reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INPUT           reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    IF              reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VARIABLE        reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    TYPE            reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FUNCTION        reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VAR             reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    SWITCH          reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CHARSTRING      reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    LBRACE          reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FOR             reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INT             reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FLOAT           reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    $end            reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RBRACE          reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CASE            reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)
    DEFAULT         reduce using rule 77 (conditional_body -> LBRACE CONTINUE RBRACE .)


state 195

    (27) structure -> TYPE VARIABLE STRUCT LBRACE statement . RBRACE

    RBRACE          shift and go to state 216


state 196

    (109) defined_list -> TYPE VARIABLE LBRACE values RBRACE .

    PRINT           reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    PRINTF          reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    INPUT           reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    IF              reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    VARIABLE        reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    TYPE            reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    FUNCTION        reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    VAR             reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    SWITCH          reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    LBRACE          reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    FOR             reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    INT             reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    FLOAT           reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    $end            reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    RBRACE          reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    CASE            reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    DEFAULT         reduce using rule 109 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)


state 197

    (117) slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .

    PRINT           reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    PRINTF          reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    INPUT           reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    IF              reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    TYPE            reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FUNCTION        reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    VAR             reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CHARSTRING      reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    LBRACE          reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FOR             reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    INT             reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FLOAT           reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    $end            reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CASE            reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 117 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)


state 198

    (96) switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .

    PRINT           reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    PRINTF          reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    INPUT           reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    IF              reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    VARIABLE        reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    TYPE            reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FUNCTION        reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    VAR             reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    SWITCH          reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CHARSTRING      reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    LBRACE          reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FOR             reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    INT             reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FLOAT           reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    $end            reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    RBRACE          reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CASE            reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    DEFAULT         reduce using rule 96 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)


state 199

    (100) case_blocks -> case_block case_blocks .

    RBRACE          reduce using rule 100 (case_blocks -> case_block case_blocks .)


state 200

    (101) case_block -> CASE values . COLON statement

    COLON           shift and go to state 217


state 201

    (102) case_block -> DEFAULT COLON . statement
    (1) statement -> . blocks
    (2) statement -> . package blocks
    (3) statement -> . main LBRACE blocks RBRACE
    (4) statement -> . package main LBRACE blocks RBRACE
    (7) blocks -> . block
    (8) blocks -> . block blocks
    (5) package -> . PACKAGE VARIABLE
    (6) main -> . FUNCTION MAIN LPAREN RPAREN
    (9) block -> . print_statement
    (10) block -> . input_statement
    (11) block -> . conditional_structure
    (12) block -> . operation
    (13) block -> . list_structure
    (14) block -> . map_estructure
    (15) block -> . map_assign
    (16) block -> . for_estructure
    (17) block -> . structure
    (18) block -> . function
    (19) block -> . parameters
    (20) block -> . variable_declaration
    (21) block -> . switch_structure
    (22) block -> . slice_structure
    (41) print_statement -> . PRINT LPAREN values RPAREN
    (42) print_statement -> . PRINT LPAREN string_value RPAREN
    (43) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (44) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (45) print_statement -> . PRINT LPAREN operation RPAREN
    (46) print_statement -> . PRINT LPAREN RPAREN
    (47) input_statement -> . INPUT LPAREN values RPAREN
    (48) input_statement -> . INPUT LPAREN operation RPAREN
    (49) input_statement -> . INPUT LPAREN RPAREN
    (72) conditional_structure -> . IF conditions conditional_body
    (73) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (74) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (104) list_structure -> . empty_list
    (105) list_structure -> . list_with_data
    (106) list_structure -> . defined_list
    (110) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (115) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (90) for_estructure -> . for_initialization
    (91) for_estructure -> . for_infinite_bucle
    (92) for_estructure -> . for_iterator
    (27) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (28) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (23) variable_declaration -> . VAR VARIABLE type
    (24) variable_declaration -> . VAR VARIABLE ASSIGN value
    (25) variable_declaration -> . VARIABLE SHORTASSIGN value
    (26) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (96) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (116) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (117) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (118) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (119) slice_structure -> . VARIABLE ASSIGN append_statement
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (107) empty_list -> . LBRACE RBRACE
    (108) list_with_data -> . LBRACE values RBRACE
    (109) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (93) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (94) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (95) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (63) parameter -> . VARIABLE type
    (39) number -> . INT
    (40) number -> . FLOAT

    PACKAGE         shift and go to state 7
    FUNCTION        shift and go to state 9
    PRINT           shift and go to state 24
    PRINTF          shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 27
    VARIABLE        shift and go to state 8
    TYPE            shift and go to state 35
    VAR             shift and go to state 37
    SWITCH          shift and go to state 38
    CHARSTRING      shift and go to state 40
    LBRACE          shift and go to state 5
    FOR             shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    statement                      shift and go to state 218
    blocks                         shift and go to state 2
    package                        shift and go to state 3
    main                           shift and go to state 4
    block                          shift and go to state 6
    print_statement                shift and go to state 10
    input_statement                shift and go to state 11
    conditional_structure          shift and go to state 12
    operation                      shift and go to state 13
    list_structure                 shift and go to state 14
    map_estructure                 shift and go to state 15
    map_assign                     shift and go to state 16
    for_estructure                 shift and go to state 17
    structure                      shift and go to state 18
    function                       shift and go to state 19
    parameters                     shift and go to state 20
    variable_declaration           shift and go to state 21
    switch_structure               shift and go to state 22
    slice_structure                shift and go to state 23
    value                          shift and go to state 28
    empty_list                     shift and go to state 29
    list_with_data                 shift and go to state 30
    defined_list                   shift and go to state 31
    for_initialization             shift and go to state 32
    for_infinite_bucle             shift and go to state 33
    for_iterator                   shift and go to state 34
    parameter                      shift and go to state 36
    number                         shift and go to state 39

state 202

    (93) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON . condition SEMICOLON value double_operator LBRACE statement RBRACE
    (80) condition -> . value relational_operator value
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    value                          shift and go to state 73
    condition                      shift and go to state 219
    number                         shift and go to state 39

state 203

    (95) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN . RANGE VARIABLE LBRACE statement RBRACE

    RANGE           shift and go to state 220


state 204

    (110) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET . type LBRACE map_values RBRACE
    (64) type -> . INT
    (65) type -> . INT32
    (66) type -> . INT64
    (67) type -> . STRING
    (68) type -> . FLOAT
    (69) type -> . FLOAT32
    (70) type -> . FLOAT64
    (71) type -> . BOOL

    INT             shift and go to state 58
    INT32           shift and go to state 59
    INT64           shift and go to state 60
    STRING          shift and go to state 61
    FLOAT           shift and go to state 62
    FLOAT32         shift and go to state 63
    FLOAT64         shift and go to state 64
    BOOL            shift and go to state 65

    type                           shift and go to state 221

state 205

    (116) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE . values RBRACE
    (32) values -> . value
    (33) values -> . value COMMA values
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    values                         shift and go to state 222
    value                          shift and go to state 49
    number                         shift and go to state 39

state 206

    (111) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (64) type -> . INT
    (65) type -> . INT32
    (66) type -> . INT64
    (67) type -> . STRING
    (68) type -> . FLOAT
    (69) type -> . FLOAT32
    (70) type -> . FLOAT64
    (71) type -> . BOOL

    INT             shift and go to state 58
    INT32           shift and go to state 59
    INT64           shift and go to state 60
    STRING          shift and go to state 61
    FLOAT           shift and go to state 62
    FLOAT32         shift and go to state 63
    FLOAT64         shift and go to state 64
    BOOL            shift and go to state 65

    type                           shift and go to state 223

state 207

    (115) map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .

    PRINT           reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    PRINTF          reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    INPUT           reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    IF              reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    VARIABLE        reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    TYPE            reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    FUNCTION        reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    VAR             reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    SWITCH          reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    CHARSTRING      reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    LBRACE          reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    FOR             reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    INT             reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    FLOAT           reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    $end            reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    RBRACE          reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    CASE            reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    DEFAULT         reduce using rule 115 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)


state 208

    (120) append_statement -> APPEND LPAREN VARIABLE COMMA . values RPAREN
    (32) values -> . value
    (33) values -> . value COMMA values
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    values                         shift and go to state 224
    value                          shift and go to state 49
    number                         shift and go to state 39

state 209

    (28) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 225


state 210

    (30) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE . RETURN value RBRACE

    RETURN          shift and go to state 226


state 211

    (29) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE . blocks RBRACE
    (7) blocks -> . block
    (8) blocks -> . block blocks
    (9) block -> . print_statement
    (10) block -> . input_statement
    (11) block -> . conditional_structure
    (12) block -> . operation
    (13) block -> . list_structure
    (14) block -> . map_estructure
    (15) block -> . map_assign
    (16) block -> . for_estructure
    (17) block -> . structure
    (18) block -> . function
    (19) block -> . parameters
    (20) block -> . variable_declaration
    (21) block -> . switch_structure
    (22) block -> . slice_structure
    (41) print_statement -> . PRINT LPAREN values RPAREN
    (42) print_statement -> . PRINT LPAREN string_value RPAREN
    (43) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (44) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (45) print_statement -> . PRINT LPAREN operation RPAREN
    (46) print_statement -> . PRINT LPAREN RPAREN
    (47) input_statement -> . INPUT LPAREN values RPAREN
    (48) input_statement -> . INPUT LPAREN operation RPAREN
    (49) input_statement -> . INPUT LPAREN RPAREN
    (72) conditional_structure -> . IF conditions conditional_body
    (73) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (74) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (104) list_structure -> . empty_list
    (105) list_structure -> . list_with_data
    (106) list_structure -> . defined_list
    (110) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (115) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (90) for_estructure -> . for_initialization
    (91) for_estructure -> . for_infinite_bucle
    (92) for_estructure -> . for_iterator
    (27) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (28) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (23) variable_declaration -> . VAR VARIABLE type
    (24) variable_declaration -> . VAR VARIABLE ASSIGN value
    (25) variable_declaration -> . VARIABLE SHORTASSIGN value
    (26) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (96) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (116) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (117) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (118) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (119) slice_structure -> . VARIABLE ASSIGN append_statement
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (107) empty_list -> . LBRACE RBRACE
    (108) list_with_data -> . LBRACE values RBRACE
    (109) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (93) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (94) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (95) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (63) parameter -> . VARIABLE type
    (39) number -> . INT
    (40) number -> . FLOAT

    PRINT           shift and go to state 24
    PRINTF          shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 27
    VARIABLE        shift and go to state 8
    TYPE            shift and go to state 35
    FUNCTION        shift and go to state 52
    VAR             shift and go to state 37
    SWITCH          shift and go to state 38
    CHARSTRING      shift and go to state 40
    LBRACE          shift and go to state 5
    FOR             shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    parameters                     shift and go to state 20
    blocks                         shift and go to state 227
    block                          shift and go to state 6
    print_statement                shift and go to state 10
    input_statement                shift and go to state 11
    conditional_structure          shift and go to state 12
    operation                      shift and go to state 13
    list_structure                 shift and go to state 14
    map_estructure                 shift and go to state 15
    map_assign                     shift and go to state 16
    for_estructure                 shift and go to state 17
    structure                      shift and go to state 18
    function                       shift and go to state 19
    variable_declaration           shift and go to state 21
    switch_structure               shift and go to state 22
    slice_structure                shift and go to state 23
    value                          shift and go to state 28
    empty_list                     shift and go to state 29
    list_with_data                 shift and go to state 30
    defined_list                   shift and go to state 31
    for_initialization             shift and go to state 32
    for_infinite_bucle             shift and go to state 33
    for_iterator                   shift and go to state 34
    parameter                      shift and go to state 36
    number                         shift and go to state 39

state 212

    (31) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type . LBRACE RETURN value RBRACE

    LBRACE          shift and go to state 228


state 213

    (44) print_statement -> PRINT LPAREN string_value COMMA values RPAREN .

    PRINT           reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    PRINTF          reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    INPUT           reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    IF              reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    VARIABLE        reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    TYPE            reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    FUNCTION        reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    VAR             reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    SWITCH          reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    CHARSTRING      reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    LBRACE          reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    FOR             reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    INT             reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    FLOAT           reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    $end            reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    RBRACE          reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    CASE            reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    DEFAULT         reduce using rule 44 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)


state 214

    (43) print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .

    PRINT           reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    PRINTF          reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    INPUT           reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    IF              reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    VARIABLE        reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    TYPE            reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FUNCTION        reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    VAR             reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    SWITCH          reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CHARSTRING      reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    LBRACE          reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FOR             reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    INT             reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FLOAT           reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    $end            reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    RBRACE          reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CASE            reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    DEFAULT         reduce using rule 43 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)


state 215

    (74) conditional_structure -> IF conditions conditional_body ELSE IF conditions . conditional_body ELSE conditional_body
    (75) conditional_body -> . LBRACE statement RBRACE
    (76) conditional_body -> . LBRACE BREAK RBRACE
    (77) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 120

    conditional_body               shift and go to state 229

state 216

    (27) structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .

    PRINT           reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    PRINTF          reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    INPUT           reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    IF              reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    TYPE            reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    VAR             reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    SWITCH          reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    LBRACE          reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    FOR             reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    INT             reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    FLOAT           reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    $end            reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    RBRACE          reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    CASE            reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 27 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)


state 217

    (101) case_block -> CASE values COLON . statement
    (1) statement -> . blocks
    (2) statement -> . package blocks
    (3) statement -> . main LBRACE blocks RBRACE
    (4) statement -> . package main LBRACE blocks RBRACE
    (7) blocks -> . block
    (8) blocks -> . block blocks
    (5) package -> . PACKAGE VARIABLE
    (6) main -> . FUNCTION MAIN LPAREN RPAREN
    (9) block -> . print_statement
    (10) block -> . input_statement
    (11) block -> . conditional_structure
    (12) block -> . operation
    (13) block -> . list_structure
    (14) block -> . map_estructure
    (15) block -> . map_assign
    (16) block -> . for_estructure
    (17) block -> . structure
    (18) block -> . function
    (19) block -> . parameters
    (20) block -> . variable_declaration
    (21) block -> . switch_structure
    (22) block -> . slice_structure
    (41) print_statement -> . PRINT LPAREN values RPAREN
    (42) print_statement -> . PRINT LPAREN string_value RPAREN
    (43) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (44) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (45) print_statement -> . PRINT LPAREN operation RPAREN
    (46) print_statement -> . PRINT LPAREN RPAREN
    (47) input_statement -> . INPUT LPAREN values RPAREN
    (48) input_statement -> . INPUT LPAREN operation RPAREN
    (49) input_statement -> . INPUT LPAREN RPAREN
    (72) conditional_structure -> . IF conditions conditional_body
    (73) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (74) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (104) list_structure -> . empty_list
    (105) list_structure -> . list_with_data
    (106) list_structure -> . defined_list
    (110) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (115) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (90) for_estructure -> . for_initialization
    (91) for_estructure -> . for_infinite_bucle
    (92) for_estructure -> . for_iterator
    (27) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (28) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (23) variable_declaration -> . VAR VARIABLE type
    (24) variable_declaration -> . VAR VARIABLE ASSIGN value
    (25) variable_declaration -> . VARIABLE SHORTASSIGN value
    (26) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (96) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (116) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (117) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (118) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (119) slice_structure -> . VARIABLE ASSIGN append_statement
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (107) empty_list -> . LBRACE RBRACE
    (108) list_with_data -> . LBRACE values RBRACE
    (109) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (93) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (94) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (95) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (63) parameter -> . VARIABLE type
    (39) number -> . INT
    (40) number -> . FLOAT

    PACKAGE         shift and go to state 7
    FUNCTION        shift and go to state 9
    PRINT           shift and go to state 24
    PRINTF          shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 27
    VARIABLE        shift and go to state 8
    TYPE            shift and go to state 35
    VAR             shift and go to state 37
    SWITCH          shift and go to state 38
    CHARSTRING      shift and go to state 40
    LBRACE          shift and go to state 5
    FOR             shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    statement                      shift and go to state 230
    blocks                         shift and go to state 2
    package                        shift and go to state 3
    main                           shift and go to state 4
    block                          shift and go to state 6
    print_statement                shift and go to state 10
    input_statement                shift and go to state 11
    conditional_structure          shift and go to state 12
    operation                      shift and go to state 13
    list_structure                 shift and go to state 14
    map_estructure                 shift and go to state 15
    map_assign                     shift and go to state 16
    for_estructure                 shift and go to state 17
    structure                      shift and go to state 18
    function                       shift and go to state 19
    parameters                     shift and go to state 20
    variable_declaration           shift and go to state 21
    switch_structure               shift and go to state 22
    slice_structure                shift and go to state 23
    value                          shift and go to state 28
    empty_list                     shift and go to state 29
    list_with_data                 shift and go to state 30
    defined_list                   shift and go to state 31
    for_initialization             shift and go to state 32
    for_infinite_bucle             shift and go to state 33
    for_iterator                   shift and go to state 34
    parameter                      shift and go to state 36
    number                         shift and go to state 39

state 218

    (102) case_block -> DEFAULT COLON statement .

    CASE            reduce using rule 102 (case_block -> DEFAULT COLON statement .)
    DEFAULT         reduce using rule 102 (case_block -> DEFAULT COLON statement .)
    RBRACE          reduce using rule 102 (case_block -> DEFAULT COLON statement .)


state 219

    (93) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition . SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 231


state 220

    (95) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE . VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 232


state 221

    (110) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type . LBRACE map_values RBRACE

    LBRACE          shift and go to state 233


state 222

    (116) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values . RBRACE

    RBRACE          shift and go to state 234


state 223

    (111) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN

    RBRACKET        shift and go to state 235


state 224

    (120) append_statement -> APPEND LPAREN VARIABLE COMMA values . RPAREN

    RPAREN          shift and go to state 236


state 225

    (28) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .

    PRINT           reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    LBRACE          reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CASE            reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 28 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)


state 226

    (30) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN . value RBRACE
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    value                          shift and go to state 237
    number                         shift and go to state 39

state 227

    (29) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 238


state 228

    (31) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE . RETURN value RBRACE

    RETURN          shift and go to state 239


state 229

    (74) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body . ELSE conditional_body

    ELSE            shift and go to state 240


state 230

    (101) case_block -> CASE values COLON statement .

    CASE            reduce using rule 101 (case_block -> CASE values COLON statement .)
    DEFAULT         reduce using rule 101 (case_block -> CASE values COLON statement .)
    RBRACE          reduce using rule 101 (case_block -> CASE values COLON statement .)


state 231

    (93) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON . value double_operator LBRACE statement RBRACE
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    value                          shift and go to state 241
    number                         shift and go to state 39

state 232

    (95) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE . LBRACE statement RBRACE

    LBRACE          shift and go to state 242


state 233

    (110) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE . map_values RBRACE
    (112) map_values -> . map_value
    (113) map_values -> . map_value COMMA map_values
    (114) map_value -> . string_value COLON string_value
    (34) string_value -> . value
    (35) string_value -> . CHARSTRING
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    CHARSTRING      shift and go to state 104
    VARIABLE        shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    map_values                     shift and go to state 243
    map_value                      shift and go to state 244
    string_value                   shift and go to state 245
    value                          shift and go to state 103
    number                         shift and go to state 39

state 234

    (116) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .

    PRINT           reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    PRINTF          reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    INPUT           reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    IF              reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    VARIABLE        reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    TYPE            reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FUNCTION        reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    VAR             reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    SWITCH          reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    LBRACE          reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FOR             reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    INT             reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FLOAT           reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    $end            reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    RBRACE          reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CASE            reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    DEFAULT         reduce using rule 116 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)


state 235

    (111) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (64) type -> . INT
    (65) type -> . INT32
    (66) type -> . INT64
    (67) type -> . STRING
    (68) type -> . FLOAT
    (69) type -> . FLOAT32
    (70) type -> . FLOAT64
    (71) type -> . BOOL

    INT             shift and go to state 58
    INT32           shift and go to state 59
    INT64           shift and go to state 60
    STRING          shift and go to state 61
    FLOAT           shift and go to state 62
    FLOAT32         shift and go to state 63
    FLOAT64         shift and go to state 64
    BOOL            shift and go to state 65

    type                           shift and go to state 246

state 236

    (120) append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .

    PRINT           reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    PRINTF          reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    INPUT           reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    IF              reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    VARIABLE        reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    TYPE            reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FUNCTION        reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    VAR             reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    SWITCH          reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CHARSTRING      reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    LBRACE          reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FOR             reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    INT             reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FLOAT           reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    $end            reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    RBRACE          reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CASE            reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    DEFAULT         reduce using rule 120 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)


state 237

    (30) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value . RBRACE

    RBRACE          shift and go to state 247


state 238

    (29) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .

    PRINT           reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    LBRACE          reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CASE            reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 29 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)


state 239

    (31) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN . value RBRACE
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    VARIABLE        shift and go to state 50
    CHARSTRING      shift and go to state 40
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    value                          shift and go to state 248
    number                         shift and go to state 39

state 240

    (74) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE . conditional_body
    (75) conditional_body -> . LBRACE statement RBRACE
    (76) conditional_body -> . LBRACE BREAK RBRACE
    (77) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 120

    conditional_body               shift and go to state 249

state 241

    (93) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value . double_operator LBRACE statement RBRACE
    (58) double_operator -> . INCREMENT
    (59) double_operator -> . DECREMENT

    INCREMENT       shift and go to state 81
    DECREMENT       shift and go to state 82

    double_operator                shift and go to state 250

state 242

    (95) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . package blocks
    (3) statement -> . main LBRACE blocks RBRACE
    (4) statement -> . package main LBRACE blocks RBRACE
    (7) blocks -> . block
    (8) blocks -> . block blocks
    (5) package -> . PACKAGE VARIABLE
    (6) main -> . FUNCTION MAIN LPAREN RPAREN
    (9) block -> . print_statement
    (10) block -> . input_statement
    (11) block -> . conditional_structure
    (12) block -> . operation
    (13) block -> . list_structure
    (14) block -> . map_estructure
    (15) block -> . map_assign
    (16) block -> . for_estructure
    (17) block -> . structure
    (18) block -> . function
    (19) block -> . parameters
    (20) block -> . variable_declaration
    (21) block -> . switch_structure
    (22) block -> . slice_structure
    (41) print_statement -> . PRINT LPAREN values RPAREN
    (42) print_statement -> . PRINT LPAREN string_value RPAREN
    (43) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (44) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (45) print_statement -> . PRINT LPAREN operation RPAREN
    (46) print_statement -> . PRINT LPAREN RPAREN
    (47) input_statement -> . INPUT LPAREN values RPAREN
    (48) input_statement -> . INPUT LPAREN operation RPAREN
    (49) input_statement -> . INPUT LPAREN RPAREN
    (72) conditional_structure -> . IF conditions conditional_body
    (73) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (74) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (104) list_structure -> . empty_list
    (105) list_structure -> . list_with_data
    (106) list_structure -> . defined_list
    (110) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (115) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (90) for_estructure -> . for_initialization
    (91) for_estructure -> . for_infinite_bucle
    (92) for_estructure -> . for_iterator
    (27) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (28) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (23) variable_declaration -> . VAR VARIABLE type
    (24) variable_declaration -> . VAR VARIABLE ASSIGN value
    (25) variable_declaration -> . VARIABLE SHORTASSIGN value
    (26) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (96) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (116) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (117) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (118) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (119) slice_structure -> . VARIABLE ASSIGN append_statement
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (107) empty_list -> . LBRACE RBRACE
    (108) list_with_data -> . LBRACE values RBRACE
    (109) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (93) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (94) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (95) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (63) parameter -> . VARIABLE type
    (39) number -> . INT
    (40) number -> . FLOAT

    PACKAGE         shift and go to state 7
    FUNCTION        shift and go to state 9
    PRINT           shift and go to state 24
    PRINTF          shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 27
    VARIABLE        shift and go to state 8
    TYPE            shift and go to state 35
    VAR             shift and go to state 37
    SWITCH          shift and go to state 38
    CHARSTRING      shift and go to state 40
    LBRACE          shift and go to state 5
    FOR             shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    statement                      shift and go to state 251
    blocks                         shift and go to state 2
    package                        shift and go to state 3
    main                           shift and go to state 4
    block                          shift and go to state 6
    print_statement                shift and go to state 10
    input_statement                shift and go to state 11
    conditional_structure          shift and go to state 12
    operation                      shift and go to state 13
    list_structure                 shift and go to state 14
    map_estructure                 shift and go to state 15
    map_assign                     shift and go to state 16
    for_estructure                 shift and go to state 17
    structure                      shift and go to state 18
    function                       shift and go to state 19
    parameters                     shift and go to state 20
    variable_declaration           shift and go to state 21
    switch_structure               shift and go to state 22
    slice_structure                shift and go to state 23
    value                          shift and go to state 28
    empty_list                     shift and go to state 29
    list_with_data                 shift and go to state 30
    defined_list                   shift and go to state 31
    for_initialization             shift and go to state 32
    for_infinite_bucle             shift and go to state 33
    for_iterator                   shift and go to state 34
    parameter                      shift and go to state 36
    number                         shift and go to state 39

state 243

    (110) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values . RBRACE

    RBRACE          shift and go to state 252


state 244

    (112) map_values -> map_value .
    (113) map_values -> map_value . COMMA map_values

    RBRACE          reduce using rule 112 (map_values -> map_value .)
    COMMA           shift and go to state 253


state 245

    (114) map_value -> string_value . COLON string_value

    COLON           shift and go to state 254


state 246

    (111) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN

    RPAREN          shift and go to state 255


state 247

    (30) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .

    PRINT           reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    PRINTF          reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    INPUT           reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    IF              reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    VARIABLE        reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    TYPE            reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    FUNCTION        reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    VAR             reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    SWITCH          reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    CHARSTRING      reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    LBRACE          reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    FOR             reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    INT             reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    FLOAT           reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    $end            reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    RBRACE          reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    CASE            reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    DEFAULT         reduce using rule 30 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)


state 248

    (31) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value . RBRACE

    RBRACE          shift and go to state 256


state 249

    (74) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .

    PRINT           reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    PRINTF          reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    SWITCH          reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CHARSTRING      reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    LBRACE          reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CASE            reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    DEFAULT         reduce using rule 74 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)


state 250

    (93) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator . LBRACE statement RBRACE

    LBRACE          shift and go to state 257


state 251

    (95) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement . RBRACE

    RBRACE          shift and go to state 258


state 252

    (110) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .

    PRINT           reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    PRINTF          reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INPUT           reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    IF              reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VARIABLE        reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    TYPE            reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FUNCTION        reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VAR             reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    SWITCH          reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CHARSTRING      reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    LBRACE          reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FOR             reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INT             reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FLOAT           reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    $end            reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RBRACE          reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CASE            reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    DEFAULT         reduce using rule 110 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)


state 253

    (113) map_values -> map_value COMMA . map_values
    (112) map_values -> . map_value
    (113) map_values -> . map_value COMMA map_values
    (114) map_value -> . string_value COLON string_value
    (34) string_value -> . value
    (35) string_value -> . CHARSTRING
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    CHARSTRING      shift and go to state 104
    VARIABLE        shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    map_value                      shift and go to state 244
    map_values                     shift and go to state 259
    string_value                   shift and go to state 245
    value                          shift and go to state 103
    number                         shift and go to state 39

state 254

    (114) map_value -> string_value COLON . string_value
    (34) string_value -> . value
    (35) string_value -> . CHARSTRING
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (39) number -> . INT
    (40) number -> . FLOAT

    CHARSTRING      shift and go to state 104
    VARIABLE        shift and go to state 50
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    string_value                   shift and go to state 260
    value                          shift and go to state 103
    number                         shift and go to state 39

state 255

    (111) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .

    PRINT           reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    PRINTF          reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INPUT           reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    IF              reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TYPE            reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FUNCTION        reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VAR             reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SWITCH          reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CHARSTRING      reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LBRACE          reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FOR             reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INT             reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FLOAT           reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    $end            reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RBRACE          reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CASE            reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 111 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)


state 256

    (31) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .

    PRINT           reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    PRINTF          reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    INPUT           reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    IF              reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    VARIABLE        reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    TYPE            reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    FUNCTION        reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    VAR             reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    SWITCH          reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    CHARSTRING      reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    LBRACE          reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    FOR             reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    INT             reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    FLOAT           reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    $end            reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    RBRACE          reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    CASE            reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    DEFAULT         reduce using rule 31 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)


state 257

    (93) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . package blocks
    (3) statement -> . main LBRACE blocks RBRACE
    (4) statement -> . package main LBRACE blocks RBRACE
    (7) blocks -> . block
    (8) blocks -> . block blocks
    (5) package -> . PACKAGE VARIABLE
    (6) main -> . FUNCTION MAIN LPAREN RPAREN
    (9) block -> . print_statement
    (10) block -> . input_statement
    (11) block -> . conditional_structure
    (12) block -> . operation
    (13) block -> . list_structure
    (14) block -> . map_estructure
    (15) block -> . map_assign
    (16) block -> . for_estructure
    (17) block -> . structure
    (18) block -> . function
    (19) block -> . parameters
    (20) block -> . variable_declaration
    (21) block -> . switch_structure
    (22) block -> . slice_structure
    (41) print_statement -> . PRINT LPAREN values RPAREN
    (42) print_statement -> . PRINT LPAREN string_value RPAREN
    (43) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (44) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (45) print_statement -> . PRINT LPAREN operation RPAREN
    (46) print_statement -> . PRINT LPAREN RPAREN
    (47) input_statement -> . INPUT LPAREN values RPAREN
    (48) input_statement -> . INPUT LPAREN operation RPAREN
    (49) input_statement -> . INPUT LPAREN RPAREN
    (72) conditional_structure -> . IF conditions conditional_body
    (73) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (74) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (50) operation -> . value operator value
    (51) operation -> . value operator operation
    (52) operation -> . value double_operator
    (104) list_structure -> . empty_list
    (105) list_structure -> . list_with_data
    (106) list_structure -> . defined_list
    (110) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (111) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (115) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (90) for_estructure -> . for_initialization
    (91) for_estructure -> . for_infinite_bucle
    (92) for_estructure -> . for_iterator
    (27) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (28) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (29) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (30) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (31) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (60) parameters -> . parameter
    (61) parameters -> . parameter parameters
    (62) parameters -> . parameter COMMA parameters
    (23) variable_declaration -> . VAR VARIABLE type
    (24) variable_declaration -> . VAR VARIABLE ASSIGN value
    (25) variable_declaration -> . VARIABLE SHORTASSIGN value
    (26) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (96) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (116) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (117) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (118) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (119) slice_structure -> . VARIABLE ASSIGN append_statement
    (36) value -> . VARIABLE
    (37) value -> . number
    (38) value -> . CHARSTRING
    (107) empty_list -> . LBRACE RBRACE
    (108) list_with_data -> . LBRACE values RBRACE
    (109) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (93) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (94) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (95) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (63) parameter -> . VARIABLE type
    (39) number -> . INT
    (40) number -> . FLOAT

    PACKAGE         shift and go to state 7
    FUNCTION        shift and go to state 9
    PRINT           shift and go to state 24
    PRINTF          shift and go to state 25
    INPUT           shift and go to state 26
    IF              shift and go to state 27
    VARIABLE        shift and go to state 8
    TYPE            shift and go to state 35
    VAR             shift and go to state 37
    SWITCH          shift and go to state 38
    CHARSTRING      shift and go to state 40
    LBRACE          shift and go to state 5
    FOR             shift and go to state 41
    INT             shift and go to state 42
    FLOAT           shift and go to state 43

    value                          shift and go to state 28
    statement                      shift and go to state 261
    blocks                         shift and go to state 2
    package                        shift and go to state 3
    main                           shift and go to state 4
    block                          shift and go to state 6
    print_statement                shift and go to state 10
    input_statement                shift and go to state 11
    conditional_structure          shift and go to state 12
    operation                      shift and go to state 13
    list_structure                 shift and go to state 14
    map_estructure                 shift and go to state 15
    map_assign                     shift and go to state 16
    for_estructure                 shift and go to state 17
    structure                      shift and go to state 18
    function                       shift and go to state 19
    parameters                     shift and go to state 20
    variable_declaration           shift and go to state 21
    switch_structure               shift and go to state 22
    slice_structure                shift and go to state 23
    empty_list                     shift and go to state 29
    list_with_data                 shift and go to state 30
    defined_list                   shift and go to state 31
    for_initialization             shift and go to state 32
    for_infinite_bucle             shift and go to state 33
    for_iterator                   shift and go to state 34
    parameter                      shift and go to state 36
    number                         shift and go to state 39

state 258

    (95) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .

    PRINT           reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    PRINTF          reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INPUT           reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    IF              reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    TYPE            reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VAR             reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    SWITCH          reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    LBRACE          reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FOR             reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INT             reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FLOAT           reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    $end            reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RBRACE          reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CASE            reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 95 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)


state 259

    (113) map_values -> map_value COMMA map_values .

    RBRACE          reduce using rule 113 (map_values -> map_value COMMA map_values .)


state 260

    (114) map_value -> string_value COLON string_value .

    COMMA           reduce using rule 114 (map_value -> string_value COLON string_value .)
    RBRACE          reduce using rule 114 (map_value -> string_value COLON string_value .)


state 261

    (93) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement . RBRACE

    RBRACE          shift and go to state 262


state 262

    (93) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .

    PRINT           reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    PRINTF          reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INPUT           reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    IF              reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    TYPE            reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VAR             reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    SWITCH          reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    LBRACE          reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FOR             reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INT             reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FLOAT           reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    $end            reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RBRACE          reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CASE            reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 93 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ASSIGN in state 8 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 36 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 113 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 181 resolved as shift
WARNING: reduce/reduce conflict in state 104 resolved using rule (string_value -> CHARSTRING)
WARNING: rejected rule (value -> CHARSTRING) in state 104
WARNING: reduce/reduce conflict in state 113 resolved using rule (values -> value)
WARNING: rejected rule (string_value -> value) in state 113
