Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    APPEND
    CASE
    CONST
    DEFAULT
    DIVIDEASSIGN
    FALSE
    IDENTIFIER
    IMPORT
    MAIN
    MINUSASSIGN
    MOD
    MODASSIGN
    PACKAGE
    PLUSASSIGN
    SWITCH
    TEXT
    TIMESASSIGN
    TRUE

Grammar

Rule 0     S' -> statement
Rule 1     statement -> blocks
Rule 2     blocks -> block
Rule 3     blocks -> block blocks
Rule 4     block -> print_statement
Rule 5     block -> input_statement
Rule 6     block -> conditional_structure
Rule 7     block -> operation
Rule 8     block -> list_structure
Rule 9     block -> map_estructure
Rule 10    block -> map_assign
Rule 11    block -> for_estructure
Rule 12    block -> structure
Rule 13    block -> function
Rule 14    block -> parameters
Rule 15    block -> variable_declaration
Rule 16    variable_declaration -> VAR VARIABLE type
Rule 17    variable_declaration -> VAR VARIABLE ASSIGN value
Rule 18    variable_declaration -> VARIABLE SHORTASSIGN value
Rule 19    structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE
Rule 20    function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
Rule 21    function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
Rule 22    function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
Rule 23    function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
Rule 24    values -> value
Rule 25    values -> value COMMA values
Rule 26    string_value -> value
Rule 27    string_value -> CHARSTRING
Rule 28    value -> VARIABLE
Rule 29    value -> number
Rule 30    number -> INT
Rule 31    number -> FLOAT
Rule 32    print_statement -> PRINT LPAREN values RPAREN
Rule 33    print_statement -> PRINT LPAREN string_value RPAREN
Rule 34    print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN
Rule 35    print_statement -> PRINT LPAREN operation RPAREN
Rule 36    print_statement -> PRINT LPAREN RPAREN
Rule 37    input_statement -> INPUT LPAREN values RPAREN
Rule 38    input_statement -> INPUT LPAREN operation RPAREN
Rule 39    input_statement -> INPUT LPAREN RPAREN
Rule 40    operation -> value operator value
Rule 41    operation -> value operator operation
Rule 42    operation -> value double_operator
Rule 43    operator -> PLUS
Rule 44    operator -> MINUS
Rule 45    operator -> TIMES
Rule 46    operator -> DIVIDE
Rule 47    operator -> ASSIGN
Rule 48    double_operator -> INCREMENT
Rule 49    double_operator -> DECREMENT
Rule 50    parameters -> parameter
Rule 51    parameters -> parameter parameters
Rule 52    parameters -> parameter COMMA parameters
Rule 53    parameter -> VARIABLE type
Rule 54    type -> INT
Rule 55    type -> INT32
Rule 56    type -> INT64
Rule 57    type -> STRING
Rule 58    type -> FLOAT
Rule 59    type -> FLOAT32
Rule 60    type -> FLOAT64
Rule 61    type -> BOOL
Rule 62    conditional_structure -> IF conditions conditional_body
Rule 63    conditional_structure -> IF conditions conditional_body ELSE conditional_body
Rule 64    conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
Rule 65    conditional_body -> LBRACE statement RBRACE
Rule 66    conditional_body -> LBRACE BREAK RBRACE
Rule 67    conditional_body -> LBRACE CONTINUE RBRACE
Rule 68    conditions -> condition
Rule 69    conditions -> condition logical_operator conditions
Rule 70    condition -> value relational_operator value
Rule 71    logical_operator -> AND
Rule 72    logical_operator -> OR
Rule 73    logical_operator -> NOT
Rule 74    relational_operator -> GREATER
Rule 75    relational_operator -> LESS
Rule 76    relational_operator -> GREATEREQUALS
Rule 77    relational_operator -> LESSEQUALS
Rule 78    relational_operator -> EQUALS
Rule 79    relational_operator -> DIFFERENT
Rule 80    for_estructure -> for_initialization
Rule 81    for_estructure -> for_infinite_bucle
Rule 82    for_estructure -> for_iterator
Rule 83    for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
Rule 84    for_infinite_bucle -> FOR LBRACE statement RBRACE
Rule 85    for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
Rule 86    list_structure -> empty_list
Rule 87    list_structure -> list_with_data
Rule 88    list_structure -> defined_list
Rule 89    empty_list -> LBRACE RBRACE
Rule 90    list_with_data -> LBRACE values RBRACE
Rule 91    defined_list -> TYPE VARIABLE LBRACE values RBRACE
Rule 92    map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
Rule 93    map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
Rule 94    map_values -> map_value
Rule 95    map_values -> map_value COMMA map_values
Rule 96    map_value -> string_value COLON string_value
Rule 97    map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 71
APPEND               : 
ASSIGN               : 17 47 97
BOOL                 : 61
BREAK                : 66
CASE                 : 
CHARSTRING           : 27
COLON                : 96
COMMA                : 25 34 52 95
CONST                : 
CONTINUE             : 67
DECREMENT            : 49
DEFAULT              : 
DIFFERENT            : 79
DIVIDE               : 46
DIVIDEASSIGN         : 
ELSE                 : 63 64 64
EQUALS               : 78
FALSE                : 
FLOAT                : 31 58
FLOAT32              : 59
FLOAT64              : 60
FOR                  : 83 84 85
FORMATSTRING         : 34
FUNCTION             : 20 21 22 23
GREATER              : 74
GREATEREQUALS        : 76
IDENTIFIER           : 
IF                   : 62 63 64 64
IMPORT               : 
INCREMENT            : 48
INPUT                : 37 38 39
INT                  : 30 54
INT32                : 55
INT64                : 56
LBRACE               : 19 20 21 22 23 65 66 67 83 84 85 89 90 91 92
LBRACKET             : 92 93 97
LESS                 : 75
LESSEQUALS           : 77
LPAREN               : 20 21 22 23 32 33 34 35 36 37 38 39 93
MAIN                 : 
MAKE                 : 93
MAP                  : 92 93
MINUS                : 44
MINUSASSIGN          : 
MOD                  : 
MODASSIGN            : 
NOT                  : 73
OR                   : 72
PACKAGE              : 
PLUS                 : 43
PLUSASSIGN           : 
PRINT                : 32 33 34 35 36
RANGE                : 85
RBRACE               : 19 20 21 22 23 65 66 67 83 84 85 89 90 91 92
RBRACKET             : 92 93 97
RETURN               : 20 22
RPAREN               : 20 21 22 23 32 33 34 35 36 37 38 39 93
SEMICOLON            : 83 83 85
SHORTASSIGN          : 18 83 85 92 93
STRING               : 57
STRUCT               : 19
SWITCH               : 
TEXT                 : 
TIMES                : 45
TIMESASSIGN          : 
TRUE                 : 
TYPE                 : 19 91
VAR                  : 16 17
VARIABLE             : 16 17 18 19 20 20 21 22 22 23 28 53 83 85 85 85 91 92 93 97
error                : 

Nonterminals, with rules where they appear

block                : 2 3
blocks               : 1 3 20 21 22 23
condition            : 68 69 83
conditional_body     : 62 63 63 64 64 64
conditional_structure : 6
conditions           : 62 63 64 64 69
defined_list         : 88
double_operator      : 42 83
empty_list           : 86
for_estructure       : 11
for_infinite_bucle   : 81
for_initialization   : 80
for_iterator         : 82
function             : 13
input_statement      : 5
list_structure       : 8
list_with_data       : 87
logical_operator     : 69
map_assign           : 10
map_estructure       : 9
map_value            : 94 95
map_values           : 92 95
number               : 29
operation            : 7 35 38 41
operator             : 40 41
parameter            : 50 51 52
parameters           : 14 20 21 51 52
print_statement      : 4
relational_operator  : 70
statement            : 19 65 83 84 85 0
string_value         : 33 96 96 97 97
structure            : 12
type                 : 16 20 22 53 92 92 93 93
value                : 17 18 24 25 26 40 40 41 42 70 70 83 83
values               : 25 32 34 37 90 91
variable_declaration : 15

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (32) print_statement -> . PRINT LPAREN values RPAREN
    (33) print_statement -> . PRINT LPAREN string_value RPAREN
    (34) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (35) print_statement -> . PRINT LPAREN operation RPAREN
    (36) print_statement -> . PRINT LPAREN RPAREN
    (37) input_statement -> . INPUT LPAREN values RPAREN
    (38) input_statement -> . INPUT LPAREN operation RPAREN
    (39) input_statement -> . INPUT LPAREN RPAREN
    (62) conditional_structure -> . IF conditions conditional_body
    (63) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (64) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (40) operation -> . value operator value
    (41) operation -> . value operator operation
    (42) operation -> . value double_operator
    (86) list_structure -> . empty_list
    (87) list_structure -> . list_with_data
    (88) list_structure -> . defined_list
    (92) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (93) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (97) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (80) for_estructure -> . for_initialization
    (81) for_estructure -> . for_infinite_bucle
    (82) for_estructure -> . for_iterator
    (19) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (50) parameters -> . parameter
    (51) parameters -> . parameter parameters
    (52) parameters -> . parameter COMMA parameters
    (16) variable_declaration -> . VAR VARIABLE type
    (17) variable_declaration -> . VAR VARIABLE ASSIGN value
    (18) variable_declaration -> . VARIABLE SHORTASSIGN value
    (28) value -> . VARIABLE
    (29) value -> . number
    (89) empty_list -> . LBRACE RBRACE
    (90) list_with_data -> . LBRACE values RBRACE
    (91) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (83) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (84) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (85) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (53) parameter -> . VARIABLE type
    (30) number -> . INT
    (31) number -> . FLOAT

    PRINT           shift and go to state 16
    INPUT           shift and go to state 17
    IF              shift and go to state 18
    VARIABLE        shift and go to state 23
    TYPE            shift and go to state 28
    FUNCTION        shift and go to state 29
    VAR             shift and go to state 31
    LBRACE          shift and go to state 24
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    statement                      shift and go to state 1
    blocks                         shift and go to state 2
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    value                          shift and go to state 19
    empty_list                     shift and go to state 20
    list_with_data                 shift and go to state 21
    defined_list                   shift and go to state 22
    for_initialization             shift and go to state 25
    for_infinite_bucle             shift and go to state 26
    for_iterator                   shift and go to state 27
    parameter                      shift and go to state 30
    number                         shift and go to state 32

state 1

    (0) S' -> statement .



state 2

    (1) statement -> blocks .

    $end            reduce using rule 1 (statement -> blocks .)
    RBRACE          reduce using rule 1 (statement -> blocks .)


state 3

    (2) blocks -> block .
    (3) blocks -> block . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (32) print_statement -> . PRINT LPAREN values RPAREN
    (33) print_statement -> . PRINT LPAREN string_value RPAREN
    (34) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (35) print_statement -> . PRINT LPAREN operation RPAREN
    (36) print_statement -> . PRINT LPAREN RPAREN
    (37) input_statement -> . INPUT LPAREN values RPAREN
    (38) input_statement -> . INPUT LPAREN operation RPAREN
    (39) input_statement -> . INPUT LPAREN RPAREN
    (62) conditional_structure -> . IF conditions conditional_body
    (63) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (64) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (40) operation -> . value operator value
    (41) operation -> . value operator operation
    (42) operation -> . value double_operator
    (86) list_structure -> . empty_list
    (87) list_structure -> . list_with_data
    (88) list_structure -> . defined_list
    (92) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (93) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (97) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (80) for_estructure -> . for_initialization
    (81) for_estructure -> . for_infinite_bucle
    (82) for_estructure -> . for_iterator
    (19) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (50) parameters -> . parameter
    (51) parameters -> . parameter parameters
    (52) parameters -> . parameter COMMA parameters
    (16) variable_declaration -> . VAR VARIABLE type
    (17) variable_declaration -> . VAR VARIABLE ASSIGN value
    (18) variable_declaration -> . VARIABLE SHORTASSIGN value
    (28) value -> . VARIABLE
    (29) value -> . number
    (89) empty_list -> . LBRACE RBRACE
    (90) list_with_data -> . LBRACE values RBRACE
    (91) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (83) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (84) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (85) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (53) parameter -> . VARIABLE type
    (30) number -> . INT
    (31) number -> . FLOAT

    $end            reduce using rule 2 (blocks -> block .)
    RBRACE          reduce using rule 2 (blocks -> block .)
    RETURN          reduce using rule 2 (blocks -> block .)
    PRINT           shift and go to state 16
    INPUT           shift and go to state 17
    IF              shift and go to state 18
    VARIABLE        shift and go to state 23
    TYPE            shift and go to state 28
    FUNCTION        shift and go to state 29
    VAR             shift and go to state 31
    LBRACE          shift and go to state 24
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    block                          shift and go to state 3
    blocks                         shift and go to state 36
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    value                          shift and go to state 19
    empty_list                     shift and go to state 20
    list_with_data                 shift and go to state 21
    defined_list                   shift and go to state 22
    for_initialization             shift and go to state 25
    for_infinite_bucle             shift and go to state 26
    for_iterator                   shift and go to state 27
    parameter                      shift and go to state 30
    number                         shift and go to state 32

state 4

    (4) block -> print_statement .

    PRINT           reduce using rule 4 (block -> print_statement .)
    INPUT           reduce using rule 4 (block -> print_statement .)
    IF              reduce using rule 4 (block -> print_statement .)
    VARIABLE        reduce using rule 4 (block -> print_statement .)
    TYPE            reduce using rule 4 (block -> print_statement .)
    FUNCTION        reduce using rule 4 (block -> print_statement .)
    VAR             reduce using rule 4 (block -> print_statement .)
    LBRACE          reduce using rule 4 (block -> print_statement .)
    FOR             reduce using rule 4 (block -> print_statement .)
    INT             reduce using rule 4 (block -> print_statement .)
    FLOAT           reduce using rule 4 (block -> print_statement .)
    $end            reduce using rule 4 (block -> print_statement .)
    RBRACE          reduce using rule 4 (block -> print_statement .)
    RETURN          reduce using rule 4 (block -> print_statement .)


state 5

    (5) block -> input_statement .

    PRINT           reduce using rule 5 (block -> input_statement .)
    INPUT           reduce using rule 5 (block -> input_statement .)
    IF              reduce using rule 5 (block -> input_statement .)
    VARIABLE        reduce using rule 5 (block -> input_statement .)
    TYPE            reduce using rule 5 (block -> input_statement .)
    FUNCTION        reduce using rule 5 (block -> input_statement .)
    VAR             reduce using rule 5 (block -> input_statement .)
    LBRACE          reduce using rule 5 (block -> input_statement .)
    FOR             reduce using rule 5 (block -> input_statement .)
    INT             reduce using rule 5 (block -> input_statement .)
    FLOAT           reduce using rule 5 (block -> input_statement .)
    $end            reduce using rule 5 (block -> input_statement .)
    RBRACE          reduce using rule 5 (block -> input_statement .)
    RETURN          reduce using rule 5 (block -> input_statement .)


state 6

    (6) block -> conditional_structure .

    PRINT           reduce using rule 6 (block -> conditional_structure .)
    INPUT           reduce using rule 6 (block -> conditional_structure .)
    IF              reduce using rule 6 (block -> conditional_structure .)
    VARIABLE        reduce using rule 6 (block -> conditional_structure .)
    TYPE            reduce using rule 6 (block -> conditional_structure .)
    FUNCTION        reduce using rule 6 (block -> conditional_structure .)
    VAR             reduce using rule 6 (block -> conditional_structure .)
    LBRACE          reduce using rule 6 (block -> conditional_structure .)
    FOR             reduce using rule 6 (block -> conditional_structure .)
    INT             reduce using rule 6 (block -> conditional_structure .)
    FLOAT           reduce using rule 6 (block -> conditional_structure .)
    $end            reduce using rule 6 (block -> conditional_structure .)
    RBRACE          reduce using rule 6 (block -> conditional_structure .)
    RETURN          reduce using rule 6 (block -> conditional_structure .)


state 7

    (7) block -> operation .

    PRINT           reduce using rule 7 (block -> operation .)
    INPUT           reduce using rule 7 (block -> operation .)
    IF              reduce using rule 7 (block -> operation .)
    VARIABLE        reduce using rule 7 (block -> operation .)
    TYPE            reduce using rule 7 (block -> operation .)
    FUNCTION        reduce using rule 7 (block -> operation .)
    VAR             reduce using rule 7 (block -> operation .)
    LBRACE          reduce using rule 7 (block -> operation .)
    FOR             reduce using rule 7 (block -> operation .)
    INT             reduce using rule 7 (block -> operation .)
    FLOAT           reduce using rule 7 (block -> operation .)
    $end            reduce using rule 7 (block -> operation .)
    RBRACE          reduce using rule 7 (block -> operation .)
    RETURN          reduce using rule 7 (block -> operation .)


state 8

    (8) block -> list_structure .

    PRINT           reduce using rule 8 (block -> list_structure .)
    INPUT           reduce using rule 8 (block -> list_structure .)
    IF              reduce using rule 8 (block -> list_structure .)
    VARIABLE        reduce using rule 8 (block -> list_structure .)
    TYPE            reduce using rule 8 (block -> list_structure .)
    FUNCTION        reduce using rule 8 (block -> list_structure .)
    VAR             reduce using rule 8 (block -> list_structure .)
    LBRACE          reduce using rule 8 (block -> list_structure .)
    FOR             reduce using rule 8 (block -> list_structure .)
    INT             reduce using rule 8 (block -> list_structure .)
    FLOAT           reduce using rule 8 (block -> list_structure .)
    $end            reduce using rule 8 (block -> list_structure .)
    RBRACE          reduce using rule 8 (block -> list_structure .)
    RETURN          reduce using rule 8 (block -> list_structure .)


state 9

    (9) block -> map_estructure .

    PRINT           reduce using rule 9 (block -> map_estructure .)
    INPUT           reduce using rule 9 (block -> map_estructure .)
    IF              reduce using rule 9 (block -> map_estructure .)
    VARIABLE        reduce using rule 9 (block -> map_estructure .)
    TYPE            reduce using rule 9 (block -> map_estructure .)
    FUNCTION        reduce using rule 9 (block -> map_estructure .)
    VAR             reduce using rule 9 (block -> map_estructure .)
    LBRACE          reduce using rule 9 (block -> map_estructure .)
    FOR             reduce using rule 9 (block -> map_estructure .)
    INT             reduce using rule 9 (block -> map_estructure .)
    FLOAT           reduce using rule 9 (block -> map_estructure .)
    $end            reduce using rule 9 (block -> map_estructure .)
    RBRACE          reduce using rule 9 (block -> map_estructure .)
    RETURN          reduce using rule 9 (block -> map_estructure .)


state 10

    (10) block -> map_assign .

    PRINT           reduce using rule 10 (block -> map_assign .)
    INPUT           reduce using rule 10 (block -> map_assign .)
    IF              reduce using rule 10 (block -> map_assign .)
    VARIABLE        reduce using rule 10 (block -> map_assign .)
    TYPE            reduce using rule 10 (block -> map_assign .)
    FUNCTION        reduce using rule 10 (block -> map_assign .)
    VAR             reduce using rule 10 (block -> map_assign .)
    LBRACE          reduce using rule 10 (block -> map_assign .)
    FOR             reduce using rule 10 (block -> map_assign .)
    INT             reduce using rule 10 (block -> map_assign .)
    FLOAT           reduce using rule 10 (block -> map_assign .)
    $end            reduce using rule 10 (block -> map_assign .)
    RBRACE          reduce using rule 10 (block -> map_assign .)
    RETURN          reduce using rule 10 (block -> map_assign .)


state 11

    (11) block -> for_estructure .

    PRINT           reduce using rule 11 (block -> for_estructure .)
    INPUT           reduce using rule 11 (block -> for_estructure .)
    IF              reduce using rule 11 (block -> for_estructure .)
    VARIABLE        reduce using rule 11 (block -> for_estructure .)
    TYPE            reduce using rule 11 (block -> for_estructure .)
    FUNCTION        reduce using rule 11 (block -> for_estructure .)
    VAR             reduce using rule 11 (block -> for_estructure .)
    LBRACE          reduce using rule 11 (block -> for_estructure .)
    FOR             reduce using rule 11 (block -> for_estructure .)
    INT             reduce using rule 11 (block -> for_estructure .)
    FLOAT           reduce using rule 11 (block -> for_estructure .)
    $end            reduce using rule 11 (block -> for_estructure .)
    RBRACE          reduce using rule 11 (block -> for_estructure .)
    RETURN          reduce using rule 11 (block -> for_estructure .)


state 12

    (12) block -> structure .

    PRINT           reduce using rule 12 (block -> structure .)
    INPUT           reduce using rule 12 (block -> structure .)
    IF              reduce using rule 12 (block -> structure .)
    VARIABLE        reduce using rule 12 (block -> structure .)
    TYPE            reduce using rule 12 (block -> structure .)
    FUNCTION        reduce using rule 12 (block -> structure .)
    VAR             reduce using rule 12 (block -> structure .)
    LBRACE          reduce using rule 12 (block -> structure .)
    FOR             reduce using rule 12 (block -> structure .)
    INT             reduce using rule 12 (block -> structure .)
    FLOAT           reduce using rule 12 (block -> structure .)
    $end            reduce using rule 12 (block -> structure .)
    RBRACE          reduce using rule 12 (block -> structure .)
    RETURN          reduce using rule 12 (block -> structure .)


state 13

    (13) block -> function .

    PRINT           reduce using rule 13 (block -> function .)
    INPUT           reduce using rule 13 (block -> function .)
    IF              reduce using rule 13 (block -> function .)
    VARIABLE        reduce using rule 13 (block -> function .)
    TYPE            reduce using rule 13 (block -> function .)
    FUNCTION        reduce using rule 13 (block -> function .)
    VAR             reduce using rule 13 (block -> function .)
    LBRACE          reduce using rule 13 (block -> function .)
    FOR             reduce using rule 13 (block -> function .)
    INT             reduce using rule 13 (block -> function .)
    FLOAT           reduce using rule 13 (block -> function .)
    $end            reduce using rule 13 (block -> function .)
    RBRACE          reduce using rule 13 (block -> function .)
    RETURN          reduce using rule 13 (block -> function .)


state 14

    (14) block -> parameters .

    PRINT           reduce using rule 14 (block -> parameters .)
    INPUT           reduce using rule 14 (block -> parameters .)
    IF              reduce using rule 14 (block -> parameters .)
    VARIABLE        reduce using rule 14 (block -> parameters .)
    TYPE            reduce using rule 14 (block -> parameters .)
    FUNCTION        reduce using rule 14 (block -> parameters .)
    VAR             reduce using rule 14 (block -> parameters .)
    LBRACE          reduce using rule 14 (block -> parameters .)
    FOR             reduce using rule 14 (block -> parameters .)
    INT             reduce using rule 14 (block -> parameters .)
    FLOAT           reduce using rule 14 (block -> parameters .)
    $end            reduce using rule 14 (block -> parameters .)
    RBRACE          reduce using rule 14 (block -> parameters .)
    RETURN          reduce using rule 14 (block -> parameters .)


state 15

    (15) block -> variable_declaration .

    PRINT           reduce using rule 15 (block -> variable_declaration .)
    INPUT           reduce using rule 15 (block -> variable_declaration .)
    IF              reduce using rule 15 (block -> variable_declaration .)
    VARIABLE        reduce using rule 15 (block -> variable_declaration .)
    TYPE            reduce using rule 15 (block -> variable_declaration .)
    FUNCTION        reduce using rule 15 (block -> variable_declaration .)
    VAR             reduce using rule 15 (block -> variable_declaration .)
    LBRACE          reduce using rule 15 (block -> variable_declaration .)
    FOR             reduce using rule 15 (block -> variable_declaration .)
    INT             reduce using rule 15 (block -> variable_declaration .)
    FLOAT           reduce using rule 15 (block -> variable_declaration .)
    $end            reduce using rule 15 (block -> variable_declaration .)
    RBRACE          reduce using rule 15 (block -> variable_declaration .)
    RETURN          reduce using rule 15 (block -> variable_declaration .)


state 16

    (32) print_statement -> PRINT . LPAREN values RPAREN
    (33) print_statement -> PRINT . LPAREN string_value RPAREN
    (34) print_statement -> PRINT . LPAREN FORMATSTRING COMMA values RPAREN
    (35) print_statement -> PRINT . LPAREN operation RPAREN
    (36) print_statement -> PRINT . LPAREN RPAREN

    LPAREN          shift and go to state 37


state 17

    (37) input_statement -> INPUT . LPAREN values RPAREN
    (38) input_statement -> INPUT . LPAREN operation RPAREN
    (39) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 38


state 18

    (62) conditional_structure -> IF . conditions conditional_body
    (63) conditional_structure -> IF . conditions conditional_body ELSE conditional_body
    (64) conditional_structure -> IF . conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (68) conditions -> . condition
    (69) conditions -> . condition logical_operator conditions
    (70) condition -> . value relational_operator value
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    conditions                     shift and go to state 39
    condition                      shift and go to state 40
    value                          shift and go to state 41
    number                         shift and go to state 32

state 19

    (40) operation -> value . operator value
    (41) operation -> value . operator operation
    (42) operation -> value . double_operator
    (43) operator -> . PLUS
    (44) operator -> . MINUS
    (45) operator -> . TIMES
    (46) operator -> . DIVIDE
    (47) operator -> . ASSIGN
    (48) double_operator -> . INCREMENT
    (49) double_operator -> . DECREMENT

    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    TIMES           shift and go to state 47
    DIVIDE          shift and go to state 48
    ASSIGN          shift and go to state 49
    INCREMENT       shift and go to state 50
    DECREMENT       shift and go to state 51

    operator                       shift and go to state 43
    double_operator                shift and go to state 44

state 20

    (86) list_structure -> empty_list .

    PRINT           reduce using rule 86 (list_structure -> empty_list .)
    INPUT           reduce using rule 86 (list_structure -> empty_list .)
    IF              reduce using rule 86 (list_structure -> empty_list .)
    VARIABLE        reduce using rule 86 (list_structure -> empty_list .)
    TYPE            reduce using rule 86 (list_structure -> empty_list .)
    FUNCTION        reduce using rule 86 (list_structure -> empty_list .)
    VAR             reduce using rule 86 (list_structure -> empty_list .)
    LBRACE          reduce using rule 86 (list_structure -> empty_list .)
    FOR             reduce using rule 86 (list_structure -> empty_list .)
    INT             reduce using rule 86 (list_structure -> empty_list .)
    FLOAT           reduce using rule 86 (list_structure -> empty_list .)
    $end            reduce using rule 86 (list_structure -> empty_list .)
    RBRACE          reduce using rule 86 (list_structure -> empty_list .)
    RETURN          reduce using rule 86 (list_structure -> empty_list .)


state 21

    (87) list_structure -> list_with_data .

    PRINT           reduce using rule 87 (list_structure -> list_with_data .)
    INPUT           reduce using rule 87 (list_structure -> list_with_data .)
    IF              reduce using rule 87 (list_structure -> list_with_data .)
    VARIABLE        reduce using rule 87 (list_structure -> list_with_data .)
    TYPE            reduce using rule 87 (list_structure -> list_with_data .)
    FUNCTION        reduce using rule 87 (list_structure -> list_with_data .)
    VAR             reduce using rule 87 (list_structure -> list_with_data .)
    LBRACE          reduce using rule 87 (list_structure -> list_with_data .)
    FOR             reduce using rule 87 (list_structure -> list_with_data .)
    INT             reduce using rule 87 (list_structure -> list_with_data .)
    FLOAT           reduce using rule 87 (list_structure -> list_with_data .)
    $end            reduce using rule 87 (list_structure -> list_with_data .)
    RBRACE          reduce using rule 87 (list_structure -> list_with_data .)
    RETURN          reduce using rule 87 (list_structure -> list_with_data .)


state 22

    (88) list_structure -> defined_list .

    PRINT           reduce using rule 88 (list_structure -> defined_list .)
    INPUT           reduce using rule 88 (list_structure -> defined_list .)
    IF              reduce using rule 88 (list_structure -> defined_list .)
    VARIABLE        reduce using rule 88 (list_structure -> defined_list .)
    TYPE            reduce using rule 88 (list_structure -> defined_list .)
    FUNCTION        reduce using rule 88 (list_structure -> defined_list .)
    VAR             reduce using rule 88 (list_structure -> defined_list .)
    LBRACE          reduce using rule 88 (list_structure -> defined_list .)
    FOR             reduce using rule 88 (list_structure -> defined_list .)
    INT             reduce using rule 88 (list_structure -> defined_list .)
    FLOAT           reduce using rule 88 (list_structure -> defined_list .)
    $end            reduce using rule 88 (list_structure -> defined_list .)
    RBRACE          reduce using rule 88 (list_structure -> defined_list .)
    RETURN          reduce using rule 88 (list_structure -> defined_list .)


state 23

    (92) map_estructure -> VARIABLE . SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (93) map_estructure -> VARIABLE . SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (97) map_assign -> VARIABLE . LBRACKET string_value RBRACKET ASSIGN string_value
    (18) variable_declaration -> VARIABLE . SHORTASSIGN value
    (28) value -> VARIABLE .
    (53) parameter -> VARIABLE . type
    (54) type -> . INT
    (55) type -> . INT32
    (56) type -> . INT64
    (57) type -> . STRING
    (58) type -> . FLOAT
    (59) type -> . FLOAT32
    (60) type -> . FLOAT64
    (61) type -> . BOOL

    SHORTASSIGN     shift and go to state 52
    LBRACKET        shift and go to state 53
    PLUS            reduce using rule 28 (value -> VARIABLE .)
    MINUS           reduce using rule 28 (value -> VARIABLE .)
    TIMES           reduce using rule 28 (value -> VARIABLE .)
    DIVIDE          reduce using rule 28 (value -> VARIABLE .)
    ASSIGN          reduce using rule 28 (value -> VARIABLE .)
    INCREMENT       reduce using rule 28 (value -> VARIABLE .)
    DECREMENT       reduce using rule 28 (value -> VARIABLE .)
    INT             shift and go to state 55
    INT32           shift and go to state 56
    INT64           shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 59
    FLOAT32         shift and go to state 60
    FLOAT64         shift and go to state 61
    BOOL            shift and go to state 62

    type                           shift and go to state 54

state 24

    (89) empty_list -> LBRACE . RBRACE
    (90) list_with_data -> LBRACE . values RBRACE
    (24) values -> . value
    (25) values -> . value COMMA values
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    RBRACE          shift and go to state 63
    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    values                         shift and go to state 64
    value                          shift and go to state 65
    number                         shift and go to state 32

state 25

    (80) for_estructure -> for_initialization .

    PRINT           reduce using rule 80 (for_estructure -> for_initialization .)
    INPUT           reduce using rule 80 (for_estructure -> for_initialization .)
    IF              reduce using rule 80 (for_estructure -> for_initialization .)
    VARIABLE        reduce using rule 80 (for_estructure -> for_initialization .)
    TYPE            reduce using rule 80 (for_estructure -> for_initialization .)
    FUNCTION        reduce using rule 80 (for_estructure -> for_initialization .)
    VAR             reduce using rule 80 (for_estructure -> for_initialization .)
    LBRACE          reduce using rule 80 (for_estructure -> for_initialization .)
    FOR             reduce using rule 80 (for_estructure -> for_initialization .)
    INT             reduce using rule 80 (for_estructure -> for_initialization .)
    FLOAT           reduce using rule 80 (for_estructure -> for_initialization .)
    $end            reduce using rule 80 (for_estructure -> for_initialization .)
    RBRACE          reduce using rule 80 (for_estructure -> for_initialization .)
    RETURN          reduce using rule 80 (for_estructure -> for_initialization .)


state 26

    (81) for_estructure -> for_infinite_bucle .

    PRINT           reduce using rule 81 (for_estructure -> for_infinite_bucle .)
    INPUT           reduce using rule 81 (for_estructure -> for_infinite_bucle .)
    IF              reduce using rule 81 (for_estructure -> for_infinite_bucle .)
    VARIABLE        reduce using rule 81 (for_estructure -> for_infinite_bucle .)
    TYPE            reduce using rule 81 (for_estructure -> for_infinite_bucle .)
    FUNCTION        reduce using rule 81 (for_estructure -> for_infinite_bucle .)
    VAR             reduce using rule 81 (for_estructure -> for_infinite_bucle .)
    LBRACE          reduce using rule 81 (for_estructure -> for_infinite_bucle .)
    FOR             reduce using rule 81 (for_estructure -> for_infinite_bucle .)
    INT             reduce using rule 81 (for_estructure -> for_infinite_bucle .)
    FLOAT           reduce using rule 81 (for_estructure -> for_infinite_bucle .)
    $end            reduce using rule 81 (for_estructure -> for_infinite_bucle .)
    RBRACE          reduce using rule 81 (for_estructure -> for_infinite_bucle .)
    RETURN          reduce using rule 81 (for_estructure -> for_infinite_bucle .)


state 27

    (82) for_estructure -> for_iterator .

    PRINT           reduce using rule 82 (for_estructure -> for_iterator .)
    INPUT           reduce using rule 82 (for_estructure -> for_iterator .)
    IF              reduce using rule 82 (for_estructure -> for_iterator .)
    VARIABLE        reduce using rule 82 (for_estructure -> for_iterator .)
    TYPE            reduce using rule 82 (for_estructure -> for_iterator .)
    FUNCTION        reduce using rule 82 (for_estructure -> for_iterator .)
    VAR             reduce using rule 82 (for_estructure -> for_iterator .)
    LBRACE          reduce using rule 82 (for_estructure -> for_iterator .)
    FOR             reduce using rule 82 (for_estructure -> for_iterator .)
    INT             reduce using rule 82 (for_estructure -> for_iterator .)
    FLOAT           reduce using rule 82 (for_estructure -> for_iterator .)
    $end            reduce using rule 82 (for_estructure -> for_iterator .)
    RBRACE          reduce using rule 82 (for_estructure -> for_iterator .)
    RETURN          reduce using rule 82 (for_estructure -> for_iterator .)


state 28

    (19) structure -> TYPE . VARIABLE STRUCT LBRACE statement RBRACE
    (91) defined_list -> TYPE . VARIABLE LBRACE values RBRACE

    VARIABLE        shift and go to state 66


state 29

    (20) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (22) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (23) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE blocks RBRACE

    VARIABLE        shift and go to state 67


state 30

    (50) parameters -> parameter .
    (51) parameters -> parameter . parameters
    (52) parameters -> parameter . COMMA parameters
    (50) parameters -> . parameter
    (51) parameters -> . parameter parameters
    (52) parameters -> . parameter COMMA parameters
    (53) parameter -> . VARIABLE type

  ! shift/reduce conflict for VARIABLE resolved as shift
    PRINT           reduce using rule 50 (parameters -> parameter .)
    INPUT           reduce using rule 50 (parameters -> parameter .)
    IF              reduce using rule 50 (parameters -> parameter .)
    TYPE            reduce using rule 50 (parameters -> parameter .)
    FUNCTION        reduce using rule 50 (parameters -> parameter .)
    VAR             reduce using rule 50 (parameters -> parameter .)
    LBRACE          reduce using rule 50 (parameters -> parameter .)
    FOR             reduce using rule 50 (parameters -> parameter .)
    INT             reduce using rule 50 (parameters -> parameter .)
    FLOAT           reduce using rule 50 (parameters -> parameter .)
    $end            reduce using rule 50 (parameters -> parameter .)
    RBRACE          reduce using rule 50 (parameters -> parameter .)
    RETURN          reduce using rule 50 (parameters -> parameter .)
    RPAREN          reduce using rule 50 (parameters -> parameter .)
    COMMA           shift and go to state 69
    VARIABLE        shift and go to state 70

  ! VARIABLE        [ reduce using rule 50 (parameters -> parameter .) ]

    parameter                      shift and go to state 30
    parameters                     shift and go to state 68

state 31

    (16) variable_declaration -> VAR . VARIABLE type
    (17) variable_declaration -> VAR . VARIABLE ASSIGN value

    VARIABLE        shift and go to state 71


state 32

    (29) value -> number .

    PLUS            reduce using rule 29 (value -> number .)
    MINUS           reduce using rule 29 (value -> number .)
    TIMES           reduce using rule 29 (value -> number .)
    DIVIDE          reduce using rule 29 (value -> number .)
    ASSIGN          reduce using rule 29 (value -> number .)
    INCREMENT       reduce using rule 29 (value -> number .)
    DECREMENT       reduce using rule 29 (value -> number .)
    GREATER         reduce using rule 29 (value -> number .)
    LESS            reduce using rule 29 (value -> number .)
    GREATEREQUALS   reduce using rule 29 (value -> number .)
    LESSEQUALS      reduce using rule 29 (value -> number .)
    EQUALS          reduce using rule 29 (value -> number .)
    DIFFERENT       reduce using rule 29 (value -> number .)
    COMMA           reduce using rule 29 (value -> number .)
    RBRACE          reduce using rule 29 (value -> number .)
    RPAREN          reduce using rule 29 (value -> number .)
    PRINT           reduce using rule 29 (value -> number .)
    INPUT           reduce using rule 29 (value -> number .)
    IF              reduce using rule 29 (value -> number .)
    VARIABLE        reduce using rule 29 (value -> number .)
    TYPE            reduce using rule 29 (value -> number .)
    FUNCTION        reduce using rule 29 (value -> number .)
    VAR             reduce using rule 29 (value -> number .)
    LBRACE          reduce using rule 29 (value -> number .)
    FOR             reduce using rule 29 (value -> number .)
    INT             reduce using rule 29 (value -> number .)
    FLOAT           reduce using rule 29 (value -> number .)
    $end            reduce using rule 29 (value -> number .)
    RETURN          reduce using rule 29 (value -> number .)
    RBRACKET        reduce using rule 29 (value -> number .)
    AND             reduce using rule 29 (value -> number .)
    OR              reduce using rule 29 (value -> number .)
    NOT             reduce using rule 29 (value -> number .)
    SEMICOLON       reduce using rule 29 (value -> number .)
    COLON           reduce using rule 29 (value -> number .)


state 33

    (83) for_initialization -> FOR . VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (84) for_infinite_bucle -> FOR . LBRACE statement RBRACE
    (85) for_iterator -> FOR . VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 72
    LBRACE          shift and go to state 73


state 34

    (30) number -> INT .

    PLUS            reduce using rule 30 (number -> INT .)
    MINUS           reduce using rule 30 (number -> INT .)
    TIMES           reduce using rule 30 (number -> INT .)
    DIVIDE          reduce using rule 30 (number -> INT .)
    ASSIGN          reduce using rule 30 (number -> INT .)
    INCREMENT       reduce using rule 30 (number -> INT .)
    DECREMENT       reduce using rule 30 (number -> INT .)
    GREATER         reduce using rule 30 (number -> INT .)
    LESS            reduce using rule 30 (number -> INT .)
    GREATEREQUALS   reduce using rule 30 (number -> INT .)
    LESSEQUALS      reduce using rule 30 (number -> INT .)
    EQUALS          reduce using rule 30 (number -> INT .)
    DIFFERENT       reduce using rule 30 (number -> INT .)
    COMMA           reduce using rule 30 (number -> INT .)
    RBRACE          reduce using rule 30 (number -> INT .)
    RPAREN          reduce using rule 30 (number -> INT .)
    PRINT           reduce using rule 30 (number -> INT .)
    INPUT           reduce using rule 30 (number -> INT .)
    IF              reduce using rule 30 (number -> INT .)
    VARIABLE        reduce using rule 30 (number -> INT .)
    TYPE            reduce using rule 30 (number -> INT .)
    FUNCTION        reduce using rule 30 (number -> INT .)
    VAR             reduce using rule 30 (number -> INT .)
    LBRACE          reduce using rule 30 (number -> INT .)
    FOR             reduce using rule 30 (number -> INT .)
    INT             reduce using rule 30 (number -> INT .)
    FLOAT           reduce using rule 30 (number -> INT .)
    $end            reduce using rule 30 (number -> INT .)
    RETURN          reduce using rule 30 (number -> INT .)
    RBRACKET        reduce using rule 30 (number -> INT .)
    AND             reduce using rule 30 (number -> INT .)
    OR              reduce using rule 30 (number -> INT .)
    NOT             reduce using rule 30 (number -> INT .)
    SEMICOLON       reduce using rule 30 (number -> INT .)
    COLON           reduce using rule 30 (number -> INT .)


state 35

    (31) number -> FLOAT .

    PLUS            reduce using rule 31 (number -> FLOAT .)
    MINUS           reduce using rule 31 (number -> FLOAT .)
    TIMES           reduce using rule 31 (number -> FLOAT .)
    DIVIDE          reduce using rule 31 (number -> FLOAT .)
    ASSIGN          reduce using rule 31 (number -> FLOAT .)
    INCREMENT       reduce using rule 31 (number -> FLOAT .)
    DECREMENT       reduce using rule 31 (number -> FLOAT .)
    GREATER         reduce using rule 31 (number -> FLOAT .)
    LESS            reduce using rule 31 (number -> FLOAT .)
    GREATEREQUALS   reduce using rule 31 (number -> FLOAT .)
    LESSEQUALS      reduce using rule 31 (number -> FLOAT .)
    EQUALS          reduce using rule 31 (number -> FLOAT .)
    DIFFERENT       reduce using rule 31 (number -> FLOAT .)
    COMMA           reduce using rule 31 (number -> FLOAT .)
    RBRACE          reduce using rule 31 (number -> FLOAT .)
    RPAREN          reduce using rule 31 (number -> FLOAT .)
    PRINT           reduce using rule 31 (number -> FLOAT .)
    INPUT           reduce using rule 31 (number -> FLOAT .)
    IF              reduce using rule 31 (number -> FLOAT .)
    VARIABLE        reduce using rule 31 (number -> FLOAT .)
    TYPE            reduce using rule 31 (number -> FLOAT .)
    FUNCTION        reduce using rule 31 (number -> FLOAT .)
    VAR             reduce using rule 31 (number -> FLOAT .)
    LBRACE          reduce using rule 31 (number -> FLOAT .)
    FOR             reduce using rule 31 (number -> FLOAT .)
    INT             reduce using rule 31 (number -> FLOAT .)
    FLOAT           reduce using rule 31 (number -> FLOAT .)
    $end            reduce using rule 31 (number -> FLOAT .)
    RETURN          reduce using rule 31 (number -> FLOAT .)
    RBRACKET        reduce using rule 31 (number -> FLOAT .)
    AND             reduce using rule 31 (number -> FLOAT .)
    OR              reduce using rule 31 (number -> FLOAT .)
    NOT             reduce using rule 31 (number -> FLOAT .)
    SEMICOLON       reduce using rule 31 (number -> FLOAT .)
    COLON           reduce using rule 31 (number -> FLOAT .)


state 36

    (3) blocks -> block blocks .

    $end            reduce using rule 3 (blocks -> block blocks .)
    RBRACE          reduce using rule 3 (blocks -> block blocks .)
    RETURN          reduce using rule 3 (blocks -> block blocks .)


state 37

    (32) print_statement -> PRINT LPAREN . values RPAREN
    (33) print_statement -> PRINT LPAREN . string_value RPAREN
    (34) print_statement -> PRINT LPAREN . FORMATSTRING COMMA values RPAREN
    (35) print_statement -> PRINT LPAREN . operation RPAREN
    (36) print_statement -> PRINT LPAREN . RPAREN
    (24) values -> . value
    (25) values -> . value COMMA values
    (26) string_value -> . value
    (27) string_value -> . CHARSTRING
    (40) operation -> . value operator value
    (41) operation -> . value operator operation
    (42) operation -> . value double_operator
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    FORMATSTRING    shift and go to state 77
    RPAREN          shift and go to state 75
    CHARSTRING      shift and go to state 80
    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    values                         shift and go to state 74
    string_value                   shift and go to state 76
    operation                      shift and go to state 78
    value                          shift and go to state 79
    number                         shift and go to state 32

state 38

    (37) input_statement -> INPUT LPAREN . values RPAREN
    (38) input_statement -> INPUT LPAREN . operation RPAREN
    (39) input_statement -> INPUT LPAREN . RPAREN
    (24) values -> . value
    (25) values -> . value COMMA values
    (40) operation -> . value operator value
    (41) operation -> . value operator operation
    (42) operation -> . value double_operator
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    RPAREN          shift and go to state 82
    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    values                         shift and go to state 81
    operation                      shift and go to state 83
    value                          shift and go to state 84
    number                         shift and go to state 32

state 39

    (62) conditional_structure -> IF conditions . conditional_body
    (63) conditional_structure -> IF conditions . conditional_body ELSE conditional_body
    (64) conditional_structure -> IF conditions . conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (65) conditional_body -> . LBRACE statement RBRACE
    (66) conditional_body -> . LBRACE BREAK RBRACE
    (67) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 86

    conditional_body               shift and go to state 85

state 40

    (68) conditions -> condition .
    (69) conditions -> condition . logical_operator conditions
    (71) logical_operator -> . AND
    (72) logical_operator -> . OR
    (73) logical_operator -> . NOT

    LBRACE          reduce using rule 68 (conditions -> condition .)
    AND             shift and go to state 88
    OR              shift and go to state 89
    NOT             shift and go to state 90

    logical_operator               shift and go to state 87

state 41

    (70) condition -> value . relational_operator value
    (74) relational_operator -> . GREATER
    (75) relational_operator -> . LESS
    (76) relational_operator -> . GREATEREQUALS
    (77) relational_operator -> . LESSEQUALS
    (78) relational_operator -> . EQUALS
    (79) relational_operator -> . DIFFERENT

    GREATER         shift and go to state 92
    LESS            shift and go to state 93
    GREATEREQUALS   shift and go to state 94
    LESSEQUALS      shift and go to state 95
    EQUALS          shift and go to state 96
    DIFFERENT       shift and go to state 97

    relational_operator            shift and go to state 91

state 42

    (28) value -> VARIABLE .

    GREATER         reduce using rule 28 (value -> VARIABLE .)
    LESS            reduce using rule 28 (value -> VARIABLE .)
    GREATEREQUALS   reduce using rule 28 (value -> VARIABLE .)
    LESSEQUALS      reduce using rule 28 (value -> VARIABLE .)
    EQUALS          reduce using rule 28 (value -> VARIABLE .)
    DIFFERENT       reduce using rule 28 (value -> VARIABLE .)
    COMMA           reduce using rule 28 (value -> VARIABLE .)
    RBRACE          reduce using rule 28 (value -> VARIABLE .)
    PLUS            reduce using rule 28 (value -> VARIABLE .)
    MINUS           reduce using rule 28 (value -> VARIABLE .)
    TIMES           reduce using rule 28 (value -> VARIABLE .)
    DIVIDE          reduce using rule 28 (value -> VARIABLE .)
    ASSIGN          reduce using rule 28 (value -> VARIABLE .)
    INCREMENT       reduce using rule 28 (value -> VARIABLE .)
    DECREMENT       reduce using rule 28 (value -> VARIABLE .)
    RPAREN          reduce using rule 28 (value -> VARIABLE .)
    PRINT           reduce using rule 28 (value -> VARIABLE .)
    INPUT           reduce using rule 28 (value -> VARIABLE .)
    IF              reduce using rule 28 (value -> VARIABLE .)
    VARIABLE        reduce using rule 28 (value -> VARIABLE .)
    TYPE            reduce using rule 28 (value -> VARIABLE .)
    FUNCTION        reduce using rule 28 (value -> VARIABLE .)
    VAR             reduce using rule 28 (value -> VARIABLE .)
    LBRACE          reduce using rule 28 (value -> VARIABLE .)
    FOR             reduce using rule 28 (value -> VARIABLE .)
    INT             reduce using rule 28 (value -> VARIABLE .)
    FLOAT           reduce using rule 28 (value -> VARIABLE .)
    $end            reduce using rule 28 (value -> VARIABLE .)
    RETURN          reduce using rule 28 (value -> VARIABLE .)
    RBRACKET        reduce using rule 28 (value -> VARIABLE .)
    AND             reduce using rule 28 (value -> VARIABLE .)
    OR              reduce using rule 28 (value -> VARIABLE .)
    NOT             reduce using rule 28 (value -> VARIABLE .)
    SEMICOLON       reduce using rule 28 (value -> VARIABLE .)
    COLON           reduce using rule 28 (value -> VARIABLE .)


state 43

    (40) operation -> value operator . value
    (41) operation -> value operator . operation
    (28) value -> . VARIABLE
    (29) value -> . number
    (40) operation -> . value operator value
    (41) operation -> . value operator operation
    (42) operation -> . value double_operator
    (30) number -> . INT
    (31) number -> . FLOAT

    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 98
    operation                      shift and go to state 99
    number                         shift and go to state 32

state 44

    (42) operation -> value double_operator .

    PRINT           reduce using rule 42 (operation -> value double_operator .)
    INPUT           reduce using rule 42 (operation -> value double_operator .)
    IF              reduce using rule 42 (operation -> value double_operator .)
    VARIABLE        reduce using rule 42 (operation -> value double_operator .)
    TYPE            reduce using rule 42 (operation -> value double_operator .)
    FUNCTION        reduce using rule 42 (operation -> value double_operator .)
    VAR             reduce using rule 42 (operation -> value double_operator .)
    LBRACE          reduce using rule 42 (operation -> value double_operator .)
    FOR             reduce using rule 42 (operation -> value double_operator .)
    INT             reduce using rule 42 (operation -> value double_operator .)
    FLOAT           reduce using rule 42 (operation -> value double_operator .)
    $end            reduce using rule 42 (operation -> value double_operator .)
    RBRACE          reduce using rule 42 (operation -> value double_operator .)
    RETURN          reduce using rule 42 (operation -> value double_operator .)
    RPAREN          reduce using rule 42 (operation -> value double_operator .)


state 45

    (43) operator -> PLUS .

    VARIABLE        reduce using rule 43 (operator -> PLUS .)
    INT             reduce using rule 43 (operator -> PLUS .)
    FLOAT           reduce using rule 43 (operator -> PLUS .)


state 46

    (44) operator -> MINUS .

    VARIABLE        reduce using rule 44 (operator -> MINUS .)
    INT             reduce using rule 44 (operator -> MINUS .)
    FLOAT           reduce using rule 44 (operator -> MINUS .)


state 47

    (45) operator -> TIMES .

    VARIABLE        reduce using rule 45 (operator -> TIMES .)
    INT             reduce using rule 45 (operator -> TIMES .)
    FLOAT           reduce using rule 45 (operator -> TIMES .)


state 48

    (46) operator -> DIVIDE .

    VARIABLE        reduce using rule 46 (operator -> DIVIDE .)
    INT             reduce using rule 46 (operator -> DIVIDE .)
    FLOAT           reduce using rule 46 (operator -> DIVIDE .)


state 49

    (47) operator -> ASSIGN .

    VARIABLE        reduce using rule 47 (operator -> ASSIGN .)
    INT             reduce using rule 47 (operator -> ASSIGN .)
    FLOAT           reduce using rule 47 (operator -> ASSIGN .)


state 50

    (48) double_operator -> INCREMENT .

    PRINT           reduce using rule 48 (double_operator -> INCREMENT .)
    INPUT           reduce using rule 48 (double_operator -> INCREMENT .)
    IF              reduce using rule 48 (double_operator -> INCREMENT .)
    VARIABLE        reduce using rule 48 (double_operator -> INCREMENT .)
    TYPE            reduce using rule 48 (double_operator -> INCREMENT .)
    FUNCTION        reduce using rule 48 (double_operator -> INCREMENT .)
    VAR             reduce using rule 48 (double_operator -> INCREMENT .)
    LBRACE          reduce using rule 48 (double_operator -> INCREMENT .)
    FOR             reduce using rule 48 (double_operator -> INCREMENT .)
    INT             reduce using rule 48 (double_operator -> INCREMENT .)
    FLOAT           reduce using rule 48 (double_operator -> INCREMENT .)
    $end            reduce using rule 48 (double_operator -> INCREMENT .)
    RBRACE          reduce using rule 48 (double_operator -> INCREMENT .)
    RETURN          reduce using rule 48 (double_operator -> INCREMENT .)
    RPAREN          reduce using rule 48 (double_operator -> INCREMENT .)


state 51

    (49) double_operator -> DECREMENT .

    PRINT           reduce using rule 49 (double_operator -> DECREMENT .)
    INPUT           reduce using rule 49 (double_operator -> DECREMENT .)
    IF              reduce using rule 49 (double_operator -> DECREMENT .)
    VARIABLE        reduce using rule 49 (double_operator -> DECREMENT .)
    TYPE            reduce using rule 49 (double_operator -> DECREMENT .)
    FUNCTION        reduce using rule 49 (double_operator -> DECREMENT .)
    VAR             reduce using rule 49 (double_operator -> DECREMENT .)
    LBRACE          reduce using rule 49 (double_operator -> DECREMENT .)
    FOR             reduce using rule 49 (double_operator -> DECREMENT .)
    INT             reduce using rule 49 (double_operator -> DECREMENT .)
    FLOAT           reduce using rule 49 (double_operator -> DECREMENT .)
    $end            reduce using rule 49 (double_operator -> DECREMENT .)
    RBRACE          reduce using rule 49 (double_operator -> DECREMENT .)
    RETURN          reduce using rule 49 (double_operator -> DECREMENT .)
    RPAREN          reduce using rule 49 (double_operator -> DECREMENT .)


state 52

    (92) map_estructure -> VARIABLE SHORTASSIGN . MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (93) map_estructure -> VARIABLE SHORTASSIGN . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (18) variable_declaration -> VARIABLE SHORTASSIGN . value
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    MAP             shift and go to state 100
    MAKE            shift and go to state 101
    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 102
    number                         shift and go to state 32

state 53

    (97) map_assign -> VARIABLE LBRACKET . string_value RBRACKET ASSIGN string_value
    (26) string_value -> . value
    (27) string_value -> . CHARSTRING
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    CHARSTRING      shift and go to state 80
    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    string_value                   shift and go to state 103
    value                          shift and go to state 104
    number                         shift and go to state 32

state 54

    (53) parameter -> VARIABLE type .

    COMMA           reduce using rule 53 (parameter -> VARIABLE type .)
    VARIABLE        reduce using rule 53 (parameter -> VARIABLE type .)
    PRINT           reduce using rule 53 (parameter -> VARIABLE type .)
    INPUT           reduce using rule 53 (parameter -> VARIABLE type .)
    IF              reduce using rule 53 (parameter -> VARIABLE type .)
    TYPE            reduce using rule 53 (parameter -> VARIABLE type .)
    FUNCTION        reduce using rule 53 (parameter -> VARIABLE type .)
    VAR             reduce using rule 53 (parameter -> VARIABLE type .)
    LBRACE          reduce using rule 53 (parameter -> VARIABLE type .)
    FOR             reduce using rule 53 (parameter -> VARIABLE type .)
    INT             reduce using rule 53 (parameter -> VARIABLE type .)
    FLOAT           reduce using rule 53 (parameter -> VARIABLE type .)
    $end            reduce using rule 53 (parameter -> VARIABLE type .)
    RBRACE          reduce using rule 53 (parameter -> VARIABLE type .)
    RETURN          reduce using rule 53 (parameter -> VARIABLE type .)
    RPAREN          reduce using rule 53 (parameter -> VARIABLE type .)


state 55

    (54) type -> INT .

    COMMA           reduce using rule 54 (type -> INT .)
    VARIABLE        reduce using rule 54 (type -> INT .)
    PRINT           reduce using rule 54 (type -> INT .)
    INPUT           reduce using rule 54 (type -> INT .)
    IF              reduce using rule 54 (type -> INT .)
    TYPE            reduce using rule 54 (type -> INT .)
    FUNCTION        reduce using rule 54 (type -> INT .)
    VAR             reduce using rule 54 (type -> INT .)
    LBRACE          reduce using rule 54 (type -> INT .)
    FOR             reduce using rule 54 (type -> INT .)
    INT             reduce using rule 54 (type -> INT .)
    FLOAT           reduce using rule 54 (type -> INT .)
    $end            reduce using rule 54 (type -> INT .)
    RBRACE          reduce using rule 54 (type -> INT .)
    RETURN          reduce using rule 54 (type -> INT .)
    RPAREN          reduce using rule 54 (type -> INT .)
    RBRACKET        reduce using rule 54 (type -> INT .)


state 56

    (55) type -> INT32 .

    COMMA           reduce using rule 55 (type -> INT32 .)
    VARIABLE        reduce using rule 55 (type -> INT32 .)
    PRINT           reduce using rule 55 (type -> INT32 .)
    INPUT           reduce using rule 55 (type -> INT32 .)
    IF              reduce using rule 55 (type -> INT32 .)
    TYPE            reduce using rule 55 (type -> INT32 .)
    FUNCTION        reduce using rule 55 (type -> INT32 .)
    VAR             reduce using rule 55 (type -> INT32 .)
    LBRACE          reduce using rule 55 (type -> INT32 .)
    FOR             reduce using rule 55 (type -> INT32 .)
    INT             reduce using rule 55 (type -> INT32 .)
    FLOAT           reduce using rule 55 (type -> INT32 .)
    $end            reduce using rule 55 (type -> INT32 .)
    RBRACE          reduce using rule 55 (type -> INT32 .)
    RETURN          reduce using rule 55 (type -> INT32 .)
    RPAREN          reduce using rule 55 (type -> INT32 .)
    RBRACKET        reduce using rule 55 (type -> INT32 .)


state 57

    (56) type -> INT64 .

    COMMA           reduce using rule 56 (type -> INT64 .)
    VARIABLE        reduce using rule 56 (type -> INT64 .)
    PRINT           reduce using rule 56 (type -> INT64 .)
    INPUT           reduce using rule 56 (type -> INT64 .)
    IF              reduce using rule 56 (type -> INT64 .)
    TYPE            reduce using rule 56 (type -> INT64 .)
    FUNCTION        reduce using rule 56 (type -> INT64 .)
    VAR             reduce using rule 56 (type -> INT64 .)
    LBRACE          reduce using rule 56 (type -> INT64 .)
    FOR             reduce using rule 56 (type -> INT64 .)
    INT             reduce using rule 56 (type -> INT64 .)
    FLOAT           reduce using rule 56 (type -> INT64 .)
    $end            reduce using rule 56 (type -> INT64 .)
    RBRACE          reduce using rule 56 (type -> INT64 .)
    RETURN          reduce using rule 56 (type -> INT64 .)
    RPAREN          reduce using rule 56 (type -> INT64 .)
    RBRACKET        reduce using rule 56 (type -> INT64 .)


state 58

    (57) type -> STRING .

    COMMA           reduce using rule 57 (type -> STRING .)
    VARIABLE        reduce using rule 57 (type -> STRING .)
    PRINT           reduce using rule 57 (type -> STRING .)
    INPUT           reduce using rule 57 (type -> STRING .)
    IF              reduce using rule 57 (type -> STRING .)
    TYPE            reduce using rule 57 (type -> STRING .)
    FUNCTION        reduce using rule 57 (type -> STRING .)
    VAR             reduce using rule 57 (type -> STRING .)
    LBRACE          reduce using rule 57 (type -> STRING .)
    FOR             reduce using rule 57 (type -> STRING .)
    INT             reduce using rule 57 (type -> STRING .)
    FLOAT           reduce using rule 57 (type -> STRING .)
    $end            reduce using rule 57 (type -> STRING .)
    RBRACE          reduce using rule 57 (type -> STRING .)
    RETURN          reduce using rule 57 (type -> STRING .)
    RPAREN          reduce using rule 57 (type -> STRING .)
    RBRACKET        reduce using rule 57 (type -> STRING .)


state 59

    (58) type -> FLOAT .

    COMMA           reduce using rule 58 (type -> FLOAT .)
    VARIABLE        reduce using rule 58 (type -> FLOAT .)
    PRINT           reduce using rule 58 (type -> FLOAT .)
    INPUT           reduce using rule 58 (type -> FLOAT .)
    IF              reduce using rule 58 (type -> FLOAT .)
    TYPE            reduce using rule 58 (type -> FLOAT .)
    FUNCTION        reduce using rule 58 (type -> FLOAT .)
    VAR             reduce using rule 58 (type -> FLOAT .)
    LBRACE          reduce using rule 58 (type -> FLOAT .)
    FOR             reduce using rule 58 (type -> FLOAT .)
    INT             reduce using rule 58 (type -> FLOAT .)
    FLOAT           reduce using rule 58 (type -> FLOAT .)
    $end            reduce using rule 58 (type -> FLOAT .)
    RBRACE          reduce using rule 58 (type -> FLOAT .)
    RETURN          reduce using rule 58 (type -> FLOAT .)
    RPAREN          reduce using rule 58 (type -> FLOAT .)
    RBRACKET        reduce using rule 58 (type -> FLOAT .)


state 60

    (59) type -> FLOAT32 .

    COMMA           reduce using rule 59 (type -> FLOAT32 .)
    VARIABLE        reduce using rule 59 (type -> FLOAT32 .)
    PRINT           reduce using rule 59 (type -> FLOAT32 .)
    INPUT           reduce using rule 59 (type -> FLOAT32 .)
    IF              reduce using rule 59 (type -> FLOAT32 .)
    TYPE            reduce using rule 59 (type -> FLOAT32 .)
    FUNCTION        reduce using rule 59 (type -> FLOAT32 .)
    VAR             reduce using rule 59 (type -> FLOAT32 .)
    LBRACE          reduce using rule 59 (type -> FLOAT32 .)
    FOR             reduce using rule 59 (type -> FLOAT32 .)
    INT             reduce using rule 59 (type -> FLOAT32 .)
    FLOAT           reduce using rule 59 (type -> FLOAT32 .)
    $end            reduce using rule 59 (type -> FLOAT32 .)
    RBRACE          reduce using rule 59 (type -> FLOAT32 .)
    RETURN          reduce using rule 59 (type -> FLOAT32 .)
    RPAREN          reduce using rule 59 (type -> FLOAT32 .)
    RBRACKET        reduce using rule 59 (type -> FLOAT32 .)


state 61

    (60) type -> FLOAT64 .

    COMMA           reduce using rule 60 (type -> FLOAT64 .)
    VARIABLE        reduce using rule 60 (type -> FLOAT64 .)
    PRINT           reduce using rule 60 (type -> FLOAT64 .)
    INPUT           reduce using rule 60 (type -> FLOAT64 .)
    IF              reduce using rule 60 (type -> FLOAT64 .)
    TYPE            reduce using rule 60 (type -> FLOAT64 .)
    FUNCTION        reduce using rule 60 (type -> FLOAT64 .)
    VAR             reduce using rule 60 (type -> FLOAT64 .)
    LBRACE          reduce using rule 60 (type -> FLOAT64 .)
    FOR             reduce using rule 60 (type -> FLOAT64 .)
    INT             reduce using rule 60 (type -> FLOAT64 .)
    FLOAT           reduce using rule 60 (type -> FLOAT64 .)
    $end            reduce using rule 60 (type -> FLOAT64 .)
    RBRACE          reduce using rule 60 (type -> FLOAT64 .)
    RETURN          reduce using rule 60 (type -> FLOAT64 .)
    RPAREN          reduce using rule 60 (type -> FLOAT64 .)
    RBRACKET        reduce using rule 60 (type -> FLOAT64 .)


state 62

    (61) type -> BOOL .

    COMMA           reduce using rule 61 (type -> BOOL .)
    VARIABLE        reduce using rule 61 (type -> BOOL .)
    PRINT           reduce using rule 61 (type -> BOOL .)
    INPUT           reduce using rule 61 (type -> BOOL .)
    IF              reduce using rule 61 (type -> BOOL .)
    TYPE            reduce using rule 61 (type -> BOOL .)
    FUNCTION        reduce using rule 61 (type -> BOOL .)
    VAR             reduce using rule 61 (type -> BOOL .)
    LBRACE          reduce using rule 61 (type -> BOOL .)
    FOR             reduce using rule 61 (type -> BOOL .)
    INT             reduce using rule 61 (type -> BOOL .)
    FLOAT           reduce using rule 61 (type -> BOOL .)
    $end            reduce using rule 61 (type -> BOOL .)
    RBRACE          reduce using rule 61 (type -> BOOL .)
    RETURN          reduce using rule 61 (type -> BOOL .)
    RPAREN          reduce using rule 61 (type -> BOOL .)
    RBRACKET        reduce using rule 61 (type -> BOOL .)


state 63

    (89) empty_list -> LBRACE RBRACE .

    PRINT           reduce using rule 89 (empty_list -> LBRACE RBRACE .)
    INPUT           reduce using rule 89 (empty_list -> LBRACE RBRACE .)
    IF              reduce using rule 89 (empty_list -> LBRACE RBRACE .)
    VARIABLE        reduce using rule 89 (empty_list -> LBRACE RBRACE .)
    TYPE            reduce using rule 89 (empty_list -> LBRACE RBRACE .)
    FUNCTION        reduce using rule 89 (empty_list -> LBRACE RBRACE .)
    VAR             reduce using rule 89 (empty_list -> LBRACE RBRACE .)
    LBRACE          reduce using rule 89 (empty_list -> LBRACE RBRACE .)
    FOR             reduce using rule 89 (empty_list -> LBRACE RBRACE .)
    INT             reduce using rule 89 (empty_list -> LBRACE RBRACE .)
    FLOAT           reduce using rule 89 (empty_list -> LBRACE RBRACE .)
    $end            reduce using rule 89 (empty_list -> LBRACE RBRACE .)
    RBRACE          reduce using rule 89 (empty_list -> LBRACE RBRACE .)
    RETURN          reduce using rule 89 (empty_list -> LBRACE RBRACE .)


state 64

    (90) list_with_data -> LBRACE values . RBRACE

    RBRACE          shift and go to state 105


state 65

    (24) values -> value .
    (25) values -> value . COMMA values

    RBRACE          reduce using rule 24 (values -> value .)
    RPAREN          reduce using rule 24 (values -> value .)
    COMMA           shift and go to state 106


state 66

    (19) structure -> TYPE VARIABLE . STRUCT LBRACE statement RBRACE
    (91) defined_list -> TYPE VARIABLE . LBRACE values RBRACE

    STRUCT          shift and go to state 107
    LBRACE          shift and go to state 108


state 67

    (20) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN LBRACE blocks RBRACE
    (22) function -> FUNCTION VARIABLE . LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (23) function -> FUNCTION VARIABLE . LPAREN RPAREN LBRACE blocks RBRACE

    LPAREN          shift and go to state 109


state 68

    (51) parameters -> parameter parameters .

    PRINT           reduce using rule 51 (parameters -> parameter parameters .)
    INPUT           reduce using rule 51 (parameters -> parameter parameters .)
    IF              reduce using rule 51 (parameters -> parameter parameters .)
    VARIABLE        reduce using rule 51 (parameters -> parameter parameters .)
    TYPE            reduce using rule 51 (parameters -> parameter parameters .)
    FUNCTION        reduce using rule 51 (parameters -> parameter parameters .)
    VAR             reduce using rule 51 (parameters -> parameter parameters .)
    LBRACE          reduce using rule 51 (parameters -> parameter parameters .)
    FOR             reduce using rule 51 (parameters -> parameter parameters .)
    INT             reduce using rule 51 (parameters -> parameter parameters .)
    FLOAT           reduce using rule 51 (parameters -> parameter parameters .)
    $end            reduce using rule 51 (parameters -> parameter parameters .)
    RBRACE          reduce using rule 51 (parameters -> parameter parameters .)
    RETURN          reduce using rule 51 (parameters -> parameter parameters .)
    RPAREN          reduce using rule 51 (parameters -> parameter parameters .)


state 69

    (52) parameters -> parameter COMMA . parameters
    (50) parameters -> . parameter
    (51) parameters -> . parameter parameters
    (52) parameters -> . parameter COMMA parameters
    (53) parameter -> . VARIABLE type

    VARIABLE        shift and go to state 70

    parameter                      shift and go to state 30
    parameters                     shift and go to state 110

state 70

    (53) parameter -> VARIABLE . type
    (54) type -> . INT
    (55) type -> . INT32
    (56) type -> . INT64
    (57) type -> . STRING
    (58) type -> . FLOAT
    (59) type -> . FLOAT32
    (60) type -> . FLOAT64
    (61) type -> . BOOL

    INT             shift and go to state 55
    INT32           shift and go to state 56
    INT64           shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 59
    FLOAT32         shift and go to state 60
    FLOAT64         shift and go to state 61
    BOOL            shift and go to state 62

    type                           shift and go to state 54

state 71

    (16) variable_declaration -> VAR VARIABLE . type
    (17) variable_declaration -> VAR VARIABLE . ASSIGN value
    (54) type -> . INT
    (55) type -> . INT32
    (56) type -> . INT64
    (57) type -> . STRING
    (58) type -> . FLOAT
    (59) type -> . FLOAT32
    (60) type -> . FLOAT64
    (61) type -> . BOOL

    ASSIGN          shift and go to state 112
    INT             shift and go to state 55
    INT32           shift and go to state 56
    INT64           shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 59
    FLOAT32         shift and go to state 60
    FLOAT64         shift and go to state 61
    BOOL            shift and go to state 62

    type                           shift and go to state 111

state 72

    (83) for_initialization -> FOR VARIABLE . SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (85) for_iterator -> FOR VARIABLE . SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 113
    SEMICOLON       shift and go to state 114


state 73

    (84) for_infinite_bucle -> FOR LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (32) print_statement -> . PRINT LPAREN values RPAREN
    (33) print_statement -> . PRINT LPAREN string_value RPAREN
    (34) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (35) print_statement -> . PRINT LPAREN operation RPAREN
    (36) print_statement -> . PRINT LPAREN RPAREN
    (37) input_statement -> . INPUT LPAREN values RPAREN
    (38) input_statement -> . INPUT LPAREN operation RPAREN
    (39) input_statement -> . INPUT LPAREN RPAREN
    (62) conditional_structure -> . IF conditions conditional_body
    (63) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (64) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (40) operation -> . value operator value
    (41) operation -> . value operator operation
    (42) operation -> . value double_operator
    (86) list_structure -> . empty_list
    (87) list_structure -> . list_with_data
    (88) list_structure -> . defined_list
    (92) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (93) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (97) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (80) for_estructure -> . for_initialization
    (81) for_estructure -> . for_infinite_bucle
    (82) for_estructure -> . for_iterator
    (19) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (50) parameters -> . parameter
    (51) parameters -> . parameter parameters
    (52) parameters -> . parameter COMMA parameters
    (16) variable_declaration -> . VAR VARIABLE type
    (17) variable_declaration -> . VAR VARIABLE ASSIGN value
    (18) variable_declaration -> . VARIABLE SHORTASSIGN value
    (28) value -> . VARIABLE
    (29) value -> . number
    (89) empty_list -> . LBRACE RBRACE
    (90) list_with_data -> . LBRACE values RBRACE
    (91) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (83) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (84) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (85) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (53) parameter -> . VARIABLE type
    (30) number -> . INT
    (31) number -> . FLOAT

    PRINT           shift and go to state 16
    INPUT           shift and go to state 17
    IF              shift and go to state 18
    VARIABLE        shift and go to state 23
    TYPE            shift and go to state 28
    FUNCTION        shift and go to state 29
    VAR             shift and go to state 31
    LBRACE          shift and go to state 24
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    statement                      shift and go to state 115
    blocks                         shift and go to state 2
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    value                          shift and go to state 19
    empty_list                     shift and go to state 20
    list_with_data                 shift and go to state 21
    defined_list                   shift and go to state 22
    for_initialization             shift and go to state 25
    for_infinite_bucle             shift and go to state 26
    for_iterator                   shift and go to state 27
    parameter                      shift and go to state 30
    number                         shift and go to state 32

state 74

    (32) print_statement -> PRINT LPAREN values . RPAREN

    RPAREN          shift and go to state 116


state 75

    (36) print_statement -> PRINT LPAREN RPAREN .

    PRINT           reduce using rule 36 (print_statement -> PRINT LPAREN RPAREN .)
    INPUT           reduce using rule 36 (print_statement -> PRINT LPAREN RPAREN .)
    IF              reduce using rule 36 (print_statement -> PRINT LPAREN RPAREN .)
    VARIABLE        reduce using rule 36 (print_statement -> PRINT LPAREN RPAREN .)
    TYPE            reduce using rule 36 (print_statement -> PRINT LPAREN RPAREN .)
    FUNCTION        reduce using rule 36 (print_statement -> PRINT LPAREN RPAREN .)
    VAR             reduce using rule 36 (print_statement -> PRINT LPAREN RPAREN .)
    LBRACE          reduce using rule 36 (print_statement -> PRINT LPAREN RPAREN .)
    FOR             reduce using rule 36 (print_statement -> PRINT LPAREN RPAREN .)
    INT             reduce using rule 36 (print_statement -> PRINT LPAREN RPAREN .)
    FLOAT           reduce using rule 36 (print_statement -> PRINT LPAREN RPAREN .)
    $end            reduce using rule 36 (print_statement -> PRINT LPAREN RPAREN .)
    RBRACE          reduce using rule 36 (print_statement -> PRINT LPAREN RPAREN .)
    RETURN          reduce using rule 36 (print_statement -> PRINT LPAREN RPAREN .)


state 76

    (33) print_statement -> PRINT LPAREN string_value . RPAREN

    RPAREN          shift and go to state 117


state 77

    (34) print_statement -> PRINT LPAREN FORMATSTRING . COMMA values RPAREN

    COMMA           shift and go to state 118


state 78

    (35) print_statement -> PRINT LPAREN operation . RPAREN

    RPAREN          shift and go to state 119


state 79

    (24) values -> value .
    (25) values -> value . COMMA values
    (26) string_value -> value .
    (40) operation -> value . operator value
    (41) operation -> value . operator operation
    (42) operation -> value . double_operator
    (43) operator -> . PLUS
    (44) operator -> . MINUS
    (45) operator -> . TIMES
    (46) operator -> . DIVIDE
    (47) operator -> . ASSIGN
    (48) double_operator -> . INCREMENT
    (49) double_operator -> . DECREMENT

  ! reduce/reduce conflict for RPAREN resolved using rule 24 (values -> value .)
    RPAREN          reduce using rule 24 (values -> value .)
    COMMA           shift and go to state 106
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    TIMES           shift and go to state 47
    DIVIDE          shift and go to state 48
    ASSIGN          shift and go to state 49
    INCREMENT       shift and go to state 50
    DECREMENT       shift and go to state 51

  ! RPAREN          [ reduce using rule 26 (string_value -> value .) ]

    operator                       shift and go to state 43
    double_operator                shift and go to state 44

state 80

    (27) string_value -> CHARSTRING .

    RPAREN          reduce using rule 27 (string_value -> CHARSTRING .)
    RBRACKET        reduce using rule 27 (string_value -> CHARSTRING .)
    PRINT           reduce using rule 27 (string_value -> CHARSTRING .)
    INPUT           reduce using rule 27 (string_value -> CHARSTRING .)
    IF              reduce using rule 27 (string_value -> CHARSTRING .)
    VARIABLE        reduce using rule 27 (string_value -> CHARSTRING .)
    TYPE            reduce using rule 27 (string_value -> CHARSTRING .)
    FUNCTION        reduce using rule 27 (string_value -> CHARSTRING .)
    VAR             reduce using rule 27 (string_value -> CHARSTRING .)
    LBRACE          reduce using rule 27 (string_value -> CHARSTRING .)
    FOR             reduce using rule 27 (string_value -> CHARSTRING .)
    INT             reduce using rule 27 (string_value -> CHARSTRING .)
    FLOAT           reduce using rule 27 (string_value -> CHARSTRING .)
    $end            reduce using rule 27 (string_value -> CHARSTRING .)
    RBRACE          reduce using rule 27 (string_value -> CHARSTRING .)
    RETURN          reduce using rule 27 (string_value -> CHARSTRING .)
    COLON           reduce using rule 27 (string_value -> CHARSTRING .)
    COMMA           reduce using rule 27 (string_value -> CHARSTRING .)


state 81

    (37) input_statement -> INPUT LPAREN values . RPAREN

    RPAREN          shift and go to state 120


state 82

    (39) input_statement -> INPUT LPAREN RPAREN .

    PRINT           reduce using rule 39 (input_statement -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 39 (input_statement -> INPUT LPAREN RPAREN .)
    IF              reduce using rule 39 (input_statement -> INPUT LPAREN RPAREN .)
    VARIABLE        reduce using rule 39 (input_statement -> INPUT LPAREN RPAREN .)
    TYPE            reduce using rule 39 (input_statement -> INPUT LPAREN RPAREN .)
    FUNCTION        reduce using rule 39 (input_statement -> INPUT LPAREN RPAREN .)
    VAR             reduce using rule 39 (input_statement -> INPUT LPAREN RPAREN .)
    LBRACE          reduce using rule 39 (input_statement -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 39 (input_statement -> INPUT LPAREN RPAREN .)
    INT             reduce using rule 39 (input_statement -> INPUT LPAREN RPAREN .)
    FLOAT           reduce using rule 39 (input_statement -> INPUT LPAREN RPAREN .)
    $end            reduce using rule 39 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 39 (input_statement -> INPUT LPAREN RPAREN .)
    RETURN          reduce using rule 39 (input_statement -> INPUT LPAREN RPAREN .)


state 83

    (38) input_statement -> INPUT LPAREN operation . RPAREN

    RPAREN          shift and go to state 121


state 84

    (24) values -> value .
    (25) values -> value . COMMA values
    (40) operation -> value . operator value
    (41) operation -> value . operator operation
    (42) operation -> value . double_operator
    (43) operator -> . PLUS
    (44) operator -> . MINUS
    (45) operator -> . TIMES
    (46) operator -> . DIVIDE
    (47) operator -> . ASSIGN
    (48) double_operator -> . INCREMENT
    (49) double_operator -> . DECREMENT

    RPAREN          reduce using rule 24 (values -> value .)
    COMMA           shift and go to state 106
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    TIMES           shift and go to state 47
    DIVIDE          shift and go to state 48
    ASSIGN          shift and go to state 49
    INCREMENT       shift and go to state 50
    DECREMENT       shift and go to state 51

    operator                       shift and go to state 43
    double_operator                shift and go to state 44

state 85

    (62) conditional_structure -> IF conditions conditional_body .
    (63) conditional_structure -> IF conditions conditional_body . ELSE conditional_body
    (64) conditional_structure -> IF conditions conditional_body . ELSE IF conditions conditional_body ELSE conditional_body

    PRINT           reduce using rule 62 (conditional_structure -> IF conditions conditional_body .)
    INPUT           reduce using rule 62 (conditional_structure -> IF conditions conditional_body .)
    IF              reduce using rule 62 (conditional_structure -> IF conditions conditional_body .)
    VARIABLE        reduce using rule 62 (conditional_structure -> IF conditions conditional_body .)
    TYPE            reduce using rule 62 (conditional_structure -> IF conditions conditional_body .)
    FUNCTION        reduce using rule 62 (conditional_structure -> IF conditions conditional_body .)
    VAR             reduce using rule 62 (conditional_structure -> IF conditions conditional_body .)
    LBRACE          reduce using rule 62 (conditional_structure -> IF conditions conditional_body .)
    FOR             reduce using rule 62 (conditional_structure -> IF conditions conditional_body .)
    INT             reduce using rule 62 (conditional_structure -> IF conditions conditional_body .)
    FLOAT           reduce using rule 62 (conditional_structure -> IF conditions conditional_body .)
    $end            reduce using rule 62 (conditional_structure -> IF conditions conditional_body .)
    RBRACE          reduce using rule 62 (conditional_structure -> IF conditions conditional_body .)
    RETURN          reduce using rule 62 (conditional_structure -> IF conditions conditional_body .)
    ELSE            shift and go to state 122


state 86

    (65) conditional_body -> LBRACE . statement RBRACE
    (66) conditional_body -> LBRACE . BREAK RBRACE
    (67) conditional_body -> LBRACE . CONTINUE RBRACE
    (1) statement -> . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (32) print_statement -> . PRINT LPAREN values RPAREN
    (33) print_statement -> . PRINT LPAREN string_value RPAREN
    (34) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (35) print_statement -> . PRINT LPAREN operation RPAREN
    (36) print_statement -> . PRINT LPAREN RPAREN
    (37) input_statement -> . INPUT LPAREN values RPAREN
    (38) input_statement -> . INPUT LPAREN operation RPAREN
    (39) input_statement -> . INPUT LPAREN RPAREN
    (62) conditional_structure -> . IF conditions conditional_body
    (63) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (64) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (40) operation -> . value operator value
    (41) operation -> . value operator operation
    (42) operation -> . value double_operator
    (86) list_structure -> . empty_list
    (87) list_structure -> . list_with_data
    (88) list_structure -> . defined_list
    (92) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (93) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (97) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (80) for_estructure -> . for_initialization
    (81) for_estructure -> . for_infinite_bucle
    (82) for_estructure -> . for_iterator
    (19) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (50) parameters -> . parameter
    (51) parameters -> . parameter parameters
    (52) parameters -> . parameter COMMA parameters
    (16) variable_declaration -> . VAR VARIABLE type
    (17) variable_declaration -> . VAR VARIABLE ASSIGN value
    (18) variable_declaration -> . VARIABLE SHORTASSIGN value
    (28) value -> . VARIABLE
    (29) value -> . number
    (89) empty_list -> . LBRACE RBRACE
    (90) list_with_data -> . LBRACE values RBRACE
    (91) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (83) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (84) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (85) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (53) parameter -> . VARIABLE type
    (30) number -> . INT
    (31) number -> . FLOAT

    BREAK           shift and go to state 124
    CONTINUE        shift and go to state 125
    PRINT           shift and go to state 16
    INPUT           shift and go to state 17
    IF              shift and go to state 18
    VARIABLE        shift and go to state 23
    TYPE            shift and go to state 28
    FUNCTION        shift and go to state 29
    VAR             shift and go to state 31
    LBRACE          shift and go to state 24
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    statement                      shift and go to state 123
    blocks                         shift and go to state 2
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    value                          shift and go to state 19
    empty_list                     shift and go to state 20
    list_with_data                 shift and go to state 21
    defined_list                   shift and go to state 22
    for_initialization             shift and go to state 25
    for_infinite_bucle             shift and go to state 26
    for_iterator                   shift and go to state 27
    parameter                      shift and go to state 30
    number                         shift and go to state 32

state 87

    (69) conditions -> condition logical_operator . conditions
    (68) conditions -> . condition
    (69) conditions -> . condition logical_operator conditions
    (70) condition -> . value relational_operator value
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    condition                      shift and go to state 40
    conditions                     shift and go to state 126
    value                          shift and go to state 41
    number                         shift and go to state 32

state 88

    (71) logical_operator -> AND .

    VARIABLE        reduce using rule 71 (logical_operator -> AND .)
    INT             reduce using rule 71 (logical_operator -> AND .)
    FLOAT           reduce using rule 71 (logical_operator -> AND .)


state 89

    (72) logical_operator -> OR .

    VARIABLE        reduce using rule 72 (logical_operator -> OR .)
    INT             reduce using rule 72 (logical_operator -> OR .)
    FLOAT           reduce using rule 72 (logical_operator -> OR .)


state 90

    (73) logical_operator -> NOT .

    VARIABLE        reduce using rule 73 (logical_operator -> NOT .)
    INT             reduce using rule 73 (logical_operator -> NOT .)
    FLOAT           reduce using rule 73 (logical_operator -> NOT .)


state 91

    (70) condition -> value relational_operator . value
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 127
    number                         shift and go to state 32

state 92

    (74) relational_operator -> GREATER .

    VARIABLE        reduce using rule 74 (relational_operator -> GREATER .)
    INT             reduce using rule 74 (relational_operator -> GREATER .)
    FLOAT           reduce using rule 74 (relational_operator -> GREATER .)


state 93

    (75) relational_operator -> LESS .

    VARIABLE        reduce using rule 75 (relational_operator -> LESS .)
    INT             reduce using rule 75 (relational_operator -> LESS .)
    FLOAT           reduce using rule 75 (relational_operator -> LESS .)


state 94

    (76) relational_operator -> GREATEREQUALS .

    VARIABLE        reduce using rule 76 (relational_operator -> GREATEREQUALS .)
    INT             reduce using rule 76 (relational_operator -> GREATEREQUALS .)
    FLOAT           reduce using rule 76 (relational_operator -> GREATEREQUALS .)


state 95

    (77) relational_operator -> LESSEQUALS .

    VARIABLE        reduce using rule 77 (relational_operator -> LESSEQUALS .)
    INT             reduce using rule 77 (relational_operator -> LESSEQUALS .)
    FLOAT           reduce using rule 77 (relational_operator -> LESSEQUALS .)


state 96

    (78) relational_operator -> EQUALS .

    VARIABLE        reduce using rule 78 (relational_operator -> EQUALS .)
    INT             reduce using rule 78 (relational_operator -> EQUALS .)
    FLOAT           reduce using rule 78 (relational_operator -> EQUALS .)


state 97

    (79) relational_operator -> DIFFERENT .

    VARIABLE        reduce using rule 79 (relational_operator -> DIFFERENT .)
    INT             reduce using rule 79 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 79 (relational_operator -> DIFFERENT .)


state 98

    (40) operation -> value operator value .
    (40) operation -> value . operator value
    (41) operation -> value . operator operation
    (42) operation -> value . double_operator
    (43) operator -> . PLUS
    (44) operator -> . MINUS
    (45) operator -> . TIMES
    (46) operator -> . DIVIDE
    (47) operator -> . ASSIGN
    (48) double_operator -> . INCREMENT
    (49) double_operator -> . DECREMENT

    PRINT           reduce using rule 40 (operation -> value operator value .)
    INPUT           reduce using rule 40 (operation -> value operator value .)
    IF              reduce using rule 40 (operation -> value operator value .)
    VARIABLE        reduce using rule 40 (operation -> value operator value .)
    TYPE            reduce using rule 40 (operation -> value operator value .)
    FUNCTION        reduce using rule 40 (operation -> value operator value .)
    VAR             reduce using rule 40 (operation -> value operator value .)
    LBRACE          reduce using rule 40 (operation -> value operator value .)
    FOR             reduce using rule 40 (operation -> value operator value .)
    INT             reduce using rule 40 (operation -> value operator value .)
    FLOAT           reduce using rule 40 (operation -> value operator value .)
    $end            reduce using rule 40 (operation -> value operator value .)
    RBRACE          reduce using rule 40 (operation -> value operator value .)
    RETURN          reduce using rule 40 (operation -> value operator value .)
    RPAREN          reduce using rule 40 (operation -> value operator value .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    TIMES           shift and go to state 47
    DIVIDE          shift and go to state 48
    ASSIGN          shift and go to state 49
    INCREMENT       shift and go to state 50
    DECREMENT       shift and go to state 51

    operator                       shift and go to state 43
    double_operator                shift and go to state 44

state 99

    (41) operation -> value operator operation .

    PRINT           reduce using rule 41 (operation -> value operator operation .)
    INPUT           reduce using rule 41 (operation -> value operator operation .)
    IF              reduce using rule 41 (operation -> value operator operation .)
    VARIABLE        reduce using rule 41 (operation -> value operator operation .)
    TYPE            reduce using rule 41 (operation -> value operator operation .)
    FUNCTION        reduce using rule 41 (operation -> value operator operation .)
    VAR             reduce using rule 41 (operation -> value operator operation .)
    LBRACE          reduce using rule 41 (operation -> value operator operation .)
    FOR             reduce using rule 41 (operation -> value operator operation .)
    INT             reduce using rule 41 (operation -> value operator operation .)
    FLOAT           reduce using rule 41 (operation -> value operator operation .)
    $end            reduce using rule 41 (operation -> value operator operation .)
    RBRACE          reduce using rule 41 (operation -> value operator operation .)
    RETURN          reduce using rule 41 (operation -> value operator operation .)
    RPAREN          reduce using rule 41 (operation -> value operator operation .)


state 100

    (92) map_estructure -> VARIABLE SHORTASSIGN MAP . LBRACKET type RBRACKET type LBRACE map_values RBRACE

    LBRACKET        shift and go to state 128


state 101

    (93) map_estructure -> VARIABLE SHORTASSIGN MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN

    LPAREN          shift and go to state 129


state 102

    (18) variable_declaration -> VARIABLE SHORTASSIGN value .

    PRINT           reduce using rule 18 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INPUT           reduce using rule 18 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    IF              reduce using rule 18 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VARIABLE        reduce using rule 18 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    TYPE            reduce using rule 18 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FUNCTION        reduce using rule 18 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VAR             reduce using rule 18 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    LBRACE          reduce using rule 18 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FOR             reduce using rule 18 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INT             reduce using rule 18 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FLOAT           reduce using rule 18 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    $end            reduce using rule 18 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    RBRACE          reduce using rule 18 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    RETURN          reduce using rule 18 (variable_declaration -> VARIABLE SHORTASSIGN value .)


state 103

    (97) map_assign -> VARIABLE LBRACKET string_value . RBRACKET ASSIGN string_value

    RBRACKET        shift and go to state 130


state 104

    (26) string_value -> value .

    RBRACKET        reduce using rule 26 (string_value -> value .)
    PRINT           reduce using rule 26 (string_value -> value .)
    INPUT           reduce using rule 26 (string_value -> value .)
    IF              reduce using rule 26 (string_value -> value .)
    VARIABLE        reduce using rule 26 (string_value -> value .)
    TYPE            reduce using rule 26 (string_value -> value .)
    FUNCTION        reduce using rule 26 (string_value -> value .)
    VAR             reduce using rule 26 (string_value -> value .)
    LBRACE          reduce using rule 26 (string_value -> value .)
    FOR             reduce using rule 26 (string_value -> value .)
    INT             reduce using rule 26 (string_value -> value .)
    FLOAT           reduce using rule 26 (string_value -> value .)
    $end            reduce using rule 26 (string_value -> value .)
    RBRACE          reduce using rule 26 (string_value -> value .)
    RETURN          reduce using rule 26 (string_value -> value .)
    COLON           reduce using rule 26 (string_value -> value .)
    COMMA           reduce using rule 26 (string_value -> value .)


state 105

    (90) list_with_data -> LBRACE values RBRACE .

    PRINT           reduce using rule 90 (list_with_data -> LBRACE values RBRACE .)
    INPUT           reduce using rule 90 (list_with_data -> LBRACE values RBRACE .)
    IF              reduce using rule 90 (list_with_data -> LBRACE values RBRACE .)
    VARIABLE        reduce using rule 90 (list_with_data -> LBRACE values RBRACE .)
    TYPE            reduce using rule 90 (list_with_data -> LBRACE values RBRACE .)
    FUNCTION        reduce using rule 90 (list_with_data -> LBRACE values RBRACE .)
    VAR             reduce using rule 90 (list_with_data -> LBRACE values RBRACE .)
    LBRACE          reduce using rule 90 (list_with_data -> LBRACE values RBRACE .)
    FOR             reduce using rule 90 (list_with_data -> LBRACE values RBRACE .)
    INT             reduce using rule 90 (list_with_data -> LBRACE values RBRACE .)
    FLOAT           reduce using rule 90 (list_with_data -> LBRACE values RBRACE .)
    $end            reduce using rule 90 (list_with_data -> LBRACE values RBRACE .)
    RBRACE          reduce using rule 90 (list_with_data -> LBRACE values RBRACE .)
    RETURN          reduce using rule 90 (list_with_data -> LBRACE values RBRACE .)


state 106

    (25) values -> value COMMA . values
    (24) values -> . value
    (25) values -> . value COMMA values
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 65
    values                         shift and go to state 131
    number                         shift and go to state 32

state 107

    (19) structure -> TYPE VARIABLE STRUCT . LBRACE statement RBRACE

    LBRACE          shift and go to state 132


state 108

    (91) defined_list -> TYPE VARIABLE LBRACE . values RBRACE
    (24) values -> . value
    (25) values -> . value COMMA values
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    values                         shift and go to state 133
    value                          shift and go to state 65
    number                         shift and go to state 32

state 109

    (20) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN LBRACE blocks RBRACE
    (22) function -> FUNCTION VARIABLE LPAREN . RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (23) function -> FUNCTION VARIABLE LPAREN . RPAREN LBRACE blocks RBRACE
    (50) parameters -> . parameter
    (51) parameters -> . parameter parameters
    (52) parameters -> . parameter COMMA parameters
    (53) parameter -> . VARIABLE type

    RPAREN          shift and go to state 135
    VARIABLE        shift and go to state 70

    parameters                     shift and go to state 134
    parameter                      shift and go to state 30

state 110

    (52) parameters -> parameter COMMA parameters .

    PRINT           reduce using rule 52 (parameters -> parameter COMMA parameters .)
    INPUT           reduce using rule 52 (parameters -> parameter COMMA parameters .)
    IF              reduce using rule 52 (parameters -> parameter COMMA parameters .)
    VARIABLE        reduce using rule 52 (parameters -> parameter COMMA parameters .)
    TYPE            reduce using rule 52 (parameters -> parameter COMMA parameters .)
    FUNCTION        reduce using rule 52 (parameters -> parameter COMMA parameters .)
    VAR             reduce using rule 52 (parameters -> parameter COMMA parameters .)
    LBRACE          reduce using rule 52 (parameters -> parameter COMMA parameters .)
    FOR             reduce using rule 52 (parameters -> parameter COMMA parameters .)
    INT             reduce using rule 52 (parameters -> parameter COMMA parameters .)
    FLOAT           reduce using rule 52 (parameters -> parameter COMMA parameters .)
    $end            reduce using rule 52 (parameters -> parameter COMMA parameters .)
    RBRACE          reduce using rule 52 (parameters -> parameter COMMA parameters .)
    RETURN          reduce using rule 52 (parameters -> parameter COMMA parameters .)
    RPAREN          reduce using rule 52 (parameters -> parameter COMMA parameters .)


state 111

    (16) variable_declaration -> VAR VARIABLE type .

    PRINT           reduce using rule 16 (variable_declaration -> VAR VARIABLE type .)
    INPUT           reduce using rule 16 (variable_declaration -> VAR VARIABLE type .)
    IF              reduce using rule 16 (variable_declaration -> VAR VARIABLE type .)
    VARIABLE        reduce using rule 16 (variable_declaration -> VAR VARIABLE type .)
    TYPE            reduce using rule 16 (variable_declaration -> VAR VARIABLE type .)
    FUNCTION        reduce using rule 16 (variable_declaration -> VAR VARIABLE type .)
    VAR             reduce using rule 16 (variable_declaration -> VAR VARIABLE type .)
    LBRACE          reduce using rule 16 (variable_declaration -> VAR VARIABLE type .)
    FOR             reduce using rule 16 (variable_declaration -> VAR VARIABLE type .)
    INT             reduce using rule 16 (variable_declaration -> VAR VARIABLE type .)
    FLOAT           reduce using rule 16 (variable_declaration -> VAR VARIABLE type .)
    $end            reduce using rule 16 (variable_declaration -> VAR VARIABLE type .)
    RBRACE          reduce using rule 16 (variable_declaration -> VAR VARIABLE type .)
    RETURN          reduce using rule 16 (variable_declaration -> VAR VARIABLE type .)


state 112

    (17) variable_declaration -> VAR VARIABLE ASSIGN . value
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 136
    number                         shift and go to state 32

state 113

    (83) for_initialization -> FOR VARIABLE SHORTASSIGN . value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 137
    number                         shift and go to state 32

state 114

    (85) for_iterator -> FOR VARIABLE SEMICOLON . VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 138


state 115

    (84) for_infinite_bucle -> FOR LBRACE statement . RBRACE

    RBRACE          shift and go to state 139


state 116

    (32) print_statement -> PRINT LPAREN values RPAREN .

    PRINT           reduce using rule 32 (print_statement -> PRINT LPAREN values RPAREN .)
    INPUT           reduce using rule 32 (print_statement -> PRINT LPAREN values RPAREN .)
    IF              reduce using rule 32 (print_statement -> PRINT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 32 (print_statement -> PRINT LPAREN values RPAREN .)
    TYPE            reduce using rule 32 (print_statement -> PRINT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 32 (print_statement -> PRINT LPAREN values RPAREN .)
    VAR             reduce using rule 32 (print_statement -> PRINT LPAREN values RPAREN .)
    LBRACE          reduce using rule 32 (print_statement -> PRINT LPAREN values RPAREN .)
    FOR             reduce using rule 32 (print_statement -> PRINT LPAREN values RPAREN .)
    INT             reduce using rule 32 (print_statement -> PRINT LPAREN values RPAREN .)
    FLOAT           reduce using rule 32 (print_statement -> PRINT LPAREN values RPAREN .)
    $end            reduce using rule 32 (print_statement -> PRINT LPAREN values RPAREN .)
    RBRACE          reduce using rule 32 (print_statement -> PRINT LPAREN values RPAREN .)
    RETURN          reduce using rule 32 (print_statement -> PRINT LPAREN values RPAREN .)


state 117

    (33) print_statement -> PRINT LPAREN string_value RPAREN .

    PRINT           reduce using rule 33 (print_statement -> PRINT LPAREN string_value RPAREN .)
    INPUT           reduce using rule 33 (print_statement -> PRINT LPAREN string_value RPAREN .)
    IF              reduce using rule 33 (print_statement -> PRINT LPAREN string_value RPAREN .)
    VARIABLE        reduce using rule 33 (print_statement -> PRINT LPAREN string_value RPAREN .)
    TYPE            reduce using rule 33 (print_statement -> PRINT LPAREN string_value RPAREN .)
    FUNCTION        reduce using rule 33 (print_statement -> PRINT LPAREN string_value RPAREN .)
    VAR             reduce using rule 33 (print_statement -> PRINT LPAREN string_value RPAREN .)
    LBRACE          reduce using rule 33 (print_statement -> PRINT LPAREN string_value RPAREN .)
    FOR             reduce using rule 33 (print_statement -> PRINT LPAREN string_value RPAREN .)
    INT             reduce using rule 33 (print_statement -> PRINT LPAREN string_value RPAREN .)
    FLOAT           reduce using rule 33 (print_statement -> PRINT LPAREN string_value RPAREN .)
    $end            reduce using rule 33 (print_statement -> PRINT LPAREN string_value RPAREN .)
    RBRACE          reduce using rule 33 (print_statement -> PRINT LPAREN string_value RPAREN .)
    RETURN          reduce using rule 33 (print_statement -> PRINT LPAREN string_value RPAREN .)


state 118

    (34) print_statement -> PRINT LPAREN FORMATSTRING COMMA . values RPAREN
    (24) values -> . value
    (25) values -> . value COMMA values
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    values                         shift and go to state 140
    value                          shift and go to state 65
    number                         shift and go to state 32

state 119

    (35) print_statement -> PRINT LPAREN operation RPAREN .

    PRINT           reduce using rule 35 (print_statement -> PRINT LPAREN operation RPAREN .)
    INPUT           reduce using rule 35 (print_statement -> PRINT LPAREN operation RPAREN .)
    IF              reduce using rule 35 (print_statement -> PRINT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 35 (print_statement -> PRINT LPAREN operation RPAREN .)
    TYPE            reduce using rule 35 (print_statement -> PRINT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 35 (print_statement -> PRINT LPAREN operation RPAREN .)
    VAR             reduce using rule 35 (print_statement -> PRINT LPAREN operation RPAREN .)
    LBRACE          reduce using rule 35 (print_statement -> PRINT LPAREN operation RPAREN .)
    FOR             reduce using rule 35 (print_statement -> PRINT LPAREN operation RPAREN .)
    INT             reduce using rule 35 (print_statement -> PRINT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 35 (print_statement -> PRINT LPAREN operation RPAREN .)
    $end            reduce using rule 35 (print_statement -> PRINT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 35 (print_statement -> PRINT LPAREN operation RPAREN .)
    RETURN          reduce using rule 35 (print_statement -> PRINT LPAREN operation RPAREN .)


state 120

    (37) input_statement -> INPUT LPAREN values RPAREN .

    PRINT           reduce using rule 37 (input_statement -> INPUT LPAREN values RPAREN .)
    INPUT           reduce using rule 37 (input_statement -> INPUT LPAREN values RPAREN .)
    IF              reduce using rule 37 (input_statement -> INPUT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 37 (input_statement -> INPUT LPAREN values RPAREN .)
    TYPE            reduce using rule 37 (input_statement -> INPUT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 37 (input_statement -> INPUT LPAREN values RPAREN .)
    VAR             reduce using rule 37 (input_statement -> INPUT LPAREN values RPAREN .)
    LBRACE          reduce using rule 37 (input_statement -> INPUT LPAREN values RPAREN .)
    FOR             reduce using rule 37 (input_statement -> INPUT LPAREN values RPAREN .)
    INT             reduce using rule 37 (input_statement -> INPUT LPAREN values RPAREN .)
    FLOAT           reduce using rule 37 (input_statement -> INPUT LPAREN values RPAREN .)
    $end            reduce using rule 37 (input_statement -> INPUT LPAREN values RPAREN .)
    RBRACE          reduce using rule 37 (input_statement -> INPUT LPAREN values RPAREN .)
    RETURN          reduce using rule 37 (input_statement -> INPUT LPAREN values RPAREN .)


state 121

    (38) input_statement -> INPUT LPAREN operation RPAREN .

    PRINT           reduce using rule 38 (input_statement -> INPUT LPAREN operation RPAREN .)
    INPUT           reduce using rule 38 (input_statement -> INPUT LPAREN operation RPAREN .)
    IF              reduce using rule 38 (input_statement -> INPUT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 38 (input_statement -> INPUT LPAREN operation RPAREN .)
    TYPE            reduce using rule 38 (input_statement -> INPUT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 38 (input_statement -> INPUT LPAREN operation RPAREN .)
    VAR             reduce using rule 38 (input_statement -> INPUT LPAREN operation RPAREN .)
    LBRACE          reduce using rule 38 (input_statement -> INPUT LPAREN operation RPAREN .)
    FOR             reduce using rule 38 (input_statement -> INPUT LPAREN operation RPAREN .)
    INT             reduce using rule 38 (input_statement -> INPUT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 38 (input_statement -> INPUT LPAREN operation RPAREN .)
    $end            reduce using rule 38 (input_statement -> INPUT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 38 (input_statement -> INPUT LPAREN operation RPAREN .)
    RETURN          reduce using rule 38 (input_statement -> INPUT LPAREN operation RPAREN .)


state 122

    (63) conditional_structure -> IF conditions conditional_body ELSE . conditional_body
    (64) conditional_structure -> IF conditions conditional_body ELSE . IF conditions conditional_body ELSE conditional_body
    (65) conditional_body -> . LBRACE statement RBRACE
    (66) conditional_body -> . LBRACE BREAK RBRACE
    (67) conditional_body -> . LBRACE CONTINUE RBRACE

    IF              shift and go to state 141
    LBRACE          shift and go to state 86

    conditional_body               shift and go to state 142

state 123

    (65) conditional_body -> LBRACE statement . RBRACE

    RBRACE          shift and go to state 143


state 124

    (66) conditional_body -> LBRACE BREAK . RBRACE

    RBRACE          shift and go to state 144


state 125

    (67) conditional_body -> LBRACE CONTINUE . RBRACE

    RBRACE          shift and go to state 145


state 126

    (69) conditions -> condition logical_operator conditions .

    LBRACE          reduce using rule 69 (conditions -> condition logical_operator conditions .)


state 127

    (70) condition -> value relational_operator value .

    AND             reduce using rule 70 (condition -> value relational_operator value .)
    OR              reduce using rule 70 (condition -> value relational_operator value .)
    NOT             reduce using rule 70 (condition -> value relational_operator value .)
    LBRACE          reduce using rule 70 (condition -> value relational_operator value .)
    SEMICOLON       reduce using rule 70 (condition -> value relational_operator value .)


state 128

    (92) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET . type RBRACKET type LBRACE map_values RBRACE
    (54) type -> . INT
    (55) type -> . INT32
    (56) type -> . INT64
    (57) type -> . STRING
    (58) type -> . FLOAT
    (59) type -> . FLOAT32
    (60) type -> . FLOAT64
    (61) type -> . BOOL

    INT             shift and go to state 55
    INT32           shift and go to state 56
    INT64           shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 59
    FLOAT32         shift and go to state 60
    FLOAT64         shift and go to state 61
    BOOL            shift and go to state 62

    type                           shift and go to state 146

state 129

    (93) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN

    MAP             shift and go to state 147


state 130

    (97) map_assign -> VARIABLE LBRACKET string_value RBRACKET . ASSIGN string_value

    ASSIGN          shift and go to state 148


state 131

    (25) values -> value COMMA values .

    RBRACE          reduce using rule 25 (values -> value COMMA values .)
    RPAREN          reduce using rule 25 (values -> value COMMA values .)


state 132

    (19) structure -> TYPE VARIABLE STRUCT LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (32) print_statement -> . PRINT LPAREN values RPAREN
    (33) print_statement -> . PRINT LPAREN string_value RPAREN
    (34) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (35) print_statement -> . PRINT LPAREN operation RPAREN
    (36) print_statement -> . PRINT LPAREN RPAREN
    (37) input_statement -> . INPUT LPAREN values RPAREN
    (38) input_statement -> . INPUT LPAREN operation RPAREN
    (39) input_statement -> . INPUT LPAREN RPAREN
    (62) conditional_structure -> . IF conditions conditional_body
    (63) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (64) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (40) operation -> . value operator value
    (41) operation -> . value operator operation
    (42) operation -> . value double_operator
    (86) list_structure -> . empty_list
    (87) list_structure -> . list_with_data
    (88) list_structure -> . defined_list
    (92) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (93) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (97) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (80) for_estructure -> . for_initialization
    (81) for_estructure -> . for_infinite_bucle
    (82) for_estructure -> . for_iterator
    (19) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (50) parameters -> . parameter
    (51) parameters -> . parameter parameters
    (52) parameters -> . parameter COMMA parameters
    (16) variable_declaration -> . VAR VARIABLE type
    (17) variable_declaration -> . VAR VARIABLE ASSIGN value
    (18) variable_declaration -> . VARIABLE SHORTASSIGN value
    (28) value -> . VARIABLE
    (29) value -> . number
    (89) empty_list -> . LBRACE RBRACE
    (90) list_with_data -> . LBRACE values RBRACE
    (91) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (83) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (84) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (85) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (53) parameter -> . VARIABLE type
    (30) number -> . INT
    (31) number -> . FLOAT

    PRINT           shift and go to state 16
    INPUT           shift and go to state 17
    IF              shift and go to state 18
    VARIABLE        shift and go to state 23
    TYPE            shift and go to state 28
    FUNCTION        shift and go to state 29
    VAR             shift and go to state 31
    LBRACE          shift and go to state 24
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    statement                      shift and go to state 149
    blocks                         shift and go to state 2
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    value                          shift and go to state 19
    empty_list                     shift and go to state 20
    list_with_data                 shift and go to state 21
    defined_list                   shift and go to state 22
    for_initialization             shift and go to state 25
    for_infinite_bucle             shift and go to state 26
    for_iterator                   shift and go to state 27
    parameter                      shift and go to state 30
    number                         shift and go to state 32

state 133

    (91) defined_list -> TYPE VARIABLE LBRACE values . RBRACE

    RBRACE          shift and go to state 150


state 134

    (20) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN LBRACE blocks RBRACE

    RPAREN          shift and go to state 151


state 135

    (22) function -> FUNCTION VARIABLE LPAREN RPAREN . type LBRACE blocks RETURN VARIABLE RBRACE
    (23) function -> FUNCTION VARIABLE LPAREN RPAREN . LBRACE blocks RBRACE
    (54) type -> . INT
    (55) type -> . INT32
    (56) type -> . INT64
    (57) type -> . STRING
    (58) type -> . FLOAT
    (59) type -> . FLOAT32
    (60) type -> . FLOAT64
    (61) type -> . BOOL

    LBRACE          shift and go to state 153
    INT             shift and go to state 55
    INT32           shift and go to state 56
    INT64           shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 59
    FLOAT32         shift and go to state 60
    FLOAT64         shift and go to state 61
    BOOL            shift and go to state 62

    type                           shift and go to state 152

state 136

    (17) variable_declaration -> VAR VARIABLE ASSIGN value .

    PRINT           reduce using rule 17 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    INPUT           reduce using rule 17 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    IF              reduce using rule 17 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    VARIABLE        reduce using rule 17 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    TYPE            reduce using rule 17 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    FUNCTION        reduce using rule 17 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    VAR             reduce using rule 17 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    LBRACE          reduce using rule 17 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    FOR             reduce using rule 17 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    INT             reduce using rule 17 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    FLOAT           reduce using rule 17 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    $end            reduce using rule 17 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    RBRACE          reduce using rule 17 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    RETURN          reduce using rule 17 (variable_declaration -> VAR VARIABLE ASSIGN value .)


state 137

    (83) for_initialization -> FOR VARIABLE SHORTASSIGN value . SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 154


state 138

    (85) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE . SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 155


state 139

    (84) for_infinite_bucle -> FOR LBRACE statement RBRACE .

    PRINT           reduce using rule 84 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INPUT           reduce using rule 84 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    IF              reduce using rule 84 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 84 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    TYPE            reduce using rule 84 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 84 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VAR             reduce using rule 84 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    LBRACE          reduce using rule 84 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FOR             reduce using rule 84 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INT             reduce using rule 84 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FLOAT           reduce using rule 84 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    $end            reduce using rule 84 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RBRACE          reduce using rule 84 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RETURN          reduce using rule 84 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)


state 140

    (34) print_statement -> PRINT LPAREN FORMATSTRING COMMA values . RPAREN

    RPAREN          shift and go to state 156


state 141

    (64) conditional_structure -> IF conditions conditional_body ELSE IF . conditions conditional_body ELSE conditional_body
    (68) conditions -> . condition
    (69) conditions -> . condition logical_operator conditions
    (70) condition -> . value relational_operator value
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    conditions                     shift and go to state 157
    condition                      shift and go to state 40
    value                          shift and go to state 41
    number                         shift and go to state 32

state 142

    (63) conditional_structure -> IF conditions conditional_body ELSE conditional_body .

    PRINT           reduce using rule 63 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 63 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 63 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 63 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 63 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 63 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 63 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    LBRACE          reduce using rule 63 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 63 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 63 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 63 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 63 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 63 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RETURN          reduce using rule 63 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)


state 143

    (65) conditional_body -> LBRACE statement RBRACE .

    ELSE            reduce using rule 65 (conditional_body -> LBRACE statement RBRACE .)
    PRINT           reduce using rule 65 (conditional_body -> LBRACE statement RBRACE .)
    INPUT           reduce using rule 65 (conditional_body -> LBRACE statement RBRACE .)
    IF              reduce using rule 65 (conditional_body -> LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 65 (conditional_body -> LBRACE statement RBRACE .)
    TYPE            reduce using rule 65 (conditional_body -> LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 65 (conditional_body -> LBRACE statement RBRACE .)
    VAR             reduce using rule 65 (conditional_body -> LBRACE statement RBRACE .)
    LBRACE          reduce using rule 65 (conditional_body -> LBRACE statement RBRACE .)
    FOR             reduce using rule 65 (conditional_body -> LBRACE statement RBRACE .)
    INT             reduce using rule 65 (conditional_body -> LBRACE statement RBRACE .)
    FLOAT           reduce using rule 65 (conditional_body -> LBRACE statement RBRACE .)
    $end            reduce using rule 65 (conditional_body -> LBRACE statement RBRACE .)
    RBRACE          reduce using rule 65 (conditional_body -> LBRACE statement RBRACE .)
    RETURN          reduce using rule 65 (conditional_body -> LBRACE statement RBRACE .)


state 144

    (66) conditional_body -> LBRACE BREAK RBRACE .

    ELSE            reduce using rule 66 (conditional_body -> LBRACE BREAK RBRACE .)
    PRINT           reduce using rule 66 (conditional_body -> LBRACE BREAK RBRACE .)
    INPUT           reduce using rule 66 (conditional_body -> LBRACE BREAK RBRACE .)
    IF              reduce using rule 66 (conditional_body -> LBRACE BREAK RBRACE .)
    VARIABLE        reduce using rule 66 (conditional_body -> LBRACE BREAK RBRACE .)
    TYPE            reduce using rule 66 (conditional_body -> LBRACE BREAK RBRACE .)
    FUNCTION        reduce using rule 66 (conditional_body -> LBRACE BREAK RBRACE .)
    VAR             reduce using rule 66 (conditional_body -> LBRACE BREAK RBRACE .)
    LBRACE          reduce using rule 66 (conditional_body -> LBRACE BREAK RBRACE .)
    FOR             reduce using rule 66 (conditional_body -> LBRACE BREAK RBRACE .)
    INT             reduce using rule 66 (conditional_body -> LBRACE BREAK RBRACE .)
    FLOAT           reduce using rule 66 (conditional_body -> LBRACE BREAK RBRACE .)
    $end            reduce using rule 66 (conditional_body -> LBRACE BREAK RBRACE .)
    RBRACE          reduce using rule 66 (conditional_body -> LBRACE BREAK RBRACE .)
    RETURN          reduce using rule 66 (conditional_body -> LBRACE BREAK RBRACE .)


state 145

    (67) conditional_body -> LBRACE CONTINUE RBRACE .

    ELSE            reduce using rule 67 (conditional_body -> LBRACE CONTINUE RBRACE .)
    PRINT           reduce using rule 67 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INPUT           reduce using rule 67 (conditional_body -> LBRACE CONTINUE RBRACE .)
    IF              reduce using rule 67 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VARIABLE        reduce using rule 67 (conditional_body -> LBRACE CONTINUE RBRACE .)
    TYPE            reduce using rule 67 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FUNCTION        reduce using rule 67 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VAR             reduce using rule 67 (conditional_body -> LBRACE CONTINUE RBRACE .)
    LBRACE          reduce using rule 67 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FOR             reduce using rule 67 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INT             reduce using rule 67 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FLOAT           reduce using rule 67 (conditional_body -> LBRACE CONTINUE RBRACE .)
    $end            reduce using rule 67 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RBRACE          reduce using rule 67 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RETURN          reduce using rule 67 (conditional_body -> LBRACE CONTINUE RBRACE .)


state 146

    (92) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type . RBRACKET type LBRACE map_values RBRACE

    RBRACKET        shift and go to state 158


state 147

    (93) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN

    LBRACKET        shift and go to state 159


state 148

    (97) map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN . string_value
    (26) string_value -> . value
    (27) string_value -> . CHARSTRING
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    CHARSTRING      shift and go to state 80
    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    string_value                   shift and go to state 160
    value                          shift and go to state 104
    number                         shift and go to state 32

state 149

    (19) structure -> TYPE VARIABLE STRUCT LBRACE statement . RBRACE

    RBRACE          shift and go to state 161


state 150

    (91) defined_list -> TYPE VARIABLE LBRACE values RBRACE .

    PRINT           reduce using rule 91 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    INPUT           reduce using rule 91 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    IF              reduce using rule 91 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    VARIABLE        reduce using rule 91 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    TYPE            reduce using rule 91 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    FUNCTION        reduce using rule 91 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    VAR             reduce using rule 91 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    LBRACE          reduce using rule 91 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    FOR             reduce using rule 91 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    INT             reduce using rule 91 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    FLOAT           reduce using rule 91 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    $end            reduce using rule 91 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    RBRACE          reduce using rule 91 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    RETURN          reduce using rule 91 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)


state 151

    (20) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . LBRACE blocks RBRACE
    (54) type -> . INT
    (55) type -> . INT32
    (56) type -> . INT64
    (57) type -> . STRING
    (58) type -> . FLOAT
    (59) type -> . FLOAT32
    (60) type -> . FLOAT64
    (61) type -> . BOOL

    LBRACE          shift and go to state 163
    INT             shift and go to state 55
    INT32           shift and go to state 56
    INT64           shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 59
    FLOAT32         shift and go to state 60
    FLOAT64         shift and go to state 61
    BOOL            shift and go to state 62

    type                           shift and go to state 162

state 152

    (22) function -> FUNCTION VARIABLE LPAREN RPAREN type . LBRACE blocks RETURN VARIABLE RBRACE

    LBRACE          shift and go to state 164


state 153

    (23) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE . blocks RBRACE
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (32) print_statement -> . PRINT LPAREN values RPAREN
    (33) print_statement -> . PRINT LPAREN string_value RPAREN
    (34) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (35) print_statement -> . PRINT LPAREN operation RPAREN
    (36) print_statement -> . PRINT LPAREN RPAREN
    (37) input_statement -> . INPUT LPAREN values RPAREN
    (38) input_statement -> . INPUT LPAREN operation RPAREN
    (39) input_statement -> . INPUT LPAREN RPAREN
    (62) conditional_structure -> . IF conditions conditional_body
    (63) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (64) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (40) operation -> . value operator value
    (41) operation -> . value operator operation
    (42) operation -> . value double_operator
    (86) list_structure -> . empty_list
    (87) list_structure -> . list_with_data
    (88) list_structure -> . defined_list
    (92) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (93) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (97) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (80) for_estructure -> . for_initialization
    (81) for_estructure -> . for_infinite_bucle
    (82) for_estructure -> . for_iterator
    (19) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (50) parameters -> . parameter
    (51) parameters -> . parameter parameters
    (52) parameters -> . parameter COMMA parameters
    (16) variable_declaration -> . VAR VARIABLE type
    (17) variable_declaration -> . VAR VARIABLE ASSIGN value
    (18) variable_declaration -> . VARIABLE SHORTASSIGN value
    (28) value -> . VARIABLE
    (29) value -> . number
    (89) empty_list -> . LBRACE RBRACE
    (90) list_with_data -> . LBRACE values RBRACE
    (91) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (83) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (84) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (85) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (53) parameter -> . VARIABLE type
    (30) number -> . INT
    (31) number -> . FLOAT

    PRINT           shift and go to state 16
    INPUT           shift and go to state 17
    IF              shift and go to state 18
    VARIABLE        shift and go to state 23
    TYPE            shift and go to state 28
    FUNCTION        shift and go to state 29
    VAR             shift and go to state 31
    LBRACE          shift and go to state 24
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    blocks                         shift and go to state 165
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    value                          shift and go to state 19
    empty_list                     shift and go to state 20
    list_with_data                 shift and go to state 21
    defined_list                   shift and go to state 22
    for_initialization             shift and go to state 25
    for_infinite_bucle             shift and go to state 26
    for_iterator                   shift and go to state 27
    parameter                      shift and go to state 30
    number                         shift and go to state 32

state 154

    (83) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON . condition SEMICOLON value double_operator LBRACE statement RBRACE
    (70) condition -> . value relational_operator value
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 41
    condition                      shift and go to state 166
    number                         shift and go to state 32

state 155

    (85) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN . RANGE VARIABLE LBRACE statement RBRACE

    RANGE           shift and go to state 167


state 156

    (34) print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .

    PRINT           reduce using rule 34 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    INPUT           reduce using rule 34 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    IF              reduce using rule 34 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    VARIABLE        reduce using rule 34 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    TYPE            reduce using rule 34 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    FUNCTION        reduce using rule 34 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    VAR             reduce using rule 34 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    LBRACE          reduce using rule 34 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    FOR             reduce using rule 34 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    INT             reduce using rule 34 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    FLOAT           reduce using rule 34 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    $end            reduce using rule 34 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    RBRACE          reduce using rule 34 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    RETURN          reduce using rule 34 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)


state 157

    (64) conditional_structure -> IF conditions conditional_body ELSE IF conditions . conditional_body ELSE conditional_body
    (65) conditional_body -> . LBRACE statement RBRACE
    (66) conditional_body -> . LBRACE BREAK RBRACE
    (67) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 86

    conditional_body               shift and go to state 168

state 158

    (92) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET . type LBRACE map_values RBRACE
    (54) type -> . INT
    (55) type -> . INT32
    (56) type -> . INT64
    (57) type -> . STRING
    (58) type -> . FLOAT
    (59) type -> . FLOAT32
    (60) type -> . FLOAT64
    (61) type -> . BOOL

    INT             shift and go to state 55
    INT32           shift and go to state 56
    INT64           shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 59
    FLOAT32         shift and go to state 60
    FLOAT64         shift and go to state 61
    BOOL            shift and go to state 62

    type                           shift and go to state 169

state 159

    (93) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (54) type -> . INT
    (55) type -> . INT32
    (56) type -> . INT64
    (57) type -> . STRING
    (58) type -> . FLOAT
    (59) type -> . FLOAT32
    (60) type -> . FLOAT64
    (61) type -> . BOOL

    INT             shift and go to state 55
    INT32           shift and go to state 56
    INT64           shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 59
    FLOAT32         shift and go to state 60
    FLOAT64         shift and go to state 61
    BOOL            shift and go to state 62

    type                           shift and go to state 170

state 160

    (97) map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .

    PRINT           reduce using rule 97 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    INPUT           reduce using rule 97 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    IF              reduce using rule 97 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    VARIABLE        reduce using rule 97 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    TYPE            reduce using rule 97 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    FUNCTION        reduce using rule 97 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    VAR             reduce using rule 97 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    LBRACE          reduce using rule 97 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    FOR             reduce using rule 97 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    INT             reduce using rule 97 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    FLOAT           reduce using rule 97 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    $end            reduce using rule 97 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    RBRACE          reduce using rule 97 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    RETURN          reduce using rule 97 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)


state 161

    (19) structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .

    PRINT           reduce using rule 19 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    INPUT           reduce using rule 19 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    IF              reduce using rule 19 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 19 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    TYPE            reduce using rule 19 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 19 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    VAR             reduce using rule 19 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    LBRACE          reduce using rule 19 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    FOR             reduce using rule 19 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    INT             reduce using rule 19 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    FLOAT           reduce using rule 19 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    $end            reduce using rule 19 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    RBRACE          reduce using rule 19 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    RETURN          reduce using rule 19 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)


state 162

    (20) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type . LBRACE blocks RETURN VARIABLE RBRACE

    LBRACE          shift and go to state 171


state 163

    (21) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE . blocks RBRACE
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (32) print_statement -> . PRINT LPAREN values RPAREN
    (33) print_statement -> . PRINT LPAREN string_value RPAREN
    (34) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (35) print_statement -> . PRINT LPAREN operation RPAREN
    (36) print_statement -> . PRINT LPAREN RPAREN
    (37) input_statement -> . INPUT LPAREN values RPAREN
    (38) input_statement -> . INPUT LPAREN operation RPAREN
    (39) input_statement -> . INPUT LPAREN RPAREN
    (62) conditional_structure -> . IF conditions conditional_body
    (63) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (64) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (40) operation -> . value operator value
    (41) operation -> . value operator operation
    (42) operation -> . value double_operator
    (86) list_structure -> . empty_list
    (87) list_structure -> . list_with_data
    (88) list_structure -> . defined_list
    (92) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (93) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (97) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (80) for_estructure -> . for_initialization
    (81) for_estructure -> . for_infinite_bucle
    (82) for_estructure -> . for_iterator
    (19) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (50) parameters -> . parameter
    (51) parameters -> . parameter parameters
    (52) parameters -> . parameter COMMA parameters
    (16) variable_declaration -> . VAR VARIABLE type
    (17) variable_declaration -> . VAR VARIABLE ASSIGN value
    (18) variable_declaration -> . VARIABLE SHORTASSIGN value
    (28) value -> . VARIABLE
    (29) value -> . number
    (89) empty_list -> . LBRACE RBRACE
    (90) list_with_data -> . LBRACE values RBRACE
    (91) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (83) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (84) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (85) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (53) parameter -> . VARIABLE type
    (30) number -> . INT
    (31) number -> . FLOAT

    PRINT           shift and go to state 16
    INPUT           shift and go to state 17
    IF              shift and go to state 18
    VARIABLE        shift and go to state 23
    TYPE            shift and go to state 28
    FUNCTION        shift and go to state 29
    VAR             shift and go to state 31
    LBRACE          shift and go to state 24
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    parameters                     shift and go to state 14
    blocks                         shift and go to state 172
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    variable_declaration           shift and go to state 15
    value                          shift and go to state 19
    empty_list                     shift and go to state 20
    list_with_data                 shift and go to state 21
    defined_list                   shift and go to state 22
    for_initialization             shift and go to state 25
    for_infinite_bucle             shift and go to state 26
    for_iterator                   shift and go to state 27
    parameter                      shift and go to state 30
    number                         shift and go to state 32

state 164

    (22) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE . blocks RETURN VARIABLE RBRACE
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (32) print_statement -> . PRINT LPAREN values RPAREN
    (33) print_statement -> . PRINT LPAREN string_value RPAREN
    (34) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (35) print_statement -> . PRINT LPAREN operation RPAREN
    (36) print_statement -> . PRINT LPAREN RPAREN
    (37) input_statement -> . INPUT LPAREN values RPAREN
    (38) input_statement -> . INPUT LPAREN operation RPAREN
    (39) input_statement -> . INPUT LPAREN RPAREN
    (62) conditional_structure -> . IF conditions conditional_body
    (63) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (64) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (40) operation -> . value operator value
    (41) operation -> . value operator operation
    (42) operation -> . value double_operator
    (86) list_structure -> . empty_list
    (87) list_structure -> . list_with_data
    (88) list_structure -> . defined_list
    (92) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (93) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (97) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (80) for_estructure -> . for_initialization
    (81) for_estructure -> . for_infinite_bucle
    (82) for_estructure -> . for_iterator
    (19) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (50) parameters -> . parameter
    (51) parameters -> . parameter parameters
    (52) parameters -> . parameter COMMA parameters
    (16) variable_declaration -> . VAR VARIABLE type
    (17) variable_declaration -> . VAR VARIABLE ASSIGN value
    (18) variable_declaration -> . VARIABLE SHORTASSIGN value
    (28) value -> . VARIABLE
    (29) value -> . number
    (89) empty_list -> . LBRACE RBRACE
    (90) list_with_data -> . LBRACE values RBRACE
    (91) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (83) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (84) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (85) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (53) parameter -> . VARIABLE type
    (30) number -> . INT
    (31) number -> . FLOAT

    PRINT           shift and go to state 16
    INPUT           shift and go to state 17
    IF              shift and go to state 18
    VARIABLE        shift and go to state 23
    TYPE            shift and go to state 28
    FUNCTION        shift and go to state 29
    VAR             shift and go to state 31
    LBRACE          shift and go to state 24
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    blocks                         shift and go to state 173
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    value                          shift and go to state 19
    empty_list                     shift and go to state 20
    list_with_data                 shift and go to state 21
    defined_list                   shift and go to state 22
    for_initialization             shift and go to state 25
    for_infinite_bucle             shift and go to state 26
    for_iterator                   shift and go to state 27
    parameter                      shift and go to state 30
    number                         shift and go to state 32

state 165

    (23) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 174


state 166

    (83) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition . SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 175


state 167

    (85) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE . VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 176


state 168

    (64) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body . ELSE conditional_body

    ELSE            shift and go to state 177


state 169

    (92) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type . LBRACE map_values RBRACE

    LBRACE          shift and go to state 178


state 170

    (93) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN

    RBRACKET        shift and go to state 179


state 171

    (20) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE . blocks RETURN VARIABLE RBRACE
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (32) print_statement -> . PRINT LPAREN values RPAREN
    (33) print_statement -> . PRINT LPAREN string_value RPAREN
    (34) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (35) print_statement -> . PRINT LPAREN operation RPAREN
    (36) print_statement -> . PRINT LPAREN RPAREN
    (37) input_statement -> . INPUT LPAREN values RPAREN
    (38) input_statement -> . INPUT LPAREN operation RPAREN
    (39) input_statement -> . INPUT LPAREN RPAREN
    (62) conditional_structure -> . IF conditions conditional_body
    (63) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (64) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (40) operation -> . value operator value
    (41) operation -> . value operator operation
    (42) operation -> . value double_operator
    (86) list_structure -> . empty_list
    (87) list_structure -> . list_with_data
    (88) list_structure -> . defined_list
    (92) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (93) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (97) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (80) for_estructure -> . for_initialization
    (81) for_estructure -> . for_infinite_bucle
    (82) for_estructure -> . for_iterator
    (19) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (50) parameters -> . parameter
    (51) parameters -> . parameter parameters
    (52) parameters -> . parameter COMMA parameters
    (16) variable_declaration -> . VAR VARIABLE type
    (17) variable_declaration -> . VAR VARIABLE ASSIGN value
    (18) variable_declaration -> . VARIABLE SHORTASSIGN value
    (28) value -> . VARIABLE
    (29) value -> . number
    (89) empty_list -> . LBRACE RBRACE
    (90) list_with_data -> . LBRACE values RBRACE
    (91) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (83) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (84) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (85) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (53) parameter -> . VARIABLE type
    (30) number -> . INT
    (31) number -> . FLOAT

    PRINT           shift and go to state 16
    INPUT           shift and go to state 17
    IF              shift and go to state 18
    VARIABLE        shift and go to state 23
    TYPE            shift and go to state 28
    FUNCTION        shift and go to state 29
    VAR             shift and go to state 31
    LBRACE          shift and go to state 24
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    parameters                     shift and go to state 14
    blocks                         shift and go to state 180
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    variable_declaration           shift and go to state 15
    value                          shift and go to state 19
    empty_list                     shift and go to state 20
    list_with_data                 shift and go to state 21
    defined_list                   shift and go to state 22
    for_initialization             shift and go to state 25
    for_infinite_bucle             shift and go to state 26
    for_iterator                   shift and go to state 27
    parameter                      shift and go to state 30
    number                         shift and go to state 32

state 172

    (21) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 181


state 173

    (22) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks . RETURN VARIABLE RBRACE

    RETURN          shift and go to state 182


state 174

    (23) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .

    PRINT           reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    LBRACE          reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    RETURN          reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)


state 175

    (83) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON . value double_operator LBRACE statement RBRACE
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 183
    number                         shift and go to state 32

state 176

    (85) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE . LBRACE statement RBRACE

    LBRACE          shift and go to state 184


state 177

    (64) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE . conditional_body
    (65) conditional_body -> . LBRACE statement RBRACE
    (66) conditional_body -> . LBRACE BREAK RBRACE
    (67) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 86

    conditional_body               shift and go to state 185

state 178

    (92) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE . map_values RBRACE
    (94) map_values -> . map_value
    (95) map_values -> . map_value COMMA map_values
    (96) map_value -> . string_value COLON string_value
    (26) string_value -> . value
    (27) string_value -> . CHARSTRING
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    CHARSTRING      shift and go to state 80
    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    map_values                     shift and go to state 186
    map_value                      shift and go to state 187
    string_value                   shift and go to state 188
    value                          shift and go to state 104
    number                         shift and go to state 32

state 179

    (93) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (54) type -> . INT
    (55) type -> . INT32
    (56) type -> . INT64
    (57) type -> . STRING
    (58) type -> . FLOAT
    (59) type -> . FLOAT32
    (60) type -> . FLOAT64
    (61) type -> . BOOL

    INT             shift and go to state 55
    INT32           shift and go to state 56
    INT64           shift and go to state 57
    STRING          shift and go to state 58
    FLOAT           shift and go to state 59
    FLOAT32         shift and go to state 60
    FLOAT64         shift and go to state 61
    BOOL            shift and go to state 62

    type                           shift and go to state 189

state 180

    (20) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks . RETURN VARIABLE RBRACE

    RETURN          shift and go to state 190


state 181

    (21) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .

    PRINT           reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    LBRACE          reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    RETURN          reduce using rule 21 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)


state 182

    (22) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN . VARIABLE RBRACE

    VARIABLE        shift and go to state 191


state 183

    (83) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value . double_operator LBRACE statement RBRACE
    (48) double_operator -> . INCREMENT
    (49) double_operator -> . DECREMENT

    INCREMENT       shift and go to state 50
    DECREMENT       shift and go to state 51

    double_operator                shift and go to state 192

state 184

    (85) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (32) print_statement -> . PRINT LPAREN values RPAREN
    (33) print_statement -> . PRINT LPAREN string_value RPAREN
    (34) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (35) print_statement -> . PRINT LPAREN operation RPAREN
    (36) print_statement -> . PRINT LPAREN RPAREN
    (37) input_statement -> . INPUT LPAREN values RPAREN
    (38) input_statement -> . INPUT LPAREN operation RPAREN
    (39) input_statement -> . INPUT LPAREN RPAREN
    (62) conditional_structure -> . IF conditions conditional_body
    (63) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (64) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (40) operation -> . value operator value
    (41) operation -> . value operator operation
    (42) operation -> . value double_operator
    (86) list_structure -> . empty_list
    (87) list_structure -> . list_with_data
    (88) list_structure -> . defined_list
    (92) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (93) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (97) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (80) for_estructure -> . for_initialization
    (81) for_estructure -> . for_infinite_bucle
    (82) for_estructure -> . for_iterator
    (19) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (50) parameters -> . parameter
    (51) parameters -> . parameter parameters
    (52) parameters -> . parameter COMMA parameters
    (16) variable_declaration -> . VAR VARIABLE type
    (17) variable_declaration -> . VAR VARIABLE ASSIGN value
    (18) variable_declaration -> . VARIABLE SHORTASSIGN value
    (28) value -> . VARIABLE
    (29) value -> . number
    (89) empty_list -> . LBRACE RBRACE
    (90) list_with_data -> . LBRACE values RBRACE
    (91) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (83) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (84) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (85) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (53) parameter -> . VARIABLE type
    (30) number -> . INT
    (31) number -> . FLOAT

    PRINT           shift and go to state 16
    INPUT           shift and go to state 17
    IF              shift and go to state 18
    VARIABLE        shift and go to state 23
    TYPE            shift and go to state 28
    FUNCTION        shift and go to state 29
    VAR             shift and go to state 31
    LBRACE          shift and go to state 24
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    statement                      shift and go to state 193
    blocks                         shift and go to state 2
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    value                          shift and go to state 19
    empty_list                     shift and go to state 20
    list_with_data                 shift and go to state 21
    defined_list                   shift and go to state 22
    for_initialization             shift and go to state 25
    for_infinite_bucle             shift and go to state 26
    for_iterator                   shift and go to state 27
    parameter                      shift and go to state 30
    number                         shift and go to state 32

state 185

    (64) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .

    PRINT           reduce using rule 64 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 64 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 64 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 64 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 64 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 64 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 64 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    LBRACE          reduce using rule 64 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 64 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 64 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 64 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 64 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 64 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RETURN          reduce using rule 64 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)


state 186

    (92) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values . RBRACE

    RBRACE          shift and go to state 194


state 187

    (94) map_values -> map_value .
    (95) map_values -> map_value . COMMA map_values

    RBRACE          reduce using rule 94 (map_values -> map_value .)
    COMMA           shift and go to state 195


state 188

    (96) map_value -> string_value . COLON string_value

    COLON           shift and go to state 196


state 189

    (93) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN

    RPAREN          shift and go to state 197


state 190

    (20) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN . VARIABLE RBRACE

    VARIABLE        shift and go to state 198


state 191

    (22) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE . RBRACE

    RBRACE          shift and go to state 199


state 192

    (83) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator . LBRACE statement RBRACE

    LBRACE          shift and go to state 200


state 193

    (85) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement . RBRACE

    RBRACE          shift and go to state 201


state 194

    (92) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .

    PRINT           reduce using rule 92 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INPUT           reduce using rule 92 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    IF              reduce using rule 92 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VARIABLE        reduce using rule 92 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    TYPE            reduce using rule 92 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FUNCTION        reduce using rule 92 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VAR             reduce using rule 92 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    LBRACE          reduce using rule 92 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FOR             reduce using rule 92 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INT             reduce using rule 92 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FLOAT           reduce using rule 92 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    $end            reduce using rule 92 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RBRACE          reduce using rule 92 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RETURN          reduce using rule 92 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)


state 195

    (95) map_values -> map_value COMMA . map_values
    (94) map_values -> . map_value
    (95) map_values -> . map_value COMMA map_values
    (96) map_value -> . string_value COLON string_value
    (26) string_value -> . value
    (27) string_value -> . CHARSTRING
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    CHARSTRING      shift and go to state 80
    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    map_value                      shift and go to state 187
    map_values                     shift and go to state 202
    string_value                   shift and go to state 188
    value                          shift and go to state 104
    number                         shift and go to state 32

state 196

    (96) map_value -> string_value COLON . string_value
    (26) string_value -> . value
    (27) string_value -> . CHARSTRING
    (28) value -> . VARIABLE
    (29) value -> . number
    (30) number -> . INT
    (31) number -> . FLOAT

    CHARSTRING      shift and go to state 80
    VARIABLE        shift and go to state 42
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    string_value                   shift and go to state 203
    value                          shift and go to state 104
    number                         shift and go to state 32

state 197

    (93) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .

    PRINT           reduce using rule 93 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INPUT           reduce using rule 93 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    IF              reduce using rule 93 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 93 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TYPE            reduce using rule 93 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FUNCTION        reduce using rule 93 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VAR             reduce using rule 93 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LBRACE          reduce using rule 93 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FOR             reduce using rule 93 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INT             reduce using rule 93 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FLOAT           reduce using rule 93 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    $end            reduce using rule 93 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RBRACE          reduce using rule 93 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RETURN          reduce using rule 93 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)


state 198

    (20) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE . RBRACE

    RBRACE          shift and go to state 204


state 199

    (22) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .

    PRINT           reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    INPUT           reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    IF              reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    VARIABLE        reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    TYPE            reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    FUNCTION        reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    VAR             reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    LBRACE          reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    FOR             reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    INT             reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    FLOAT           reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    $end            reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    RBRACE          reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    RETURN          reduce using rule 22 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)


state 200

    (83) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (32) print_statement -> . PRINT LPAREN values RPAREN
    (33) print_statement -> . PRINT LPAREN string_value RPAREN
    (34) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (35) print_statement -> . PRINT LPAREN operation RPAREN
    (36) print_statement -> . PRINT LPAREN RPAREN
    (37) input_statement -> . INPUT LPAREN values RPAREN
    (38) input_statement -> . INPUT LPAREN operation RPAREN
    (39) input_statement -> . INPUT LPAREN RPAREN
    (62) conditional_structure -> . IF conditions conditional_body
    (63) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (64) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (40) operation -> . value operator value
    (41) operation -> . value operator operation
    (42) operation -> . value double_operator
    (86) list_structure -> . empty_list
    (87) list_structure -> . list_with_data
    (88) list_structure -> . defined_list
    (92) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (93) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (97) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (80) for_estructure -> . for_initialization
    (81) for_estructure -> . for_infinite_bucle
    (82) for_estructure -> . for_iterator
    (19) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (20) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (21) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (22) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RETURN VARIABLE RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (50) parameters -> . parameter
    (51) parameters -> . parameter parameters
    (52) parameters -> . parameter COMMA parameters
    (16) variable_declaration -> . VAR VARIABLE type
    (17) variable_declaration -> . VAR VARIABLE ASSIGN value
    (18) variable_declaration -> . VARIABLE SHORTASSIGN value
    (28) value -> . VARIABLE
    (29) value -> . number
    (89) empty_list -> . LBRACE RBRACE
    (90) list_with_data -> . LBRACE values RBRACE
    (91) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (83) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (84) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (85) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (53) parameter -> . VARIABLE type
    (30) number -> . INT
    (31) number -> . FLOAT

    PRINT           shift and go to state 16
    INPUT           shift and go to state 17
    IF              shift and go to state 18
    VARIABLE        shift and go to state 23
    TYPE            shift and go to state 28
    FUNCTION        shift and go to state 29
    VAR             shift and go to state 31
    LBRACE          shift and go to state 24
    FOR             shift and go to state 33
    INT             shift and go to state 34
    FLOAT           shift and go to state 35

    value                          shift and go to state 19
    statement                      shift and go to state 205
    blocks                         shift and go to state 2
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    empty_list                     shift and go to state 20
    list_with_data                 shift and go to state 21
    defined_list                   shift and go to state 22
    for_initialization             shift and go to state 25
    for_infinite_bucle             shift and go to state 26
    for_iterator                   shift and go to state 27
    parameter                      shift and go to state 30
    number                         shift and go to state 32

state 201

    (85) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .

    PRINT           reduce using rule 85 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INPUT           reduce using rule 85 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    IF              reduce using rule 85 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 85 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    TYPE            reduce using rule 85 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 85 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VAR             reduce using rule 85 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    LBRACE          reduce using rule 85 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FOR             reduce using rule 85 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INT             reduce using rule 85 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FLOAT           reduce using rule 85 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    $end            reduce using rule 85 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RBRACE          reduce using rule 85 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RETURN          reduce using rule 85 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)


state 202

    (95) map_values -> map_value COMMA map_values .

    RBRACE          reduce using rule 95 (map_values -> map_value COMMA map_values .)


state 203

    (96) map_value -> string_value COLON string_value .

    COMMA           reduce using rule 96 (map_value -> string_value COLON string_value .)
    RBRACE          reduce using rule 96 (map_value -> string_value COLON string_value .)


state 204

    (20) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .

    PRINT           reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    INPUT           reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    IF              reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    VARIABLE        reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    TYPE            reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    FUNCTION        reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    VAR             reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    LBRACE          reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    FOR             reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    INT             reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    FLOAT           reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    $end            reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    RBRACE          reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)
    RETURN          reduce using rule 20 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN VARIABLE RBRACE .)


state 205

    (83) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement . RBRACE

    RBRACE          shift and go to state 206


state 206

    (83) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .

    PRINT           reduce using rule 83 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INPUT           reduce using rule 83 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    IF              reduce using rule 83 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 83 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    TYPE            reduce using rule 83 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 83 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VAR             reduce using rule 83 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    LBRACE          reduce using rule 83 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FOR             reduce using rule 83 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INT             reduce using rule 83 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FLOAT           reduce using rule 83 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    $end            reduce using rule 83 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RBRACE          reduce using rule 83 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RETURN          reduce using rule 83 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VARIABLE in state 30 resolved as shift
WARNING: reduce/reduce conflict in state 79 resolved using rule (values -> value)
WARNING: rejected rule (string_value -> value) in state 79
