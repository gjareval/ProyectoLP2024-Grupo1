Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    IDENTIFIER
    MOD
    TEXT

Grammar

Rule 0     S' -> statement
Rule 1     statement -> blocks
Rule 2     statement -> import blocks
Rule 3     statement -> package blocks
Rule 4     statement -> package import blocks
Rule 5     statement -> main LBRACE blocks RBRACE
Rule 6     statement -> package main LBRACE blocks RBRACE
Rule 7     statement -> import main LBRACE blocks RBRACE
Rule 8     statement -> package import main LBRACE blocks RBRACE
Rule 9     import -> <empty>
Rule 10    import -> IMPORT CHARSTRING
Rule 11    import -> IMPORT LPAREN values_for_import RPAREN
Rule 12    values_for_import -> CHARSTRING
Rule 13    values_for_import -> CHARSTRING values_for_import
Rule 14    package -> PACKAGE VARIABLE
Rule 15    package -> PACKAGE MAIN
Rule 16    main -> FUNCTION MAIN LPAREN RPAREN
Rule 17    blocks -> block
Rule 18    blocks -> block blocks
Rule 19    block -> print_statement
Rule 20    block -> input_statement
Rule 21    block -> operation
Rule 22    block -> data_structure
Rule 23    block -> control_structure
Rule 24    block -> function
Rule 25    block -> parameters
Rule 26    block -> variable_declaration
Rule 27    block -> variable_assignation
Rule 28    block -> return
Rule 29    variable_declaration -> VAR VARIABLE type
Rule 30    variable_declaration -> VAR VARIABLE type ASSIGN value
Rule 31    variable_declaration -> VARIABLE SHORTASSIGN value
Rule 32    variable_declaration -> VARIABLE SHORTASSIGN operation
Rule 33    variable_declaration -> CONST VARIABLE ASSIGN value
Rule 34    variable_assignation -> VARIABLE assignation value
Rule 35    variable_assignation -> VARIABLE assignation operation
Rule 36    variable_assignation -> VARIABLE double_operator
Rule 37    variable_assignation -> map_assign
Rule 38    variable_assignation -> array_assign
Rule 39    variables -> VARIABLE
Rule 40    variables -> VARIABLE COMMA variables
Rule 41    assignation -> ASSIGN
Rule 42    assignation -> PLUSASSIGN
Rule 43    assignation -> MINUSASSIGN
Rule 44    assignation -> TIMESASSIGN
Rule 45    assignation -> DIVIDEASSIGN
Rule 46    assignation -> MODASSIGN
Rule 47    function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
Rule 48    function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
Rule 49    function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
Rule 50    function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
Rule 51    function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
Rule 52    function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
Rule 53    return -> RETURN values
Rule 54    return -> RETURN value LBRACKET value RBRACKET
Rule 55    return -> RETURN value PERIOD value
Rule 56    return -> RETURN TRUE
Rule 57    return -> RETURN FALSE
Rule 58    values -> value
Rule 59    values -> value COMMA values
Rule 60    value -> VARIABLE
Rule 61    value -> not_variable_value
Rule 62    not_variable_value -> CHARSTRING
Rule 63    not_variable_value -> number
Rule 64    number -> INT
Rule 65    number -> FLOAT
Rule 66    print_statement -> PRINT LPAREN values RPAREN
Rule 67    print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN
Rule 68    print_statement -> PRINT LPAREN operation RPAREN
Rule 69    print_statement -> PRINT LPAREN RPAREN
Rule 70    input_statement -> INPUT LPAREN values RPAREN
Rule 71    input_statement -> INPUT LPAREN operation RPAREN
Rule 72    input_statement -> INPUT LPAREN RPAREN
Rule 73    operation -> value operator value
Rule 74    operation -> value operator operation
Rule 75    operation -> value double_operator
Rule 76    operator -> PLUS
Rule 77    operator -> MINUS
Rule 78    operator -> TIMES
Rule 79    operator -> DIVIDE
Rule 80    operator -> ASSIGN
Rule 81    double_operator -> INCREMENT
Rule 82    double_operator -> DECREMENT
Rule 83    parameters -> parameter
Rule 84    parameters -> parameter COMMA parameters
Rule 85    parameter -> VARIABLE type
Rule 86    type -> INT
Rule 87    type -> INT32
Rule 88    type -> INT64
Rule 89    type -> STRING
Rule 90    type -> FLOAT
Rule 91    type -> FLOAT32
Rule 92    type -> FLOAT64
Rule 93    type -> BOOL
Rule 94    control_structure -> conditional_structure
Rule 95    control_structure -> for_estructure
Rule 96    control_structure -> switch_structure
Rule 97    conditional_structure -> IF conditions conditional_body
Rule 98    conditional_structure -> IF conditions conditional_body ELSE conditional_body
Rule 99    conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
Rule 100   conditional_body -> LBRACE statement RBRACE
Rule 101   conditional_body -> LBRACE BREAK RBRACE
Rule 102   conditional_body -> LBRACE CONTINUE RBRACE
Rule 103   conditions -> condition
Rule 104   conditions -> condition logical_operator conditions
Rule 105   condition -> value relational_operator value
Rule 106   logical_operator -> AND
Rule 107   logical_operator -> OR
Rule 108   logical_operator -> NOT
Rule 109   relational_operator -> GREATER
Rule 110   relational_operator -> LESS
Rule 111   relational_operator -> GREATEREQUALS
Rule 112   relational_operator -> LESSEQUALS
Rule 113   relational_operator -> EQUALS
Rule 114   relational_operator -> DIFFERENT
Rule 115   for_estructure -> for_initialization
Rule 116   for_estructure -> for_infinite_bucle
Rule 117   for_estructure -> for_iterator
Rule 118   for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
Rule 119   for_infinite_bucle -> FOR LBRACE statement RBRACE
Rule 120   for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
Rule 121   switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE
Rule 122   switch_expression -> value
Rule 123   switch_expression -> empty
Rule 124   case_blocks -> case_block
Rule 125   case_blocks -> case_block case_blocks
Rule 126   case_block -> CASE values COLON statement
Rule 127   case_block -> DEFAULT COLON statement
Rule 128   empty -> <empty>
Rule 129   data_structure -> array_structure
Rule 130   data_structure -> map_structure
Rule 131   data_structure -> slice_structure
Rule 132   data_structure -> struct_structure
Rule 133   struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
Rule 134   struct_fields -> struct_field
Rule 135   struct_fields -> struct_field struct_fields
Rule 136   struct_field -> VARIABLE type
Rule 137   array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type
Rule 138   array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
Rule 139   array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value
Rule 140   map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
Rule 141   map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
Rule 142   map_values -> map_value
Rule 143   map_values -> map_value COMMA map_values
Rule 144   map_value -> value COLON value
Rule 145   map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value
Rule 146   slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
Rule 147   slice_structure -> VAR VARIABLE LBRACKET RBRACKET type
Rule 148   slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type
Rule 149   slice_structure -> VARIABLE ASSIGN append_statement
Rule 150   append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN
Rule 151   append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 106
APPEND               : 150 151
ASSIGN               : 30 33 41 80 138 139 145 149
BOOL                 : 93
BREAK                : 101
CASE                 : 126
CHARSTRING           : 10 12 13 62
COLON                : 126 127 144
COMMA                : 40 59 67 84 143 150 151
CONST                : 33
CONTINUE             : 102
DECREMENT            : 82
DEFAULT              : 127
DIFFERENT            : 114
DIVIDE               : 79
DIVIDEASSIGN         : 45
ELSE                 : 98 99 99
EQUALS               : 113
FALSE                : 57
FLOAT                : 65 90
FLOAT32              : 91
FLOAT64              : 92
FOR                  : 118 119 120
FORMATSTRING         : 67
FUNCTION             : 16 47 48 49 50 51 52
GREATER              : 109
GREATEREQUALS        : 111
IDENTIFIER           : 
IF                   : 97 98 99 99
IMPORT               : 10 11
INCREMENT            : 81
INPUT                : 70 71 72
INT                  : 64 86 137 138 139
INT32                : 87
INT64                : 88
LBRACE               : 5 6 7 8 47 48 49 50 51 52 100 101 102 118 119 120 121 133 138 140 146 151
LBRACKET             : 54 137 138 139 140 141 145 146 147 148 151
LESS                 : 110
LESSEQUALS           : 112
LPAREN               : 11 16 47 48 49 50 51 52 66 67 68 69 70 71 72 141 150 151
MAIN                 : 15 16
MAKE                 : 141
MAP                  : 140 141
MINUS                : 77
MINUSASSIGN          : 43
MOD                  : 
MODASSIGN            : 46
NOT                  : 108
OR                   : 107
PACKAGE              : 14 15
PERIOD               : 55
PLUS                 : 76
PLUSASSIGN           : 42
PRINT                : 66 68 69
PRINTF               : 67
RANGE                : 120
RBRACE               : 5 6 7 8 47 48 49 50 51 52 100 101 102 118 119 120 121 133 138 140 146 151
RBRACKET             : 54 137 138 139 140 141 145 146 147 148 151
RETURN               : 53 54 55 56 57
RPAREN               : 11 16 47 48 49 50 51 52 66 67 68 69 70 71 72 141 150 151
SEMICOLON            : 118 118 120
SHORTASSIGN          : 31 32 118 120 140 141 146 148
STRING               : 89
STRUCT               : 133
SWITCH               : 121
TEXT                 : 
TIMES                : 78
TIMESASSIGN          : 44
TRUE                 : 56
TYPE                 : 133
VAR                  : 29 30 137 138 147
VARIABLE             : 14 29 30 31 32 33 34 35 36 39 40 47 48 49 50 51 52 60 85 118 120 120 120 133 136 137 138 139 140 141 145 146 147 148 149 150 151
error                : 

Nonterminals, with rules where they appear

append_statement     : 149
array_assign         : 38
array_structure      : 129
assignation          : 34 35
block                : 17 18
blocks               : 1 2 3 4 5 6 7 8 18 47 48 51 52
case_block           : 124 125
case_blocks          : 121 125
condition            : 103 104 118
conditional_body     : 97 98 98 99 99 99
conditional_structure : 94
conditions           : 97 98 99 99 104
control_structure    : 23
data_structure       : 22
double_operator      : 36 75 118
empty                : 123
for_estructure       : 95
for_infinite_bucle   : 116
for_initialization   : 115
for_iterator         : 117
function             : 24
import               : 2 4 7 8
input_statement      : 20
logical_operator     : 104
main                 : 5 6 7 8
map_assign           : 37
map_structure        : 130
map_value            : 142 143
map_values           : 140 143
not_variable_value   : 61
number               : 63
operation            : 21 32 35 68 71 74
operator             : 73 74
package              : 3 4 6 8
parameter            : 83 84
parameters           : 25 48 50 51 84
print_statement      : 19
relational_operator  : 105
return               : 28
slice_structure      : 131
statement            : 100 118 119 120 126 127 0
struct_field         : 134 135
struct_fields        : 133 135
struct_structure     : 132
switch_expression    : 121
switch_structure     : 96
type                 : 29 30 49 50 51 52 85 136 137 138 140 140 141 141 146 147 148 151
value                : 30 31 33 34 54 54 55 55 58 59 73 73 74 75 105 105 118 118 122 139 144 144 145 145
values               : 53 59 66 67 70 126 138 146 150 151
values_for_import    : 11 13
variable_assignation : 27
variable_declaration : 26
variables            : 40

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 9
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 1
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 1

    (0) S' -> statement .



state 2

    (1) statement -> blocks .

    $end            reduce using rule 1 (statement -> blocks .)
    RBRACE          reduce using rule 1 (statement -> blocks .)
    CASE            reduce using rule 1 (statement -> blocks .)
    DEFAULT         reduce using rule 1 (statement -> blocks .)


state 3

    (2) statement -> import . blocks
    (7) statement -> import . main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    blocks                         shift and go to state 50
    main                           shift and go to state 51
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 4

    (3) statement -> package . blocks
    (4) statement -> package . import blocks
    (6) statement -> package . main LBRACE blocks RBRACE
    (8) statement -> package . import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    blocks                         shift and go to state 52
    import                         shift and go to state 53
    main                           shift and go to state 54
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 5

    (5) statement -> main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 55


state 6

    (17) blocks -> block .
    (18) blocks -> block . blocks
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

    $end            reduce using rule 17 (blocks -> block .)
    RBRACE          reduce using rule 17 (blocks -> block .)
    CASE            reduce using rule 17 (blocks -> block .)
    DEFAULT         reduce using rule 17 (blocks -> block .)
    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    block                          shift and go to state 6
    blocks                         shift and go to state 56
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 7

    (10) import -> IMPORT . CHARSTRING
    (11) import -> IMPORT . LPAREN values_for_import RPAREN

    CHARSTRING      shift and go to state 58
    LPAREN          shift and go to state 59


state 8

    (62) not_variable_value -> CHARSTRING .

    PLUS            reduce using rule 62 (not_variable_value -> CHARSTRING .)
    MINUS           reduce using rule 62 (not_variable_value -> CHARSTRING .)
    TIMES           reduce using rule 62 (not_variable_value -> CHARSTRING .)
    DIVIDE          reduce using rule 62 (not_variable_value -> CHARSTRING .)
    ASSIGN          reduce using rule 62 (not_variable_value -> CHARSTRING .)
    INCREMENT       reduce using rule 62 (not_variable_value -> CHARSTRING .)
    DECREMENT       reduce using rule 62 (not_variable_value -> CHARSTRING .)
    LBRACKET        reduce using rule 62 (not_variable_value -> CHARSTRING .)
    PERIOD          reduce using rule 62 (not_variable_value -> CHARSTRING .)
    COMMA           reduce using rule 62 (not_variable_value -> CHARSTRING .)
    PRINT           reduce using rule 62 (not_variable_value -> CHARSTRING .)
    PRINTF          reduce using rule 62 (not_variable_value -> CHARSTRING .)
    INPUT           reduce using rule 62 (not_variable_value -> CHARSTRING .)
    FUNCTION        reduce using rule 62 (not_variable_value -> CHARSTRING .)
    VAR             reduce using rule 62 (not_variable_value -> CHARSTRING .)
    VARIABLE        reduce using rule 62 (not_variable_value -> CHARSTRING .)
    CONST           reduce using rule 62 (not_variable_value -> CHARSTRING .)
    RETURN          reduce using rule 62 (not_variable_value -> CHARSTRING .)
    TYPE            reduce using rule 62 (not_variable_value -> CHARSTRING .)
    IF              reduce using rule 62 (not_variable_value -> CHARSTRING .)
    SWITCH          reduce using rule 62 (not_variable_value -> CHARSTRING .)
    CHARSTRING      reduce using rule 62 (not_variable_value -> CHARSTRING .)
    FOR             reduce using rule 62 (not_variable_value -> CHARSTRING .)
    INT             reduce using rule 62 (not_variable_value -> CHARSTRING .)
    FLOAT           reduce using rule 62 (not_variable_value -> CHARSTRING .)
    $end            reduce using rule 62 (not_variable_value -> CHARSTRING .)
    RBRACE          reduce using rule 62 (not_variable_value -> CHARSTRING .)
    CASE            reduce using rule 62 (not_variable_value -> CHARSTRING .)
    DEFAULT         reduce using rule 62 (not_variable_value -> CHARSTRING .)
    GREATER         reduce using rule 62 (not_variable_value -> CHARSTRING .)
    LESS            reduce using rule 62 (not_variable_value -> CHARSTRING .)
    GREATEREQUALS   reduce using rule 62 (not_variable_value -> CHARSTRING .)
    LESSEQUALS      reduce using rule 62 (not_variable_value -> CHARSTRING .)
    EQUALS          reduce using rule 62 (not_variable_value -> CHARSTRING .)
    DIFFERENT       reduce using rule 62 (not_variable_value -> CHARSTRING .)
    LBRACE          reduce using rule 62 (not_variable_value -> CHARSTRING .)
    RBRACKET        reduce using rule 62 (not_variable_value -> CHARSTRING .)
    RPAREN          reduce using rule 62 (not_variable_value -> CHARSTRING .)
    COLON           reduce using rule 62 (not_variable_value -> CHARSTRING .)
    AND             reduce using rule 62 (not_variable_value -> CHARSTRING .)
    OR              reduce using rule 62 (not_variable_value -> CHARSTRING .)
    NOT             reduce using rule 62 (not_variable_value -> CHARSTRING .)
    SEMICOLON       reduce using rule 62 (not_variable_value -> CHARSTRING .)


state 9

    (14) package -> PACKAGE . VARIABLE
    (15) package -> PACKAGE . MAIN

    VARIABLE        shift and go to state 60
    MAIN            shift and go to state 61


state 10

    (31) variable_declaration -> VARIABLE . SHORTASSIGN value
    (32) variable_declaration -> VARIABLE . SHORTASSIGN operation
    (34) variable_assignation -> VARIABLE . assignation value
    (35) variable_assignation -> VARIABLE . assignation operation
    (36) variable_assignation -> VARIABLE . double_operator
    (60) value -> VARIABLE .
    (140) map_structure -> VARIABLE . SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> VARIABLE . SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> VARIABLE . SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (148) slice_structure -> VARIABLE . SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> VARIABLE . ASSIGN append_statement
    (85) parameter -> VARIABLE . type
    (145) map_assign -> VARIABLE . LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> VARIABLE . LBRACKET INT RBRACKET ASSIGN value
    (41) assignation -> . ASSIGN
    (42) assignation -> . PLUSASSIGN
    (43) assignation -> . MINUSASSIGN
    (44) assignation -> . TIMESASSIGN
    (45) assignation -> . DIVIDEASSIGN
    (46) assignation -> . MODASSIGN
    (81) double_operator -> . INCREMENT
    (82) double_operator -> . DECREMENT
    (86) type -> . INT
    (87) type -> . INT32
    (88) type -> . INT64
    (89) type -> . STRING
    (90) type -> . FLOAT
    (91) type -> . FLOAT32
    (92) type -> . FLOAT64
    (93) type -> . BOOL

  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
    SHORTASSIGN     shift and go to state 62
    PLUS            reduce using rule 60 (value -> VARIABLE .)
    MINUS           reduce using rule 60 (value -> VARIABLE .)
    TIMES           reduce using rule 60 (value -> VARIABLE .)
    DIVIDE          reduce using rule 60 (value -> VARIABLE .)
    ASSIGN          shift and go to state 67
    LBRACKET        shift and go to state 65
    PLUSASSIGN      shift and go to state 69
    MINUSASSIGN     shift and go to state 70
    TIMESASSIGN     shift and go to state 71
    DIVIDEASSIGN    shift and go to state 72
    MODASSIGN       shift and go to state 73
    INCREMENT       shift and go to state 74
    DECREMENT       shift and go to state 75
    INT             shift and go to state 68
    INT32           shift and go to state 76
    INT64           shift and go to state 77
    STRING          shift and go to state 78
    FLOAT           shift and go to state 79
    FLOAT32         shift and go to state 80
    FLOAT64         shift and go to state 81
    BOOL            shift and go to state 82

  ! ASSIGN          [ reduce using rule 60 (value -> VARIABLE .) ]
  ! INCREMENT       [ reduce using rule 60 (value -> VARIABLE .) ]
  ! DECREMENT       [ reduce using rule 60 (value -> VARIABLE .) ]

    assignation                    shift and go to state 63
    double_operator                shift and go to state 64
    type                           shift and go to state 66

state 11

    (16) main -> FUNCTION . MAIN LPAREN RPAREN
    (47) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE

    MAIN            shift and go to state 83
    VARIABLE        shift and go to state 84


state 12

    (19) block -> print_statement .

    PRINT           reduce using rule 19 (block -> print_statement .)
    PRINTF          reduce using rule 19 (block -> print_statement .)
    INPUT           reduce using rule 19 (block -> print_statement .)
    FUNCTION        reduce using rule 19 (block -> print_statement .)
    VAR             reduce using rule 19 (block -> print_statement .)
    VARIABLE        reduce using rule 19 (block -> print_statement .)
    CONST           reduce using rule 19 (block -> print_statement .)
    RETURN          reduce using rule 19 (block -> print_statement .)
    TYPE            reduce using rule 19 (block -> print_statement .)
    IF              reduce using rule 19 (block -> print_statement .)
    SWITCH          reduce using rule 19 (block -> print_statement .)
    CHARSTRING      reduce using rule 19 (block -> print_statement .)
    FOR             reduce using rule 19 (block -> print_statement .)
    INT             reduce using rule 19 (block -> print_statement .)
    FLOAT           reduce using rule 19 (block -> print_statement .)
    $end            reduce using rule 19 (block -> print_statement .)
    RBRACE          reduce using rule 19 (block -> print_statement .)
    CASE            reduce using rule 19 (block -> print_statement .)
    DEFAULT         reduce using rule 19 (block -> print_statement .)


state 13

    (20) block -> input_statement .

    PRINT           reduce using rule 20 (block -> input_statement .)
    PRINTF          reduce using rule 20 (block -> input_statement .)
    INPUT           reduce using rule 20 (block -> input_statement .)
    FUNCTION        reduce using rule 20 (block -> input_statement .)
    VAR             reduce using rule 20 (block -> input_statement .)
    VARIABLE        reduce using rule 20 (block -> input_statement .)
    CONST           reduce using rule 20 (block -> input_statement .)
    RETURN          reduce using rule 20 (block -> input_statement .)
    TYPE            reduce using rule 20 (block -> input_statement .)
    IF              reduce using rule 20 (block -> input_statement .)
    SWITCH          reduce using rule 20 (block -> input_statement .)
    CHARSTRING      reduce using rule 20 (block -> input_statement .)
    FOR             reduce using rule 20 (block -> input_statement .)
    INT             reduce using rule 20 (block -> input_statement .)
    FLOAT           reduce using rule 20 (block -> input_statement .)
    $end            reduce using rule 20 (block -> input_statement .)
    RBRACE          reduce using rule 20 (block -> input_statement .)
    CASE            reduce using rule 20 (block -> input_statement .)
    DEFAULT         reduce using rule 20 (block -> input_statement .)


state 14

    (21) block -> operation .

    PRINT           reduce using rule 21 (block -> operation .)
    PRINTF          reduce using rule 21 (block -> operation .)
    INPUT           reduce using rule 21 (block -> operation .)
    FUNCTION        reduce using rule 21 (block -> operation .)
    VAR             reduce using rule 21 (block -> operation .)
    VARIABLE        reduce using rule 21 (block -> operation .)
    CONST           reduce using rule 21 (block -> operation .)
    RETURN          reduce using rule 21 (block -> operation .)
    TYPE            reduce using rule 21 (block -> operation .)
    IF              reduce using rule 21 (block -> operation .)
    SWITCH          reduce using rule 21 (block -> operation .)
    CHARSTRING      reduce using rule 21 (block -> operation .)
    FOR             reduce using rule 21 (block -> operation .)
    INT             reduce using rule 21 (block -> operation .)
    FLOAT           reduce using rule 21 (block -> operation .)
    $end            reduce using rule 21 (block -> operation .)
    RBRACE          reduce using rule 21 (block -> operation .)
    CASE            reduce using rule 21 (block -> operation .)
    DEFAULT         reduce using rule 21 (block -> operation .)


state 15

    (22) block -> data_structure .

    PRINT           reduce using rule 22 (block -> data_structure .)
    PRINTF          reduce using rule 22 (block -> data_structure .)
    INPUT           reduce using rule 22 (block -> data_structure .)
    FUNCTION        reduce using rule 22 (block -> data_structure .)
    VAR             reduce using rule 22 (block -> data_structure .)
    VARIABLE        reduce using rule 22 (block -> data_structure .)
    CONST           reduce using rule 22 (block -> data_structure .)
    RETURN          reduce using rule 22 (block -> data_structure .)
    TYPE            reduce using rule 22 (block -> data_structure .)
    IF              reduce using rule 22 (block -> data_structure .)
    SWITCH          reduce using rule 22 (block -> data_structure .)
    CHARSTRING      reduce using rule 22 (block -> data_structure .)
    FOR             reduce using rule 22 (block -> data_structure .)
    INT             reduce using rule 22 (block -> data_structure .)
    FLOAT           reduce using rule 22 (block -> data_structure .)
    $end            reduce using rule 22 (block -> data_structure .)
    RBRACE          reduce using rule 22 (block -> data_structure .)
    CASE            reduce using rule 22 (block -> data_structure .)
    DEFAULT         reduce using rule 22 (block -> data_structure .)


state 16

    (23) block -> control_structure .

    PRINT           reduce using rule 23 (block -> control_structure .)
    PRINTF          reduce using rule 23 (block -> control_structure .)
    INPUT           reduce using rule 23 (block -> control_structure .)
    FUNCTION        reduce using rule 23 (block -> control_structure .)
    VAR             reduce using rule 23 (block -> control_structure .)
    VARIABLE        reduce using rule 23 (block -> control_structure .)
    CONST           reduce using rule 23 (block -> control_structure .)
    RETURN          reduce using rule 23 (block -> control_structure .)
    TYPE            reduce using rule 23 (block -> control_structure .)
    IF              reduce using rule 23 (block -> control_structure .)
    SWITCH          reduce using rule 23 (block -> control_structure .)
    CHARSTRING      reduce using rule 23 (block -> control_structure .)
    FOR             reduce using rule 23 (block -> control_structure .)
    INT             reduce using rule 23 (block -> control_structure .)
    FLOAT           reduce using rule 23 (block -> control_structure .)
    $end            reduce using rule 23 (block -> control_structure .)
    RBRACE          reduce using rule 23 (block -> control_structure .)
    CASE            reduce using rule 23 (block -> control_structure .)
    DEFAULT         reduce using rule 23 (block -> control_structure .)


state 17

    (24) block -> function .

    PRINT           reduce using rule 24 (block -> function .)
    PRINTF          reduce using rule 24 (block -> function .)
    INPUT           reduce using rule 24 (block -> function .)
    FUNCTION        reduce using rule 24 (block -> function .)
    VAR             reduce using rule 24 (block -> function .)
    VARIABLE        reduce using rule 24 (block -> function .)
    CONST           reduce using rule 24 (block -> function .)
    RETURN          reduce using rule 24 (block -> function .)
    TYPE            reduce using rule 24 (block -> function .)
    IF              reduce using rule 24 (block -> function .)
    SWITCH          reduce using rule 24 (block -> function .)
    CHARSTRING      reduce using rule 24 (block -> function .)
    FOR             reduce using rule 24 (block -> function .)
    INT             reduce using rule 24 (block -> function .)
    FLOAT           reduce using rule 24 (block -> function .)
    $end            reduce using rule 24 (block -> function .)
    RBRACE          reduce using rule 24 (block -> function .)
    CASE            reduce using rule 24 (block -> function .)
    DEFAULT         reduce using rule 24 (block -> function .)


state 18

    (25) block -> parameters .

    PRINT           reduce using rule 25 (block -> parameters .)
    PRINTF          reduce using rule 25 (block -> parameters .)
    INPUT           reduce using rule 25 (block -> parameters .)
    FUNCTION        reduce using rule 25 (block -> parameters .)
    VAR             reduce using rule 25 (block -> parameters .)
    VARIABLE        reduce using rule 25 (block -> parameters .)
    CONST           reduce using rule 25 (block -> parameters .)
    RETURN          reduce using rule 25 (block -> parameters .)
    TYPE            reduce using rule 25 (block -> parameters .)
    IF              reduce using rule 25 (block -> parameters .)
    SWITCH          reduce using rule 25 (block -> parameters .)
    CHARSTRING      reduce using rule 25 (block -> parameters .)
    FOR             reduce using rule 25 (block -> parameters .)
    INT             reduce using rule 25 (block -> parameters .)
    FLOAT           reduce using rule 25 (block -> parameters .)
    $end            reduce using rule 25 (block -> parameters .)
    RBRACE          reduce using rule 25 (block -> parameters .)
    CASE            reduce using rule 25 (block -> parameters .)
    DEFAULT         reduce using rule 25 (block -> parameters .)


state 19

    (26) block -> variable_declaration .

    PRINT           reduce using rule 26 (block -> variable_declaration .)
    PRINTF          reduce using rule 26 (block -> variable_declaration .)
    INPUT           reduce using rule 26 (block -> variable_declaration .)
    FUNCTION        reduce using rule 26 (block -> variable_declaration .)
    VAR             reduce using rule 26 (block -> variable_declaration .)
    VARIABLE        reduce using rule 26 (block -> variable_declaration .)
    CONST           reduce using rule 26 (block -> variable_declaration .)
    RETURN          reduce using rule 26 (block -> variable_declaration .)
    TYPE            reduce using rule 26 (block -> variable_declaration .)
    IF              reduce using rule 26 (block -> variable_declaration .)
    SWITCH          reduce using rule 26 (block -> variable_declaration .)
    CHARSTRING      reduce using rule 26 (block -> variable_declaration .)
    FOR             reduce using rule 26 (block -> variable_declaration .)
    INT             reduce using rule 26 (block -> variable_declaration .)
    FLOAT           reduce using rule 26 (block -> variable_declaration .)
    $end            reduce using rule 26 (block -> variable_declaration .)
    RBRACE          reduce using rule 26 (block -> variable_declaration .)
    CASE            reduce using rule 26 (block -> variable_declaration .)
    DEFAULT         reduce using rule 26 (block -> variable_declaration .)


state 20

    (27) block -> variable_assignation .

    PRINT           reduce using rule 27 (block -> variable_assignation .)
    PRINTF          reduce using rule 27 (block -> variable_assignation .)
    INPUT           reduce using rule 27 (block -> variable_assignation .)
    FUNCTION        reduce using rule 27 (block -> variable_assignation .)
    VAR             reduce using rule 27 (block -> variable_assignation .)
    VARIABLE        reduce using rule 27 (block -> variable_assignation .)
    CONST           reduce using rule 27 (block -> variable_assignation .)
    RETURN          reduce using rule 27 (block -> variable_assignation .)
    TYPE            reduce using rule 27 (block -> variable_assignation .)
    IF              reduce using rule 27 (block -> variable_assignation .)
    SWITCH          reduce using rule 27 (block -> variable_assignation .)
    CHARSTRING      reduce using rule 27 (block -> variable_assignation .)
    FOR             reduce using rule 27 (block -> variable_assignation .)
    INT             reduce using rule 27 (block -> variable_assignation .)
    FLOAT           reduce using rule 27 (block -> variable_assignation .)
    $end            reduce using rule 27 (block -> variable_assignation .)
    RBRACE          reduce using rule 27 (block -> variable_assignation .)
    CASE            reduce using rule 27 (block -> variable_assignation .)
    DEFAULT         reduce using rule 27 (block -> variable_assignation .)


state 21

    (28) block -> return .

    PRINT           reduce using rule 28 (block -> return .)
    PRINTF          reduce using rule 28 (block -> return .)
    INPUT           reduce using rule 28 (block -> return .)
    FUNCTION        reduce using rule 28 (block -> return .)
    VAR             reduce using rule 28 (block -> return .)
    VARIABLE        reduce using rule 28 (block -> return .)
    CONST           reduce using rule 28 (block -> return .)
    RETURN          reduce using rule 28 (block -> return .)
    TYPE            reduce using rule 28 (block -> return .)
    IF              reduce using rule 28 (block -> return .)
    SWITCH          reduce using rule 28 (block -> return .)
    CHARSTRING      reduce using rule 28 (block -> return .)
    FOR             reduce using rule 28 (block -> return .)
    INT             reduce using rule 28 (block -> return .)
    FLOAT           reduce using rule 28 (block -> return .)
    $end            reduce using rule 28 (block -> return .)
    RBRACE          reduce using rule 28 (block -> return .)
    CASE            reduce using rule 28 (block -> return .)
    DEFAULT         reduce using rule 28 (block -> return .)


state 22

    (66) print_statement -> PRINT . LPAREN values RPAREN
    (68) print_statement -> PRINT . LPAREN operation RPAREN
    (69) print_statement -> PRINT . LPAREN RPAREN

    LPAREN          shift and go to state 85


state 23

    (67) print_statement -> PRINTF . LPAREN FORMATSTRING COMMA values RPAREN

    LPAREN          shift and go to state 86


state 24

    (70) input_statement -> INPUT . LPAREN values RPAREN
    (71) input_statement -> INPUT . LPAREN operation RPAREN
    (72) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 87


state 25

    (73) operation -> value . operator value
    (74) operation -> value . operator operation
    (75) operation -> value . double_operator
    (76) operator -> . PLUS
    (77) operator -> . MINUS
    (78) operator -> . TIMES
    (79) operator -> . DIVIDE
    (80) operator -> . ASSIGN
    (81) double_operator -> . INCREMENT
    (82) double_operator -> . DECREMENT

    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    TIMES           shift and go to state 92
    DIVIDE          shift and go to state 93
    ASSIGN          shift and go to state 94
    INCREMENT       shift and go to state 74
    DECREMENT       shift and go to state 75

    operator                       shift and go to state 88
    double_operator                shift and go to state 89

state 26

    (129) data_structure -> array_structure .

    PRINT           reduce using rule 129 (data_structure -> array_structure .)
    PRINTF          reduce using rule 129 (data_structure -> array_structure .)
    INPUT           reduce using rule 129 (data_structure -> array_structure .)
    FUNCTION        reduce using rule 129 (data_structure -> array_structure .)
    VAR             reduce using rule 129 (data_structure -> array_structure .)
    VARIABLE        reduce using rule 129 (data_structure -> array_structure .)
    CONST           reduce using rule 129 (data_structure -> array_structure .)
    RETURN          reduce using rule 129 (data_structure -> array_structure .)
    TYPE            reduce using rule 129 (data_structure -> array_structure .)
    IF              reduce using rule 129 (data_structure -> array_structure .)
    SWITCH          reduce using rule 129 (data_structure -> array_structure .)
    CHARSTRING      reduce using rule 129 (data_structure -> array_structure .)
    FOR             reduce using rule 129 (data_structure -> array_structure .)
    INT             reduce using rule 129 (data_structure -> array_structure .)
    FLOAT           reduce using rule 129 (data_structure -> array_structure .)
    $end            reduce using rule 129 (data_structure -> array_structure .)
    RBRACE          reduce using rule 129 (data_structure -> array_structure .)
    CASE            reduce using rule 129 (data_structure -> array_structure .)
    DEFAULT         reduce using rule 129 (data_structure -> array_structure .)


state 27

    (130) data_structure -> map_structure .

    PRINT           reduce using rule 130 (data_structure -> map_structure .)
    PRINTF          reduce using rule 130 (data_structure -> map_structure .)
    INPUT           reduce using rule 130 (data_structure -> map_structure .)
    FUNCTION        reduce using rule 130 (data_structure -> map_structure .)
    VAR             reduce using rule 130 (data_structure -> map_structure .)
    VARIABLE        reduce using rule 130 (data_structure -> map_structure .)
    CONST           reduce using rule 130 (data_structure -> map_structure .)
    RETURN          reduce using rule 130 (data_structure -> map_structure .)
    TYPE            reduce using rule 130 (data_structure -> map_structure .)
    IF              reduce using rule 130 (data_structure -> map_structure .)
    SWITCH          reduce using rule 130 (data_structure -> map_structure .)
    CHARSTRING      reduce using rule 130 (data_structure -> map_structure .)
    FOR             reduce using rule 130 (data_structure -> map_structure .)
    INT             reduce using rule 130 (data_structure -> map_structure .)
    FLOAT           reduce using rule 130 (data_structure -> map_structure .)
    $end            reduce using rule 130 (data_structure -> map_structure .)
    RBRACE          reduce using rule 130 (data_structure -> map_structure .)
    CASE            reduce using rule 130 (data_structure -> map_structure .)
    DEFAULT         reduce using rule 130 (data_structure -> map_structure .)


state 28

    (131) data_structure -> slice_structure .

    PRINT           reduce using rule 131 (data_structure -> slice_structure .)
    PRINTF          reduce using rule 131 (data_structure -> slice_structure .)
    INPUT           reduce using rule 131 (data_structure -> slice_structure .)
    FUNCTION        reduce using rule 131 (data_structure -> slice_structure .)
    VAR             reduce using rule 131 (data_structure -> slice_structure .)
    VARIABLE        reduce using rule 131 (data_structure -> slice_structure .)
    CONST           reduce using rule 131 (data_structure -> slice_structure .)
    RETURN          reduce using rule 131 (data_structure -> slice_structure .)
    TYPE            reduce using rule 131 (data_structure -> slice_structure .)
    IF              reduce using rule 131 (data_structure -> slice_structure .)
    SWITCH          reduce using rule 131 (data_structure -> slice_structure .)
    CHARSTRING      reduce using rule 131 (data_structure -> slice_structure .)
    FOR             reduce using rule 131 (data_structure -> slice_structure .)
    INT             reduce using rule 131 (data_structure -> slice_structure .)
    FLOAT           reduce using rule 131 (data_structure -> slice_structure .)
    $end            reduce using rule 131 (data_structure -> slice_structure .)
    RBRACE          reduce using rule 131 (data_structure -> slice_structure .)
    CASE            reduce using rule 131 (data_structure -> slice_structure .)
    DEFAULT         reduce using rule 131 (data_structure -> slice_structure .)


state 29

    (132) data_structure -> struct_structure .

    PRINT           reduce using rule 132 (data_structure -> struct_structure .)
    PRINTF          reduce using rule 132 (data_structure -> struct_structure .)
    INPUT           reduce using rule 132 (data_structure -> struct_structure .)
    FUNCTION        reduce using rule 132 (data_structure -> struct_structure .)
    VAR             reduce using rule 132 (data_structure -> struct_structure .)
    VARIABLE        reduce using rule 132 (data_structure -> struct_structure .)
    CONST           reduce using rule 132 (data_structure -> struct_structure .)
    RETURN          reduce using rule 132 (data_structure -> struct_structure .)
    TYPE            reduce using rule 132 (data_structure -> struct_structure .)
    IF              reduce using rule 132 (data_structure -> struct_structure .)
    SWITCH          reduce using rule 132 (data_structure -> struct_structure .)
    CHARSTRING      reduce using rule 132 (data_structure -> struct_structure .)
    FOR             reduce using rule 132 (data_structure -> struct_structure .)
    INT             reduce using rule 132 (data_structure -> struct_structure .)
    FLOAT           reduce using rule 132 (data_structure -> struct_structure .)
    $end            reduce using rule 132 (data_structure -> struct_structure .)
    RBRACE          reduce using rule 132 (data_structure -> struct_structure .)
    CASE            reduce using rule 132 (data_structure -> struct_structure .)
    DEFAULT         reduce using rule 132 (data_structure -> struct_structure .)


state 30

    (94) control_structure -> conditional_structure .

    PRINT           reduce using rule 94 (control_structure -> conditional_structure .)
    PRINTF          reduce using rule 94 (control_structure -> conditional_structure .)
    INPUT           reduce using rule 94 (control_structure -> conditional_structure .)
    FUNCTION        reduce using rule 94 (control_structure -> conditional_structure .)
    VAR             reduce using rule 94 (control_structure -> conditional_structure .)
    VARIABLE        reduce using rule 94 (control_structure -> conditional_structure .)
    CONST           reduce using rule 94 (control_structure -> conditional_structure .)
    RETURN          reduce using rule 94 (control_structure -> conditional_structure .)
    TYPE            reduce using rule 94 (control_structure -> conditional_structure .)
    IF              reduce using rule 94 (control_structure -> conditional_structure .)
    SWITCH          reduce using rule 94 (control_structure -> conditional_structure .)
    CHARSTRING      reduce using rule 94 (control_structure -> conditional_structure .)
    FOR             reduce using rule 94 (control_structure -> conditional_structure .)
    INT             reduce using rule 94 (control_structure -> conditional_structure .)
    FLOAT           reduce using rule 94 (control_structure -> conditional_structure .)
    $end            reduce using rule 94 (control_structure -> conditional_structure .)
    RBRACE          reduce using rule 94 (control_structure -> conditional_structure .)
    CASE            reduce using rule 94 (control_structure -> conditional_structure .)
    DEFAULT         reduce using rule 94 (control_structure -> conditional_structure .)


state 31

    (95) control_structure -> for_estructure .

    PRINT           reduce using rule 95 (control_structure -> for_estructure .)
    PRINTF          reduce using rule 95 (control_structure -> for_estructure .)
    INPUT           reduce using rule 95 (control_structure -> for_estructure .)
    FUNCTION        reduce using rule 95 (control_structure -> for_estructure .)
    VAR             reduce using rule 95 (control_structure -> for_estructure .)
    VARIABLE        reduce using rule 95 (control_structure -> for_estructure .)
    CONST           reduce using rule 95 (control_structure -> for_estructure .)
    RETURN          reduce using rule 95 (control_structure -> for_estructure .)
    TYPE            reduce using rule 95 (control_structure -> for_estructure .)
    IF              reduce using rule 95 (control_structure -> for_estructure .)
    SWITCH          reduce using rule 95 (control_structure -> for_estructure .)
    CHARSTRING      reduce using rule 95 (control_structure -> for_estructure .)
    FOR             reduce using rule 95 (control_structure -> for_estructure .)
    INT             reduce using rule 95 (control_structure -> for_estructure .)
    FLOAT           reduce using rule 95 (control_structure -> for_estructure .)
    $end            reduce using rule 95 (control_structure -> for_estructure .)
    RBRACE          reduce using rule 95 (control_structure -> for_estructure .)
    CASE            reduce using rule 95 (control_structure -> for_estructure .)
    DEFAULT         reduce using rule 95 (control_structure -> for_estructure .)


state 32

    (96) control_structure -> switch_structure .

    PRINT           reduce using rule 96 (control_structure -> switch_structure .)
    PRINTF          reduce using rule 96 (control_structure -> switch_structure .)
    INPUT           reduce using rule 96 (control_structure -> switch_structure .)
    FUNCTION        reduce using rule 96 (control_structure -> switch_structure .)
    VAR             reduce using rule 96 (control_structure -> switch_structure .)
    VARIABLE        reduce using rule 96 (control_structure -> switch_structure .)
    CONST           reduce using rule 96 (control_structure -> switch_structure .)
    RETURN          reduce using rule 96 (control_structure -> switch_structure .)
    TYPE            reduce using rule 96 (control_structure -> switch_structure .)
    IF              reduce using rule 96 (control_structure -> switch_structure .)
    SWITCH          reduce using rule 96 (control_structure -> switch_structure .)
    CHARSTRING      reduce using rule 96 (control_structure -> switch_structure .)
    FOR             reduce using rule 96 (control_structure -> switch_structure .)
    INT             reduce using rule 96 (control_structure -> switch_structure .)
    FLOAT           reduce using rule 96 (control_structure -> switch_structure .)
    $end            reduce using rule 96 (control_structure -> switch_structure .)
    RBRACE          reduce using rule 96 (control_structure -> switch_structure .)
    CASE            reduce using rule 96 (control_structure -> switch_structure .)
    DEFAULT         reduce using rule 96 (control_structure -> switch_structure .)


state 33

    (83) parameters -> parameter .
    (84) parameters -> parameter . COMMA parameters

    PRINT           reduce using rule 83 (parameters -> parameter .)
    PRINTF          reduce using rule 83 (parameters -> parameter .)
    INPUT           reduce using rule 83 (parameters -> parameter .)
    FUNCTION        reduce using rule 83 (parameters -> parameter .)
    VAR             reduce using rule 83 (parameters -> parameter .)
    VARIABLE        reduce using rule 83 (parameters -> parameter .)
    CONST           reduce using rule 83 (parameters -> parameter .)
    RETURN          reduce using rule 83 (parameters -> parameter .)
    TYPE            reduce using rule 83 (parameters -> parameter .)
    IF              reduce using rule 83 (parameters -> parameter .)
    SWITCH          reduce using rule 83 (parameters -> parameter .)
    CHARSTRING      reduce using rule 83 (parameters -> parameter .)
    FOR             reduce using rule 83 (parameters -> parameter .)
    INT             reduce using rule 83 (parameters -> parameter .)
    FLOAT           reduce using rule 83 (parameters -> parameter .)
    $end            reduce using rule 83 (parameters -> parameter .)
    RBRACE          reduce using rule 83 (parameters -> parameter .)
    CASE            reduce using rule 83 (parameters -> parameter .)
    DEFAULT         reduce using rule 83 (parameters -> parameter .)
    RPAREN          reduce using rule 83 (parameters -> parameter .)
    COMMA           shift and go to state 95


state 34

    (29) variable_declaration -> VAR . VARIABLE type
    (30) variable_declaration -> VAR . VARIABLE type ASSIGN value
    (137) array_structure -> VAR . VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> VAR . VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> VAR . VARIABLE LBRACKET RBRACKET type

    VARIABLE        shift and go to state 96


state 35

    (33) variable_declaration -> CONST . VARIABLE ASSIGN value

    VARIABLE        shift and go to state 97


state 36

    (37) variable_assignation -> map_assign .

    PRINT           reduce using rule 37 (variable_assignation -> map_assign .)
    PRINTF          reduce using rule 37 (variable_assignation -> map_assign .)
    INPUT           reduce using rule 37 (variable_assignation -> map_assign .)
    FUNCTION        reduce using rule 37 (variable_assignation -> map_assign .)
    VAR             reduce using rule 37 (variable_assignation -> map_assign .)
    VARIABLE        reduce using rule 37 (variable_assignation -> map_assign .)
    CONST           reduce using rule 37 (variable_assignation -> map_assign .)
    RETURN          reduce using rule 37 (variable_assignation -> map_assign .)
    TYPE            reduce using rule 37 (variable_assignation -> map_assign .)
    IF              reduce using rule 37 (variable_assignation -> map_assign .)
    SWITCH          reduce using rule 37 (variable_assignation -> map_assign .)
    CHARSTRING      reduce using rule 37 (variable_assignation -> map_assign .)
    FOR             reduce using rule 37 (variable_assignation -> map_assign .)
    INT             reduce using rule 37 (variable_assignation -> map_assign .)
    FLOAT           reduce using rule 37 (variable_assignation -> map_assign .)
    $end            reduce using rule 37 (variable_assignation -> map_assign .)
    RBRACE          reduce using rule 37 (variable_assignation -> map_assign .)
    CASE            reduce using rule 37 (variable_assignation -> map_assign .)
    DEFAULT         reduce using rule 37 (variable_assignation -> map_assign .)


state 37

    (38) variable_assignation -> array_assign .

    PRINT           reduce using rule 38 (variable_assignation -> array_assign .)
    PRINTF          reduce using rule 38 (variable_assignation -> array_assign .)
    INPUT           reduce using rule 38 (variable_assignation -> array_assign .)
    FUNCTION        reduce using rule 38 (variable_assignation -> array_assign .)
    VAR             reduce using rule 38 (variable_assignation -> array_assign .)
    VARIABLE        reduce using rule 38 (variable_assignation -> array_assign .)
    CONST           reduce using rule 38 (variable_assignation -> array_assign .)
    RETURN          reduce using rule 38 (variable_assignation -> array_assign .)
    TYPE            reduce using rule 38 (variable_assignation -> array_assign .)
    IF              reduce using rule 38 (variable_assignation -> array_assign .)
    SWITCH          reduce using rule 38 (variable_assignation -> array_assign .)
    CHARSTRING      reduce using rule 38 (variable_assignation -> array_assign .)
    FOR             reduce using rule 38 (variable_assignation -> array_assign .)
    INT             reduce using rule 38 (variable_assignation -> array_assign .)
    FLOAT           reduce using rule 38 (variable_assignation -> array_assign .)
    $end            reduce using rule 38 (variable_assignation -> array_assign .)
    RBRACE          reduce using rule 38 (variable_assignation -> array_assign .)
    CASE            reduce using rule 38 (variable_assignation -> array_assign .)
    DEFAULT         reduce using rule 38 (variable_assignation -> array_assign .)


state 38

    (53) return -> RETURN . values
    (54) return -> RETURN . value LBRACKET value RBRACKET
    (55) return -> RETURN . value PERIOD value
    (56) return -> RETURN . TRUE
    (57) return -> RETURN . FALSE
    (58) values -> . value
    (59) values -> . value COMMA values
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    TRUE            shift and go to state 100
    FALSE           shift and go to state 101
    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    values                         shift and go to state 98
    value                          shift and go to state 99
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 39

    (61) value -> not_variable_value .

    PLUS            reduce using rule 61 (value -> not_variable_value .)
    MINUS           reduce using rule 61 (value -> not_variable_value .)
    TIMES           reduce using rule 61 (value -> not_variable_value .)
    DIVIDE          reduce using rule 61 (value -> not_variable_value .)
    ASSIGN          reduce using rule 61 (value -> not_variable_value .)
    INCREMENT       reduce using rule 61 (value -> not_variable_value .)
    DECREMENT       reduce using rule 61 (value -> not_variable_value .)
    LBRACKET        reduce using rule 61 (value -> not_variable_value .)
    PERIOD          reduce using rule 61 (value -> not_variable_value .)
    COMMA           reduce using rule 61 (value -> not_variable_value .)
    PRINT           reduce using rule 61 (value -> not_variable_value .)
    PRINTF          reduce using rule 61 (value -> not_variable_value .)
    INPUT           reduce using rule 61 (value -> not_variable_value .)
    FUNCTION        reduce using rule 61 (value -> not_variable_value .)
    VAR             reduce using rule 61 (value -> not_variable_value .)
    VARIABLE        reduce using rule 61 (value -> not_variable_value .)
    CONST           reduce using rule 61 (value -> not_variable_value .)
    RETURN          reduce using rule 61 (value -> not_variable_value .)
    TYPE            reduce using rule 61 (value -> not_variable_value .)
    IF              reduce using rule 61 (value -> not_variable_value .)
    SWITCH          reduce using rule 61 (value -> not_variable_value .)
    CHARSTRING      reduce using rule 61 (value -> not_variable_value .)
    FOR             reduce using rule 61 (value -> not_variable_value .)
    INT             reduce using rule 61 (value -> not_variable_value .)
    FLOAT           reduce using rule 61 (value -> not_variable_value .)
    $end            reduce using rule 61 (value -> not_variable_value .)
    RBRACE          reduce using rule 61 (value -> not_variable_value .)
    CASE            reduce using rule 61 (value -> not_variable_value .)
    DEFAULT         reduce using rule 61 (value -> not_variable_value .)
    GREATER         reduce using rule 61 (value -> not_variable_value .)
    LESS            reduce using rule 61 (value -> not_variable_value .)
    GREATEREQUALS   reduce using rule 61 (value -> not_variable_value .)
    LESSEQUALS      reduce using rule 61 (value -> not_variable_value .)
    EQUALS          reduce using rule 61 (value -> not_variable_value .)
    DIFFERENT       reduce using rule 61 (value -> not_variable_value .)
    LBRACE          reduce using rule 61 (value -> not_variable_value .)
    RBRACKET        reduce using rule 61 (value -> not_variable_value .)
    RPAREN          reduce using rule 61 (value -> not_variable_value .)
    COLON           reduce using rule 61 (value -> not_variable_value .)
    AND             reduce using rule 61 (value -> not_variable_value .)
    OR              reduce using rule 61 (value -> not_variable_value .)
    NOT             reduce using rule 61 (value -> not_variable_value .)
    SEMICOLON       reduce using rule 61 (value -> not_variable_value .)


state 40

    (64) number -> INT .

    PLUS            reduce using rule 64 (number -> INT .)
    MINUS           reduce using rule 64 (number -> INT .)
    TIMES           reduce using rule 64 (number -> INT .)
    DIVIDE          reduce using rule 64 (number -> INT .)
    ASSIGN          reduce using rule 64 (number -> INT .)
    INCREMENT       reduce using rule 64 (number -> INT .)
    DECREMENT       reduce using rule 64 (number -> INT .)
    LBRACKET        reduce using rule 64 (number -> INT .)
    PERIOD          reduce using rule 64 (number -> INT .)
    COMMA           reduce using rule 64 (number -> INT .)
    PRINT           reduce using rule 64 (number -> INT .)
    PRINTF          reduce using rule 64 (number -> INT .)
    INPUT           reduce using rule 64 (number -> INT .)
    FUNCTION        reduce using rule 64 (number -> INT .)
    VAR             reduce using rule 64 (number -> INT .)
    VARIABLE        reduce using rule 64 (number -> INT .)
    CONST           reduce using rule 64 (number -> INT .)
    RETURN          reduce using rule 64 (number -> INT .)
    TYPE            reduce using rule 64 (number -> INT .)
    IF              reduce using rule 64 (number -> INT .)
    SWITCH          reduce using rule 64 (number -> INT .)
    CHARSTRING      reduce using rule 64 (number -> INT .)
    FOR             reduce using rule 64 (number -> INT .)
    INT             reduce using rule 64 (number -> INT .)
    FLOAT           reduce using rule 64 (number -> INT .)
    $end            reduce using rule 64 (number -> INT .)
    RBRACE          reduce using rule 64 (number -> INT .)
    CASE            reduce using rule 64 (number -> INT .)
    DEFAULT         reduce using rule 64 (number -> INT .)
    GREATER         reduce using rule 64 (number -> INT .)
    LESS            reduce using rule 64 (number -> INT .)
    GREATEREQUALS   reduce using rule 64 (number -> INT .)
    LESSEQUALS      reduce using rule 64 (number -> INT .)
    EQUALS          reduce using rule 64 (number -> INT .)
    DIFFERENT       reduce using rule 64 (number -> INT .)
    LBRACE          reduce using rule 64 (number -> INT .)
    RPAREN          reduce using rule 64 (number -> INT .)
    RBRACKET        reduce using rule 64 (number -> INT .)
    COLON           reduce using rule 64 (number -> INT .)
    AND             reduce using rule 64 (number -> INT .)
    OR              reduce using rule 64 (number -> INT .)
    NOT             reduce using rule 64 (number -> INT .)
    SEMICOLON       reduce using rule 64 (number -> INT .)


state 41

    (133) struct_structure -> TYPE . VARIABLE STRUCT LBRACE struct_fields RBRACE

    VARIABLE        shift and go to state 103


state 42

    (97) conditional_structure -> IF . conditions conditional_body
    (98) conditional_structure -> IF . conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> IF . conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (103) conditions -> . condition
    (104) conditions -> . condition logical_operator conditions
    (105) condition -> . value relational_operator value
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    conditions                     shift and go to state 104
    condition                      shift and go to state 105
    value                          shift and go to state 106
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 43

    (115) for_estructure -> for_initialization .

    PRINT           reduce using rule 115 (for_estructure -> for_initialization .)
    PRINTF          reduce using rule 115 (for_estructure -> for_initialization .)
    INPUT           reduce using rule 115 (for_estructure -> for_initialization .)
    FUNCTION        reduce using rule 115 (for_estructure -> for_initialization .)
    VAR             reduce using rule 115 (for_estructure -> for_initialization .)
    VARIABLE        reduce using rule 115 (for_estructure -> for_initialization .)
    CONST           reduce using rule 115 (for_estructure -> for_initialization .)
    RETURN          reduce using rule 115 (for_estructure -> for_initialization .)
    TYPE            reduce using rule 115 (for_estructure -> for_initialization .)
    IF              reduce using rule 115 (for_estructure -> for_initialization .)
    SWITCH          reduce using rule 115 (for_estructure -> for_initialization .)
    CHARSTRING      reduce using rule 115 (for_estructure -> for_initialization .)
    FOR             reduce using rule 115 (for_estructure -> for_initialization .)
    INT             reduce using rule 115 (for_estructure -> for_initialization .)
    FLOAT           reduce using rule 115 (for_estructure -> for_initialization .)
    $end            reduce using rule 115 (for_estructure -> for_initialization .)
    RBRACE          reduce using rule 115 (for_estructure -> for_initialization .)
    CASE            reduce using rule 115 (for_estructure -> for_initialization .)
    DEFAULT         reduce using rule 115 (for_estructure -> for_initialization .)


state 44

    (116) for_estructure -> for_infinite_bucle .

    PRINT           reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    PRINTF          reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    INPUT           reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    FUNCTION        reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    VAR             reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    VARIABLE        reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    CONST           reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    RETURN          reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    TYPE            reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    IF              reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    SWITCH          reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    CHARSTRING      reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    FOR             reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    INT             reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    FLOAT           reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    $end            reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    RBRACE          reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    CASE            reduce using rule 116 (for_estructure -> for_infinite_bucle .)
    DEFAULT         reduce using rule 116 (for_estructure -> for_infinite_bucle .)


state 45

    (117) for_estructure -> for_iterator .

    PRINT           reduce using rule 117 (for_estructure -> for_iterator .)
    PRINTF          reduce using rule 117 (for_estructure -> for_iterator .)
    INPUT           reduce using rule 117 (for_estructure -> for_iterator .)
    FUNCTION        reduce using rule 117 (for_estructure -> for_iterator .)
    VAR             reduce using rule 117 (for_estructure -> for_iterator .)
    VARIABLE        reduce using rule 117 (for_estructure -> for_iterator .)
    CONST           reduce using rule 117 (for_estructure -> for_iterator .)
    RETURN          reduce using rule 117 (for_estructure -> for_iterator .)
    TYPE            reduce using rule 117 (for_estructure -> for_iterator .)
    IF              reduce using rule 117 (for_estructure -> for_iterator .)
    SWITCH          reduce using rule 117 (for_estructure -> for_iterator .)
    CHARSTRING      reduce using rule 117 (for_estructure -> for_iterator .)
    FOR             reduce using rule 117 (for_estructure -> for_iterator .)
    INT             reduce using rule 117 (for_estructure -> for_iterator .)
    FLOAT           reduce using rule 117 (for_estructure -> for_iterator .)
    $end            reduce using rule 117 (for_estructure -> for_iterator .)
    RBRACE          reduce using rule 117 (for_estructure -> for_iterator .)
    CASE            reduce using rule 117 (for_estructure -> for_iterator .)
    DEFAULT         reduce using rule 117 (for_estructure -> for_iterator .)


state 46

    (121) switch_structure -> SWITCH . switch_expression LBRACE case_blocks RBRACE
    (122) switch_expression -> . value
    (123) switch_expression -> . empty
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (128) empty -> .
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    LBRACE          reduce using rule 128 (empty -> .)
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    switch_expression              shift and go to state 107
    value                          shift and go to state 108
    empty                          shift and go to state 109
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 47

    (63) not_variable_value -> number .

    PLUS            reduce using rule 63 (not_variable_value -> number .)
    MINUS           reduce using rule 63 (not_variable_value -> number .)
    TIMES           reduce using rule 63 (not_variable_value -> number .)
    DIVIDE          reduce using rule 63 (not_variable_value -> number .)
    ASSIGN          reduce using rule 63 (not_variable_value -> number .)
    INCREMENT       reduce using rule 63 (not_variable_value -> number .)
    DECREMENT       reduce using rule 63 (not_variable_value -> number .)
    LBRACKET        reduce using rule 63 (not_variable_value -> number .)
    PERIOD          reduce using rule 63 (not_variable_value -> number .)
    COMMA           reduce using rule 63 (not_variable_value -> number .)
    PRINT           reduce using rule 63 (not_variable_value -> number .)
    PRINTF          reduce using rule 63 (not_variable_value -> number .)
    INPUT           reduce using rule 63 (not_variable_value -> number .)
    FUNCTION        reduce using rule 63 (not_variable_value -> number .)
    VAR             reduce using rule 63 (not_variable_value -> number .)
    VARIABLE        reduce using rule 63 (not_variable_value -> number .)
    CONST           reduce using rule 63 (not_variable_value -> number .)
    RETURN          reduce using rule 63 (not_variable_value -> number .)
    TYPE            reduce using rule 63 (not_variable_value -> number .)
    IF              reduce using rule 63 (not_variable_value -> number .)
    SWITCH          reduce using rule 63 (not_variable_value -> number .)
    CHARSTRING      reduce using rule 63 (not_variable_value -> number .)
    FOR             reduce using rule 63 (not_variable_value -> number .)
    INT             reduce using rule 63 (not_variable_value -> number .)
    FLOAT           reduce using rule 63 (not_variable_value -> number .)
    $end            reduce using rule 63 (not_variable_value -> number .)
    RBRACE          reduce using rule 63 (not_variable_value -> number .)
    CASE            reduce using rule 63 (not_variable_value -> number .)
    DEFAULT         reduce using rule 63 (not_variable_value -> number .)
    GREATER         reduce using rule 63 (not_variable_value -> number .)
    LESS            reduce using rule 63 (not_variable_value -> number .)
    GREATEREQUALS   reduce using rule 63 (not_variable_value -> number .)
    LESSEQUALS      reduce using rule 63 (not_variable_value -> number .)
    EQUALS          reduce using rule 63 (not_variable_value -> number .)
    DIFFERENT       reduce using rule 63 (not_variable_value -> number .)
    LBRACE          reduce using rule 63 (not_variable_value -> number .)
    RBRACKET        reduce using rule 63 (not_variable_value -> number .)
    RPAREN          reduce using rule 63 (not_variable_value -> number .)
    COLON           reduce using rule 63 (not_variable_value -> number .)
    AND             reduce using rule 63 (not_variable_value -> number .)
    OR              reduce using rule 63 (not_variable_value -> number .)
    NOT             reduce using rule 63 (not_variable_value -> number .)
    SEMICOLON       reduce using rule 63 (not_variable_value -> number .)


state 48

    (118) for_initialization -> FOR . VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> FOR . LBRACE statement RBRACE
    (120) for_iterator -> FOR . VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 110
    LBRACE          shift and go to state 111


state 49

    (65) number -> FLOAT .

    PLUS            reduce using rule 65 (number -> FLOAT .)
    MINUS           reduce using rule 65 (number -> FLOAT .)
    TIMES           reduce using rule 65 (number -> FLOAT .)
    DIVIDE          reduce using rule 65 (number -> FLOAT .)
    ASSIGN          reduce using rule 65 (number -> FLOAT .)
    INCREMENT       reduce using rule 65 (number -> FLOAT .)
    DECREMENT       reduce using rule 65 (number -> FLOAT .)
    LBRACKET        reduce using rule 65 (number -> FLOAT .)
    PERIOD          reduce using rule 65 (number -> FLOAT .)
    COMMA           reduce using rule 65 (number -> FLOAT .)
    PRINT           reduce using rule 65 (number -> FLOAT .)
    PRINTF          reduce using rule 65 (number -> FLOAT .)
    INPUT           reduce using rule 65 (number -> FLOAT .)
    FUNCTION        reduce using rule 65 (number -> FLOAT .)
    VAR             reduce using rule 65 (number -> FLOAT .)
    VARIABLE        reduce using rule 65 (number -> FLOAT .)
    CONST           reduce using rule 65 (number -> FLOAT .)
    RETURN          reduce using rule 65 (number -> FLOAT .)
    TYPE            reduce using rule 65 (number -> FLOAT .)
    IF              reduce using rule 65 (number -> FLOAT .)
    SWITCH          reduce using rule 65 (number -> FLOAT .)
    CHARSTRING      reduce using rule 65 (number -> FLOAT .)
    FOR             reduce using rule 65 (number -> FLOAT .)
    INT             reduce using rule 65 (number -> FLOAT .)
    FLOAT           reduce using rule 65 (number -> FLOAT .)
    $end            reduce using rule 65 (number -> FLOAT .)
    RBRACE          reduce using rule 65 (number -> FLOAT .)
    CASE            reduce using rule 65 (number -> FLOAT .)
    DEFAULT         reduce using rule 65 (number -> FLOAT .)
    GREATER         reduce using rule 65 (number -> FLOAT .)
    LESS            reduce using rule 65 (number -> FLOAT .)
    GREATEREQUALS   reduce using rule 65 (number -> FLOAT .)
    LESSEQUALS      reduce using rule 65 (number -> FLOAT .)
    EQUALS          reduce using rule 65 (number -> FLOAT .)
    DIFFERENT       reduce using rule 65 (number -> FLOAT .)
    LBRACE          reduce using rule 65 (number -> FLOAT .)
    RBRACKET        reduce using rule 65 (number -> FLOAT .)
    RPAREN          reduce using rule 65 (number -> FLOAT .)
    COLON           reduce using rule 65 (number -> FLOAT .)
    AND             reduce using rule 65 (number -> FLOAT .)
    OR              reduce using rule 65 (number -> FLOAT .)
    NOT             reduce using rule 65 (number -> FLOAT .)
    SEMICOLON       reduce using rule 65 (number -> FLOAT .)


state 50

    (2) statement -> import blocks .

    $end            reduce using rule 2 (statement -> import blocks .)
    RBRACE          reduce using rule 2 (statement -> import blocks .)
    CASE            reduce using rule 2 (statement -> import blocks .)
    DEFAULT         reduce using rule 2 (statement -> import blocks .)


state 51

    (7) statement -> import main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 112


state 52

    (3) statement -> package blocks .

    $end            reduce using rule 3 (statement -> package blocks .)
    RBRACE          reduce using rule 3 (statement -> package blocks .)
    CASE            reduce using rule 3 (statement -> package blocks .)
    DEFAULT         reduce using rule 3 (statement -> package blocks .)


state 53

    (4) statement -> package import . blocks
    (8) statement -> package import . main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    blocks                         shift and go to state 113
    main                           shift and go to state 114
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 54

    (6) statement -> package main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 115


state 55

    (5) statement -> main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    blocks                         shift and go to state 116
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 56

    (18) blocks -> block blocks .

    $end            reduce using rule 18 (blocks -> block blocks .)
    RBRACE          reduce using rule 18 (blocks -> block blocks .)
    CASE            reduce using rule 18 (blocks -> block blocks .)
    DEFAULT         reduce using rule 18 (blocks -> block blocks .)


state 57

    (47) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE

    VARIABLE        shift and go to state 84


state 58

    (10) import -> IMPORT CHARSTRING .

    FUNCTION        reduce using rule 10 (import -> IMPORT CHARSTRING .)
    PRINT           reduce using rule 10 (import -> IMPORT CHARSTRING .)
    PRINTF          reduce using rule 10 (import -> IMPORT CHARSTRING .)
    INPUT           reduce using rule 10 (import -> IMPORT CHARSTRING .)
    VAR             reduce using rule 10 (import -> IMPORT CHARSTRING .)
    VARIABLE        reduce using rule 10 (import -> IMPORT CHARSTRING .)
    CONST           reduce using rule 10 (import -> IMPORT CHARSTRING .)
    RETURN          reduce using rule 10 (import -> IMPORT CHARSTRING .)
    TYPE            reduce using rule 10 (import -> IMPORT CHARSTRING .)
    IF              reduce using rule 10 (import -> IMPORT CHARSTRING .)
    SWITCH          reduce using rule 10 (import -> IMPORT CHARSTRING .)
    CHARSTRING      reduce using rule 10 (import -> IMPORT CHARSTRING .)
    FOR             reduce using rule 10 (import -> IMPORT CHARSTRING .)
    INT             reduce using rule 10 (import -> IMPORT CHARSTRING .)
    FLOAT           reduce using rule 10 (import -> IMPORT CHARSTRING .)


state 59

    (11) import -> IMPORT LPAREN . values_for_import RPAREN
    (12) values_for_import -> . CHARSTRING
    (13) values_for_import -> . CHARSTRING values_for_import

    CHARSTRING      shift and go to state 118

    values_for_import              shift and go to state 117

state 60

    (14) package -> PACKAGE VARIABLE .

    IMPORT          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    FUNCTION        reduce using rule 14 (package -> PACKAGE VARIABLE .)
    PRINT           reduce using rule 14 (package -> PACKAGE VARIABLE .)
    PRINTF          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    INPUT           reduce using rule 14 (package -> PACKAGE VARIABLE .)
    VAR             reduce using rule 14 (package -> PACKAGE VARIABLE .)
    VARIABLE        reduce using rule 14 (package -> PACKAGE VARIABLE .)
    CONST           reduce using rule 14 (package -> PACKAGE VARIABLE .)
    RETURN          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    TYPE            reduce using rule 14 (package -> PACKAGE VARIABLE .)
    IF              reduce using rule 14 (package -> PACKAGE VARIABLE .)
    SWITCH          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    CHARSTRING      reduce using rule 14 (package -> PACKAGE VARIABLE .)
    FOR             reduce using rule 14 (package -> PACKAGE VARIABLE .)
    INT             reduce using rule 14 (package -> PACKAGE VARIABLE .)
    FLOAT           reduce using rule 14 (package -> PACKAGE VARIABLE .)


state 61

    (15) package -> PACKAGE MAIN .

    IMPORT          reduce using rule 15 (package -> PACKAGE MAIN .)
    FUNCTION        reduce using rule 15 (package -> PACKAGE MAIN .)
    PRINT           reduce using rule 15 (package -> PACKAGE MAIN .)
    PRINTF          reduce using rule 15 (package -> PACKAGE MAIN .)
    INPUT           reduce using rule 15 (package -> PACKAGE MAIN .)
    VAR             reduce using rule 15 (package -> PACKAGE MAIN .)
    VARIABLE        reduce using rule 15 (package -> PACKAGE MAIN .)
    CONST           reduce using rule 15 (package -> PACKAGE MAIN .)
    RETURN          reduce using rule 15 (package -> PACKAGE MAIN .)
    TYPE            reduce using rule 15 (package -> PACKAGE MAIN .)
    IF              reduce using rule 15 (package -> PACKAGE MAIN .)
    SWITCH          reduce using rule 15 (package -> PACKAGE MAIN .)
    CHARSTRING      reduce using rule 15 (package -> PACKAGE MAIN .)
    FOR             reduce using rule 15 (package -> PACKAGE MAIN .)
    INT             reduce using rule 15 (package -> PACKAGE MAIN .)
    FLOAT           reduce using rule 15 (package -> PACKAGE MAIN .)


state 62

    (31) variable_declaration -> VARIABLE SHORTASSIGN . value
    (32) variable_declaration -> VARIABLE SHORTASSIGN . operation
    (140) map_structure -> VARIABLE SHORTASSIGN . MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> VARIABLE SHORTASSIGN . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> VARIABLE SHORTASSIGN . LBRACKET RBRACKET type LBRACE values RBRACE
    (148) slice_structure -> VARIABLE SHORTASSIGN . LBRACKET RBRACKET type
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    MAP             shift and go to state 121
    MAKE            shift and go to state 123
    LBRACKET        shift and go to state 122
    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    value                          shift and go to state 119
    operation                      shift and go to state 120
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 63

    (34) variable_assignation -> VARIABLE assignation . value
    (35) variable_assignation -> VARIABLE assignation . operation
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    value                          shift and go to state 124
    operation                      shift and go to state 125
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 64

    (36) variable_assignation -> VARIABLE double_operator .

    PRINT           reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    PRINTF          reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    INPUT           reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    FUNCTION        reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    VAR             reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    VARIABLE        reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    CONST           reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    RETURN          reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    TYPE            reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    IF              reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    SWITCH          reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    CHARSTRING      reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    FOR             reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    INT             reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    FLOAT           reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    $end            reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    RBRACE          reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    CASE            reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)
    DEFAULT         reduce using rule 36 (variable_assignation -> VARIABLE double_operator .)


state 65

    (145) map_assign -> VARIABLE LBRACKET . value RBRACKET ASSIGN value
    (139) array_assign -> VARIABLE LBRACKET . INT RBRACKET ASSIGN value
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    INT             shift and go to state 127
    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    FLOAT           shift and go to state 49

    value                          shift and go to state 126
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 66

    (85) parameter -> VARIABLE type .

    COMMA           reduce using rule 85 (parameter -> VARIABLE type .)
    PRINT           reduce using rule 85 (parameter -> VARIABLE type .)
    PRINTF          reduce using rule 85 (parameter -> VARIABLE type .)
    INPUT           reduce using rule 85 (parameter -> VARIABLE type .)
    FUNCTION        reduce using rule 85 (parameter -> VARIABLE type .)
    VAR             reduce using rule 85 (parameter -> VARIABLE type .)
    VARIABLE        reduce using rule 85 (parameter -> VARIABLE type .)
    CONST           reduce using rule 85 (parameter -> VARIABLE type .)
    RETURN          reduce using rule 85 (parameter -> VARIABLE type .)
    TYPE            reduce using rule 85 (parameter -> VARIABLE type .)
    IF              reduce using rule 85 (parameter -> VARIABLE type .)
    SWITCH          reduce using rule 85 (parameter -> VARIABLE type .)
    CHARSTRING      reduce using rule 85 (parameter -> VARIABLE type .)
    FOR             reduce using rule 85 (parameter -> VARIABLE type .)
    INT             reduce using rule 85 (parameter -> VARIABLE type .)
    FLOAT           reduce using rule 85 (parameter -> VARIABLE type .)
    $end            reduce using rule 85 (parameter -> VARIABLE type .)
    RBRACE          reduce using rule 85 (parameter -> VARIABLE type .)
    CASE            reduce using rule 85 (parameter -> VARIABLE type .)
    DEFAULT         reduce using rule 85 (parameter -> VARIABLE type .)
    RPAREN          reduce using rule 85 (parameter -> VARIABLE type .)


state 67

    (149) slice_structure -> VARIABLE ASSIGN . append_statement
    (41) assignation -> ASSIGN .
    (150) append_statement -> . APPEND LPAREN VARIABLE COMMA values RPAREN
    (151) append_statement -> . APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN

    VARIABLE        reduce using rule 41 (assignation -> ASSIGN .)
    CHARSTRING      reduce using rule 41 (assignation -> ASSIGN .)
    INT             reduce using rule 41 (assignation -> ASSIGN .)
    FLOAT           reduce using rule 41 (assignation -> ASSIGN .)
    APPEND          shift and go to state 129

    append_statement               shift and go to state 128

state 68

    (86) type -> INT .

    COMMA           reduce using rule 86 (type -> INT .)
    PRINT           reduce using rule 86 (type -> INT .)
    PRINTF          reduce using rule 86 (type -> INT .)
    INPUT           reduce using rule 86 (type -> INT .)
    FUNCTION        reduce using rule 86 (type -> INT .)
    VAR             reduce using rule 86 (type -> INT .)
    VARIABLE        reduce using rule 86 (type -> INT .)
    CONST           reduce using rule 86 (type -> INT .)
    RETURN          reduce using rule 86 (type -> INT .)
    TYPE            reduce using rule 86 (type -> INT .)
    IF              reduce using rule 86 (type -> INT .)
    SWITCH          reduce using rule 86 (type -> INT .)
    CHARSTRING      reduce using rule 86 (type -> INT .)
    FOR             reduce using rule 86 (type -> INT .)
    INT             reduce using rule 86 (type -> INT .)
    FLOAT           reduce using rule 86 (type -> INT .)
    $end            reduce using rule 86 (type -> INT .)
    RBRACE          reduce using rule 86 (type -> INT .)
    CASE            reduce using rule 86 (type -> INT .)
    DEFAULT         reduce using rule 86 (type -> INT .)
    ASSIGN          reduce using rule 86 (type -> INT .)
    RPAREN          reduce using rule 86 (type -> INT .)
    RBRACKET        reduce using rule 86 (type -> INT .)
    LBRACE          reduce using rule 86 (type -> INT .)


state 69

    (42) assignation -> PLUSASSIGN .

    VARIABLE        reduce using rule 42 (assignation -> PLUSASSIGN .)
    CHARSTRING      reduce using rule 42 (assignation -> PLUSASSIGN .)
    INT             reduce using rule 42 (assignation -> PLUSASSIGN .)
    FLOAT           reduce using rule 42 (assignation -> PLUSASSIGN .)


state 70

    (43) assignation -> MINUSASSIGN .

    VARIABLE        reduce using rule 43 (assignation -> MINUSASSIGN .)
    CHARSTRING      reduce using rule 43 (assignation -> MINUSASSIGN .)
    INT             reduce using rule 43 (assignation -> MINUSASSIGN .)
    FLOAT           reduce using rule 43 (assignation -> MINUSASSIGN .)


state 71

    (44) assignation -> TIMESASSIGN .

    VARIABLE        reduce using rule 44 (assignation -> TIMESASSIGN .)
    CHARSTRING      reduce using rule 44 (assignation -> TIMESASSIGN .)
    INT             reduce using rule 44 (assignation -> TIMESASSIGN .)
    FLOAT           reduce using rule 44 (assignation -> TIMESASSIGN .)


state 72

    (45) assignation -> DIVIDEASSIGN .

    VARIABLE        reduce using rule 45 (assignation -> DIVIDEASSIGN .)
    CHARSTRING      reduce using rule 45 (assignation -> DIVIDEASSIGN .)
    INT             reduce using rule 45 (assignation -> DIVIDEASSIGN .)
    FLOAT           reduce using rule 45 (assignation -> DIVIDEASSIGN .)


state 73

    (46) assignation -> MODASSIGN .

    VARIABLE        reduce using rule 46 (assignation -> MODASSIGN .)
    CHARSTRING      reduce using rule 46 (assignation -> MODASSIGN .)
    INT             reduce using rule 46 (assignation -> MODASSIGN .)
    FLOAT           reduce using rule 46 (assignation -> MODASSIGN .)


state 74

    (81) double_operator -> INCREMENT .

    PRINT           reduce using rule 81 (double_operator -> INCREMENT .)
    PRINTF          reduce using rule 81 (double_operator -> INCREMENT .)
    INPUT           reduce using rule 81 (double_operator -> INCREMENT .)
    FUNCTION        reduce using rule 81 (double_operator -> INCREMENT .)
    VAR             reduce using rule 81 (double_operator -> INCREMENT .)
    VARIABLE        reduce using rule 81 (double_operator -> INCREMENT .)
    CONST           reduce using rule 81 (double_operator -> INCREMENT .)
    RETURN          reduce using rule 81 (double_operator -> INCREMENT .)
    TYPE            reduce using rule 81 (double_operator -> INCREMENT .)
    IF              reduce using rule 81 (double_operator -> INCREMENT .)
    SWITCH          reduce using rule 81 (double_operator -> INCREMENT .)
    CHARSTRING      reduce using rule 81 (double_operator -> INCREMENT .)
    FOR             reduce using rule 81 (double_operator -> INCREMENT .)
    INT             reduce using rule 81 (double_operator -> INCREMENT .)
    FLOAT           reduce using rule 81 (double_operator -> INCREMENT .)
    $end            reduce using rule 81 (double_operator -> INCREMENT .)
    RBRACE          reduce using rule 81 (double_operator -> INCREMENT .)
    CASE            reduce using rule 81 (double_operator -> INCREMENT .)
    DEFAULT         reduce using rule 81 (double_operator -> INCREMENT .)
    RPAREN          reduce using rule 81 (double_operator -> INCREMENT .)
    LBRACE          reduce using rule 81 (double_operator -> INCREMENT .)


state 75

    (82) double_operator -> DECREMENT .

    PRINT           reduce using rule 82 (double_operator -> DECREMENT .)
    PRINTF          reduce using rule 82 (double_operator -> DECREMENT .)
    INPUT           reduce using rule 82 (double_operator -> DECREMENT .)
    FUNCTION        reduce using rule 82 (double_operator -> DECREMENT .)
    VAR             reduce using rule 82 (double_operator -> DECREMENT .)
    VARIABLE        reduce using rule 82 (double_operator -> DECREMENT .)
    CONST           reduce using rule 82 (double_operator -> DECREMENT .)
    RETURN          reduce using rule 82 (double_operator -> DECREMENT .)
    TYPE            reduce using rule 82 (double_operator -> DECREMENT .)
    IF              reduce using rule 82 (double_operator -> DECREMENT .)
    SWITCH          reduce using rule 82 (double_operator -> DECREMENT .)
    CHARSTRING      reduce using rule 82 (double_operator -> DECREMENT .)
    FOR             reduce using rule 82 (double_operator -> DECREMENT .)
    INT             reduce using rule 82 (double_operator -> DECREMENT .)
    FLOAT           reduce using rule 82 (double_operator -> DECREMENT .)
    $end            reduce using rule 82 (double_operator -> DECREMENT .)
    RBRACE          reduce using rule 82 (double_operator -> DECREMENT .)
    CASE            reduce using rule 82 (double_operator -> DECREMENT .)
    DEFAULT         reduce using rule 82 (double_operator -> DECREMENT .)
    RPAREN          reduce using rule 82 (double_operator -> DECREMENT .)
    LBRACE          reduce using rule 82 (double_operator -> DECREMENT .)


state 76

    (87) type -> INT32 .

    COMMA           reduce using rule 87 (type -> INT32 .)
    PRINT           reduce using rule 87 (type -> INT32 .)
    PRINTF          reduce using rule 87 (type -> INT32 .)
    INPUT           reduce using rule 87 (type -> INT32 .)
    FUNCTION        reduce using rule 87 (type -> INT32 .)
    VAR             reduce using rule 87 (type -> INT32 .)
    VARIABLE        reduce using rule 87 (type -> INT32 .)
    CONST           reduce using rule 87 (type -> INT32 .)
    RETURN          reduce using rule 87 (type -> INT32 .)
    TYPE            reduce using rule 87 (type -> INT32 .)
    IF              reduce using rule 87 (type -> INT32 .)
    SWITCH          reduce using rule 87 (type -> INT32 .)
    CHARSTRING      reduce using rule 87 (type -> INT32 .)
    FOR             reduce using rule 87 (type -> INT32 .)
    INT             reduce using rule 87 (type -> INT32 .)
    FLOAT           reduce using rule 87 (type -> INT32 .)
    $end            reduce using rule 87 (type -> INT32 .)
    RBRACE          reduce using rule 87 (type -> INT32 .)
    CASE            reduce using rule 87 (type -> INT32 .)
    DEFAULT         reduce using rule 87 (type -> INT32 .)
    ASSIGN          reduce using rule 87 (type -> INT32 .)
    RPAREN          reduce using rule 87 (type -> INT32 .)
    RBRACKET        reduce using rule 87 (type -> INT32 .)
    LBRACE          reduce using rule 87 (type -> INT32 .)


state 77

    (88) type -> INT64 .

    COMMA           reduce using rule 88 (type -> INT64 .)
    PRINT           reduce using rule 88 (type -> INT64 .)
    PRINTF          reduce using rule 88 (type -> INT64 .)
    INPUT           reduce using rule 88 (type -> INT64 .)
    FUNCTION        reduce using rule 88 (type -> INT64 .)
    VAR             reduce using rule 88 (type -> INT64 .)
    VARIABLE        reduce using rule 88 (type -> INT64 .)
    CONST           reduce using rule 88 (type -> INT64 .)
    RETURN          reduce using rule 88 (type -> INT64 .)
    TYPE            reduce using rule 88 (type -> INT64 .)
    IF              reduce using rule 88 (type -> INT64 .)
    SWITCH          reduce using rule 88 (type -> INT64 .)
    CHARSTRING      reduce using rule 88 (type -> INT64 .)
    FOR             reduce using rule 88 (type -> INT64 .)
    INT             reduce using rule 88 (type -> INT64 .)
    FLOAT           reduce using rule 88 (type -> INT64 .)
    $end            reduce using rule 88 (type -> INT64 .)
    RBRACE          reduce using rule 88 (type -> INT64 .)
    CASE            reduce using rule 88 (type -> INT64 .)
    DEFAULT         reduce using rule 88 (type -> INT64 .)
    ASSIGN          reduce using rule 88 (type -> INT64 .)
    RPAREN          reduce using rule 88 (type -> INT64 .)
    RBRACKET        reduce using rule 88 (type -> INT64 .)
    LBRACE          reduce using rule 88 (type -> INT64 .)


state 78

    (89) type -> STRING .

    COMMA           reduce using rule 89 (type -> STRING .)
    PRINT           reduce using rule 89 (type -> STRING .)
    PRINTF          reduce using rule 89 (type -> STRING .)
    INPUT           reduce using rule 89 (type -> STRING .)
    FUNCTION        reduce using rule 89 (type -> STRING .)
    VAR             reduce using rule 89 (type -> STRING .)
    VARIABLE        reduce using rule 89 (type -> STRING .)
    CONST           reduce using rule 89 (type -> STRING .)
    RETURN          reduce using rule 89 (type -> STRING .)
    TYPE            reduce using rule 89 (type -> STRING .)
    IF              reduce using rule 89 (type -> STRING .)
    SWITCH          reduce using rule 89 (type -> STRING .)
    CHARSTRING      reduce using rule 89 (type -> STRING .)
    FOR             reduce using rule 89 (type -> STRING .)
    INT             reduce using rule 89 (type -> STRING .)
    FLOAT           reduce using rule 89 (type -> STRING .)
    $end            reduce using rule 89 (type -> STRING .)
    RBRACE          reduce using rule 89 (type -> STRING .)
    CASE            reduce using rule 89 (type -> STRING .)
    DEFAULT         reduce using rule 89 (type -> STRING .)
    ASSIGN          reduce using rule 89 (type -> STRING .)
    RPAREN          reduce using rule 89 (type -> STRING .)
    RBRACKET        reduce using rule 89 (type -> STRING .)
    LBRACE          reduce using rule 89 (type -> STRING .)


state 79

    (90) type -> FLOAT .

    COMMA           reduce using rule 90 (type -> FLOAT .)
    PRINT           reduce using rule 90 (type -> FLOAT .)
    PRINTF          reduce using rule 90 (type -> FLOAT .)
    INPUT           reduce using rule 90 (type -> FLOAT .)
    FUNCTION        reduce using rule 90 (type -> FLOAT .)
    VAR             reduce using rule 90 (type -> FLOAT .)
    VARIABLE        reduce using rule 90 (type -> FLOAT .)
    CONST           reduce using rule 90 (type -> FLOAT .)
    RETURN          reduce using rule 90 (type -> FLOAT .)
    TYPE            reduce using rule 90 (type -> FLOAT .)
    IF              reduce using rule 90 (type -> FLOAT .)
    SWITCH          reduce using rule 90 (type -> FLOAT .)
    CHARSTRING      reduce using rule 90 (type -> FLOAT .)
    FOR             reduce using rule 90 (type -> FLOAT .)
    INT             reduce using rule 90 (type -> FLOAT .)
    FLOAT           reduce using rule 90 (type -> FLOAT .)
    $end            reduce using rule 90 (type -> FLOAT .)
    RBRACE          reduce using rule 90 (type -> FLOAT .)
    CASE            reduce using rule 90 (type -> FLOAT .)
    DEFAULT         reduce using rule 90 (type -> FLOAT .)
    ASSIGN          reduce using rule 90 (type -> FLOAT .)
    RPAREN          reduce using rule 90 (type -> FLOAT .)
    RBRACKET        reduce using rule 90 (type -> FLOAT .)
    LBRACE          reduce using rule 90 (type -> FLOAT .)


state 80

    (91) type -> FLOAT32 .

    COMMA           reduce using rule 91 (type -> FLOAT32 .)
    PRINT           reduce using rule 91 (type -> FLOAT32 .)
    PRINTF          reduce using rule 91 (type -> FLOAT32 .)
    INPUT           reduce using rule 91 (type -> FLOAT32 .)
    FUNCTION        reduce using rule 91 (type -> FLOAT32 .)
    VAR             reduce using rule 91 (type -> FLOAT32 .)
    VARIABLE        reduce using rule 91 (type -> FLOAT32 .)
    CONST           reduce using rule 91 (type -> FLOAT32 .)
    RETURN          reduce using rule 91 (type -> FLOAT32 .)
    TYPE            reduce using rule 91 (type -> FLOAT32 .)
    IF              reduce using rule 91 (type -> FLOAT32 .)
    SWITCH          reduce using rule 91 (type -> FLOAT32 .)
    CHARSTRING      reduce using rule 91 (type -> FLOAT32 .)
    FOR             reduce using rule 91 (type -> FLOAT32 .)
    INT             reduce using rule 91 (type -> FLOAT32 .)
    FLOAT           reduce using rule 91 (type -> FLOAT32 .)
    $end            reduce using rule 91 (type -> FLOAT32 .)
    RBRACE          reduce using rule 91 (type -> FLOAT32 .)
    CASE            reduce using rule 91 (type -> FLOAT32 .)
    DEFAULT         reduce using rule 91 (type -> FLOAT32 .)
    ASSIGN          reduce using rule 91 (type -> FLOAT32 .)
    RPAREN          reduce using rule 91 (type -> FLOAT32 .)
    RBRACKET        reduce using rule 91 (type -> FLOAT32 .)
    LBRACE          reduce using rule 91 (type -> FLOAT32 .)


state 81

    (92) type -> FLOAT64 .

    COMMA           reduce using rule 92 (type -> FLOAT64 .)
    PRINT           reduce using rule 92 (type -> FLOAT64 .)
    PRINTF          reduce using rule 92 (type -> FLOAT64 .)
    INPUT           reduce using rule 92 (type -> FLOAT64 .)
    FUNCTION        reduce using rule 92 (type -> FLOAT64 .)
    VAR             reduce using rule 92 (type -> FLOAT64 .)
    VARIABLE        reduce using rule 92 (type -> FLOAT64 .)
    CONST           reduce using rule 92 (type -> FLOAT64 .)
    RETURN          reduce using rule 92 (type -> FLOAT64 .)
    TYPE            reduce using rule 92 (type -> FLOAT64 .)
    IF              reduce using rule 92 (type -> FLOAT64 .)
    SWITCH          reduce using rule 92 (type -> FLOAT64 .)
    CHARSTRING      reduce using rule 92 (type -> FLOAT64 .)
    FOR             reduce using rule 92 (type -> FLOAT64 .)
    INT             reduce using rule 92 (type -> FLOAT64 .)
    FLOAT           reduce using rule 92 (type -> FLOAT64 .)
    $end            reduce using rule 92 (type -> FLOAT64 .)
    RBRACE          reduce using rule 92 (type -> FLOAT64 .)
    CASE            reduce using rule 92 (type -> FLOAT64 .)
    DEFAULT         reduce using rule 92 (type -> FLOAT64 .)
    ASSIGN          reduce using rule 92 (type -> FLOAT64 .)
    RPAREN          reduce using rule 92 (type -> FLOAT64 .)
    RBRACKET        reduce using rule 92 (type -> FLOAT64 .)
    LBRACE          reduce using rule 92 (type -> FLOAT64 .)


state 82

    (93) type -> BOOL .

    COMMA           reduce using rule 93 (type -> BOOL .)
    PRINT           reduce using rule 93 (type -> BOOL .)
    PRINTF          reduce using rule 93 (type -> BOOL .)
    INPUT           reduce using rule 93 (type -> BOOL .)
    FUNCTION        reduce using rule 93 (type -> BOOL .)
    VAR             reduce using rule 93 (type -> BOOL .)
    VARIABLE        reduce using rule 93 (type -> BOOL .)
    CONST           reduce using rule 93 (type -> BOOL .)
    RETURN          reduce using rule 93 (type -> BOOL .)
    TYPE            reduce using rule 93 (type -> BOOL .)
    IF              reduce using rule 93 (type -> BOOL .)
    SWITCH          reduce using rule 93 (type -> BOOL .)
    CHARSTRING      reduce using rule 93 (type -> BOOL .)
    FOR             reduce using rule 93 (type -> BOOL .)
    INT             reduce using rule 93 (type -> BOOL .)
    FLOAT           reduce using rule 93 (type -> BOOL .)
    $end            reduce using rule 93 (type -> BOOL .)
    RBRACE          reduce using rule 93 (type -> BOOL .)
    CASE            reduce using rule 93 (type -> BOOL .)
    DEFAULT         reduce using rule 93 (type -> BOOL .)
    ASSIGN          reduce using rule 93 (type -> BOOL .)
    RPAREN          reduce using rule 93 (type -> BOOL .)
    RBRACKET        reduce using rule 93 (type -> BOOL .)
    LBRACE          reduce using rule 93 (type -> BOOL .)


state 83

    (16) main -> FUNCTION MAIN . LPAREN RPAREN

    LPAREN          shift and go to state 130


state 84

    (47) function -> FUNCTION VARIABLE . LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> FUNCTION VARIABLE . LPAREN RPAREN type LBRACE RBRACE
    (50) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> FUNCTION VARIABLE . LPAREN RPAREN type LBRACE blocks RBRACE

    LPAREN          shift and go to state 131


state 85

    (66) print_statement -> PRINT LPAREN . values RPAREN
    (68) print_statement -> PRINT LPAREN . operation RPAREN
    (69) print_statement -> PRINT LPAREN . RPAREN
    (58) values -> . value
    (59) values -> . value COMMA values
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    RPAREN          shift and go to state 133
    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    values                         shift and go to state 132
    operation                      shift and go to state 134
    value                          shift and go to state 135
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 86

    (67) print_statement -> PRINTF LPAREN . FORMATSTRING COMMA values RPAREN

    FORMATSTRING    shift and go to state 136


state 87

    (70) input_statement -> INPUT LPAREN . values RPAREN
    (71) input_statement -> INPUT LPAREN . operation RPAREN
    (72) input_statement -> INPUT LPAREN . RPAREN
    (58) values -> . value
    (59) values -> . value COMMA values
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    RPAREN          shift and go to state 138
    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    values                         shift and go to state 137
    operation                      shift and go to state 139
    value                          shift and go to state 135
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 88

    (73) operation -> value operator . value
    (74) operation -> value operator . operation
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    value                          shift and go to state 140
    operation                      shift and go to state 141
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 89

    (75) operation -> value double_operator .

    PRINT           reduce using rule 75 (operation -> value double_operator .)
    PRINTF          reduce using rule 75 (operation -> value double_operator .)
    INPUT           reduce using rule 75 (operation -> value double_operator .)
    FUNCTION        reduce using rule 75 (operation -> value double_operator .)
    VAR             reduce using rule 75 (operation -> value double_operator .)
    VARIABLE        reduce using rule 75 (operation -> value double_operator .)
    CONST           reduce using rule 75 (operation -> value double_operator .)
    RETURN          reduce using rule 75 (operation -> value double_operator .)
    TYPE            reduce using rule 75 (operation -> value double_operator .)
    IF              reduce using rule 75 (operation -> value double_operator .)
    SWITCH          reduce using rule 75 (operation -> value double_operator .)
    CHARSTRING      reduce using rule 75 (operation -> value double_operator .)
    FOR             reduce using rule 75 (operation -> value double_operator .)
    INT             reduce using rule 75 (operation -> value double_operator .)
    FLOAT           reduce using rule 75 (operation -> value double_operator .)
    $end            reduce using rule 75 (operation -> value double_operator .)
    RBRACE          reduce using rule 75 (operation -> value double_operator .)
    CASE            reduce using rule 75 (operation -> value double_operator .)
    DEFAULT         reduce using rule 75 (operation -> value double_operator .)
    RPAREN          reduce using rule 75 (operation -> value double_operator .)


state 90

    (76) operator -> PLUS .

    VARIABLE        reduce using rule 76 (operator -> PLUS .)
    CHARSTRING      reduce using rule 76 (operator -> PLUS .)
    INT             reduce using rule 76 (operator -> PLUS .)
    FLOAT           reduce using rule 76 (operator -> PLUS .)


state 91

    (77) operator -> MINUS .

    VARIABLE        reduce using rule 77 (operator -> MINUS .)
    CHARSTRING      reduce using rule 77 (operator -> MINUS .)
    INT             reduce using rule 77 (operator -> MINUS .)
    FLOAT           reduce using rule 77 (operator -> MINUS .)


state 92

    (78) operator -> TIMES .

    VARIABLE        reduce using rule 78 (operator -> TIMES .)
    CHARSTRING      reduce using rule 78 (operator -> TIMES .)
    INT             reduce using rule 78 (operator -> TIMES .)
    FLOAT           reduce using rule 78 (operator -> TIMES .)


state 93

    (79) operator -> DIVIDE .

    VARIABLE        reduce using rule 79 (operator -> DIVIDE .)
    CHARSTRING      reduce using rule 79 (operator -> DIVIDE .)
    INT             reduce using rule 79 (operator -> DIVIDE .)
    FLOAT           reduce using rule 79 (operator -> DIVIDE .)


state 94

    (80) operator -> ASSIGN .

    VARIABLE        reduce using rule 80 (operator -> ASSIGN .)
    CHARSTRING      reduce using rule 80 (operator -> ASSIGN .)
    INT             reduce using rule 80 (operator -> ASSIGN .)
    FLOAT           reduce using rule 80 (operator -> ASSIGN .)


state 95

    (84) parameters -> parameter COMMA . parameters
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (85) parameter -> . VARIABLE type

    VARIABLE        shift and go to state 143

    parameter                      shift and go to state 33
    parameters                     shift and go to state 142

state 96

    (29) variable_declaration -> VAR VARIABLE . type
    (30) variable_declaration -> VAR VARIABLE . type ASSIGN value
    (137) array_structure -> VAR VARIABLE . LBRACKET INT RBRACKET type
    (138) array_structure -> VAR VARIABLE . ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> VAR VARIABLE . LBRACKET RBRACKET type
    (86) type -> . INT
    (87) type -> . INT32
    (88) type -> . INT64
    (89) type -> . STRING
    (90) type -> . FLOAT
    (91) type -> . FLOAT32
    (92) type -> . FLOAT64
    (93) type -> . BOOL

    LBRACKET        shift and go to state 146
    ASSIGN          shift and go to state 145
    INT             shift and go to state 68
    INT32           shift and go to state 76
    INT64           shift and go to state 77
    STRING          shift and go to state 78
    FLOAT           shift and go to state 79
    FLOAT32         shift and go to state 80
    FLOAT64         shift and go to state 81
    BOOL            shift and go to state 82

    type                           shift and go to state 144

state 97

    (33) variable_declaration -> CONST VARIABLE . ASSIGN value

    ASSIGN          shift and go to state 147


state 98

    (53) return -> RETURN values .

    PRINT           reduce using rule 53 (return -> RETURN values .)
    PRINTF          reduce using rule 53 (return -> RETURN values .)
    INPUT           reduce using rule 53 (return -> RETURN values .)
    FUNCTION        reduce using rule 53 (return -> RETURN values .)
    VAR             reduce using rule 53 (return -> RETURN values .)
    VARIABLE        reduce using rule 53 (return -> RETURN values .)
    CONST           reduce using rule 53 (return -> RETURN values .)
    RETURN          reduce using rule 53 (return -> RETURN values .)
    TYPE            reduce using rule 53 (return -> RETURN values .)
    IF              reduce using rule 53 (return -> RETURN values .)
    SWITCH          reduce using rule 53 (return -> RETURN values .)
    CHARSTRING      reduce using rule 53 (return -> RETURN values .)
    FOR             reduce using rule 53 (return -> RETURN values .)
    INT             reduce using rule 53 (return -> RETURN values .)
    FLOAT           reduce using rule 53 (return -> RETURN values .)
    $end            reduce using rule 53 (return -> RETURN values .)
    RBRACE          reduce using rule 53 (return -> RETURN values .)
    CASE            reduce using rule 53 (return -> RETURN values .)
    DEFAULT         reduce using rule 53 (return -> RETURN values .)


state 99

    (54) return -> RETURN value . LBRACKET value RBRACKET
    (55) return -> RETURN value . PERIOD value
    (58) values -> value .
    (59) values -> value . COMMA values

    LBRACKET        shift and go to state 148
    PERIOD          shift and go to state 149
    PRINT           reduce using rule 58 (values -> value .)
    PRINTF          reduce using rule 58 (values -> value .)
    INPUT           reduce using rule 58 (values -> value .)
    FUNCTION        reduce using rule 58 (values -> value .)
    VAR             reduce using rule 58 (values -> value .)
    VARIABLE        reduce using rule 58 (values -> value .)
    CONST           reduce using rule 58 (values -> value .)
    RETURN          reduce using rule 58 (values -> value .)
    TYPE            reduce using rule 58 (values -> value .)
    IF              reduce using rule 58 (values -> value .)
    SWITCH          reduce using rule 58 (values -> value .)
    CHARSTRING      reduce using rule 58 (values -> value .)
    FOR             reduce using rule 58 (values -> value .)
    INT             reduce using rule 58 (values -> value .)
    FLOAT           reduce using rule 58 (values -> value .)
    $end            reduce using rule 58 (values -> value .)
    RBRACE          reduce using rule 58 (values -> value .)
    CASE            reduce using rule 58 (values -> value .)
    DEFAULT         reduce using rule 58 (values -> value .)
    COMMA           shift and go to state 150


state 100

    (56) return -> RETURN TRUE .

    PRINT           reduce using rule 56 (return -> RETURN TRUE .)
    PRINTF          reduce using rule 56 (return -> RETURN TRUE .)
    INPUT           reduce using rule 56 (return -> RETURN TRUE .)
    FUNCTION        reduce using rule 56 (return -> RETURN TRUE .)
    VAR             reduce using rule 56 (return -> RETURN TRUE .)
    VARIABLE        reduce using rule 56 (return -> RETURN TRUE .)
    CONST           reduce using rule 56 (return -> RETURN TRUE .)
    RETURN          reduce using rule 56 (return -> RETURN TRUE .)
    TYPE            reduce using rule 56 (return -> RETURN TRUE .)
    IF              reduce using rule 56 (return -> RETURN TRUE .)
    SWITCH          reduce using rule 56 (return -> RETURN TRUE .)
    CHARSTRING      reduce using rule 56 (return -> RETURN TRUE .)
    FOR             reduce using rule 56 (return -> RETURN TRUE .)
    INT             reduce using rule 56 (return -> RETURN TRUE .)
    FLOAT           reduce using rule 56 (return -> RETURN TRUE .)
    $end            reduce using rule 56 (return -> RETURN TRUE .)
    RBRACE          reduce using rule 56 (return -> RETURN TRUE .)
    CASE            reduce using rule 56 (return -> RETURN TRUE .)
    DEFAULT         reduce using rule 56 (return -> RETURN TRUE .)


state 101

    (57) return -> RETURN FALSE .

    PRINT           reduce using rule 57 (return -> RETURN FALSE .)
    PRINTF          reduce using rule 57 (return -> RETURN FALSE .)
    INPUT           reduce using rule 57 (return -> RETURN FALSE .)
    FUNCTION        reduce using rule 57 (return -> RETURN FALSE .)
    VAR             reduce using rule 57 (return -> RETURN FALSE .)
    VARIABLE        reduce using rule 57 (return -> RETURN FALSE .)
    CONST           reduce using rule 57 (return -> RETURN FALSE .)
    RETURN          reduce using rule 57 (return -> RETURN FALSE .)
    TYPE            reduce using rule 57 (return -> RETURN FALSE .)
    IF              reduce using rule 57 (return -> RETURN FALSE .)
    SWITCH          reduce using rule 57 (return -> RETURN FALSE .)
    CHARSTRING      reduce using rule 57 (return -> RETURN FALSE .)
    FOR             reduce using rule 57 (return -> RETURN FALSE .)
    INT             reduce using rule 57 (return -> RETURN FALSE .)
    FLOAT           reduce using rule 57 (return -> RETURN FALSE .)
    $end            reduce using rule 57 (return -> RETURN FALSE .)
    RBRACE          reduce using rule 57 (return -> RETURN FALSE .)
    CASE            reduce using rule 57 (return -> RETURN FALSE .)
    DEFAULT         reduce using rule 57 (return -> RETURN FALSE .)


state 102

    (60) value -> VARIABLE .

    LBRACKET        reduce using rule 60 (value -> VARIABLE .)
    PERIOD          reduce using rule 60 (value -> VARIABLE .)
    COMMA           reduce using rule 60 (value -> VARIABLE .)
    PRINT           reduce using rule 60 (value -> VARIABLE .)
    PRINTF          reduce using rule 60 (value -> VARIABLE .)
    INPUT           reduce using rule 60 (value -> VARIABLE .)
    FUNCTION        reduce using rule 60 (value -> VARIABLE .)
    VAR             reduce using rule 60 (value -> VARIABLE .)
    VARIABLE        reduce using rule 60 (value -> VARIABLE .)
    CONST           reduce using rule 60 (value -> VARIABLE .)
    RETURN          reduce using rule 60 (value -> VARIABLE .)
    TYPE            reduce using rule 60 (value -> VARIABLE .)
    IF              reduce using rule 60 (value -> VARIABLE .)
    SWITCH          reduce using rule 60 (value -> VARIABLE .)
    CHARSTRING      reduce using rule 60 (value -> VARIABLE .)
    FOR             reduce using rule 60 (value -> VARIABLE .)
    INT             reduce using rule 60 (value -> VARIABLE .)
    FLOAT           reduce using rule 60 (value -> VARIABLE .)
    $end            reduce using rule 60 (value -> VARIABLE .)
    RBRACE          reduce using rule 60 (value -> VARIABLE .)
    CASE            reduce using rule 60 (value -> VARIABLE .)
    DEFAULT         reduce using rule 60 (value -> VARIABLE .)
    GREATER         reduce using rule 60 (value -> VARIABLE .)
    LESS            reduce using rule 60 (value -> VARIABLE .)
    GREATEREQUALS   reduce using rule 60 (value -> VARIABLE .)
    LESSEQUALS      reduce using rule 60 (value -> VARIABLE .)
    EQUALS          reduce using rule 60 (value -> VARIABLE .)
    DIFFERENT       reduce using rule 60 (value -> VARIABLE .)
    LBRACE          reduce using rule 60 (value -> VARIABLE .)
    PLUS            reduce using rule 60 (value -> VARIABLE .)
    MINUS           reduce using rule 60 (value -> VARIABLE .)
    TIMES           reduce using rule 60 (value -> VARIABLE .)
    DIVIDE          reduce using rule 60 (value -> VARIABLE .)
    ASSIGN          reduce using rule 60 (value -> VARIABLE .)
    INCREMENT       reduce using rule 60 (value -> VARIABLE .)
    DECREMENT       reduce using rule 60 (value -> VARIABLE .)
    RBRACKET        reduce using rule 60 (value -> VARIABLE .)
    RPAREN          reduce using rule 60 (value -> VARIABLE .)
    COLON           reduce using rule 60 (value -> VARIABLE .)
    AND             reduce using rule 60 (value -> VARIABLE .)
    OR              reduce using rule 60 (value -> VARIABLE .)
    NOT             reduce using rule 60 (value -> VARIABLE .)
    SEMICOLON       reduce using rule 60 (value -> VARIABLE .)


state 103

    (133) struct_structure -> TYPE VARIABLE . STRUCT LBRACE struct_fields RBRACE

    STRUCT          shift and go to state 151


state 104

    (97) conditional_structure -> IF conditions . conditional_body
    (98) conditional_structure -> IF conditions . conditional_body ELSE conditional_body
    (99) conditional_structure -> IF conditions . conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (100) conditional_body -> . LBRACE statement RBRACE
    (101) conditional_body -> . LBRACE BREAK RBRACE
    (102) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 153

    conditional_body               shift and go to state 152

state 105

    (103) conditions -> condition .
    (104) conditions -> condition . logical_operator conditions
    (106) logical_operator -> . AND
    (107) logical_operator -> . OR
    (108) logical_operator -> . NOT

    LBRACE          reduce using rule 103 (conditions -> condition .)
    AND             shift and go to state 155
    OR              shift and go to state 156
    NOT             shift and go to state 157

    logical_operator               shift and go to state 154

state 106

    (105) condition -> value . relational_operator value
    (109) relational_operator -> . GREATER
    (110) relational_operator -> . LESS
    (111) relational_operator -> . GREATEREQUALS
    (112) relational_operator -> . LESSEQUALS
    (113) relational_operator -> . EQUALS
    (114) relational_operator -> . DIFFERENT

    GREATER         shift and go to state 159
    LESS            shift and go to state 160
    GREATEREQUALS   shift and go to state 161
    LESSEQUALS      shift and go to state 162
    EQUALS          shift and go to state 163
    DIFFERENT       shift and go to state 164

    relational_operator            shift and go to state 158

state 107

    (121) switch_structure -> SWITCH switch_expression . LBRACE case_blocks RBRACE

    LBRACE          shift and go to state 165


state 108

    (122) switch_expression -> value .

    LBRACE          reduce using rule 122 (switch_expression -> value .)


state 109

    (123) switch_expression -> empty .

    LBRACE          reduce using rule 123 (switch_expression -> empty .)


state 110

    (118) for_initialization -> FOR VARIABLE . SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (120) for_iterator -> FOR VARIABLE . SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 166
    SEMICOLON       shift and go to state 167


state 111

    (119) for_infinite_bucle -> FOR LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 9
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 168
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 112

    (7) statement -> import main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    blocks                         shift and go to state 169
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 113

    (4) statement -> package import blocks .

    $end            reduce using rule 4 (statement -> package import blocks .)
    RBRACE          reduce using rule 4 (statement -> package import blocks .)
    CASE            reduce using rule 4 (statement -> package import blocks .)
    DEFAULT         reduce using rule 4 (statement -> package import blocks .)


state 114

    (8) statement -> package import main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 170


state 115

    (6) statement -> package main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    blocks                         shift and go to state 171
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 116

    (5) statement -> main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 172


state 117

    (11) import -> IMPORT LPAREN values_for_import . RPAREN

    RPAREN          shift and go to state 173


state 118

    (12) values_for_import -> CHARSTRING .
    (13) values_for_import -> CHARSTRING . values_for_import
    (12) values_for_import -> . CHARSTRING
    (13) values_for_import -> . CHARSTRING values_for_import

    RPAREN          reduce using rule 12 (values_for_import -> CHARSTRING .)
    CHARSTRING      shift and go to state 118

    values_for_import              shift and go to state 174

state 119

    (31) variable_declaration -> VARIABLE SHORTASSIGN value .
    (73) operation -> value . operator value
    (74) operation -> value . operator operation
    (75) operation -> value . double_operator
    (76) operator -> . PLUS
    (77) operator -> . MINUS
    (78) operator -> . TIMES
    (79) operator -> . DIVIDE
    (80) operator -> . ASSIGN
    (81) double_operator -> . INCREMENT
    (82) double_operator -> . DECREMENT

    PRINT           reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    PRINTF          reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INPUT           reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FUNCTION        reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VAR             reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VARIABLE        reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CONST           reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    RETURN          reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    TYPE            reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    IF              reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    SWITCH          reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CHARSTRING      reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FOR             reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INT             reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FLOAT           reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    $end            reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    RBRACE          reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CASE            reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    DEFAULT         reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    TIMES           shift and go to state 92
    DIVIDE          shift and go to state 93
    ASSIGN          shift and go to state 94
    INCREMENT       shift and go to state 74
    DECREMENT       shift and go to state 75

    operator                       shift and go to state 88
    double_operator                shift and go to state 89

state 120

    (32) variable_declaration -> VARIABLE SHORTASSIGN operation .

    PRINT           reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    PRINTF          reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    INPUT           reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FUNCTION        reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    VAR             reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    VARIABLE        reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CONST           reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    RETURN          reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    TYPE            reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    IF              reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    SWITCH          reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CHARSTRING      reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FOR             reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    INT             reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FLOAT           reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    $end            reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    RBRACE          reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CASE            reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    DEFAULT         reduce using rule 32 (variable_declaration -> VARIABLE SHORTASSIGN operation .)


state 121

    (140) map_structure -> VARIABLE SHORTASSIGN MAP . LBRACKET type RBRACKET type LBRACE map_values RBRACE

    LBRACKET        shift and go to state 175


state 122

    (146) slice_structure -> VARIABLE SHORTASSIGN LBRACKET . RBRACKET type LBRACE values RBRACE
    (148) slice_structure -> VARIABLE SHORTASSIGN LBRACKET . RBRACKET type

    RBRACKET        shift and go to state 176


state 123

    (141) map_structure -> VARIABLE SHORTASSIGN MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN

    LPAREN          shift and go to state 177


state 124

    (34) variable_assignation -> VARIABLE assignation value .
    (73) operation -> value . operator value
    (74) operation -> value . operator operation
    (75) operation -> value . double_operator
    (76) operator -> . PLUS
    (77) operator -> . MINUS
    (78) operator -> . TIMES
    (79) operator -> . DIVIDE
    (80) operator -> . ASSIGN
    (81) double_operator -> . INCREMENT
    (82) double_operator -> . DECREMENT

    PRINT           reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    PRINTF          reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    INPUT           reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    FUNCTION        reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    VAR             reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    VARIABLE        reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    CONST           reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    RETURN          reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    TYPE            reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    IF              reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    SWITCH          reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    CHARSTRING      reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    FOR             reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    INT             reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    FLOAT           reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    $end            reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    RBRACE          reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    CASE            reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    DEFAULT         reduce using rule 34 (variable_assignation -> VARIABLE assignation value .)
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    TIMES           shift and go to state 92
    DIVIDE          shift and go to state 93
    ASSIGN          shift and go to state 94
    INCREMENT       shift and go to state 74
    DECREMENT       shift and go to state 75

    operator                       shift and go to state 88
    double_operator                shift and go to state 89

state 125

    (35) variable_assignation -> VARIABLE assignation operation .

    PRINT           reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    PRINTF          reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    INPUT           reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    FUNCTION        reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    VAR             reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    VARIABLE        reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    CONST           reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    RETURN          reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    TYPE            reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    IF              reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    SWITCH          reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    CHARSTRING      reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    FOR             reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    INT             reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    FLOAT           reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    $end            reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    RBRACE          reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    CASE            reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)
    DEFAULT         reduce using rule 35 (variable_assignation -> VARIABLE assignation operation .)


state 126

    (145) map_assign -> VARIABLE LBRACKET value . RBRACKET ASSIGN value

    RBRACKET        shift and go to state 178


state 127

    (139) array_assign -> VARIABLE LBRACKET INT . RBRACKET ASSIGN value
    (64) number -> INT .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 179

  ! RBRACKET        [ reduce using rule 64 (number -> INT .) ]


state 128

    (149) slice_structure -> VARIABLE ASSIGN append_statement .

    PRINT           reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    PRINTF          reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    INPUT           reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FUNCTION        reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    VAR             reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    VARIABLE        reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CONST           reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    RETURN          reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    TYPE            reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    IF              reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    SWITCH          reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CHARSTRING      reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FOR             reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    INT             reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FLOAT           reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    $end            reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    RBRACE          reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CASE            reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)
    DEFAULT         reduce using rule 149 (slice_structure -> VARIABLE ASSIGN append_statement .)


state 129

    (150) append_statement -> APPEND . LPAREN VARIABLE COMMA values RPAREN
    (151) append_statement -> APPEND . LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN

    LPAREN          shift and go to state 180


state 130

    (16) main -> FUNCTION MAIN LPAREN . RPAREN

    RPAREN          shift and go to state 181


state 131

    (47) function -> FUNCTION VARIABLE LPAREN . RPAREN LBRACE blocks RBRACE
    (48) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN LBRACE blocks RBRACE
    (49) function -> FUNCTION VARIABLE LPAREN . RPAREN type LBRACE RBRACE
    (50) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN type LBRACE RBRACE
    (51) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> FUNCTION VARIABLE LPAREN . RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (85) parameter -> . VARIABLE type

    RPAREN          shift and go to state 182
    VARIABLE        shift and go to state 143

    parameters                     shift and go to state 183
    parameter                      shift and go to state 33

state 132

    (66) print_statement -> PRINT LPAREN values . RPAREN

    RPAREN          shift and go to state 184


state 133

    (69) print_statement -> PRINT LPAREN RPAREN .

    PRINT           reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    PRINTF          reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    INPUT           reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    FUNCTION        reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    VAR             reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    VARIABLE        reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    CONST           reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    RETURN          reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    TYPE            reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    IF              reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    SWITCH          reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    CHARSTRING      reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    FOR             reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    INT             reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    FLOAT           reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    $end            reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    RBRACE          reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    CASE            reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)
    DEFAULT         reduce using rule 69 (print_statement -> PRINT LPAREN RPAREN .)


state 134

    (68) print_statement -> PRINT LPAREN operation . RPAREN

    RPAREN          shift and go to state 185


state 135

    (58) values -> value .
    (59) values -> value . COMMA values
    (73) operation -> value . operator value
    (74) operation -> value . operator operation
    (75) operation -> value . double_operator
    (76) operator -> . PLUS
    (77) operator -> . MINUS
    (78) operator -> . TIMES
    (79) operator -> . DIVIDE
    (80) operator -> . ASSIGN
    (81) double_operator -> . INCREMENT
    (82) double_operator -> . DECREMENT

    RPAREN          reduce using rule 58 (values -> value .)
    COMMA           shift and go to state 150
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    TIMES           shift and go to state 92
    DIVIDE          shift and go to state 93
    ASSIGN          shift and go to state 94
    INCREMENT       shift and go to state 74
    DECREMENT       shift and go to state 75

    operator                       shift and go to state 88
    double_operator                shift and go to state 89

state 136

    (67) print_statement -> PRINTF LPAREN FORMATSTRING . COMMA values RPAREN

    COMMA           shift and go to state 186


state 137

    (70) input_statement -> INPUT LPAREN values . RPAREN

    RPAREN          shift and go to state 187


state 138

    (72) input_statement -> INPUT LPAREN RPAREN .

    PRINT           reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    PRINTF          reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    FUNCTION        reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    VAR             reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    VARIABLE        reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    CONST           reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    RETURN          reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    TYPE            reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    IF              reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    SWITCH          reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    CHARSTRING      reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    INT             reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    FLOAT           reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    $end            reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    CASE            reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)
    DEFAULT         reduce using rule 72 (input_statement -> INPUT LPAREN RPAREN .)


state 139

    (71) input_statement -> INPUT LPAREN operation . RPAREN

    RPAREN          shift and go to state 188


state 140

    (73) operation -> value operator value .
    (73) operation -> value . operator value
    (74) operation -> value . operator operation
    (75) operation -> value . double_operator
    (76) operator -> . PLUS
    (77) operator -> . MINUS
    (78) operator -> . TIMES
    (79) operator -> . DIVIDE
    (80) operator -> . ASSIGN
    (81) double_operator -> . INCREMENT
    (82) double_operator -> . DECREMENT

    PRINT           reduce using rule 73 (operation -> value operator value .)
    PRINTF          reduce using rule 73 (operation -> value operator value .)
    INPUT           reduce using rule 73 (operation -> value operator value .)
    FUNCTION        reduce using rule 73 (operation -> value operator value .)
    VAR             reduce using rule 73 (operation -> value operator value .)
    VARIABLE        reduce using rule 73 (operation -> value operator value .)
    CONST           reduce using rule 73 (operation -> value operator value .)
    RETURN          reduce using rule 73 (operation -> value operator value .)
    TYPE            reduce using rule 73 (operation -> value operator value .)
    IF              reduce using rule 73 (operation -> value operator value .)
    SWITCH          reduce using rule 73 (operation -> value operator value .)
    CHARSTRING      reduce using rule 73 (operation -> value operator value .)
    FOR             reduce using rule 73 (operation -> value operator value .)
    INT             reduce using rule 73 (operation -> value operator value .)
    FLOAT           reduce using rule 73 (operation -> value operator value .)
    $end            reduce using rule 73 (operation -> value operator value .)
    RBRACE          reduce using rule 73 (operation -> value operator value .)
    CASE            reduce using rule 73 (operation -> value operator value .)
    DEFAULT         reduce using rule 73 (operation -> value operator value .)
    RPAREN          reduce using rule 73 (operation -> value operator value .)
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    TIMES           shift and go to state 92
    DIVIDE          shift and go to state 93
    ASSIGN          shift and go to state 94
    INCREMENT       shift and go to state 74
    DECREMENT       shift and go to state 75

    operator                       shift and go to state 88
    double_operator                shift and go to state 89

state 141

    (74) operation -> value operator operation .

    PRINT           reduce using rule 74 (operation -> value operator operation .)
    PRINTF          reduce using rule 74 (operation -> value operator operation .)
    INPUT           reduce using rule 74 (operation -> value operator operation .)
    FUNCTION        reduce using rule 74 (operation -> value operator operation .)
    VAR             reduce using rule 74 (operation -> value operator operation .)
    VARIABLE        reduce using rule 74 (operation -> value operator operation .)
    CONST           reduce using rule 74 (operation -> value operator operation .)
    RETURN          reduce using rule 74 (operation -> value operator operation .)
    TYPE            reduce using rule 74 (operation -> value operator operation .)
    IF              reduce using rule 74 (operation -> value operator operation .)
    SWITCH          reduce using rule 74 (operation -> value operator operation .)
    CHARSTRING      reduce using rule 74 (operation -> value operator operation .)
    FOR             reduce using rule 74 (operation -> value operator operation .)
    INT             reduce using rule 74 (operation -> value operator operation .)
    FLOAT           reduce using rule 74 (operation -> value operator operation .)
    $end            reduce using rule 74 (operation -> value operator operation .)
    RBRACE          reduce using rule 74 (operation -> value operator operation .)
    CASE            reduce using rule 74 (operation -> value operator operation .)
    DEFAULT         reduce using rule 74 (operation -> value operator operation .)
    RPAREN          reduce using rule 74 (operation -> value operator operation .)


state 142

    (84) parameters -> parameter COMMA parameters .

    PRINT           reduce using rule 84 (parameters -> parameter COMMA parameters .)
    PRINTF          reduce using rule 84 (parameters -> parameter COMMA parameters .)
    INPUT           reduce using rule 84 (parameters -> parameter COMMA parameters .)
    FUNCTION        reduce using rule 84 (parameters -> parameter COMMA parameters .)
    VAR             reduce using rule 84 (parameters -> parameter COMMA parameters .)
    VARIABLE        reduce using rule 84 (parameters -> parameter COMMA parameters .)
    CONST           reduce using rule 84 (parameters -> parameter COMMA parameters .)
    RETURN          reduce using rule 84 (parameters -> parameter COMMA parameters .)
    TYPE            reduce using rule 84 (parameters -> parameter COMMA parameters .)
    IF              reduce using rule 84 (parameters -> parameter COMMA parameters .)
    SWITCH          reduce using rule 84 (parameters -> parameter COMMA parameters .)
    CHARSTRING      reduce using rule 84 (parameters -> parameter COMMA parameters .)
    FOR             reduce using rule 84 (parameters -> parameter COMMA parameters .)
    INT             reduce using rule 84 (parameters -> parameter COMMA parameters .)
    FLOAT           reduce using rule 84 (parameters -> parameter COMMA parameters .)
    $end            reduce using rule 84 (parameters -> parameter COMMA parameters .)
    RBRACE          reduce using rule 84 (parameters -> parameter COMMA parameters .)
    CASE            reduce using rule 84 (parameters -> parameter COMMA parameters .)
    DEFAULT         reduce using rule 84 (parameters -> parameter COMMA parameters .)
    RPAREN          reduce using rule 84 (parameters -> parameter COMMA parameters .)


state 143

    (85) parameter -> VARIABLE . type
    (86) type -> . INT
    (87) type -> . INT32
    (88) type -> . INT64
    (89) type -> . STRING
    (90) type -> . FLOAT
    (91) type -> . FLOAT32
    (92) type -> . FLOAT64
    (93) type -> . BOOL

    INT             shift and go to state 68
    INT32           shift and go to state 76
    INT64           shift and go to state 77
    STRING          shift and go to state 78
    FLOAT           shift and go to state 79
    FLOAT32         shift and go to state 80
    FLOAT64         shift and go to state 81
    BOOL            shift and go to state 82

    type                           shift and go to state 66

state 144

    (29) variable_declaration -> VAR VARIABLE type .
    (30) variable_declaration -> VAR VARIABLE type . ASSIGN value

    PRINT           reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    PRINTF          reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    INPUT           reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    FUNCTION        reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    VAR             reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    VARIABLE        reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    CONST           reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    RETURN          reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    TYPE            reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    IF              reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    SWITCH          reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    CHARSTRING      reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    FOR             reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    INT             reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    FLOAT           reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    $end            reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    RBRACE          reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    CASE            reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    DEFAULT         reduce using rule 29 (variable_declaration -> VAR VARIABLE type .)
    ASSIGN          shift and go to state 189


state 145

    (138) array_structure -> VAR VARIABLE ASSIGN . LBRACKET INT RBRACKET type LBRACE values RBRACE

    LBRACKET        shift and go to state 190


state 146

    (137) array_structure -> VAR VARIABLE LBRACKET . INT RBRACKET type
    (147) slice_structure -> VAR VARIABLE LBRACKET . RBRACKET type

    INT             shift and go to state 191
    RBRACKET        shift and go to state 192


state 147

    (33) variable_declaration -> CONST VARIABLE ASSIGN . value
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    value                          shift and go to state 193
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 148

    (54) return -> RETURN value LBRACKET . value RBRACKET
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    value                          shift and go to state 194
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 149

    (55) return -> RETURN value PERIOD . value
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    value                          shift and go to state 195
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 150

    (59) values -> value COMMA . values
    (58) values -> . value
    (59) values -> . value COMMA values
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    value                          shift and go to state 196
    values                         shift and go to state 197
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 151

    (133) struct_structure -> TYPE VARIABLE STRUCT . LBRACE struct_fields RBRACE

    LBRACE          shift and go to state 198


state 152

    (97) conditional_structure -> IF conditions conditional_body .
    (98) conditional_structure -> IF conditions conditional_body . ELSE conditional_body
    (99) conditional_structure -> IF conditions conditional_body . ELSE IF conditions conditional_body ELSE conditional_body

    PRINT           reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    PRINTF          reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    INPUT           reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    FUNCTION        reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    VAR             reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    VARIABLE        reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    CONST           reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    RETURN          reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    TYPE            reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    IF              reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    SWITCH          reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    CHARSTRING      reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    FOR             reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    INT             reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    FLOAT           reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    $end            reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    RBRACE          reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    CASE            reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    DEFAULT         reduce using rule 97 (conditional_structure -> IF conditions conditional_body .)
    ELSE            shift and go to state 199


state 153

    (100) conditional_body -> LBRACE . statement RBRACE
    (101) conditional_body -> LBRACE . BREAK RBRACE
    (102) conditional_body -> LBRACE . CONTINUE RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    BREAK           shift and go to state 201
    CONTINUE        shift and go to state 202
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 9
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 200
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 154

    (104) conditions -> condition logical_operator . conditions
    (103) conditions -> . condition
    (104) conditions -> . condition logical_operator conditions
    (105) condition -> . value relational_operator value
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    condition                      shift and go to state 105
    conditions                     shift and go to state 203
    value                          shift and go to state 106
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 155

    (106) logical_operator -> AND .

    VARIABLE        reduce using rule 106 (logical_operator -> AND .)
    CHARSTRING      reduce using rule 106 (logical_operator -> AND .)
    INT             reduce using rule 106 (logical_operator -> AND .)
    FLOAT           reduce using rule 106 (logical_operator -> AND .)


state 156

    (107) logical_operator -> OR .

    VARIABLE        reduce using rule 107 (logical_operator -> OR .)
    CHARSTRING      reduce using rule 107 (logical_operator -> OR .)
    INT             reduce using rule 107 (logical_operator -> OR .)
    FLOAT           reduce using rule 107 (logical_operator -> OR .)


state 157

    (108) logical_operator -> NOT .

    VARIABLE        reduce using rule 108 (logical_operator -> NOT .)
    CHARSTRING      reduce using rule 108 (logical_operator -> NOT .)
    INT             reduce using rule 108 (logical_operator -> NOT .)
    FLOAT           reduce using rule 108 (logical_operator -> NOT .)


state 158

    (105) condition -> value relational_operator . value
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    value                          shift and go to state 204
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 159

    (109) relational_operator -> GREATER .

    VARIABLE        reduce using rule 109 (relational_operator -> GREATER .)
    CHARSTRING      reduce using rule 109 (relational_operator -> GREATER .)
    INT             reduce using rule 109 (relational_operator -> GREATER .)
    FLOAT           reduce using rule 109 (relational_operator -> GREATER .)


state 160

    (110) relational_operator -> LESS .

    VARIABLE        reduce using rule 110 (relational_operator -> LESS .)
    CHARSTRING      reduce using rule 110 (relational_operator -> LESS .)
    INT             reduce using rule 110 (relational_operator -> LESS .)
    FLOAT           reduce using rule 110 (relational_operator -> LESS .)


state 161

    (111) relational_operator -> GREATEREQUALS .

    VARIABLE        reduce using rule 111 (relational_operator -> GREATEREQUALS .)
    CHARSTRING      reduce using rule 111 (relational_operator -> GREATEREQUALS .)
    INT             reduce using rule 111 (relational_operator -> GREATEREQUALS .)
    FLOAT           reduce using rule 111 (relational_operator -> GREATEREQUALS .)


state 162

    (112) relational_operator -> LESSEQUALS .

    VARIABLE        reduce using rule 112 (relational_operator -> LESSEQUALS .)
    CHARSTRING      reduce using rule 112 (relational_operator -> LESSEQUALS .)
    INT             reduce using rule 112 (relational_operator -> LESSEQUALS .)
    FLOAT           reduce using rule 112 (relational_operator -> LESSEQUALS .)


state 163

    (113) relational_operator -> EQUALS .

    VARIABLE        reduce using rule 113 (relational_operator -> EQUALS .)
    CHARSTRING      reduce using rule 113 (relational_operator -> EQUALS .)
    INT             reduce using rule 113 (relational_operator -> EQUALS .)
    FLOAT           reduce using rule 113 (relational_operator -> EQUALS .)


state 164

    (114) relational_operator -> DIFFERENT .

    VARIABLE        reduce using rule 114 (relational_operator -> DIFFERENT .)
    CHARSTRING      reduce using rule 114 (relational_operator -> DIFFERENT .)
    INT             reduce using rule 114 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 114 (relational_operator -> DIFFERENT .)


state 165

    (121) switch_structure -> SWITCH switch_expression LBRACE . case_blocks RBRACE
    (124) case_blocks -> . case_block
    (125) case_blocks -> . case_block case_blocks
    (126) case_block -> . CASE values COLON statement
    (127) case_block -> . DEFAULT COLON statement

    CASE            shift and go to state 207
    DEFAULT         shift and go to state 208

    case_blocks                    shift and go to state 205
    case_block                     shift and go to state 206

state 166

    (118) for_initialization -> FOR VARIABLE SHORTASSIGN . value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    value                          shift and go to state 209
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 167

    (120) for_iterator -> FOR VARIABLE SEMICOLON . VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 210


state 168

    (119) for_infinite_bucle -> FOR LBRACE statement . RBRACE

    RBRACE          shift and go to state 211


state 169

    (7) statement -> import main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 212


state 170

    (8) statement -> package import main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    blocks                         shift and go to state 213
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 171

    (6) statement -> package main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 214


state 172

    (5) statement -> main LBRACE blocks RBRACE .

    $end            reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)
    CASE            reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)


state 173

    (11) import -> IMPORT LPAREN values_for_import RPAREN .

    FUNCTION        reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    PRINT           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    PRINTF          reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    INPUT           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    VAR             reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    VARIABLE        reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    CONST           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    RETURN          reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    TYPE            reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    IF              reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    SWITCH          reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    CHARSTRING      reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    FOR             reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    INT             reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    FLOAT           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)


state 174

    (13) values_for_import -> CHARSTRING values_for_import .

    RPAREN          reduce using rule 13 (values_for_import -> CHARSTRING values_for_import .)


state 175

    (140) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET . type RBRACKET type LBRACE map_values RBRACE
    (86) type -> . INT
    (87) type -> . INT32
    (88) type -> . INT64
    (89) type -> . STRING
    (90) type -> . FLOAT
    (91) type -> . FLOAT32
    (92) type -> . FLOAT64
    (93) type -> . BOOL

    INT             shift and go to state 68
    INT32           shift and go to state 76
    INT64           shift and go to state 77
    STRING          shift and go to state 78
    FLOAT           shift and go to state 79
    FLOAT32         shift and go to state 80
    FLOAT64         shift and go to state 81
    BOOL            shift and go to state 82

    type                           shift and go to state 215

state 176

    (146) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET . type LBRACE values RBRACE
    (148) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET . type
    (86) type -> . INT
    (87) type -> . INT32
    (88) type -> . INT64
    (89) type -> . STRING
    (90) type -> . FLOAT
    (91) type -> . FLOAT32
    (92) type -> . FLOAT64
    (93) type -> . BOOL

    INT             shift and go to state 68
    INT32           shift and go to state 76
    INT64           shift and go to state 77
    STRING          shift and go to state 78
    FLOAT           shift and go to state 79
    FLOAT32         shift and go to state 80
    FLOAT64         shift and go to state 81
    BOOL            shift and go to state 82

    type                           shift and go to state 216

state 177

    (141) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN

    MAP             shift and go to state 217


state 178

    (145) map_assign -> VARIABLE LBRACKET value RBRACKET . ASSIGN value

    ASSIGN          shift and go to state 218


state 179

    (139) array_assign -> VARIABLE LBRACKET INT RBRACKET . ASSIGN value

    ASSIGN          shift and go to state 219


state 180

    (150) append_statement -> APPEND LPAREN . VARIABLE COMMA values RPAREN
    (151) append_statement -> APPEND LPAREN . VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN

    VARIABLE        shift and go to state 220


state 181

    (16) main -> FUNCTION MAIN LPAREN RPAREN .

    LBRACE          reduce using rule 16 (main -> FUNCTION MAIN LPAREN RPAREN .)


state 182

    (47) function -> FUNCTION VARIABLE LPAREN RPAREN . LBRACE blocks RBRACE
    (49) function -> FUNCTION VARIABLE LPAREN RPAREN . type LBRACE RBRACE
    (52) function -> FUNCTION VARIABLE LPAREN RPAREN . type LBRACE blocks RBRACE
    (86) type -> . INT
    (87) type -> . INT32
    (88) type -> . INT64
    (89) type -> . STRING
    (90) type -> . FLOAT
    (91) type -> . FLOAT32
    (92) type -> . FLOAT64
    (93) type -> . BOOL

    LBRACE          shift and go to state 221
    INT             shift and go to state 68
    INT32           shift and go to state 76
    INT64           shift and go to state 77
    STRING          shift and go to state 78
    FLOAT           shift and go to state 79
    FLOAT32         shift and go to state 80
    FLOAT64         shift and go to state 81
    BOOL            shift and go to state 82

    type                           shift and go to state 222

state 183

    (48) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN LBRACE blocks RBRACE
    (50) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN type LBRACE RBRACE
    (51) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN type LBRACE blocks RBRACE

    RPAREN          shift and go to state 223


state 184

    (66) print_statement -> PRINT LPAREN values RPAREN .

    PRINT           reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    PRINTF          reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    INPUT           reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    VAR             reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    CONST           reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    RETURN          reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    TYPE            reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    IF              reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    SWITCH          reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    CHARSTRING      reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    FOR             reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    INT             reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    FLOAT           reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    $end            reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    RBRACE          reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    CASE            reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)
    DEFAULT         reduce using rule 66 (print_statement -> PRINT LPAREN values RPAREN .)


state 185

    (68) print_statement -> PRINT LPAREN operation RPAREN .

    PRINT           reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    PRINTF          reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    INPUT           reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    VAR             reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    CONST           reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    RETURN          reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    TYPE            reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    IF              reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    SWITCH          reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    FOR             reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    INT             reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    $end            reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    CASE            reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 68 (print_statement -> PRINT LPAREN operation RPAREN .)


state 186

    (67) print_statement -> PRINTF LPAREN FORMATSTRING COMMA . values RPAREN
    (58) values -> . value
    (59) values -> . value COMMA values
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    values                         shift and go to state 224
    value                          shift and go to state 196
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 187

    (70) input_statement -> INPUT LPAREN values RPAREN .

    PRINT           reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    PRINTF          reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    INPUT           reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    VAR             reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    CONST           reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    RETURN          reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    TYPE            reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    IF              reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    SWITCH          reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    CHARSTRING      reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    FOR             reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    INT             reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    FLOAT           reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    $end            reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    RBRACE          reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    CASE            reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)
    DEFAULT         reduce using rule 70 (input_statement -> INPUT LPAREN values RPAREN .)


state 188

    (71) input_statement -> INPUT LPAREN operation RPAREN .

    PRINT           reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    PRINTF          reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    INPUT           reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    VAR             reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    CONST           reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    RETURN          reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    TYPE            reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    IF              reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    SWITCH          reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    FOR             reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    INT             reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    $end            reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    CASE            reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 71 (input_statement -> INPUT LPAREN operation RPAREN .)


state 189

    (30) variable_declaration -> VAR VARIABLE type ASSIGN . value
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    value                          shift and go to state 225
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 190

    (138) array_structure -> VAR VARIABLE ASSIGN LBRACKET . INT RBRACKET type LBRACE values RBRACE

    INT             shift and go to state 226


state 191

    (137) array_structure -> VAR VARIABLE LBRACKET INT . RBRACKET type

    RBRACKET        shift and go to state 227


state 192

    (147) slice_structure -> VAR VARIABLE LBRACKET RBRACKET . type
    (86) type -> . INT
    (87) type -> . INT32
    (88) type -> . INT64
    (89) type -> . STRING
    (90) type -> . FLOAT
    (91) type -> . FLOAT32
    (92) type -> . FLOAT64
    (93) type -> . BOOL

    INT             shift and go to state 68
    INT32           shift and go to state 76
    INT64           shift and go to state 77
    STRING          shift and go to state 78
    FLOAT           shift and go to state 79
    FLOAT32         shift and go to state 80
    FLOAT64         shift and go to state 81
    BOOL            shift and go to state 82

    type                           shift and go to state 228

state 193

    (33) variable_declaration -> CONST VARIABLE ASSIGN value .

    PRINT           reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    PRINTF          reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    INPUT           reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    FUNCTION        reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    VAR             reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    VARIABLE        reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    CONST           reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    RETURN          reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    TYPE            reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    IF              reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    SWITCH          reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    CHARSTRING      reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    FOR             reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    INT             reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    FLOAT           reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    $end            reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    RBRACE          reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    CASE            reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    DEFAULT         reduce using rule 33 (variable_declaration -> CONST VARIABLE ASSIGN value .)


state 194

    (54) return -> RETURN value LBRACKET value . RBRACKET

    RBRACKET        shift and go to state 229


state 195

    (55) return -> RETURN value PERIOD value .

    PRINT           reduce using rule 55 (return -> RETURN value PERIOD value .)
    PRINTF          reduce using rule 55 (return -> RETURN value PERIOD value .)
    INPUT           reduce using rule 55 (return -> RETURN value PERIOD value .)
    FUNCTION        reduce using rule 55 (return -> RETURN value PERIOD value .)
    VAR             reduce using rule 55 (return -> RETURN value PERIOD value .)
    VARIABLE        reduce using rule 55 (return -> RETURN value PERIOD value .)
    CONST           reduce using rule 55 (return -> RETURN value PERIOD value .)
    RETURN          reduce using rule 55 (return -> RETURN value PERIOD value .)
    TYPE            reduce using rule 55 (return -> RETURN value PERIOD value .)
    IF              reduce using rule 55 (return -> RETURN value PERIOD value .)
    SWITCH          reduce using rule 55 (return -> RETURN value PERIOD value .)
    CHARSTRING      reduce using rule 55 (return -> RETURN value PERIOD value .)
    FOR             reduce using rule 55 (return -> RETURN value PERIOD value .)
    INT             reduce using rule 55 (return -> RETURN value PERIOD value .)
    FLOAT           reduce using rule 55 (return -> RETURN value PERIOD value .)
    $end            reduce using rule 55 (return -> RETURN value PERIOD value .)
    RBRACE          reduce using rule 55 (return -> RETURN value PERIOD value .)
    CASE            reduce using rule 55 (return -> RETURN value PERIOD value .)
    DEFAULT         reduce using rule 55 (return -> RETURN value PERIOD value .)


state 196

    (58) values -> value .
    (59) values -> value . COMMA values

    PRINT           reduce using rule 58 (values -> value .)
    PRINTF          reduce using rule 58 (values -> value .)
    INPUT           reduce using rule 58 (values -> value .)
    FUNCTION        reduce using rule 58 (values -> value .)
    VAR             reduce using rule 58 (values -> value .)
    VARIABLE        reduce using rule 58 (values -> value .)
    CONST           reduce using rule 58 (values -> value .)
    RETURN          reduce using rule 58 (values -> value .)
    TYPE            reduce using rule 58 (values -> value .)
    IF              reduce using rule 58 (values -> value .)
    SWITCH          reduce using rule 58 (values -> value .)
    CHARSTRING      reduce using rule 58 (values -> value .)
    FOR             reduce using rule 58 (values -> value .)
    INT             reduce using rule 58 (values -> value .)
    FLOAT           reduce using rule 58 (values -> value .)
    $end            reduce using rule 58 (values -> value .)
    RBRACE          reduce using rule 58 (values -> value .)
    CASE            reduce using rule 58 (values -> value .)
    DEFAULT         reduce using rule 58 (values -> value .)
    RPAREN          reduce using rule 58 (values -> value .)
    COLON           reduce using rule 58 (values -> value .)
    COMMA           shift and go to state 150


state 197

    (59) values -> value COMMA values .

    PRINT           reduce using rule 59 (values -> value COMMA values .)
    PRINTF          reduce using rule 59 (values -> value COMMA values .)
    INPUT           reduce using rule 59 (values -> value COMMA values .)
    FUNCTION        reduce using rule 59 (values -> value COMMA values .)
    VAR             reduce using rule 59 (values -> value COMMA values .)
    VARIABLE        reduce using rule 59 (values -> value COMMA values .)
    CONST           reduce using rule 59 (values -> value COMMA values .)
    RETURN          reduce using rule 59 (values -> value COMMA values .)
    TYPE            reduce using rule 59 (values -> value COMMA values .)
    IF              reduce using rule 59 (values -> value COMMA values .)
    SWITCH          reduce using rule 59 (values -> value COMMA values .)
    CHARSTRING      reduce using rule 59 (values -> value COMMA values .)
    FOR             reduce using rule 59 (values -> value COMMA values .)
    INT             reduce using rule 59 (values -> value COMMA values .)
    FLOAT           reduce using rule 59 (values -> value COMMA values .)
    $end            reduce using rule 59 (values -> value COMMA values .)
    RBRACE          reduce using rule 59 (values -> value COMMA values .)
    CASE            reduce using rule 59 (values -> value COMMA values .)
    DEFAULT         reduce using rule 59 (values -> value COMMA values .)
    RPAREN          reduce using rule 59 (values -> value COMMA values .)
    COLON           reduce using rule 59 (values -> value COMMA values .)


state 198

    (133) struct_structure -> TYPE VARIABLE STRUCT LBRACE . struct_fields RBRACE
    (134) struct_fields -> . struct_field
    (135) struct_fields -> . struct_field struct_fields
    (136) struct_field -> . VARIABLE type

    VARIABLE        shift and go to state 230

    struct_fields                  shift and go to state 231
    struct_field                   shift and go to state 232

state 199

    (98) conditional_structure -> IF conditions conditional_body ELSE . conditional_body
    (99) conditional_structure -> IF conditions conditional_body ELSE . IF conditions conditional_body ELSE conditional_body
    (100) conditional_body -> . LBRACE statement RBRACE
    (101) conditional_body -> . LBRACE BREAK RBRACE
    (102) conditional_body -> . LBRACE CONTINUE RBRACE

    IF              shift and go to state 233
    LBRACE          shift and go to state 153

    conditional_body               shift and go to state 234

state 200

    (100) conditional_body -> LBRACE statement . RBRACE

    RBRACE          shift and go to state 235


state 201

    (101) conditional_body -> LBRACE BREAK . RBRACE

    RBRACE          shift and go to state 236


state 202

    (102) conditional_body -> LBRACE CONTINUE . RBRACE

    RBRACE          shift and go to state 237


state 203

    (104) conditions -> condition logical_operator conditions .

    LBRACE          reduce using rule 104 (conditions -> condition logical_operator conditions .)


state 204

    (105) condition -> value relational_operator value .

    AND             reduce using rule 105 (condition -> value relational_operator value .)
    OR              reduce using rule 105 (condition -> value relational_operator value .)
    NOT             reduce using rule 105 (condition -> value relational_operator value .)
    LBRACE          reduce using rule 105 (condition -> value relational_operator value .)
    SEMICOLON       reduce using rule 105 (condition -> value relational_operator value .)


state 205

    (121) switch_structure -> SWITCH switch_expression LBRACE case_blocks . RBRACE

    RBRACE          shift and go to state 238


state 206

    (124) case_blocks -> case_block .
    (125) case_blocks -> case_block . case_blocks
    (124) case_blocks -> . case_block
    (125) case_blocks -> . case_block case_blocks
    (126) case_block -> . CASE values COLON statement
    (127) case_block -> . DEFAULT COLON statement

    RBRACE          reduce using rule 124 (case_blocks -> case_block .)
    CASE            shift and go to state 207
    DEFAULT         shift and go to state 208

    case_block                     shift and go to state 206
    case_blocks                    shift and go to state 239

state 207

    (126) case_block -> CASE . values COLON statement
    (58) values -> . value
    (59) values -> . value COMMA values
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    values                         shift and go to state 240
    value                          shift and go to state 196
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 208

    (127) case_block -> DEFAULT . COLON statement

    COLON           shift and go to state 241


state 209

    (118) for_initialization -> FOR VARIABLE SHORTASSIGN value . SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 242


state 210

    (120) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE . SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 243


state 211

    (119) for_infinite_bucle -> FOR LBRACE statement RBRACE .

    PRINT           reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    PRINTF          reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INPUT           reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VAR             reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CONST           reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RETURN          reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    TYPE            reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    IF              reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    SWITCH          reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FOR             reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INT             reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FLOAT           reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    $end            reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RBRACE          reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CASE            reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 119 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)


state 212

    (7) statement -> import main LBRACE blocks RBRACE .

    $end            reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)
    CASE            reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)


state 213

    (8) statement -> package import main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 244


state 214

    (6) statement -> package main LBRACE blocks RBRACE .

    $end            reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)
    CASE            reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)


state 215

    (140) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type . RBRACKET type LBRACE map_values RBRACE

    RBRACKET        shift and go to state 245


state 216

    (146) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type . LBRACE values RBRACE
    (148) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .

    LBRACE          shift and go to state 246
    PRINT           reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    PRINTF          reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    INPUT           reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FUNCTION        reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    VAR             reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CONST           reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    RETURN          reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    TYPE            reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    IF              reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CHARSTRING      reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FOR             reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    INT             reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FLOAT           reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    $end            reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CASE            reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 148 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)


state 217

    (141) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN

    LBRACKET        shift and go to state 247


state 218

    (145) map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN . value
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    value                          shift and go to state 248
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 219

    (139) array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN . value
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    value                          shift and go to state 249
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 220

    (150) append_statement -> APPEND LPAREN VARIABLE . COMMA values RPAREN
    (151) append_statement -> APPEND LPAREN VARIABLE . COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN

    COMMA           shift and go to state 250


state 221

    (47) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    blocks                         shift and go to state 251
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 222

    (49) function -> FUNCTION VARIABLE LPAREN RPAREN type . LBRACE RBRACE
    (52) function -> FUNCTION VARIABLE LPAREN RPAREN type . LBRACE blocks RBRACE

    LBRACE          shift and go to state 252


state 223

    (48) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . LBRACE blocks RBRACE
    (50) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . type LBRACE RBRACE
    (51) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . type LBRACE blocks RBRACE
    (86) type -> . INT
    (87) type -> . INT32
    (88) type -> . INT64
    (89) type -> . STRING
    (90) type -> . FLOAT
    (91) type -> . FLOAT32
    (92) type -> . FLOAT64
    (93) type -> . BOOL

    LBRACE          shift and go to state 253
    INT             shift and go to state 68
    INT32           shift and go to state 76
    INT64           shift and go to state 77
    STRING          shift and go to state 78
    FLOAT           shift and go to state 79
    FLOAT32         shift and go to state 80
    FLOAT64         shift and go to state 81
    BOOL            shift and go to state 82

    type                           shift and go to state 254

state 224

    (67) print_statement -> PRINTF LPAREN FORMATSTRING COMMA values . RPAREN

    RPAREN          shift and go to state 255


state 225

    (30) variable_declaration -> VAR VARIABLE type ASSIGN value .

    PRINT           reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    PRINTF          reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    INPUT           reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    FUNCTION        reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    VAR             reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    VARIABLE        reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    CONST           reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    RETURN          reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    TYPE            reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    IF              reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    SWITCH          reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    CHARSTRING      reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    FOR             reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    INT             reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    FLOAT           reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    $end            reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    RBRACE          reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    CASE            reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    DEFAULT         reduce using rule 30 (variable_declaration -> VAR VARIABLE type ASSIGN value .)


state 226

    (138) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT . RBRACKET type LBRACE values RBRACE

    RBRACKET        shift and go to state 256


state 227

    (137) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET . type
    (86) type -> . INT
    (87) type -> . INT32
    (88) type -> . INT64
    (89) type -> . STRING
    (90) type -> . FLOAT
    (91) type -> . FLOAT32
    (92) type -> . FLOAT64
    (93) type -> . BOOL

    INT             shift and go to state 68
    INT32           shift and go to state 76
    INT64           shift and go to state 77
    STRING          shift and go to state 78
    FLOAT           shift and go to state 79
    FLOAT32         shift and go to state 80
    FLOAT64         shift and go to state 81
    BOOL            shift and go to state 82

    type                           shift and go to state 257

state 228

    (147) slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .

    PRINT           reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    PRINTF          reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    INPUT           reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FUNCTION        reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    VAR             reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CONST           reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    RETURN          reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    TYPE            reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    IF              reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CHARSTRING      reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FOR             reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    INT             reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FLOAT           reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    $end            reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CASE            reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 147 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)


state 229

    (54) return -> RETURN value LBRACKET value RBRACKET .

    PRINT           reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    PRINTF          reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    INPUT           reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    FUNCTION        reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    VAR             reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    VARIABLE        reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    CONST           reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    RETURN          reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    TYPE            reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    IF              reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    SWITCH          reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    CHARSTRING      reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    FOR             reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    INT             reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    FLOAT           reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    $end            reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    RBRACE          reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    CASE            reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)
    DEFAULT         reduce using rule 54 (return -> RETURN value LBRACKET value RBRACKET .)


state 230

    (136) struct_field -> VARIABLE . type
    (86) type -> . INT
    (87) type -> . INT32
    (88) type -> . INT64
    (89) type -> . STRING
    (90) type -> . FLOAT
    (91) type -> . FLOAT32
    (92) type -> . FLOAT64
    (93) type -> . BOOL

    INT             shift and go to state 68
    INT32           shift and go to state 76
    INT64           shift and go to state 77
    STRING          shift and go to state 78
    FLOAT           shift and go to state 79
    FLOAT32         shift and go to state 80
    FLOAT64         shift and go to state 81
    BOOL            shift and go to state 82

    type                           shift and go to state 258

state 231

    (133) struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields . RBRACE

    RBRACE          shift and go to state 259


state 232

    (134) struct_fields -> struct_field .
    (135) struct_fields -> struct_field . struct_fields
    (134) struct_fields -> . struct_field
    (135) struct_fields -> . struct_field struct_fields
    (136) struct_field -> . VARIABLE type

    RBRACE          reduce using rule 134 (struct_fields -> struct_field .)
    VARIABLE        shift and go to state 230

    struct_field                   shift and go to state 232
    struct_fields                  shift and go to state 260

state 233

    (99) conditional_structure -> IF conditions conditional_body ELSE IF . conditions conditional_body ELSE conditional_body
    (103) conditions -> . condition
    (104) conditions -> . condition logical_operator conditions
    (105) condition -> . value relational_operator value
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    conditions                     shift and go to state 261
    condition                      shift and go to state 105
    value                          shift and go to state 106
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 234

    (98) conditional_structure -> IF conditions conditional_body ELSE conditional_body .

    PRINT           reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    PRINTF          reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CONST           reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RETURN          reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    SWITCH          reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CHARSTRING      reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CASE            reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    DEFAULT         reduce using rule 98 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)


state 235

    (100) conditional_body -> LBRACE statement RBRACE .

    ELSE            reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    PRINT           reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    PRINTF          reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    INPUT           reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    VAR             reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    CONST           reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    RETURN          reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    TYPE            reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    IF              reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    SWITCH          reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    FOR             reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    INT             reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    FLOAT           reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    $end            reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    RBRACE          reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    CASE            reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 100 (conditional_body -> LBRACE statement RBRACE .)


state 236

    (101) conditional_body -> LBRACE BREAK RBRACE .

    ELSE            reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    PRINT           reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    PRINTF          reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    INPUT           reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    FUNCTION        reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    VAR             reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    VARIABLE        reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    CONST           reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    RETURN          reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    TYPE            reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    IF              reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    SWITCH          reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    CHARSTRING      reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    FOR             reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    INT             reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    FLOAT           reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    $end            reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    RBRACE          reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    CASE            reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)
    DEFAULT         reduce using rule 101 (conditional_body -> LBRACE BREAK RBRACE .)


state 237

    (102) conditional_body -> LBRACE CONTINUE RBRACE .

    ELSE            reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    PRINT           reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    PRINTF          reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INPUT           reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FUNCTION        reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VAR             reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VARIABLE        reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CONST           reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RETURN          reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    TYPE            reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    IF              reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    SWITCH          reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CHARSTRING      reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FOR             reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INT             reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FLOAT           reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    $end            reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RBRACE          reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CASE            reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)
    DEFAULT         reduce using rule 102 (conditional_body -> LBRACE CONTINUE RBRACE .)


state 238

    (121) switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .

    PRINT           reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    PRINTF          reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    INPUT           reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FUNCTION        reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    VAR             reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    VARIABLE        reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CONST           reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    RETURN          reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    TYPE            reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    IF              reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    SWITCH          reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CHARSTRING      reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FOR             reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    INT             reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FLOAT           reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    $end            reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    RBRACE          reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CASE            reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    DEFAULT         reduce using rule 121 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)


state 239

    (125) case_blocks -> case_block case_blocks .

    RBRACE          reduce using rule 125 (case_blocks -> case_block case_blocks .)


state 240

    (126) case_block -> CASE values . COLON statement

    COLON           shift and go to state 262


state 241

    (127) case_block -> DEFAULT COLON . statement
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 9
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 263
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 242

    (118) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON . condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) condition -> . value relational_operator value
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    value                          shift and go to state 106
    condition                      shift and go to state 264
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 243

    (120) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN . RANGE VARIABLE LBRACE statement RBRACE

    RANGE           shift and go to state 265


state 244

    (8) statement -> package import main LBRACE blocks RBRACE .

    $end            reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)
    CASE            reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)


state 245

    (140) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET . type LBRACE map_values RBRACE
    (86) type -> . INT
    (87) type -> . INT32
    (88) type -> . INT64
    (89) type -> . STRING
    (90) type -> . FLOAT
    (91) type -> . FLOAT32
    (92) type -> . FLOAT64
    (93) type -> . BOOL

    INT             shift and go to state 68
    INT32           shift and go to state 76
    INT64           shift and go to state 77
    STRING          shift and go to state 78
    FLOAT           shift and go to state 79
    FLOAT32         shift and go to state 80
    FLOAT64         shift and go to state 81
    BOOL            shift and go to state 82

    type                           shift and go to state 266

state 246

    (146) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE . values RBRACE
    (58) values -> . value
    (59) values -> . value COMMA values
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    values                         shift and go to state 267
    value                          shift and go to state 196
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 247

    (141) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (86) type -> . INT
    (87) type -> . INT32
    (88) type -> . INT64
    (89) type -> . STRING
    (90) type -> . FLOAT
    (91) type -> . FLOAT32
    (92) type -> . FLOAT64
    (93) type -> . BOOL

    INT             shift and go to state 68
    INT32           shift and go to state 76
    INT64           shift and go to state 77
    STRING          shift and go to state 78
    FLOAT           shift and go to state 79
    FLOAT32         shift and go to state 80
    FLOAT64         shift and go to state 81
    BOOL            shift and go to state 82

    type                           shift and go to state 268

state 248

    (145) map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .

    PRINT           reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    PRINTF          reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    INPUT           reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    FUNCTION        reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    VAR             reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    VARIABLE        reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    CONST           reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    RETURN          reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    TYPE            reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    IF              reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    SWITCH          reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    CHARSTRING      reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    FOR             reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    INT             reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    FLOAT           reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    $end            reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    RBRACE          reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    CASE            reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    DEFAULT         reduce using rule 145 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)


state 249

    (139) array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .

    PRINT           reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    PRINTF          reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    INPUT           reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    FUNCTION        reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    VAR             reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    VARIABLE        reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    CONST           reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    RETURN          reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    TYPE            reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    IF              reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    SWITCH          reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    CHARSTRING      reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    FOR             reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    INT             reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    FLOAT           reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    $end            reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    RBRACE          reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    CASE            reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    DEFAULT         reduce using rule 139 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)


state 250

    (150) append_statement -> APPEND LPAREN VARIABLE COMMA . values RPAREN
    (151) append_statement -> APPEND LPAREN VARIABLE COMMA . LBRACKET RBRACKET type LBRACE values RBRACE RPAREN
    (58) values -> . value
    (59) values -> . value COMMA values
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    LBRACKET        shift and go to state 270
    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    values                         shift and go to state 269
    value                          shift and go to state 196
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 251

    (47) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 271


state 252

    (49) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE . RBRACE
    (52) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

    RBRACE          shift and go to state 272
    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    blocks                         shift and go to state 273
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 253

    (48) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    parameters                     shift and go to state 18
    blocks                         shift and go to state 274
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 254

    (50) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type . LBRACE RBRACE
    (51) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type . LBRACE blocks RBRACE

    LBRACE          shift and go to state 275


state 255

    (67) print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .

    PRINT           reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    PRINTF          reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    INPUT           reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FUNCTION        reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    VAR             reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    VARIABLE        reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CONST           reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    RETURN          reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    TYPE            reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    IF              reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    SWITCH          reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CHARSTRING      reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FOR             reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    INT             reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FLOAT           reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    $end            reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    RBRACE          reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CASE            reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    DEFAULT         reduce using rule 67 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)


state 256

    (138) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET . type LBRACE values RBRACE
    (86) type -> . INT
    (87) type -> . INT32
    (88) type -> . INT64
    (89) type -> . STRING
    (90) type -> . FLOAT
    (91) type -> . FLOAT32
    (92) type -> . FLOAT64
    (93) type -> . BOOL

    INT             shift and go to state 68
    INT32           shift and go to state 76
    INT64           shift and go to state 77
    STRING          shift and go to state 78
    FLOAT           shift and go to state 79
    FLOAT32         shift and go to state 80
    FLOAT64         shift and go to state 81
    BOOL            shift and go to state 82

    type                           shift and go to state 276

state 257

    (137) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .

    PRINT           reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    PRINTF          reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    INPUT           reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    FUNCTION        reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    VAR             reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    VARIABLE        reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    CONST           reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    RETURN          reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    TYPE            reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    IF              reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    SWITCH          reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    CHARSTRING      reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    FOR             reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    INT             reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    FLOAT           reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    $end            reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    RBRACE          reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    CASE            reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    DEFAULT         reduce using rule 137 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)


state 258

    (136) struct_field -> VARIABLE type .

    VARIABLE        reduce using rule 136 (struct_field -> VARIABLE type .)
    RBRACE          reduce using rule 136 (struct_field -> VARIABLE type .)


state 259

    (133) struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .

    PRINT           reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    PRINTF          reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    INPUT           reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FUNCTION        reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    VAR             reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    VARIABLE        reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CONST           reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    RETURN          reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    TYPE            reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    IF              reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    SWITCH          reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CHARSTRING      reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FOR             reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    INT             reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FLOAT           reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    $end            reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    RBRACE          reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CASE            reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    DEFAULT         reduce using rule 133 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)


state 260

    (135) struct_fields -> struct_field struct_fields .

    RBRACE          reduce using rule 135 (struct_fields -> struct_field struct_fields .)


state 261

    (99) conditional_structure -> IF conditions conditional_body ELSE IF conditions . conditional_body ELSE conditional_body
    (100) conditional_body -> . LBRACE statement RBRACE
    (101) conditional_body -> . LBRACE BREAK RBRACE
    (102) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 153

    conditional_body               shift and go to state 277

state 262

    (126) case_block -> CASE values COLON . statement
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 9
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 278
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 263

    (127) case_block -> DEFAULT COLON statement .

    CASE            reduce using rule 127 (case_block -> DEFAULT COLON statement .)
    DEFAULT         reduce using rule 127 (case_block -> DEFAULT COLON statement .)
    RBRACE          reduce using rule 127 (case_block -> DEFAULT COLON statement .)


state 264

    (118) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition . SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 279


state 265

    (120) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE . VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 280


state 266

    (140) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type . LBRACE map_values RBRACE

    LBRACE          shift and go to state 281


state 267

    (146) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values . RBRACE

    RBRACE          shift and go to state 282


state 268

    (141) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN

    RBRACKET        shift and go to state 283


state 269

    (150) append_statement -> APPEND LPAREN VARIABLE COMMA values . RPAREN

    RPAREN          shift and go to state 284


state 270

    (151) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET . RBRACKET type LBRACE values RBRACE RPAREN

    RBRACKET        shift and go to state 285


state 271

    (47) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .

    PRINT           reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CONST           reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    RETURN          reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CASE            reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)


state 272

    (49) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .

    PRINT           reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    PRINTF          reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    INPUT           reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    FUNCTION        reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    VAR             reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    VARIABLE        reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    CONST           reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    RETURN          reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    TYPE            reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    IF              reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    SWITCH          reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    CHARSTRING      reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    FOR             reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    INT             reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    FLOAT           reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    $end            reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    RBRACE          reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    CASE            reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)
    DEFAULT         reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE .)


state 273

    (52) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks . RBRACE

    RBRACE          shift and go to state 286


state 274

    (48) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 287


state 275

    (50) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE . RBRACE
    (51) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

    RBRACE          shift and go to state 288
    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    parameters                     shift and go to state 18
    blocks                         shift and go to state 289
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 276

    (138) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type . LBRACE values RBRACE

    LBRACE          shift and go to state 290


state 277

    (99) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body . ELSE conditional_body

    ELSE            shift and go to state 291


state 278

    (126) case_block -> CASE values COLON statement .

    CASE            reduce using rule 126 (case_block -> CASE values COLON statement .)
    DEFAULT         reduce using rule 126 (case_block -> CASE values COLON statement .)
    RBRACE          reduce using rule 126 (case_block -> CASE values COLON statement .)


state 279

    (118) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON . value double_operator LBRACE statement RBRACE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    value                          shift and go to state 292
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 280

    (120) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE . LBRACE statement RBRACE

    LBRACE          shift and go to state 293


state 281

    (140) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE . map_values RBRACE
    (142) map_values -> . map_value
    (143) map_values -> . map_value COMMA map_values
    (144) map_value -> . value COLON value
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    map_values                     shift and go to state 294
    map_value                      shift and go to state 295
    value                          shift and go to state 296
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 282

    (146) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .

    PRINT           reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    PRINTF          reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    INPUT           reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FUNCTION        reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    VAR             reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    VARIABLE        reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CONST           reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    RETURN          reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    TYPE            reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    IF              reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    SWITCH          reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FOR             reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    INT             reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FLOAT           reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    $end            reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    RBRACE          reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CASE            reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    DEFAULT         reduce using rule 146 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)


state 283

    (141) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (86) type -> . INT
    (87) type -> . INT32
    (88) type -> . INT64
    (89) type -> . STRING
    (90) type -> . FLOAT
    (91) type -> . FLOAT32
    (92) type -> . FLOAT64
    (93) type -> . BOOL

    INT             shift and go to state 68
    INT32           shift and go to state 76
    INT64           shift and go to state 77
    STRING          shift and go to state 78
    FLOAT           shift and go to state 79
    FLOAT32         shift and go to state 80
    FLOAT64         shift and go to state 81
    BOOL            shift and go to state 82

    type                           shift and go to state 297

state 284

    (150) append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .

    PRINT           reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    PRINTF          reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    INPUT           reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FUNCTION        reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    VAR             reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    VARIABLE        reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CONST           reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    RETURN          reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    TYPE            reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    IF              reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    SWITCH          reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CHARSTRING      reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FOR             reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    INT             reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FLOAT           reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    $end            reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    RBRACE          reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CASE            reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    DEFAULT         reduce using rule 150 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)


state 285

    (151) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET . type LBRACE values RBRACE RPAREN
    (86) type -> . INT
    (87) type -> . INT32
    (88) type -> . INT64
    (89) type -> . STRING
    (90) type -> . FLOAT
    (91) type -> . FLOAT32
    (92) type -> . FLOAT64
    (93) type -> . BOOL

    INT             shift and go to state 68
    INT32           shift and go to state 76
    INT64           shift and go to state 77
    STRING          shift and go to state 78
    FLOAT           shift and go to state 79
    FLOAT32         shift and go to state 80
    FLOAT64         shift and go to state 81
    BOOL            shift and go to state 82

    type                           shift and go to state 298

state 286

    (52) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .

    PRINT           reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    INPUT           reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    VAR             reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    CONST           reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    RETURN          reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    TYPE            reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    IF              reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    FOR             reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    INT             reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    $end            reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    CASE            reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 52 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE .)


state 287

    (48) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .

    PRINT           reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CONST           reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    RETURN          reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CASE            reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)


state 288

    (50) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .

    PRINT           reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    PRINTF          reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    INPUT           reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    FUNCTION        reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    VAR             reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    VARIABLE        reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    CONST           reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    RETURN          reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    TYPE            reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    IF              reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    SWITCH          reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    CHARSTRING      reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    FOR             reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    INT             reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    FLOAT           reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    $end            reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    RBRACE          reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    CASE            reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)
    DEFAULT         reduce using rule 50 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE .)


state 289

    (51) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks . RBRACE

    RBRACE          shift and go to state 299


state 290

    (138) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE . values RBRACE
    (58) values -> . value
    (59) values -> . value COMMA values
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    values                         shift and go to state 300
    value                          shift and go to state 196
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 291

    (99) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE . conditional_body
    (100) conditional_body -> . LBRACE statement RBRACE
    (101) conditional_body -> . LBRACE BREAK RBRACE
    (102) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 153

    conditional_body               shift and go to state 301

state 292

    (118) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value . double_operator LBRACE statement RBRACE
    (81) double_operator -> . INCREMENT
    (82) double_operator -> . DECREMENT

    INCREMENT       shift and go to state 74
    DECREMENT       shift and go to state 75

    double_operator                shift and go to state 302

state 293

    (120) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 9
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 303
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    value                          shift and go to state 25
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 294

    (140) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values . RBRACE

    RBRACE          shift and go to state 304


state 295

    (142) map_values -> map_value .
    (143) map_values -> map_value . COMMA map_values

    RBRACE          reduce using rule 142 (map_values -> map_value .)
    COMMA           shift and go to state 305


state 296

    (144) map_value -> value . COLON value

    COLON           shift and go to state 306


state 297

    (141) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN

    RPAREN          shift and go to state 307


state 298

    (151) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type . LBRACE values RBRACE RPAREN

    LBRACE          shift and go to state 308


state 299

    (51) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .

    PRINT           reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    INPUT           reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    VAR             reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    CONST           reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    RETURN          reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    TYPE            reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    IF              reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    FOR             reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    INT             reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    $end            reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    CASE            reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 51 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE .)


state 300

    (138) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values . RBRACE

    RBRACE          shift and go to state 309


state 301

    (99) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .

    PRINT           reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    PRINTF          reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CONST           reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RETURN          reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    SWITCH          reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CHARSTRING      reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CASE            reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    DEFAULT         reduce using rule 99 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)


state 302

    (118) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator . LBRACE statement RBRACE

    LBRACE          shift and go to state 310


state 303

    (120) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement . RBRACE

    RBRACE          shift and go to state 311


state 304

    (140) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .

    PRINT           reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    PRINTF          reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INPUT           reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FUNCTION        reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VAR             reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VARIABLE        reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CONST           reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RETURN          reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    TYPE            reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    IF              reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    SWITCH          reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CHARSTRING      reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FOR             reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INT             reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FLOAT           reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    $end            reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RBRACE          reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CASE            reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    DEFAULT         reduce using rule 140 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)


state 305

    (143) map_values -> map_value COMMA . map_values
    (142) map_values -> . map_value
    (143) map_values -> . map_value COMMA map_values
    (144) map_value -> . value COLON value
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    map_value                      shift and go to state 295
    map_values                     shift and go to state 312
    value                          shift and go to state 296
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 306

    (144) map_value -> value COLON . value
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    value                          shift and go to state 313
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 307

    (141) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .

    PRINT           reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    PRINTF          reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INPUT           reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FUNCTION        reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VAR             reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CONST           reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RETURN          reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TYPE            reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    IF              reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SWITCH          reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CHARSTRING      reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FOR             reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INT             reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FLOAT           reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    $end            reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RBRACE          reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CASE            reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 141 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)


state 308

    (151) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE . values RBRACE RPAREN
    (58) values -> . value
    (59) values -> . value COMMA values
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (64) number -> . INT
    (65) number -> . FLOAT

    VARIABLE        shift and go to state 102
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

    values                         shift and go to state 314
    value                          shift and go to state 196
    not_variable_value             shift and go to state 39
    number                         shift and go to state 47

state 309

    (138) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .

    PRINT           reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    PRINTF          reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    INPUT           reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    FUNCTION        reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    VAR             reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    VARIABLE        reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    CONST           reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    RETURN          reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    TYPE            reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    IF              reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    SWITCH          reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    FOR             reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    INT             reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    FLOAT           reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    $end            reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    RBRACE          reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    CASE            reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    DEFAULT         reduce using rule 138 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)


state 310

    (118) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (28) block -> . return
    (66) print_statement -> . PRINT LPAREN values RPAREN
    (67) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (68) print_statement -> . PRINT LPAREN operation RPAREN
    (69) print_statement -> . PRINT LPAREN RPAREN
    (70) input_statement -> . INPUT LPAREN values RPAREN
    (71) input_statement -> . INPUT LPAREN operation RPAREN
    (72) input_statement -> . INPUT LPAREN RPAREN
    (73) operation -> . value operator value
    (74) operation -> . value operator operation
    (75) operation -> . value double_operator
    (129) data_structure -> . array_structure
    (130) data_structure -> . map_structure
    (131) data_structure -> . slice_structure
    (132) data_structure -> . struct_structure
    (94) control_structure -> . conditional_structure
    (95) control_structure -> . for_estructure
    (96) control_structure -> . switch_structure
    (47) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RBRACE
    (50) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RBRACE
    (51) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RBRACE
    (52) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks RBRACE
    (83) parameters -> . parameter
    (84) parameters -> . parameter COMMA parameters
    (29) variable_declaration -> . VAR VARIABLE type
    (30) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN value
    (32) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (33) variable_declaration -> . CONST VARIABLE ASSIGN value
    (34) variable_assignation -> . VARIABLE assignation value
    (35) variable_assignation -> . VARIABLE assignation operation
    (36) variable_assignation -> . VARIABLE double_operator
    (37) variable_assignation -> . map_assign
    (38) variable_assignation -> . array_assign
    (53) return -> . RETURN values
    (54) return -> . RETURN value LBRACKET value RBRACKET
    (55) return -> . RETURN value PERIOD value
    (56) return -> . RETURN TRUE
    (57) return -> . RETURN FALSE
    (60) value -> . VARIABLE
    (61) value -> . not_variable_value
    (137) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (138) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (140) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (141) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (146) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (147) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (148) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (149) slice_structure -> . VARIABLE ASSIGN append_statement
    (133) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (97) conditional_structure -> . IF conditions conditional_body
    (98) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (99) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (115) for_estructure -> . for_initialization
    (116) for_estructure -> . for_infinite_bucle
    (117) for_estructure -> . for_iterator
    (121) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (85) parameter -> . VARIABLE type
    (145) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (139) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (62) not_variable_value -> . CHARSTRING
    (63) not_variable_value -> . number
    (118) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (119) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (120) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (64) number -> . INT
    (65) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 9
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 22
    PRINTF          shift and go to state 23
    INPUT           shift and go to state 24
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 35
    RETURN          shift and go to state 38
    TYPE            shift and go to state 41
    IF              shift and go to state 42
    SWITCH          shift and go to state 46
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 48
    INT             shift and go to state 40
    FLOAT           shift and go to state 49

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! RETURN          [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    value                          shift and go to state 25
    statement                      shift and go to state 315
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    return                         shift and go to state 21
    array_structure                shift and go to state 26
    map_structure                  shift and go to state 27
    slice_structure                shift and go to state 28
    struct_structure               shift and go to state 29
    conditional_structure          shift and go to state 30
    for_estructure                 shift and go to state 31
    switch_structure               shift and go to state 32
    parameter                      shift and go to state 33
    map_assign                     shift and go to state 36
    array_assign                   shift and go to state 37
    not_variable_value             shift and go to state 39
    for_initialization             shift and go to state 43
    for_infinite_bucle             shift and go to state 44
    for_iterator                   shift and go to state 45
    number                         shift and go to state 47

state 311

    (120) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .

    PRINT           reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    PRINTF          reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INPUT           reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VAR             reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CONST           reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RETURN          reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    TYPE            reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    IF              reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    SWITCH          reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FOR             reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INT             reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FLOAT           reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    $end            reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RBRACE          reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CASE            reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 120 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)


state 312

    (143) map_values -> map_value COMMA map_values .

    RBRACE          reduce using rule 143 (map_values -> map_value COMMA map_values .)


state 313

    (144) map_value -> value COLON value .

    COMMA           reduce using rule 144 (map_value -> value COLON value .)
    RBRACE          reduce using rule 144 (map_value -> value COLON value .)


state 314

    (151) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values . RBRACE RPAREN

    RBRACE          shift and go to state 316


state 315

    (118) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement . RBRACE

    RBRACE          shift and go to state 317


state 316

    (151) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE . RPAREN

    RPAREN          shift and go to state 318


state 317

    (118) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .

    PRINT           reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    PRINTF          reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INPUT           reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VAR             reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CONST           reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RETURN          reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    TYPE            reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    IF              reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    SWITCH          reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FOR             reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INT             reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FLOAT           reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    $end            reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RBRACE          reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CASE            reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 118 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)


state 318

    (151) append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .

    PRINT           reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    PRINTF          reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    INPUT           reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    FUNCTION        reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    VAR             reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    VARIABLE        reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    CONST           reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    RETURN          reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    TYPE            reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    IF              reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    SWITCH          reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    CHARSTRING      reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    FOR             reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    INT             reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    FLOAT           reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    $end            reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    RBRACE          reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    CASE            reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)
    DEFAULT         reduce using rule 151 (append_statement -> APPEND LPAREN VARIABLE COMMA LBRACKET RBRACKET type LBRACE values RBRACE RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FUNCTION in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 0 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 0 resolved as shift
WARNING: shift/reduce conflict for VAR in state 0 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 0 resolved as shift
WARNING: shift/reduce conflict for CONST in state 0 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 0 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 0 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 4 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 4 resolved as shift
WARNING: shift/reduce conflict for VAR in state 4 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 4 resolved as shift
WARNING: shift/reduce conflict for CONST in state 4 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 4 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 4 resolved as shift
WARNING: shift/reduce conflict for IF in state 4 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 4 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 4 resolved as shift
WARNING: shift/reduce conflict for FOR in state 4 resolved as shift
WARNING: shift/reduce conflict for INT in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 10 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 10 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 10 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 111 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 111 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 111 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 111 resolved as shift
WARNING: shift/reduce conflict for VAR in state 111 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 111 resolved as shift
WARNING: shift/reduce conflict for CONST in state 111 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 111 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 111 resolved as shift
WARNING: shift/reduce conflict for IF in state 111 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 111 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 111 resolved as shift
WARNING: shift/reduce conflict for FOR in state 111 resolved as shift
WARNING: shift/reduce conflict for INT in state 111 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 111 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 127 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 153 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 153 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 153 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 153 resolved as shift
WARNING: shift/reduce conflict for VAR in state 153 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 153 resolved as shift
WARNING: shift/reduce conflict for CONST in state 153 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 153 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for IF in state 153 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 153 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 153 resolved as shift
WARNING: shift/reduce conflict for FOR in state 153 resolved as shift
WARNING: shift/reduce conflict for INT in state 153 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 153 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 241 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 241 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 241 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 241 resolved as shift
WARNING: shift/reduce conflict for VAR in state 241 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 241 resolved as shift
WARNING: shift/reduce conflict for CONST in state 241 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 241 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 241 resolved as shift
WARNING: shift/reduce conflict for IF in state 241 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 241 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 241 resolved as shift
WARNING: shift/reduce conflict for FOR in state 241 resolved as shift
WARNING: shift/reduce conflict for INT in state 241 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 241 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 262 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 262 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 262 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 262 resolved as shift
WARNING: shift/reduce conflict for VAR in state 262 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 262 resolved as shift
WARNING: shift/reduce conflict for CONST in state 262 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 262 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 262 resolved as shift
WARNING: shift/reduce conflict for IF in state 262 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 262 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 262 resolved as shift
WARNING: shift/reduce conflict for FOR in state 262 resolved as shift
WARNING: shift/reduce conflict for INT in state 262 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 262 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 293 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 293 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 293 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 293 resolved as shift
WARNING: shift/reduce conflict for VAR in state 293 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 293 resolved as shift
WARNING: shift/reduce conflict for CONST in state 293 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 293 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 293 resolved as shift
WARNING: shift/reduce conflict for IF in state 293 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 293 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 293 resolved as shift
WARNING: shift/reduce conflict for FOR in state 293 resolved as shift
WARNING: shift/reduce conflict for INT in state 293 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 293 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 310 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 310 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 310 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 310 resolved as shift
WARNING: shift/reduce conflict for VAR in state 310 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 310 resolved as shift
WARNING: shift/reduce conflict for CONST in state 310 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 310 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 310 resolved as shift
WARNING: shift/reduce conflict for IF in state 310 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 310 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 310 resolved as shift
WARNING: shift/reduce conflict for FOR in state 310 resolved as shift
WARNING: shift/reduce conflict for INT in state 310 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 310 resolved as shift
