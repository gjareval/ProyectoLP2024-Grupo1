Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    CONST
    DIVIDEASSIGN
    FALSE
    IDENTIFIER
    IMPORT
    MAIN
    MINUSASSIGN
    MOD
    MODASSIGN
    PACKAGE
    PLUSASSIGN
    TEXT
    TIMESASSIGN
    TRUE

Grammar

Rule 0     S' -> statement
Rule 1     statement -> blocks
Rule 2     blocks -> block
Rule 3     blocks -> block blocks
Rule 4     block -> print_statement
Rule 5     block -> input_statement
Rule 6     block -> conditional_structure
Rule 7     block -> operation
Rule 8     block -> list_structure
Rule 9     block -> map_estructure
Rule 10    block -> map_assign
Rule 11    block -> for_estructure
Rule 12    block -> structure
Rule 13    block -> function
Rule 14    block -> parameters
Rule 15    block -> variable_declaration
Rule 16    block -> switch_structure
Rule 17    block -> slice_structure
Rule 18    variable_declaration -> VAR VARIABLE type
Rule 19    variable_declaration -> VAR VARIABLE ASSIGN value
Rule 20    variable_declaration -> VARIABLE SHORTASSIGN value
Rule 21    variable_declaration -> VARIABLE SHORTASSIGN operation
Rule 22    structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE
Rule 23    function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
Rule 24    function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
Rule 25    function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
Rule 26    function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
Rule 27    values -> value
Rule 28    values -> value COMMA values
Rule 29    string_value -> value
Rule 30    string_value -> CHARSTRING
Rule 31    value -> VARIABLE
Rule 32    value -> number
Rule 33    value -> CHARSTRING
Rule 34    number -> INT
Rule 35    number -> FLOAT
Rule 36    print_statement -> PRINT LPAREN values RPAREN
Rule 37    print_statement -> PRINT LPAREN string_value RPAREN
Rule 38    print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN
Rule 39    print_statement -> PRINT LPAREN string_value COMMA values RPAREN
Rule 40    print_statement -> PRINT LPAREN operation RPAREN
Rule 41    print_statement -> PRINT LPAREN RPAREN
Rule 42    input_statement -> INPUT LPAREN values RPAREN
Rule 43    input_statement -> INPUT LPAREN operation RPAREN
Rule 44    input_statement -> INPUT LPAREN RPAREN
Rule 45    operation -> value operator value
Rule 46    operation -> value operator operation
Rule 47    operation -> value double_operator
Rule 48    operator -> PLUS
Rule 49    operator -> MINUS
Rule 50    operator -> TIMES
Rule 51    operator -> DIVIDE
Rule 52    operator -> ASSIGN
Rule 53    double_operator -> INCREMENT
Rule 54    double_operator -> DECREMENT
Rule 55    parameters -> parameter
Rule 56    parameters -> parameter parameters
Rule 57    parameters -> parameter COMMA parameters
Rule 58    parameter -> VARIABLE type
Rule 59    type -> INT
Rule 60    type -> INT32
Rule 61    type -> INT64
Rule 62    type -> STRING
Rule 63    type -> FLOAT
Rule 64    type -> FLOAT32
Rule 65    type -> FLOAT64
Rule 66    type -> BOOL
Rule 67    conditional_structure -> IF conditions conditional_body
Rule 68    conditional_structure -> IF conditions conditional_body ELSE conditional_body
Rule 69    conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
Rule 70    conditional_body -> LBRACE statement RBRACE
Rule 71    conditional_body -> LBRACE BREAK RBRACE
Rule 72    conditional_body -> LBRACE CONTINUE RBRACE
Rule 73    conditions -> condition
Rule 74    conditions -> condition logical_operator conditions
Rule 75    condition -> value relational_operator value
Rule 76    logical_operator -> AND
Rule 77    logical_operator -> OR
Rule 78    logical_operator -> NOT
Rule 79    relational_operator -> GREATER
Rule 80    relational_operator -> LESS
Rule 81    relational_operator -> GREATEREQUALS
Rule 82    relational_operator -> LESSEQUALS
Rule 83    relational_operator -> EQUALS
Rule 84    relational_operator -> DIFFERENT
Rule 85    for_estructure -> for_initialization
Rule 86    for_estructure -> for_infinite_bucle
Rule 87    for_estructure -> for_iterator
Rule 88    for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
Rule 89    for_infinite_bucle -> FOR LBRACE statement RBRACE
Rule 90    for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
Rule 91    switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE
Rule 92    switch_expression -> value
Rule 93    switch_expression -> empty
Rule 94    case_blocks -> case_block
Rule 95    case_blocks -> case_block case_blocks
Rule 96    case_block -> CASE values COLON statement
Rule 97    case_block -> DEFAULT COLON statement
Rule 98    empty -> <empty>
Rule 99    list_structure -> empty_list
Rule 100   list_structure -> list_with_data
Rule 101   list_structure -> defined_list
Rule 102   empty_list -> LBRACE RBRACE
Rule 103   list_with_data -> LBRACE values RBRACE
Rule 104   defined_list -> TYPE VARIABLE LBRACE values RBRACE
Rule 105   map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
Rule 106   map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
Rule 107   map_values -> map_value
Rule 108   map_values -> map_value COMMA map_values
Rule 109   map_value -> string_value COLON string_value
Rule 110   map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
Rule 111   slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
Rule 112   slice_structure -> VAR VARIABLE LBRACKET RBRACKET type
Rule 113   slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type
Rule 114   slice_structure -> VARIABLE ASSIGN append_statement
Rule 115   append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 76
APPEND               : 115
ASSIGN               : 19 52 110 114
BOOL                 : 66
BREAK                : 71
CASE                 : 96
CHARSTRING           : 30 33
COLON                : 96 97 109
COMMA                : 28 38 39 57 108 115
CONST                : 
CONTINUE             : 72
DECREMENT            : 54
DEFAULT              : 97
DIFFERENT            : 84
DIVIDE               : 51
DIVIDEASSIGN         : 
ELSE                 : 68 69 69
EQUALS               : 83
FALSE                : 
FLOAT                : 35 63
FLOAT32              : 64
FLOAT64              : 65
FOR                  : 88 89 90
FORMATSTRING         : 38
FUNCTION             : 23 24 25 26
GREATER              : 79
GREATEREQUALS        : 81
IDENTIFIER           : 
IF                   : 67 68 69 69
IMPORT               : 
INCREMENT            : 53
INPUT                : 42 43 44
INT                  : 34 59
INT32                : 60
INT64                : 61
LBRACE               : 22 23 24 25 26 70 71 72 88 89 90 91 102 103 104 105 111
LBRACKET             : 105 106 110 111 112 113
LESS                 : 80
LESSEQUALS           : 82
LPAREN               : 23 24 25 26 36 37 38 39 40 41 42 43 44 106 115
MAIN                 : 
MAKE                 : 106
MAP                  : 105 106
MINUS                : 49
MINUSASSIGN          : 
MOD                  : 
MODASSIGN            : 
NOT                  : 78
OR                   : 77
PACKAGE              : 
PLUS                 : 48
PLUSASSIGN           : 
PRINT                : 36 37 38 39 40 41
RANGE                : 90
RBRACE               : 22 23 24 25 26 70 71 72 88 89 90 91 102 103 104 105 111
RBRACKET             : 105 106 110 111 112 113
RETURN               : 25 26
RPAREN               : 23 24 25 26 36 37 38 39 40 41 42 43 44 106 115
SEMICOLON            : 88 88 90
SHORTASSIGN          : 20 21 88 90 105 106 111 113
STRING               : 62
STRUCT               : 22
SWITCH               : 91
TEXT                 : 
TIMES                : 50
TIMESASSIGN          : 
TRUE                 : 
TYPE                 : 22 104
VAR                  : 18 19 112
VARIABLE             : 18 19 20 21 22 23 24 25 26 31 58 88 90 90 90 104 105 106 110 111 112 113 114 115
error                : 

Nonterminals, with rules where they appear

append_statement     : 114
block                : 2 3
blocks               : 1 3 23 24
case_block           : 94 95
case_blocks          : 91 95
condition            : 73 74 88
conditional_body     : 67 68 68 69 69 69
conditional_structure : 6
conditions           : 67 68 69 69 74
defined_list         : 101
double_operator      : 47 88
empty                : 93
empty_list           : 99
for_estructure       : 11
for_infinite_bucle   : 86
for_initialization   : 85
for_iterator         : 87
function             : 13
input_statement      : 5
list_structure       : 8
list_with_data       : 100
logical_operator     : 74
map_assign           : 10
map_estructure       : 9
map_value            : 107 108
map_values           : 105 108
number               : 32
operation            : 7 21 40 43 46
operator             : 45 46
parameter            : 55 56 57
parameters           : 14 24 26 56 57
print_statement      : 4
relational_operator  : 75
slice_structure      : 17
statement            : 22 70 88 89 90 96 97 0
string_value         : 37 39 109 109 110 110
structure            : 12
switch_expression    : 91
switch_structure     : 16
type                 : 18 25 26 58 105 105 106 106 111 112 113
value                : 19 20 25 26 27 28 29 45 45 46 47 75 75 88 88 92
values               : 28 36 38 39 42 96 103 104 111 115
variable_declaration : 15

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (16) block -> . switch_structure
    (17) block -> . slice_structure
    (36) print_statement -> . PRINT LPAREN values RPAREN
    (37) print_statement -> . PRINT LPAREN string_value RPAREN
    (38) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (39) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (40) print_statement -> . PRINT LPAREN operation RPAREN
    (41) print_statement -> . PRINT LPAREN RPAREN
    (42) input_statement -> . INPUT LPAREN values RPAREN
    (43) input_statement -> . INPUT LPAREN operation RPAREN
    (44) input_statement -> . INPUT LPAREN RPAREN
    (67) conditional_structure -> . IF conditions conditional_body
    (68) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (69) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (45) operation -> . value operator value
    (46) operation -> . value operator operation
    (47) operation -> . value double_operator
    (99) list_structure -> . empty_list
    (100) list_structure -> . list_with_data
    (101) list_structure -> . defined_list
    (105) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (106) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (110) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (85) for_estructure -> . for_initialization
    (86) for_estructure -> . for_infinite_bucle
    (87) for_estructure -> . for_iterator
    (22) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (24) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (25) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (26) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (55) parameters -> . parameter
    (56) parameters -> . parameter parameters
    (57) parameters -> . parameter COMMA parameters
    (18) variable_declaration -> . VAR VARIABLE type
    (19) variable_declaration -> . VAR VARIABLE ASSIGN value
    (20) variable_declaration -> . VARIABLE SHORTASSIGN value
    (21) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (91) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (111) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (112) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (113) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (114) slice_structure -> . VARIABLE ASSIGN append_statement
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (102) empty_list -> . LBRACE RBRACE
    (103) list_with_data -> . LBRACE values RBRACE
    (104) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (88) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (89) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (90) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (58) parameter -> . VARIABLE type
    (34) number -> . INT
    (35) number -> . FLOAT

    PRINT           shift and go to state 18
    INPUT           shift and go to state 19
    IF              shift and go to state 20
    VARIABLE        shift and go to state 25
    TYPE            shift and go to state 30
    FUNCTION        shift and go to state 31
    VAR             shift and go to state 33
    SWITCH          shift and go to state 34
    CHARSTRING      shift and go to state 36
    LBRACE          shift and go to state 26
    FOR             shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    statement                      shift and go to state 1
    blocks                         shift and go to state 2
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    switch_structure               shift and go to state 16
    slice_structure                shift and go to state 17
    value                          shift and go to state 21
    empty_list                     shift and go to state 22
    list_with_data                 shift and go to state 23
    defined_list                   shift and go to state 24
    for_initialization             shift and go to state 27
    for_infinite_bucle             shift and go to state 28
    for_iterator                   shift and go to state 29
    parameter                      shift and go to state 32
    number                         shift and go to state 35

state 1

    (0) S' -> statement .



state 2

    (1) statement -> blocks .

    $end            reduce using rule 1 (statement -> blocks .)
    RBRACE          reduce using rule 1 (statement -> blocks .)
    CASE            reduce using rule 1 (statement -> blocks .)
    DEFAULT         reduce using rule 1 (statement -> blocks .)


state 3

    (2) blocks -> block .
    (3) blocks -> block . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (16) block -> . switch_structure
    (17) block -> . slice_structure
    (36) print_statement -> . PRINT LPAREN values RPAREN
    (37) print_statement -> . PRINT LPAREN string_value RPAREN
    (38) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (39) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (40) print_statement -> . PRINT LPAREN operation RPAREN
    (41) print_statement -> . PRINT LPAREN RPAREN
    (42) input_statement -> . INPUT LPAREN values RPAREN
    (43) input_statement -> . INPUT LPAREN operation RPAREN
    (44) input_statement -> . INPUT LPAREN RPAREN
    (67) conditional_structure -> . IF conditions conditional_body
    (68) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (69) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (45) operation -> . value operator value
    (46) operation -> . value operator operation
    (47) operation -> . value double_operator
    (99) list_structure -> . empty_list
    (100) list_structure -> . list_with_data
    (101) list_structure -> . defined_list
    (105) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (106) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (110) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (85) for_estructure -> . for_initialization
    (86) for_estructure -> . for_infinite_bucle
    (87) for_estructure -> . for_iterator
    (22) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (24) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (25) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (26) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (55) parameters -> . parameter
    (56) parameters -> . parameter parameters
    (57) parameters -> . parameter COMMA parameters
    (18) variable_declaration -> . VAR VARIABLE type
    (19) variable_declaration -> . VAR VARIABLE ASSIGN value
    (20) variable_declaration -> . VARIABLE SHORTASSIGN value
    (21) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (91) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (111) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (112) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (113) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (114) slice_structure -> . VARIABLE ASSIGN append_statement
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (102) empty_list -> . LBRACE RBRACE
    (103) list_with_data -> . LBRACE values RBRACE
    (104) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (88) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (89) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (90) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (58) parameter -> . VARIABLE type
    (34) number -> . INT
    (35) number -> . FLOAT

    $end            reduce using rule 2 (blocks -> block .)
    RBRACE          reduce using rule 2 (blocks -> block .)
    CASE            reduce using rule 2 (blocks -> block .)
    DEFAULT         reduce using rule 2 (blocks -> block .)
    PRINT           shift and go to state 18
    INPUT           shift and go to state 19
    IF              shift and go to state 20
    VARIABLE        shift and go to state 25
    TYPE            shift and go to state 30
    FUNCTION        shift and go to state 31
    VAR             shift and go to state 33
    SWITCH          shift and go to state 34
    CHARSTRING      shift and go to state 36
    LBRACE          shift and go to state 26
    FOR             shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    block                          shift and go to state 3
    blocks                         shift and go to state 40
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    switch_structure               shift and go to state 16
    slice_structure                shift and go to state 17
    value                          shift and go to state 21
    empty_list                     shift and go to state 22
    list_with_data                 shift and go to state 23
    defined_list                   shift and go to state 24
    for_initialization             shift and go to state 27
    for_infinite_bucle             shift and go to state 28
    for_iterator                   shift and go to state 29
    parameter                      shift and go to state 32
    number                         shift and go to state 35

state 4

    (4) block -> print_statement .

    PRINT           reduce using rule 4 (block -> print_statement .)
    INPUT           reduce using rule 4 (block -> print_statement .)
    IF              reduce using rule 4 (block -> print_statement .)
    VARIABLE        reduce using rule 4 (block -> print_statement .)
    TYPE            reduce using rule 4 (block -> print_statement .)
    FUNCTION        reduce using rule 4 (block -> print_statement .)
    VAR             reduce using rule 4 (block -> print_statement .)
    SWITCH          reduce using rule 4 (block -> print_statement .)
    CHARSTRING      reduce using rule 4 (block -> print_statement .)
    LBRACE          reduce using rule 4 (block -> print_statement .)
    FOR             reduce using rule 4 (block -> print_statement .)
    INT             reduce using rule 4 (block -> print_statement .)
    FLOAT           reduce using rule 4 (block -> print_statement .)
    $end            reduce using rule 4 (block -> print_statement .)
    RBRACE          reduce using rule 4 (block -> print_statement .)
    CASE            reduce using rule 4 (block -> print_statement .)
    DEFAULT         reduce using rule 4 (block -> print_statement .)


state 5

    (5) block -> input_statement .

    PRINT           reduce using rule 5 (block -> input_statement .)
    INPUT           reduce using rule 5 (block -> input_statement .)
    IF              reduce using rule 5 (block -> input_statement .)
    VARIABLE        reduce using rule 5 (block -> input_statement .)
    TYPE            reduce using rule 5 (block -> input_statement .)
    FUNCTION        reduce using rule 5 (block -> input_statement .)
    VAR             reduce using rule 5 (block -> input_statement .)
    SWITCH          reduce using rule 5 (block -> input_statement .)
    CHARSTRING      reduce using rule 5 (block -> input_statement .)
    LBRACE          reduce using rule 5 (block -> input_statement .)
    FOR             reduce using rule 5 (block -> input_statement .)
    INT             reduce using rule 5 (block -> input_statement .)
    FLOAT           reduce using rule 5 (block -> input_statement .)
    $end            reduce using rule 5 (block -> input_statement .)
    RBRACE          reduce using rule 5 (block -> input_statement .)
    CASE            reduce using rule 5 (block -> input_statement .)
    DEFAULT         reduce using rule 5 (block -> input_statement .)


state 6

    (6) block -> conditional_structure .

    PRINT           reduce using rule 6 (block -> conditional_structure .)
    INPUT           reduce using rule 6 (block -> conditional_structure .)
    IF              reduce using rule 6 (block -> conditional_structure .)
    VARIABLE        reduce using rule 6 (block -> conditional_structure .)
    TYPE            reduce using rule 6 (block -> conditional_structure .)
    FUNCTION        reduce using rule 6 (block -> conditional_structure .)
    VAR             reduce using rule 6 (block -> conditional_structure .)
    SWITCH          reduce using rule 6 (block -> conditional_structure .)
    CHARSTRING      reduce using rule 6 (block -> conditional_structure .)
    LBRACE          reduce using rule 6 (block -> conditional_structure .)
    FOR             reduce using rule 6 (block -> conditional_structure .)
    INT             reduce using rule 6 (block -> conditional_structure .)
    FLOAT           reduce using rule 6 (block -> conditional_structure .)
    $end            reduce using rule 6 (block -> conditional_structure .)
    RBRACE          reduce using rule 6 (block -> conditional_structure .)
    CASE            reduce using rule 6 (block -> conditional_structure .)
    DEFAULT         reduce using rule 6 (block -> conditional_structure .)


state 7

    (7) block -> operation .

    PRINT           reduce using rule 7 (block -> operation .)
    INPUT           reduce using rule 7 (block -> operation .)
    IF              reduce using rule 7 (block -> operation .)
    VARIABLE        reduce using rule 7 (block -> operation .)
    TYPE            reduce using rule 7 (block -> operation .)
    FUNCTION        reduce using rule 7 (block -> operation .)
    VAR             reduce using rule 7 (block -> operation .)
    SWITCH          reduce using rule 7 (block -> operation .)
    CHARSTRING      reduce using rule 7 (block -> operation .)
    LBRACE          reduce using rule 7 (block -> operation .)
    FOR             reduce using rule 7 (block -> operation .)
    INT             reduce using rule 7 (block -> operation .)
    FLOAT           reduce using rule 7 (block -> operation .)
    $end            reduce using rule 7 (block -> operation .)
    RBRACE          reduce using rule 7 (block -> operation .)
    CASE            reduce using rule 7 (block -> operation .)
    DEFAULT         reduce using rule 7 (block -> operation .)


state 8

    (8) block -> list_structure .

    PRINT           reduce using rule 8 (block -> list_structure .)
    INPUT           reduce using rule 8 (block -> list_structure .)
    IF              reduce using rule 8 (block -> list_structure .)
    VARIABLE        reduce using rule 8 (block -> list_structure .)
    TYPE            reduce using rule 8 (block -> list_structure .)
    FUNCTION        reduce using rule 8 (block -> list_structure .)
    VAR             reduce using rule 8 (block -> list_structure .)
    SWITCH          reduce using rule 8 (block -> list_structure .)
    CHARSTRING      reduce using rule 8 (block -> list_structure .)
    LBRACE          reduce using rule 8 (block -> list_structure .)
    FOR             reduce using rule 8 (block -> list_structure .)
    INT             reduce using rule 8 (block -> list_structure .)
    FLOAT           reduce using rule 8 (block -> list_structure .)
    $end            reduce using rule 8 (block -> list_structure .)
    RBRACE          reduce using rule 8 (block -> list_structure .)
    CASE            reduce using rule 8 (block -> list_structure .)
    DEFAULT         reduce using rule 8 (block -> list_structure .)


state 9

    (9) block -> map_estructure .

    PRINT           reduce using rule 9 (block -> map_estructure .)
    INPUT           reduce using rule 9 (block -> map_estructure .)
    IF              reduce using rule 9 (block -> map_estructure .)
    VARIABLE        reduce using rule 9 (block -> map_estructure .)
    TYPE            reduce using rule 9 (block -> map_estructure .)
    FUNCTION        reduce using rule 9 (block -> map_estructure .)
    VAR             reduce using rule 9 (block -> map_estructure .)
    SWITCH          reduce using rule 9 (block -> map_estructure .)
    CHARSTRING      reduce using rule 9 (block -> map_estructure .)
    LBRACE          reduce using rule 9 (block -> map_estructure .)
    FOR             reduce using rule 9 (block -> map_estructure .)
    INT             reduce using rule 9 (block -> map_estructure .)
    FLOAT           reduce using rule 9 (block -> map_estructure .)
    $end            reduce using rule 9 (block -> map_estructure .)
    RBRACE          reduce using rule 9 (block -> map_estructure .)
    CASE            reduce using rule 9 (block -> map_estructure .)
    DEFAULT         reduce using rule 9 (block -> map_estructure .)


state 10

    (10) block -> map_assign .

    PRINT           reduce using rule 10 (block -> map_assign .)
    INPUT           reduce using rule 10 (block -> map_assign .)
    IF              reduce using rule 10 (block -> map_assign .)
    VARIABLE        reduce using rule 10 (block -> map_assign .)
    TYPE            reduce using rule 10 (block -> map_assign .)
    FUNCTION        reduce using rule 10 (block -> map_assign .)
    VAR             reduce using rule 10 (block -> map_assign .)
    SWITCH          reduce using rule 10 (block -> map_assign .)
    CHARSTRING      reduce using rule 10 (block -> map_assign .)
    LBRACE          reduce using rule 10 (block -> map_assign .)
    FOR             reduce using rule 10 (block -> map_assign .)
    INT             reduce using rule 10 (block -> map_assign .)
    FLOAT           reduce using rule 10 (block -> map_assign .)
    $end            reduce using rule 10 (block -> map_assign .)
    RBRACE          reduce using rule 10 (block -> map_assign .)
    CASE            reduce using rule 10 (block -> map_assign .)
    DEFAULT         reduce using rule 10 (block -> map_assign .)


state 11

    (11) block -> for_estructure .

    PRINT           reduce using rule 11 (block -> for_estructure .)
    INPUT           reduce using rule 11 (block -> for_estructure .)
    IF              reduce using rule 11 (block -> for_estructure .)
    VARIABLE        reduce using rule 11 (block -> for_estructure .)
    TYPE            reduce using rule 11 (block -> for_estructure .)
    FUNCTION        reduce using rule 11 (block -> for_estructure .)
    VAR             reduce using rule 11 (block -> for_estructure .)
    SWITCH          reduce using rule 11 (block -> for_estructure .)
    CHARSTRING      reduce using rule 11 (block -> for_estructure .)
    LBRACE          reduce using rule 11 (block -> for_estructure .)
    FOR             reduce using rule 11 (block -> for_estructure .)
    INT             reduce using rule 11 (block -> for_estructure .)
    FLOAT           reduce using rule 11 (block -> for_estructure .)
    $end            reduce using rule 11 (block -> for_estructure .)
    RBRACE          reduce using rule 11 (block -> for_estructure .)
    CASE            reduce using rule 11 (block -> for_estructure .)
    DEFAULT         reduce using rule 11 (block -> for_estructure .)


state 12

    (12) block -> structure .

    PRINT           reduce using rule 12 (block -> structure .)
    INPUT           reduce using rule 12 (block -> structure .)
    IF              reduce using rule 12 (block -> structure .)
    VARIABLE        reduce using rule 12 (block -> structure .)
    TYPE            reduce using rule 12 (block -> structure .)
    FUNCTION        reduce using rule 12 (block -> structure .)
    VAR             reduce using rule 12 (block -> structure .)
    SWITCH          reduce using rule 12 (block -> structure .)
    CHARSTRING      reduce using rule 12 (block -> structure .)
    LBRACE          reduce using rule 12 (block -> structure .)
    FOR             reduce using rule 12 (block -> structure .)
    INT             reduce using rule 12 (block -> structure .)
    FLOAT           reduce using rule 12 (block -> structure .)
    $end            reduce using rule 12 (block -> structure .)
    RBRACE          reduce using rule 12 (block -> structure .)
    CASE            reduce using rule 12 (block -> structure .)
    DEFAULT         reduce using rule 12 (block -> structure .)


state 13

    (13) block -> function .

    PRINT           reduce using rule 13 (block -> function .)
    INPUT           reduce using rule 13 (block -> function .)
    IF              reduce using rule 13 (block -> function .)
    VARIABLE        reduce using rule 13 (block -> function .)
    TYPE            reduce using rule 13 (block -> function .)
    FUNCTION        reduce using rule 13 (block -> function .)
    VAR             reduce using rule 13 (block -> function .)
    SWITCH          reduce using rule 13 (block -> function .)
    CHARSTRING      reduce using rule 13 (block -> function .)
    LBRACE          reduce using rule 13 (block -> function .)
    FOR             reduce using rule 13 (block -> function .)
    INT             reduce using rule 13 (block -> function .)
    FLOAT           reduce using rule 13 (block -> function .)
    $end            reduce using rule 13 (block -> function .)
    RBRACE          reduce using rule 13 (block -> function .)
    CASE            reduce using rule 13 (block -> function .)
    DEFAULT         reduce using rule 13 (block -> function .)


state 14

    (14) block -> parameters .

    PRINT           reduce using rule 14 (block -> parameters .)
    INPUT           reduce using rule 14 (block -> parameters .)
    IF              reduce using rule 14 (block -> parameters .)
    VARIABLE        reduce using rule 14 (block -> parameters .)
    TYPE            reduce using rule 14 (block -> parameters .)
    FUNCTION        reduce using rule 14 (block -> parameters .)
    VAR             reduce using rule 14 (block -> parameters .)
    SWITCH          reduce using rule 14 (block -> parameters .)
    CHARSTRING      reduce using rule 14 (block -> parameters .)
    LBRACE          reduce using rule 14 (block -> parameters .)
    FOR             reduce using rule 14 (block -> parameters .)
    INT             reduce using rule 14 (block -> parameters .)
    FLOAT           reduce using rule 14 (block -> parameters .)
    $end            reduce using rule 14 (block -> parameters .)
    RBRACE          reduce using rule 14 (block -> parameters .)
    CASE            reduce using rule 14 (block -> parameters .)
    DEFAULT         reduce using rule 14 (block -> parameters .)


state 15

    (15) block -> variable_declaration .

    PRINT           reduce using rule 15 (block -> variable_declaration .)
    INPUT           reduce using rule 15 (block -> variable_declaration .)
    IF              reduce using rule 15 (block -> variable_declaration .)
    VARIABLE        reduce using rule 15 (block -> variable_declaration .)
    TYPE            reduce using rule 15 (block -> variable_declaration .)
    FUNCTION        reduce using rule 15 (block -> variable_declaration .)
    VAR             reduce using rule 15 (block -> variable_declaration .)
    SWITCH          reduce using rule 15 (block -> variable_declaration .)
    CHARSTRING      reduce using rule 15 (block -> variable_declaration .)
    LBRACE          reduce using rule 15 (block -> variable_declaration .)
    FOR             reduce using rule 15 (block -> variable_declaration .)
    INT             reduce using rule 15 (block -> variable_declaration .)
    FLOAT           reduce using rule 15 (block -> variable_declaration .)
    $end            reduce using rule 15 (block -> variable_declaration .)
    RBRACE          reduce using rule 15 (block -> variable_declaration .)
    CASE            reduce using rule 15 (block -> variable_declaration .)
    DEFAULT         reduce using rule 15 (block -> variable_declaration .)


state 16

    (16) block -> switch_structure .

    PRINT           reduce using rule 16 (block -> switch_structure .)
    INPUT           reduce using rule 16 (block -> switch_structure .)
    IF              reduce using rule 16 (block -> switch_structure .)
    VARIABLE        reduce using rule 16 (block -> switch_structure .)
    TYPE            reduce using rule 16 (block -> switch_structure .)
    FUNCTION        reduce using rule 16 (block -> switch_structure .)
    VAR             reduce using rule 16 (block -> switch_structure .)
    SWITCH          reduce using rule 16 (block -> switch_structure .)
    CHARSTRING      reduce using rule 16 (block -> switch_structure .)
    LBRACE          reduce using rule 16 (block -> switch_structure .)
    FOR             reduce using rule 16 (block -> switch_structure .)
    INT             reduce using rule 16 (block -> switch_structure .)
    FLOAT           reduce using rule 16 (block -> switch_structure .)
    $end            reduce using rule 16 (block -> switch_structure .)
    RBRACE          reduce using rule 16 (block -> switch_structure .)
    CASE            reduce using rule 16 (block -> switch_structure .)
    DEFAULT         reduce using rule 16 (block -> switch_structure .)


state 17

    (17) block -> slice_structure .

    PRINT           reduce using rule 17 (block -> slice_structure .)
    INPUT           reduce using rule 17 (block -> slice_structure .)
    IF              reduce using rule 17 (block -> slice_structure .)
    VARIABLE        reduce using rule 17 (block -> slice_structure .)
    TYPE            reduce using rule 17 (block -> slice_structure .)
    FUNCTION        reduce using rule 17 (block -> slice_structure .)
    VAR             reduce using rule 17 (block -> slice_structure .)
    SWITCH          reduce using rule 17 (block -> slice_structure .)
    CHARSTRING      reduce using rule 17 (block -> slice_structure .)
    LBRACE          reduce using rule 17 (block -> slice_structure .)
    FOR             reduce using rule 17 (block -> slice_structure .)
    INT             reduce using rule 17 (block -> slice_structure .)
    FLOAT           reduce using rule 17 (block -> slice_structure .)
    $end            reduce using rule 17 (block -> slice_structure .)
    RBRACE          reduce using rule 17 (block -> slice_structure .)
    CASE            reduce using rule 17 (block -> slice_structure .)
    DEFAULT         reduce using rule 17 (block -> slice_structure .)


state 18

    (36) print_statement -> PRINT . LPAREN values RPAREN
    (37) print_statement -> PRINT . LPAREN string_value RPAREN
    (38) print_statement -> PRINT . LPAREN FORMATSTRING COMMA values RPAREN
    (39) print_statement -> PRINT . LPAREN string_value COMMA values RPAREN
    (40) print_statement -> PRINT . LPAREN operation RPAREN
    (41) print_statement -> PRINT . LPAREN RPAREN

    LPAREN          shift and go to state 41


state 19

    (42) input_statement -> INPUT . LPAREN values RPAREN
    (43) input_statement -> INPUT . LPAREN operation RPAREN
    (44) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 42


state 20

    (67) conditional_structure -> IF . conditions conditional_body
    (68) conditional_structure -> IF . conditions conditional_body ELSE conditional_body
    (69) conditional_structure -> IF . conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (73) conditions -> . condition
    (74) conditions -> . condition logical_operator conditions
    (75) condition -> . value relational_operator value
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    conditions                     shift and go to state 43
    condition                      shift and go to state 44
    value                          shift and go to state 45
    number                         shift and go to state 35

state 21

    (45) operation -> value . operator value
    (46) operation -> value . operator operation
    (47) operation -> value . double_operator
    (48) operator -> . PLUS
    (49) operator -> . MINUS
    (50) operator -> . TIMES
    (51) operator -> . DIVIDE
    (52) operator -> . ASSIGN
    (53) double_operator -> . INCREMENT
    (54) double_operator -> . DECREMENT

    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    ASSIGN          shift and go to state 53
    INCREMENT       shift and go to state 54
    DECREMENT       shift and go to state 55

    operator                       shift and go to state 47
    double_operator                shift and go to state 48

state 22

    (99) list_structure -> empty_list .

    PRINT           reduce using rule 99 (list_structure -> empty_list .)
    INPUT           reduce using rule 99 (list_structure -> empty_list .)
    IF              reduce using rule 99 (list_structure -> empty_list .)
    VARIABLE        reduce using rule 99 (list_structure -> empty_list .)
    TYPE            reduce using rule 99 (list_structure -> empty_list .)
    FUNCTION        reduce using rule 99 (list_structure -> empty_list .)
    VAR             reduce using rule 99 (list_structure -> empty_list .)
    SWITCH          reduce using rule 99 (list_structure -> empty_list .)
    CHARSTRING      reduce using rule 99 (list_structure -> empty_list .)
    LBRACE          reduce using rule 99 (list_structure -> empty_list .)
    FOR             reduce using rule 99 (list_structure -> empty_list .)
    INT             reduce using rule 99 (list_structure -> empty_list .)
    FLOAT           reduce using rule 99 (list_structure -> empty_list .)
    $end            reduce using rule 99 (list_structure -> empty_list .)
    RBRACE          reduce using rule 99 (list_structure -> empty_list .)
    CASE            reduce using rule 99 (list_structure -> empty_list .)
    DEFAULT         reduce using rule 99 (list_structure -> empty_list .)


state 23

    (100) list_structure -> list_with_data .

    PRINT           reduce using rule 100 (list_structure -> list_with_data .)
    INPUT           reduce using rule 100 (list_structure -> list_with_data .)
    IF              reduce using rule 100 (list_structure -> list_with_data .)
    VARIABLE        reduce using rule 100 (list_structure -> list_with_data .)
    TYPE            reduce using rule 100 (list_structure -> list_with_data .)
    FUNCTION        reduce using rule 100 (list_structure -> list_with_data .)
    VAR             reduce using rule 100 (list_structure -> list_with_data .)
    SWITCH          reduce using rule 100 (list_structure -> list_with_data .)
    CHARSTRING      reduce using rule 100 (list_structure -> list_with_data .)
    LBRACE          reduce using rule 100 (list_structure -> list_with_data .)
    FOR             reduce using rule 100 (list_structure -> list_with_data .)
    INT             reduce using rule 100 (list_structure -> list_with_data .)
    FLOAT           reduce using rule 100 (list_structure -> list_with_data .)
    $end            reduce using rule 100 (list_structure -> list_with_data .)
    RBRACE          reduce using rule 100 (list_structure -> list_with_data .)
    CASE            reduce using rule 100 (list_structure -> list_with_data .)
    DEFAULT         reduce using rule 100 (list_structure -> list_with_data .)


state 24

    (101) list_structure -> defined_list .

    PRINT           reduce using rule 101 (list_structure -> defined_list .)
    INPUT           reduce using rule 101 (list_structure -> defined_list .)
    IF              reduce using rule 101 (list_structure -> defined_list .)
    VARIABLE        reduce using rule 101 (list_structure -> defined_list .)
    TYPE            reduce using rule 101 (list_structure -> defined_list .)
    FUNCTION        reduce using rule 101 (list_structure -> defined_list .)
    VAR             reduce using rule 101 (list_structure -> defined_list .)
    SWITCH          reduce using rule 101 (list_structure -> defined_list .)
    CHARSTRING      reduce using rule 101 (list_structure -> defined_list .)
    LBRACE          reduce using rule 101 (list_structure -> defined_list .)
    FOR             reduce using rule 101 (list_structure -> defined_list .)
    INT             reduce using rule 101 (list_structure -> defined_list .)
    FLOAT           reduce using rule 101 (list_structure -> defined_list .)
    $end            reduce using rule 101 (list_structure -> defined_list .)
    RBRACE          reduce using rule 101 (list_structure -> defined_list .)
    CASE            reduce using rule 101 (list_structure -> defined_list .)
    DEFAULT         reduce using rule 101 (list_structure -> defined_list .)


state 25

    (105) map_estructure -> VARIABLE . SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (106) map_estructure -> VARIABLE . SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (110) map_assign -> VARIABLE . LBRACKET string_value RBRACKET ASSIGN string_value
    (20) variable_declaration -> VARIABLE . SHORTASSIGN value
    (21) variable_declaration -> VARIABLE . SHORTASSIGN operation
    (111) slice_structure -> VARIABLE . SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (113) slice_structure -> VARIABLE . SHORTASSIGN LBRACKET RBRACKET type
    (114) slice_structure -> VARIABLE . ASSIGN append_statement
    (31) value -> VARIABLE .
    (58) parameter -> VARIABLE . type
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

  ! shift/reduce conflict for ASSIGN resolved as shift
    SHORTASSIGN     shift and go to state 56
    LBRACKET        shift and go to state 57
    ASSIGN          shift and go to state 59
    PLUS            reduce using rule 31 (value -> VARIABLE .)
    MINUS           reduce using rule 31 (value -> VARIABLE .)
    TIMES           reduce using rule 31 (value -> VARIABLE .)
    DIVIDE          reduce using rule 31 (value -> VARIABLE .)
    INCREMENT       reduce using rule 31 (value -> VARIABLE .)
    DECREMENT       reduce using rule 31 (value -> VARIABLE .)
    INT             shift and go to state 60
    INT32           shift and go to state 61
    INT64           shift and go to state 62
    STRING          shift and go to state 63
    FLOAT           shift and go to state 64
    FLOAT32         shift and go to state 65
    FLOAT64         shift and go to state 66
    BOOL            shift and go to state 67

  ! ASSIGN          [ reduce using rule 31 (value -> VARIABLE .) ]

    type                           shift and go to state 58

state 26

    (102) empty_list -> LBRACE . RBRACE
    (103) list_with_data -> LBRACE . values RBRACE
    (27) values -> . value
    (28) values -> . value COMMA values
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    RBRACE          shift and go to state 68
    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    values                         shift and go to state 69
    value                          shift and go to state 70
    number                         shift and go to state 35

state 27

    (85) for_estructure -> for_initialization .

    PRINT           reduce using rule 85 (for_estructure -> for_initialization .)
    INPUT           reduce using rule 85 (for_estructure -> for_initialization .)
    IF              reduce using rule 85 (for_estructure -> for_initialization .)
    VARIABLE        reduce using rule 85 (for_estructure -> for_initialization .)
    TYPE            reduce using rule 85 (for_estructure -> for_initialization .)
    FUNCTION        reduce using rule 85 (for_estructure -> for_initialization .)
    VAR             reduce using rule 85 (for_estructure -> for_initialization .)
    SWITCH          reduce using rule 85 (for_estructure -> for_initialization .)
    CHARSTRING      reduce using rule 85 (for_estructure -> for_initialization .)
    LBRACE          reduce using rule 85 (for_estructure -> for_initialization .)
    FOR             reduce using rule 85 (for_estructure -> for_initialization .)
    INT             reduce using rule 85 (for_estructure -> for_initialization .)
    FLOAT           reduce using rule 85 (for_estructure -> for_initialization .)
    $end            reduce using rule 85 (for_estructure -> for_initialization .)
    RBRACE          reduce using rule 85 (for_estructure -> for_initialization .)
    CASE            reduce using rule 85 (for_estructure -> for_initialization .)
    DEFAULT         reduce using rule 85 (for_estructure -> for_initialization .)


state 28

    (86) for_estructure -> for_infinite_bucle .

    PRINT           reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    INPUT           reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    IF              reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    VARIABLE        reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    TYPE            reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    FUNCTION        reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    VAR             reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    SWITCH          reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    CHARSTRING      reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    LBRACE          reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    FOR             reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    INT             reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    FLOAT           reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    $end            reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    RBRACE          reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    CASE            reduce using rule 86 (for_estructure -> for_infinite_bucle .)
    DEFAULT         reduce using rule 86 (for_estructure -> for_infinite_bucle .)


state 29

    (87) for_estructure -> for_iterator .

    PRINT           reduce using rule 87 (for_estructure -> for_iterator .)
    INPUT           reduce using rule 87 (for_estructure -> for_iterator .)
    IF              reduce using rule 87 (for_estructure -> for_iterator .)
    VARIABLE        reduce using rule 87 (for_estructure -> for_iterator .)
    TYPE            reduce using rule 87 (for_estructure -> for_iterator .)
    FUNCTION        reduce using rule 87 (for_estructure -> for_iterator .)
    VAR             reduce using rule 87 (for_estructure -> for_iterator .)
    SWITCH          reduce using rule 87 (for_estructure -> for_iterator .)
    CHARSTRING      reduce using rule 87 (for_estructure -> for_iterator .)
    LBRACE          reduce using rule 87 (for_estructure -> for_iterator .)
    FOR             reduce using rule 87 (for_estructure -> for_iterator .)
    INT             reduce using rule 87 (for_estructure -> for_iterator .)
    FLOAT           reduce using rule 87 (for_estructure -> for_iterator .)
    $end            reduce using rule 87 (for_estructure -> for_iterator .)
    RBRACE          reduce using rule 87 (for_estructure -> for_iterator .)
    CASE            reduce using rule 87 (for_estructure -> for_iterator .)
    DEFAULT         reduce using rule 87 (for_estructure -> for_iterator .)


state 30

    (22) structure -> TYPE . VARIABLE STRUCT LBRACE statement RBRACE
    (104) defined_list -> TYPE . VARIABLE LBRACE values RBRACE

    VARIABLE        shift and go to state 71


state 31

    (23) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (24) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (25) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (26) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE

    VARIABLE        shift and go to state 72


state 32

    (55) parameters -> parameter .
    (56) parameters -> parameter . parameters
    (57) parameters -> parameter . COMMA parameters
    (55) parameters -> . parameter
    (56) parameters -> . parameter parameters
    (57) parameters -> . parameter COMMA parameters
    (58) parameter -> . VARIABLE type

  ! shift/reduce conflict for VARIABLE resolved as shift
    PRINT           reduce using rule 55 (parameters -> parameter .)
    INPUT           reduce using rule 55 (parameters -> parameter .)
    IF              reduce using rule 55 (parameters -> parameter .)
    TYPE            reduce using rule 55 (parameters -> parameter .)
    FUNCTION        reduce using rule 55 (parameters -> parameter .)
    VAR             reduce using rule 55 (parameters -> parameter .)
    SWITCH          reduce using rule 55 (parameters -> parameter .)
    CHARSTRING      reduce using rule 55 (parameters -> parameter .)
    LBRACE          reduce using rule 55 (parameters -> parameter .)
    FOR             reduce using rule 55 (parameters -> parameter .)
    INT             reduce using rule 55 (parameters -> parameter .)
    FLOAT           reduce using rule 55 (parameters -> parameter .)
    $end            reduce using rule 55 (parameters -> parameter .)
    RBRACE          reduce using rule 55 (parameters -> parameter .)
    CASE            reduce using rule 55 (parameters -> parameter .)
    DEFAULT         reduce using rule 55 (parameters -> parameter .)
    RPAREN          reduce using rule 55 (parameters -> parameter .)
    COMMA           shift and go to state 74
    VARIABLE        shift and go to state 75

  ! VARIABLE        [ reduce using rule 55 (parameters -> parameter .) ]

    parameter                      shift and go to state 32
    parameters                     shift and go to state 73

state 33

    (18) variable_declaration -> VAR . VARIABLE type
    (19) variable_declaration -> VAR . VARIABLE ASSIGN value
    (112) slice_structure -> VAR . VARIABLE LBRACKET RBRACKET type

    VARIABLE        shift and go to state 76


state 34

    (91) switch_structure -> SWITCH . switch_expression LBRACE case_blocks RBRACE
    (92) switch_expression -> . value
    (93) switch_expression -> . empty
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (98) empty -> .
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    LBRACE          reduce using rule 98 (empty -> .)
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    switch_expression              shift and go to state 77
    value                          shift and go to state 78
    empty                          shift and go to state 79
    number                         shift and go to state 35

state 35

    (32) value -> number .

    PLUS            reduce using rule 32 (value -> number .)
    MINUS           reduce using rule 32 (value -> number .)
    TIMES           reduce using rule 32 (value -> number .)
    DIVIDE          reduce using rule 32 (value -> number .)
    ASSIGN          reduce using rule 32 (value -> number .)
    INCREMENT       reduce using rule 32 (value -> number .)
    DECREMENT       reduce using rule 32 (value -> number .)
    GREATER         reduce using rule 32 (value -> number .)
    LESS            reduce using rule 32 (value -> number .)
    GREATEREQUALS   reduce using rule 32 (value -> number .)
    LESSEQUALS      reduce using rule 32 (value -> number .)
    EQUALS          reduce using rule 32 (value -> number .)
    DIFFERENT       reduce using rule 32 (value -> number .)
    COMMA           reduce using rule 32 (value -> number .)
    RBRACE          reduce using rule 32 (value -> number .)
    LBRACE          reduce using rule 32 (value -> number .)
    RPAREN          reduce using rule 32 (value -> number .)
    PRINT           reduce using rule 32 (value -> number .)
    INPUT           reduce using rule 32 (value -> number .)
    IF              reduce using rule 32 (value -> number .)
    VARIABLE        reduce using rule 32 (value -> number .)
    TYPE            reduce using rule 32 (value -> number .)
    FUNCTION        reduce using rule 32 (value -> number .)
    VAR             reduce using rule 32 (value -> number .)
    SWITCH          reduce using rule 32 (value -> number .)
    CHARSTRING      reduce using rule 32 (value -> number .)
    FOR             reduce using rule 32 (value -> number .)
    INT             reduce using rule 32 (value -> number .)
    FLOAT           reduce using rule 32 (value -> number .)
    $end            reduce using rule 32 (value -> number .)
    CASE            reduce using rule 32 (value -> number .)
    DEFAULT         reduce using rule 32 (value -> number .)
    RBRACKET        reduce using rule 32 (value -> number .)
    AND             reduce using rule 32 (value -> number .)
    OR              reduce using rule 32 (value -> number .)
    NOT             reduce using rule 32 (value -> number .)
    SEMICOLON       reduce using rule 32 (value -> number .)
    COLON           reduce using rule 32 (value -> number .)


state 36

    (33) value -> CHARSTRING .

    PLUS            reduce using rule 33 (value -> CHARSTRING .)
    MINUS           reduce using rule 33 (value -> CHARSTRING .)
    TIMES           reduce using rule 33 (value -> CHARSTRING .)
    DIVIDE          reduce using rule 33 (value -> CHARSTRING .)
    ASSIGN          reduce using rule 33 (value -> CHARSTRING .)
    INCREMENT       reduce using rule 33 (value -> CHARSTRING .)
    DECREMENT       reduce using rule 33 (value -> CHARSTRING .)
    GREATER         reduce using rule 33 (value -> CHARSTRING .)
    LESS            reduce using rule 33 (value -> CHARSTRING .)
    GREATEREQUALS   reduce using rule 33 (value -> CHARSTRING .)
    LESSEQUALS      reduce using rule 33 (value -> CHARSTRING .)
    EQUALS          reduce using rule 33 (value -> CHARSTRING .)
    DIFFERENT       reduce using rule 33 (value -> CHARSTRING .)
    COMMA           reduce using rule 33 (value -> CHARSTRING .)
    RBRACE          reduce using rule 33 (value -> CHARSTRING .)
    LBRACE          reduce using rule 33 (value -> CHARSTRING .)
    RPAREN          reduce using rule 33 (value -> CHARSTRING .)
    PRINT           reduce using rule 33 (value -> CHARSTRING .)
    INPUT           reduce using rule 33 (value -> CHARSTRING .)
    IF              reduce using rule 33 (value -> CHARSTRING .)
    VARIABLE        reduce using rule 33 (value -> CHARSTRING .)
    TYPE            reduce using rule 33 (value -> CHARSTRING .)
    FUNCTION        reduce using rule 33 (value -> CHARSTRING .)
    VAR             reduce using rule 33 (value -> CHARSTRING .)
    SWITCH          reduce using rule 33 (value -> CHARSTRING .)
    CHARSTRING      reduce using rule 33 (value -> CHARSTRING .)
    FOR             reduce using rule 33 (value -> CHARSTRING .)
    INT             reduce using rule 33 (value -> CHARSTRING .)
    FLOAT           reduce using rule 33 (value -> CHARSTRING .)
    $end            reduce using rule 33 (value -> CHARSTRING .)
    CASE            reduce using rule 33 (value -> CHARSTRING .)
    DEFAULT         reduce using rule 33 (value -> CHARSTRING .)
    AND             reduce using rule 33 (value -> CHARSTRING .)
    OR              reduce using rule 33 (value -> CHARSTRING .)
    NOT             reduce using rule 33 (value -> CHARSTRING .)
    SEMICOLON       reduce using rule 33 (value -> CHARSTRING .)
    COLON           reduce using rule 33 (value -> CHARSTRING .)


state 37

    (88) for_initialization -> FOR . VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (89) for_infinite_bucle -> FOR . LBRACE statement RBRACE
    (90) for_iterator -> FOR . VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 80
    LBRACE          shift and go to state 81


state 38

    (34) number -> INT .

    PLUS            reduce using rule 34 (number -> INT .)
    MINUS           reduce using rule 34 (number -> INT .)
    TIMES           reduce using rule 34 (number -> INT .)
    DIVIDE          reduce using rule 34 (number -> INT .)
    ASSIGN          reduce using rule 34 (number -> INT .)
    INCREMENT       reduce using rule 34 (number -> INT .)
    DECREMENT       reduce using rule 34 (number -> INT .)
    GREATER         reduce using rule 34 (number -> INT .)
    LESS            reduce using rule 34 (number -> INT .)
    GREATEREQUALS   reduce using rule 34 (number -> INT .)
    LESSEQUALS      reduce using rule 34 (number -> INT .)
    EQUALS          reduce using rule 34 (number -> INT .)
    DIFFERENT       reduce using rule 34 (number -> INT .)
    COMMA           reduce using rule 34 (number -> INT .)
    RBRACE          reduce using rule 34 (number -> INT .)
    LBRACE          reduce using rule 34 (number -> INT .)
    RPAREN          reduce using rule 34 (number -> INT .)
    PRINT           reduce using rule 34 (number -> INT .)
    INPUT           reduce using rule 34 (number -> INT .)
    IF              reduce using rule 34 (number -> INT .)
    VARIABLE        reduce using rule 34 (number -> INT .)
    TYPE            reduce using rule 34 (number -> INT .)
    FUNCTION        reduce using rule 34 (number -> INT .)
    VAR             reduce using rule 34 (number -> INT .)
    SWITCH          reduce using rule 34 (number -> INT .)
    CHARSTRING      reduce using rule 34 (number -> INT .)
    FOR             reduce using rule 34 (number -> INT .)
    INT             reduce using rule 34 (number -> INT .)
    FLOAT           reduce using rule 34 (number -> INT .)
    $end            reduce using rule 34 (number -> INT .)
    CASE            reduce using rule 34 (number -> INT .)
    DEFAULT         reduce using rule 34 (number -> INT .)
    RBRACKET        reduce using rule 34 (number -> INT .)
    AND             reduce using rule 34 (number -> INT .)
    OR              reduce using rule 34 (number -> INT .)
    NOT             reduce using rule 34 (number -> INT .)
    SEMICOLON       reduce using rule 34 (number -> INT .)
    COLON           reduce using rule 34 (number -> INT .)


state 39

    (35) number -> FLOAT .

    PLUS            reduce using rule 35 (number -> FLOAT .)
    MINUS           reduce using rule 35 (number -> FLOAT .)
    TIMES           reduce using rule 35 (number -> FLOAT .)
    DIVIDE          reduce using rule 35 (number -> FLOAT .)
    ASSIGN          reduce using rule 35 (number -> FLOAT .)
    INCREMENT       reduce using rule 35 (number -> FLOAT .)
    DECREMENT       reduce using rule 35 (number -> FLOAT .)
    GREATER         reduce using rule 35 (number -> FLOAT .)
    LESS            reduce using rule 35 (number -> FLOAT .)
    GREATEREQUALS   reduce using rule 35 (number -> FLOAT .)
    LESSEQUALS      reduce using rule 35 (number -> FLOAT .)
    EQUALS          reduce using rule 35 (number -> FLOAT .)
    DIFFERENT       reduce using rule 35 (number -> FLOAT .)
    COMMA           reduce using rule 35 (number -> FLOAT .)
    RBRACE          reduce using rule 35 (number -> FLOAT .)
    LBRACE          reduce using rule 35 (number -> FLOAT .)
    RPAREN          reduce using rule 35 (number -> FLOAT .)
    PRINT           reduce using rule 35 (number -> FLOAT .)
    INPUT           reduce using rule 35 (number -> FLOAT .)
    IF              reduce using rule 35 (number -> FLOAT .)
    VARIABLE        reduce using rule 35 (number -> FLOAT .)
    TYPE            reduce using rule 35 (number -> FLOAT .)
    FUNCTION        reduce using rule 35 (number -> FLOAT .)
    VAR             reduce using rule 35 (number -> FLOAT .)
    SWITCH          reduce using rule 35 (number -> FLOAT .)
    CHARSTRING      reduce using rule 35 (number -> FLOAT .)
    FOR             reduce using rule 35 (number -> FLOAT .)
    INT             reduce using rule 35 (number -> FLOAT .)
    FLOAT           reduce using rule 35 (number -> FLOAT .)
    $end            reduce using rule 35 (number -> FLOAT .)
    CASE            reduce using rule 35 (number -> FLOAT .)
    DEFAULT         reduce using rule 35 (number -> FLOAT .)
    RBRACKET        reduce using rule 35 (number -> FLOAT .)
    AND             reduce using rule 35 (number -> FLOAT .)
    OR              reduce using rule 35 (number -> FLOAT .)
    NOT             reduce using rule 35 (number -> FLOAT .)
    SEMICOLON       reduce using rule 35 (number -> FLOAT .)
    COLON           reduce using rule 35 (number -> FLOAT .)


state 40

    (3) blocks -> block blocks .

    $end            reduce using rule 3 (blocks -> block blocks .)
    RBRACE          reduce using rule 3 (blocks -> block blocks .)
    CASE            reduce using rule 3 (blocks -> block blocks .)
    DEFAULT         reduce using rule 3 (blocks -> block blocks .)


state 41

    (36) print_statement -> PRINT LPAREN . values RPAREN
    (37) print_statement -> PRINT LPAREN . string_value RPAREN
    (38) print_statement -> PRINT LPAREN . FORMATSTRING COMMA values RPAREN
    (39) print_statement -> PRINT LPAREN . string_value COMMA values RPAREN
    (40) print_statement -> PRINT LPAREN . operation RPAREN
    (41) print_statement -> PRINT LPAREN . RPAREN
    (27) values -> . value
    (28) values -> . value COMMA values
    (29) string_value -> . value
    (30) string_value -> . CHARSTRING
    (45) operation -> . value operator value
    (46) operation -> . value operator operation
    (47) operation -> . value double_operator
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    FORMATSTRING    shift and go to state 85
    RPAREN          shift and go to state 83
    CHARSTRING      shift and go to state 88
    VARIABLE        shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    values                         shift and go to state 82
    string_value                   shift and go to state 84
    operation                      shift and go to state 86
    value                          shift and go to state 87
    number                         shift and go to state 35

state 42

    (42) input_statement -> INPUT LPAREN . values RPAREN
    (43) input_statement -> INPUT LPAREN . operation RPAREN
    (44) input_statement -> INPUT LPAREN . RPAREN
    (27) values -> . value
    (28) values -> . value COMMA values
    (45) operation -> . value operator value
    (46) operation -> . value operator operation
    (47) operation -> . value double_operator
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    RPAREN          shift and go to state 90
    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    values                         shift and go to state 89
    operation                      shift and go to state 91
    value                          shift and go to state 92
    number                         shift and go to state 35

state 43

    (67) conditional_structure -> IF conditions . conditional_body
    (68) conditional_structure -> IF conditions . conditional_body ELSE conditional_body
    (69) conditional_structure -> IF conditions . conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (70) conditional_body -> . LBRACE statement RBRACE
    (71) conditional_body -> . LBRACE BREAK RBRACE
    (72) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 94

    conditional_body               shift and go to state 93

state 44

    (73) conditions -> condition .
    (74) conditions -> condition . logical_operator conditions
    (76) logical_operator -> . AND
    (77) logical_operator -> . OR
    (78) logical_operator -> . NOT

    LBRACE          reduce using rule 73 (conditions -> condition .)
    AND             shift and go to state 96
    OR              shift and go to state 97
    NOT             shift and go to state 98

    logical_operator               shift and go to state 95

state 45

    (75) condition -> value . relational_operator value
    (79) relational_operator -> . GREATER
    (80) relational_operator -> . LESS
    (81) relational_operator -> . GREATEREQUALS
    (82) relational_operator -> . LESSEQUALS
    (83) relational_operator -> . EQUALS
    (84) relational_operator -> . DIFFERENT

    GREATER         shift and go to state 100
    LESS            shift and go to state 101
    GREATEREQUALS   shift and go to state 102
    LESSEQUALS      shift and go to state 103
    EQUALS          shift and go to state 104
    DIFFERENT       shift and go to state 105

    relational_operator            shift and go to state 99

state 46

    (31) value -> VARIABLE .

    GREATER         reduce using rule 31 (value -> VARIABLE .)
    LESS            reduce using rule 31 (value -> VARIABLE .)
    GREATEREQUALS   reduce using rule 31 (value -> VARIABLE .)
    LESSEQUALS      reduce using rule 31 (value -> VARIABLE .)
    EQUALS          reduce using rule 31 (value -> VARIABLE .)
    DIFFERENT       reduce using rule 31 (value -> VARIABLE .)
    COMMA           reduce using rule 31 (value -> VARIABLE .)
    RBRACE          reduce using rule 31 (value -> VARIABLE .)
    LBRACE          reduce using rule 31 (value -> VARIABLE .)
    PLUS            reduce using rule 31 (value -> VARIABLE .)
    MINUS           reduce using rule 31 (value -> VARIABLE .)
    TIMES           reduce using rule 31 (value -> VARIABLE .)
    DIVIDE          reduce using rule 31 (value -> VARIABLE .)
    ASSIGN          reduce using rule 31 (value -> VARIABLE .)
    INCREMENT       reduce using rule 31 (value -> VARIABLE .)
    DECREMENT       reduce using rule 31 (value -> VARIABLE .)
    RPAREN          reduce using rule 31 (value -> VARIABLE .)
    PRINT           reduce using rule 31 (value -> VARIABLE .)
    INPUT           reduce using rule 31 (value -> VARIABLE .)
    IF              reduce using rule 31 (value -> VARIABLE .)
    VARIABLE        reduce using rule 31 (value -> VARIABLE .)
    TYPE            reduce using rule 31 (value -> VARIABLE .)
    FUNCTION        reduce using rule 31 (value -> VARIABLE .)
    VAR             reduce using rule 31 (value -> VARIABLE .)
    SWITCH          reduce using rule 31 (value -> VARIABLE .)
    CHARSTRING      reduce using rule 31 (value -> VARIABLE .)
    FOR             reduce using rule 31 (value -> VARIABLE .)
    INT             reduce using rule 31 (value -> VARIABLE .)
    FLOAT           reduce using rule 31 (value -> VARIABLE .)
    $end            reduce using rule 31 (value -> VARIABLE .)
    CASE            reduce using rule 31 (value -> VARIABLE .)
    DEFAULT         reduce using rule 31 (value -> VARIABLE .)
    RBRACKET        reduce using rule 31 (value -> VARIABLE .)
    AND             reduce using rule 31 (value -> VARIABLE .)
    OR              reduce using rule 31 (value -> VARIABLE .)
    NOT             reduce using rule 31 (value -> VARIABLE .)
    SEMICOLON       reduce using rule 31 (value -> VARIABLE .)
    COLON           reduce using rule 31 (value -> VARIABLE .)


state 47

    (45) operation -> value operator . value
    (46) operation -> value operator . operation
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (45) operation -> . value operator value
    (46) operation -> . value operator operation
    (47) operation -> . value double_operator
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    value                          shift and go to state 106
    operation                      shift and go to state 107
    number                         shift and go to state 35

state 48

    (47) operation -> value double_operator .

    PRINT           reduce using rule 47 (operation -> value double_operator .)
    INPUT           reduce using rule 47 (operation -> value double_operator .)
    IF              reduce using rule 47 (operation -> value double_operator .)
    VARIABLE        reduce using rule 47 (operation -> value double_operator .)
    TYPE            reduce using rule 47 (operation -> value double_operator .)
    FUNCTION        reduce using rule 47 (operation -> value double_operator .)
    VAR             reduce using rule 47 (operation -> value double_operator .)
    SWITCH          reduce using rule 47 (operation -> value double_operator .)
    CHARSTRING      reduce using rule 47 (operation -> value double_operator .)
    LBRACE          reduce using rule 47 (operation -> value double_operator .)
    FOR             reduce using rule 47 (operation -> value double_operator .)
    INT             reduce using rule 47 (operation -> value double_operator .)
    FLOAT           reduce using rule 47 (operation -> value double_operator .)
    $end            reduce using rule 47 (operation -> value double_operator .)
    RBRACE          reduce using rule 47 (operation -> value double_operator .)
    CASE            reduce using rule 47 (operation -> value double_operator .)
    DEFAULT         reduce using rule 47 (operation -> value double_operator .)
    RPAREN          reduce using rule 47 (operation -> value double_operator .)


state 49

    (48) operator -> PLUS .

    VARIABLE        reduce using rule 48 (operator -> PLUS .)
    CHARSTRING      reduce using rule 48 (operator -> PLUS .)
    INT             reduce using rule 48 (operator -> PLUS .)
    FLOAT           reduce using rule 48 (operator -> PLUS .)


state 50

    (49) operator -> MINUS .

    VARIABLE        reduce using rule 49 (operator -> MINUS .)
    CHARSTRING      reduce using rule 49 (operator -> MINUS .)
    INT             reduce using rule 49 (operator -> MINUS .)
    FLOAT           reduce using rule 49 (operator -> MINUS .)


state 51

    (50) operator -> TIMES .

    VARIABLE        reduce using rule 50 (operator -> TIMES .)
    CHARSTRING      reduce using rule 50 (operator -> TIMES .)
    INT             reduce using rule 50 (operator -> TIMES .)
    FLOAT           reduce using rule 50 (operator -> TIMES .)


state 52

    (51) operator -> DIVIDE .

    VARIABLE        reduce using rule 51 (operator -> DIVIDE .)
    CHARSTRING      reduce using rule 51 (operator -> DIVIDE .)
    INT             reduce using rule 51 (operator -> DIVIDE .)
    FLOAT           reduce using rule 51 (operator -> DIVIDE .)


state 53

    (52) operator -> ASSIGN .

    VARIABLE        reduce using rule 52 (operator -> ASSIGN .)
    CHARSTRING      reduce using rule 52 (operator -> ASSIGN .)
    INT             reduce using rule 52 (operator -> ASSIGN .)
    FLOAT           reduce using rule 52 (operator -> ASSIGN .)


state 54

    (53) double_operator -> INCREMENT .

    PRINT           reduce using rule 53 (double_operator -> INCREMENT .)
    INPUT           reduce using rule 53 (double_operator -> INCREMENT .)
    IF              reduce using rule 53 (double_operator -> INCREMENT .)
    VARIABLE        reduce using rule 53 (double_operator -> INCREMENT .)
    TYPE            reduce using rule 53 (double_operator -> INCREMENT .)
    FUNCTION        reduce using rule 53 (double_operator -> INCREMENT .)
    VAR             reduce using rule 53 (double_operator -> INCREMENT .)
    SWITCH          reduce using rule 53 (double_operator -> INCREMENT .)
    CHARSTRING      reduce using rule 53 (double_operator -> INCREMENT .)
    LBRACE          reduce using rule 53 (double_operator -> INCREMENT .)
    FOR             reduce using rule 53 (double_operator -> INCREMENT .)
    INT             reduce using rule 53 (double_operator -> INCREMENT .)
    FLOAT           reduce using rule 53 (double_operator -> INCREMENT .)
    $end            reduce using rule 53 (double_operator -> INCREMENT .)
    RBRACE          reduce using rule 53 (double_operator -> INCREMENT .)
    CASE            reduce using rule 53 (double_operator -> INCREMENT .)
    DEFAULT         reduce using rule 53 (double_operator -> INCREMENT .)
    RPAREN          reduce using rule 53 (double_operator -> INCREMENT .)


state 55

    (54) double_operator -> DECREMENT .

    PRINT           reduce using rule 54 (double_operator -> DECREMENT .)
    INPUT           reduce using rule 54 (double_operator -> DECREMENT .)
    IF              reduce using rule 54 (double_operator -> DECREMENT .)
    VARIABLE        reduce using rule 54 (double_operator -> DECREMENT .)
    TYPE            reduce using rule 54 (double_operator -> DECREMENT .)
    FUNCTION        reduce using rule 54 (double_operator -> DECREMENT .)
    VAR             reduce using rule 54 (double_operator -> DECREMENT .)
    SWITCH          reduce using rule 54 (double_operator -> DECREMENT .)
    CHARSTRING      reduce using rule 54 (double_operator -> DECREMENT .)
    LBRACE          reduce using rule 54 (double_operator -> DECREMENT .)
    FOR             reduce using rule 54 (double_operator -> DECREMENT .)
    INT             reduce using rule 54 (double_operator -> DECREMENT .)
    FLOAT           reduce using rule 54 (double_operator -> DECREMENT .)
    $end            reduce using rule 54 (double_operator -> DECREMENT .)
    RBRACE          reduce using rule 54 (double_operator -> DECREMENT .)
    CASE            reduce using rule 54 (double_operator -> DECREMENT .)
    DEFAULT         reduce using rule 54 (double_operator -> DECREMENT .)
    RPAREN          reduce using rule 54 (double_operator -> DECREMENT .)


state 56

    (105) map_estructure -> VARIABLE SHORTASSIGN . MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (106) map_estructure -> VARIABLE SHORTASSIGN . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (20) variable_declaration -> VARIABLE SHORTASSIGN . value
    (21) variable_declaration -> VARIABLE SHORTASSIGN . operation
    (111) slice_structure -> VARIABLE SHORTASSIGN . LBRACKET RBRACKET type LBRACE values RBRACE
    (113) slice_structure -> VARIABLE SHORTASSIGN . LBRACKET RBRACKET type
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (45) operation -> . value operator value
    (46) operation -> . value operator operation
    (47) operation -> . value double_operator
    (34) number -> . INT
    (35) number -> . FLOAT

    MAP             shift and go to state 108
    MAKE            shift and go to state 110
    LBRACKET        shift and go to state 109
    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    value                          shift and go to state 111
    operation                      shift and go to state 112
    number                         shift and go to state 35

state 57

    (110) map_assign -> VARIABLE LBRACKET . string_value RBRACKET ASSIGN string_value
    (29) string_value -> . value
    (30) string_value -> . CHARSTRING
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    CHARSTRING      shift and go to state 88
    VARIABLE        shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    string_value                   shift and go to state 113
    value                          shift and go to state 114
    number                         shift and go to state 35

state 58

    (58) parameter -> VARIABLE type .

    COMMA           reduce using rule 58 (parameter -> VARIABLE type .)
    VARIABLE        reduce using rule 58 (parameter -> VARIABLE type .)
    PRINT           reduce using rule 58 (parameter -> VARIABLE type .)
    INPUT           reduce using rule 58 (parameter -> VARIABLE type .)
    IF              reduce using rule 58 (parameter -> VARIABLE type .)
    TYPE            reduce using rule 58 (parameter -> VARIABLE type .)
    FUNCTION        reduce using rule 58 (parameter -> VARIABLE type .)
    VAR             reduce using rule 58 (parameter -> VARIABLE type .)
    SWITCH          reduce using rule 58 (parameter -> VARIABLE type .)
    CHARSTRING      reduce using rule 58 (parameter -> VARIABLE type .)
    LBRACE          reduce using rule 58 (parameter -> VARIABLE type .)
    FOR             reduce using rule 58 (parameter -> VARIABLE type .)
    INT             reduce using rule 58 (parameter -> VARIABLE type .)
    FLOAT           reduce using rule 58 (parameter -> VARIABLE type .)
    $end            reduce using rule 58 (parameter -> VARIABLE type .)
    RBRACE          reduce using rule 58 (parameter -> VARIABLE type .)
    CASE            reduce using rule 58 (parameter -> VARIABLE type .)
    DEFAULT         reduce using rule 58 (parameter -> VARIABLE type .)
    RPAREN          reduce using rule 58 (parameter -> VARIABLE type .)


state 59

    (114) slice_structure -> VARIABLE ASSIGN . append_statement
    (115) append_statement -> . APPEND LPAREN VARIABLE COMMA values RPAREN

    APPEND          shift and go to state 116

    append_statement               shift and go to state 115

state 60

    (59) type -> INT .

    COMMA           reduce using rule 59 (type -> INT .)
    VARIABLE        reduce using rule 59 (type -> INT .)
    PRINT           reduce using rule 59 (type -> INT .)
    INPUT           reduce using rule 59 (type -> INT .)
    IF              reduce using rule 59 (type -> INT .)
    TYPE            reduce using rule 59 (type -> INT .)
    FUNCTION        reduce using rule 59 (type -> INT .)
    VAR             reduce using rule 59 (type -> INT .)
    SWITCH          reduce using rule 59 (type -> INT .)
    CHARSTRING      reduce using rule 59 (type -> INT .)
    LBRACE          reduce using rule 59 (type -> INT .)
    FOR             reduce using rule 59 (type -> INT .)
    INT             reduce using rule 59 (type -> INT .)
    FLOAT           reduce using rule 59 (type -> INT .)
    $end            reduce using rule 59 (type -> INT .)
    RBRACE          reduce using rule 59 (type -> INT .)
    CASE            reduce using rule 59 (type -> INT .)
    DEFAULT         reduce using rule 59 (type -> INT .)
    RPAREN          reduce using rule 59 (type -> INT .)
    RBRACKET        reduce using rule 59 (type -> INT .)


state 61

    (60) type -> INT32 .

    COMMA           reduce using rule 60 (type -> INT32 .)
    VARIABLE        reduce using rule 60 (type -> INT32 .)
    PRINT           reduce using rule 60 (type -> INT32 .)
    INPUT           reduce using rule 60 (type -> INT32 .)
    IF              reduce using rule 60 (type -> INT32 .)
    TYPE            reduce using rule 60 (type -> INT32 .)
    FUNCTION        reduce using rule 60 (type -> INT32 .)
    VAR             reduce using rule 60 (type -> INT32 .)
    SWITCH          reduce using rule 60 (type -> INT32 .)
    CHARSTRING      reduce using rule 60 (type -> INT32 .)
    LBRACE          reduce using rule 60 (type -> INT32 .)
    FOR             reduce using rule 60 (type -> INT32 .)
    INT             reduce using rule 60 (type -> INT32 .)
    FLOAT           reduce using rule 60 (type -> INT32 .)
    $end            reduce using rule 60 (type -> INT32 .)
    RBRACE          reduce using rule 60 (type -> INT32 .)
    CASE            reduce using rule 60 (type -> INT32 .)
    DEFAULT         reduce using rule 60 (type -> INT32 .)
    RPAREN          reduce using rule 60 (type -> INT32 .)
    RBRACKET        reduce using rule 60 (type -> INT32 .)


state 62

    (61) type -> INT64 .

    COMMA           reduce using rule 61 (type -> INT64 .)
    VARIABLE        reduce using rule 61 (type -> INT64 .)
    PRINT           reduce using rule 61 (type -> INT64 .)
    INPUT           reduce using rule 61 (type -> INT64 .)
    IF              reduce using rule 61 (type -> INT64 .)
    TYPE            reduce using rule 61 (type -> INT64 .)
    FUNCTION        reduce using rule 61 (type -> INT64 .)
    VAR             reduce using rule 61 (type -> INT64 .)
    SWITCH          reduce using rule 61 (type -> INT64 .)
    CHARSTRING      reduce using rule 61 (type -> INT64 .)
    LBRACE          reduce using rule 61 (type -> INT64 .)
    FOR             reduce using rule 61 (type -> INT64 .)
    INT             reduce using rule 61 (type -> INT64 .)
    FLOAT           reduce using rule 61 (type -> INT64 .)
    $end            reduce using rule 61 (type -> INT64 .)
    RBRACE          reduce using rule 61 (type -> INT64 .)
    CASE            reduce using rule 61 (type -> INT64 .)
    DEFAULT         reduce using rule 61 (type -> INT64 .)
    RPAREN          reduce using rule 61 (type -> INT64 .)
    RBRACKET        reduce using rule 61 (type -> INT64 .)


state 63

    (62) type -> STRING .

    COMMA           reduce using rule 62 (type -> STRING .)
    VARIABLE        reduce using rule 62 (type -> STRING .)
    PRINT           reduce using rule 62 (type -> STRING .)
    INPUT           reduce using rule 62 (type -> STRING .)
    IF              reduce using rule 62 (type -> STRING .)
    TYPE            reduce using rule 62 (type -> STRING .)
    FUNCTION        reduce using rule 62 (type -> STRING .)
    VAR             reduce using rule 62 (type -> STRING .)
    SWITCH          reduce using rule 62 (type -> STRING .)
    CHARSTRING      reduce using rule 62 (type -> STRING .)
    LBRACE          reduce using rule 62 (type -> STRING .)
    FOR             reduce using rule 62 (type -> STRING .)
    INT             reduce using rule 62 (type -> STRING .)
    FLOAT           reduce using rule 62 (type -> STRING .)
    $end            reduce using rule 62 (type -> STRING .)
    RBRACE          reduce using rule 62 (type -> STRING .)
    CASE            reduce using rule 62 (type -> STRING .)
    DEFAULT         reduce using rule 62 (type -> STRING .)
    RPAREN          reduce using rule 62 (type -> STRING .)
    RBRACKET        reduce using rule 62 (type -> STRING .)


state 64

    (63) type -> FLOAT .

    COMMA           reduce using rule 63 (type -> FLOAT .)
    VARIABLE        reduce using rule 63 (type -> FLOAT .)
    PRINT           reduce using rule 63 (type -> FLOAT .)
    INPUT           reduce using rule 63 (type -> FLOAT .)
    IF              reduce using rule 63 (type -> FLOAT .)
    TYPE            reduce using rule 63 (type -> FLOAT .)
    FUNCTION        reduce using rule 63 (type -> FLOAT .)
    VAR             reduce using rule 63 (type -> FLOAT .)
    SWITCH          reduce using rule 63 (type -> FLOAT .)
    CHARSTRING      reduce using rule 63 (type -> FLOAT .)
    LBRACE          reduce using rule 63 (type -> FLOAT .)
    FOR             reduce using rule 63 (type -> FLOAT .)
    INT             reduce using rule 63 (type -> FLOAT .)
    FLOAT           reduce using rule 63 (type -> FLOAT .)
    $end            reduce using rule 63 (type -> FLOAT .)
    RBRACE          reduce using rule 63 (type -> FLOAT .)
    CASE            reduce using rule 63 (type -> FLOAT .)
    DEFAULT         reduce using rule 63 (type -> FLOAT .)
    RPAREN          reduce using rule 63 (type -> FLOAT .)
    RBRACKET        reduce using rule 63 (type -> FLOAT .)


state 65

    (64) type -> FLOAT32 .

    COMMA           reduce using rule 64 (type -> FLOAT32 .)
    VARIABLE        reduce using rule 64 (type -> FLOAT32 .)
    PRINT           reduce using rule 64 (type -> FLOAT32 .)
    INPUT           reduce using rule 64 (type -> FLOAT32 .)
    IF              reduce using rule 64 (type -> FLOAT32 .)
    TYPE            reduce using rule 64 (type -> FLOAT32 .)
    FUNCTION        reduce using rule 64 (type -> FLOAT32 .)
    VAR             reduce using rule 64 (type -> FLOAT32 .)
    SWITCH          reduce using rule 64 (type -> FLOAT32 .)
    CHARSTRING      reduce using rule 64 (type -> FLOAT32 .)
    LBRACE          reduce using rule 64 (type -> FLOAT32 .)
    FOR             reduce using rule 64 (type -> FLOAT32 .)
    INT             reduce using rule 64 (type -> FLOAT32 .)
    FLOAT           reduce using rule 64 (type -> FLOAT32 .)
    $end            reduce using rule 64 (type -> FLOAT32 .)
    RBRACE          reduce using rule 64 (type -> FLOAT32 .)
    CASE            reduce using rule 64 (type -> FLOAT32 .)
    DEFAULT         reduce using rule 64 (type -> FLOAT32 .)
    RPAREN          reduce using rule 64 (type -> FLOAT32 .)
    RBRACKET        reduce using rule 64 (type -> FLOAT32 .)


state 66

    (65) type -> FLOAT64 .

    COMMA           reduce using rule 65 (type -> FLOAT64 .)
    VARIABLE        reduce using rule 65 (type -> FLOAT64 .)
    PRINT           reduce using rule 65 (type -> FLOAT64 .)
    INPUT           reduce using rule 65 (type -> FLOAT64 .)
    IF              reduce using rule 65 (type -> FLOAT64 .)
    TYPE            reduce using rule 65 (type -> FLOAT64 .)
    FUNCTION        reduce using rule 65 (type -> FLOAT64 .)
    VAR             reduce using rule 65 (type -> FLOAT64 .)
    SWITCH          reduce using rule 65 (type -> FLOAT64 .)
    CHARSTRING      reduce using rule 65 (type -> FLOAT64 .)
    LBRACE          reduce using rule 65 (type -> FLOAT64 .)
    FOR             reduce using rule 65 (type -> FLOAT64 .)
    INT             reduce using rule 65 (type -> FLOAT64 .)
    FLOAT           reduce using rule 65 (type -> FLOAT64 .)
    $end            reduce using rule 65 (type -> FLOAT64 .)
    RBRACE          reduce using rule 65 (type -> FLOAT64 .)
    CASE            reduce using rule 65 (type -> FLOAT64 .)
    DEFAULT         reduce using rule 65 (type -> FLOAT64 .)
    RPAREN          reduce using rule 65 (type -> FLOAT64 .)
    RBRACKET        reduce using rule 65 (type -> FLOAT64 .)


state 67

    (66) type -> BOOL .

    COMMA           reduce using rule 66 (type -> BOOL .)
    VARIABLE        reduce using rule 66 (type -> BOOL .)
    PRINT           reduce using rule 66 (type -> BOOL .)
    INPUT           reduce using rule 66 (type -> BOOL .)
    IF              reduce using rule 66 (type -> BOOL .)
    TYPE            reduce using rule 66 (type -> BOOL .)
    FUNCTION        reduce using rule 66 (type -> BOOL .)
    VAR             reduce using rule 66 (type -> BOOL .)
    SWITCH          reduce using rule 66 (type -> BOOL .)
    CHARSTRING      reduce using rule 66 (type -> BOOL .)
    LBRACE          reduce using rule 66 (type -> BOOL .)
    FOR             reduce using rule 66 (type -> BOOL .)
    INT             reduce using rule 66 (type -> BOOL .)
    FLOAT           reduce using rule 66 (type -> BOOL .)
    $end            reduce using rule 66 (type -> BOOL .)
    RBRACE          reduce using rule 66 (type -> BOOL .)
    CASE            reduce using rule 66 (type -> BOOL .)
    DEFAULT         reduce using rule 66 (type -> BOOL .)
    RPAREN          reduce using rule 66 (type -> BOOL .)
    RBRACKET        reduce using rule 66 (type -> BOOL .)


state 68

    (102) empty_list -> LBRACE RBRACE .

    PRINT           reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    INPUT           reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    IF              reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    VARIABLE        reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    TYPE            reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    FUNCTION        reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    VAR             reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    SWITCH          reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    CHARSTRING      reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    LBRACE          reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    FOR             reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    INT             reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    FLOAT           reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    $end            reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    RBRACE          reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    CASE            reduce using rule 102 (empty_list -> LBRACE RBRACE .)
    DEFAULT         reduce using rule 102 (empty_list -> LBRACE RBRACE .)


state 69

    (103) list_with_data -> LBRACE values . RBRACE

    RBRACE          shift and go to state 117


state 70

    (27) values -> value .
    (28) values -> value . COMMA values

    RBRACE          reduce using rule 27 (values -> value .)
    RPAREN          reduce using rule 27 (values -> value .)
    COLON           reduce using rule 27 (values -> value .)
    COMMA           shift and go to state 118


state 71

    (22) structure -> TYPE VARIABLE . STRUCT LBRACE statement RBRACE
    (104) defined_list -> TYPE VARIABLE . LBRACE values RBRACE

    STRUCT          shift and go to state 119
    LBRACE          shift and go to state 120


state 72

    (23) function -> FUNCTION VARIABLE . LPAREN RPAREN LBRACE blocks RBRACE
    (24) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN LBRACE blocks RBRACE
    (25) function -> FUNCTION VARIABLE . LPAREN RPAREN type LBRACE RETURN value RBRACE
    (26) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN type LBRACE RETURN value RBRACE

    LPAREN          shift and go to state 121


state 73

    (56) parameters -> parameter parameters .

    PRINT           reduce using rule 56 (parameters -> parameter parameters .)
    INPUT           reduce using rule 56 (parameters -> parameter parameters .)
    IF              reduce using rule 56 (parameters -> parameter parameters .)
    VARIABLE        reduce using rule 56 (parameters -> parameter parameters .)
    TYPE            reduce using rule 56 (parameters -> parameter parameters .)
    FUNCTION        reduce using rule 56 (parameters -> parameter parameters .)
    VAR             reduce using rule 56 (parameters -> parameter parameters .)
    SWITCH          reduce using rule 56 (parameters -> parameter parameters .)
    CHARSTRING      reduce using rule 56 (parameters -> parameter parameters .)
    LBRACE          reduce using rule 56 (parameters -> parameter parameters .)
    FOR             reduce using rule 56 (parameters -> parameter parameters .)
    INT             reduce using rule 56 (parameters -> parameter parameters .)
    FLOAT           reduce using rule 56 (parameters -> parameter parameters .)
    $end            reduce using rule 56 (parameters -> parameter parameters .)
    RBRACE          reduce using rule 56 (parameters -> parameter parameters .)
    CASE            reduce using rule 56 (parameters -> parameter parameters .)
    DEFAULT         reduce using rule 56 (parameters -> parameter parameters .)
    RPAREN          reduce using rule 56 (parameters -> parameter parameters .)


state 74

    (57) parameters -> parameter COMMA . parameters
    (55) parameters -> . parameter
    (56) parameters -> . parameter parameters
    (57) parameters -> . parameter COMMA parameters
    (58) parameter -> . VARIABLE type

    VARIABLE        shift and go to state 75

    parameter                      shift and go to state 32
    parameters                     shift and go to state 122

state 75

    (58) parameter -> VARIABLE . type
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 60
    INT32           shift and go to state 61
    INT64           shift and go to state 62
    STRING          shift and go to state 63
    FLOAT           shift and go to state 64
    FLOAT32         shift and go to state 65
    FLOAT64         shift and go to state 66
    BOOL            shift and go to state 67

    type                           shift and go to state 58

state 76

    (18) variable_declaration -> VAR VARIABLE . type
    (19) variable_declaration -> VAR VARIABLE . ASSIGN value
    (112) slice_structure -> VAR VARIABLE . LBRACKET RBRACKET type
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    ASSIGN          shift and go to state 124
    LBRACKET        shift and go to state 125
    INT             shift and go to state 60
    INT32           shift and go to state 61
    INT64           shift and go to state 62
    STRING          shift and go to state 63
    FLOAT           shift and go to state 64
    FLOAT32         shift and go to state 65
    FLOAT64         shift and go to state 66
    BOOL            shift and go to state 67

    type                           shift and go to state 123

state 77

    (91) switch_structure -> SWITCH switch_expression . LBRACE case_blocks RBRACE

    LBRACE          shift and go to state 126


state 78

    (92) switch_expression -> value .

    LBRACE          reduce using rule 92 (switch_expression -> value .)


state 79

    (93) switch_expression -> empty .

    LBRACE          reduce using rule 93 (switch_expression -> empty .)


state 80

    (88) for_initialization -> FOR VARIABLE . SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (90) for_iterator -> FOR VARIABLE . SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 127
    SEMICOLON       shift and go to state 128


state 81

    (89) for_infinite_bucle -> FOR LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (16) block -> . switch_structure
    (17) block -> . slice_structure
    (36) print_statement -> . PRINT LPAREN values RPAREN
    (37) print_statement -> . PRINT LPAREN string_value RPAREN
    (38) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (39) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (40) print_statement -> . PRINT LPAREN operation RPAREN
    (41) print_statement -> . PRINT LPAREN RPAREN
    (42) input_statement -> . INPUT LPAREN values RPAREN
    (43) input_statement -> . INPUT LPAREN operation RPAREN
    (44) input_statement -> . INPUT LPAREN RPAREN
    (67) conditional_structure -> . IF conditions conditional_body
    (68) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (69) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (45) operation -> . value operator value
    (46) operation -> . value operator operation
    (47) operation -> . value double_operator
    (99) list_structure -> . empty_list
    (100) list_structure -> . list_with_data
    (101) list_structure -> . defined_list
    (105) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (106) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (110) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (85) for_estructure -> . for_initialization
    (86) for_estructure -> . for_infinite_bucle
    (87) for_estructure -> . for_iterator
    (22) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (24) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (25) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (26) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (55) parameters -> . parameter
    (56) parameters -> . parameter parameters
    (57) parameters -> . parameter COMMA parameters
    (18) variable_declaration -> . VAR VARIABLE type
    (19) variable_declaration -> . VAR VARIABLE ASSIGN value
    (20) variable_declaration -> . VARIABLE SHORTASSIGN value
    (21) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (91) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (111) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (112) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (113) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (114) slice_structure -> . VARIABLE ASSIGN append_statement
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (102) empty_list -> . LBRACE RBRACE
    (103) list_with_data -> . LBRACE values RBRACE
    (104) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (88) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (89) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (90) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (58) parameter -> . VARIABLE type
    (34) number -> . INT
    (35) number -> . FLOAT

    PRINT           shift and go to state 18
    INPUT           shift and go to state 19
    IF              shift and go to state 20
    VARIABLE        shift and go to state 25
    TYPE            shift and go to state 30
    FUNCTION        shift and go to state 31
    VAR             shift and go to state 33
    SWITCH          shift and go to state 34
    CHARSTRING      shift and go to state 36
    LBRACE          shift and go to state 26
    FOR             shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    statement                      shift and go to state 129
    blocks                         shift and go to state 2
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    switch_structure               shift and go to state 16
    slice_structure                shift and go to state 17
    value                          shift and go to state 21
    empty_list                     shift and go to state 22
    list_with_data                 shift and go to state 23
    defined_list                   shift and go to state 24
    for_initialization             shift and go to state 27
    for_infinite_bucle             shift and go to state 28
    for_iterator                   shift and go to state 29
    parameter                      shift and go to state 32
    number                         shift and go to state 35

state 82

    (36) print_statement -> PRINT LPAREN values . RPAREN

    RPAREN          shift and go to state 130


state 83

    (41) print_statement -> PRINT LPAREN RPAREN .

    PRINT           reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    INPUT           reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    IF              reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    VARIABLE        reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    TYPE            reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    FUNCTION        reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    VAR             reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    SWITCH          reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    CHARSTRING      reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    LBRACE          reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    FOR             reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    INT             reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    FLOAT           reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    $end            reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    RBRACE          reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    CASE            reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)
    DEFAULT         reduce using rule 41 (print_statement -> PRINT LPAREN RPAREN .)


state 84

    (37) print_statement -> PRINT LPAREN string_value . RPAREN
    (39) print_statement -> PRINT LPAREN string_value . COMMA values RPAREN

    RPAREN          shift and go to state 131
    COMMA           shift and go to state 132


state 85

    (38) print_statement -> PRINT LPAREN FORMATSTRING . COMMA values RPAREN

    COMMA           shift and go to state 133


state 86

    (40) print_statement -> PRINT LPAREN operation . RPAREN

    RPAREN          shift and go to state 134


state 87

    (27) values -> value .
    (28) values -> value . COMMA values
    (29) string_value -> value .
    (45) operation -> value . operator value
    (46) operation -> value . operator operation
    (47) operation -> value . double_operator
    (48) operator -> . PLUS
    (49) operator -> . MINUS
    (50) operator -> . TIMES
    (51) operator -> . DIVIDE
    (52) operator -> . ASSIGN
    (53) double_operator -> . INCREMENT
    (54) double_operator -> . DECREMENT

  ! reduce/reduce conflict for RPAREN resolved using rule 27 (values -> value .)
  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 27 (values -> value .)
    COMMA           shift and go to state 118
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    ASSIGN          shift and go to state 53
    INCREMENT       shift and go to state 54
    DECREMENT       shift and go to state 55

  ! RPAREN          [ reduce using rule 29 (string_value -> value .) ]
  ! COMMA           [ reduce using rule 29 (string_value -> value .) ]

    operator                       shift and go to state 47
    double_operator                shift and go to state 48

state 88

    (30) string_value -> CHARSTRING .
    (33) value -> CHARSTRING .

  ! reduce/reduce conflict for COMMA resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for RPAREN resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for PRINT resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for INPUT resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for IF resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for TYPE resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for VAR resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for SWITCH resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for CHARSTRING resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for LBRACE resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for FOR resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for INT resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for FLOAT resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for $end resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for RBRACE resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for CASE resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 30 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for COLON resolved using rule 30 (string_value -> CHARSTRING .)
    RPAREN          reduce using rule 30 (string_value -> CHARSTRING .)
    COMMA           reduce using rule 30 (string_value -> CHARSTRING .)
    RBRACKET        reduce using rule 30 (string_value -> CHARSTRING .)
    PRINT           reduce using rule 30 (string_value -> CHARSTRING .)
    INPUT           reduce using rule 30 (string_value -> CHARSTRING .)
    IF              reduce using rule 30 (string_value -> CHARSTRING .)
    VARIABLE        reduce using rule 30 (string_value -> CHARSTRING .)
    TYPE            reduce using rule 30 (string_value -> CHARSTRING .)
    FUNCTION        reduce using rule 30 (string_value -> CHARSTRING .)
    VAR             reduce using rule 30 (string_value -> CHARSTRING .)
    SWITCH          reduce using rule 30 (string_value -> CHARSTRING .)
    CHARSTRING      reduce using rule 30 (string_value -> CHARSTRING .)
    LBRACE          reduce using rule 30 (string_value -> CHARSTRING .)
    FOR             reduce using rule 30 (string_value -> CHARSTRING .)
    INT             reduce using rule 30 (string_value -> CHARSTRING .)
    FLOAT           reduce using rule 30 (string_value -> CHARSTRING .)
    $end            reduce using rule 30 (string_value -> CHARSTRING .)
    RBRACE          reduce using rule 30 (string_value -> CHARSTRING .)
    CASE            reduce using rule 30 (string_value -> CHARSTRING .)
    DEFAULT         reduce using rule 30 (string_value -> CHARSTRING .)
    COLON           reduce using rule 30 (string_value -> CHARSTRING .)
    PLUS            reduce using rule 33 (value -> CHARSTRING .)
    MINUS           reduce using rule 33 (value -> CHARSTRING .)
    TIMES           reduce using rule 33 (value -> CHARSTRING .)
    DIVIDE          reduce using rule 33 (value -> CHARSTRING .)
    ASSIGN          reduce using rule 33 (value -> CHARSTRING .)
    INCREMENT       reduce using rule 33 (value -> CHARSTRING .)
    DECREMENT       reduce using rule 33 (value -> CHARSTRING .)

  ! COMMA           [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! RPAREN          [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! RBRACKET        [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! PRINT           [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! INPUT           [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! IF              [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! VARIABLE        [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! TYPE            [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! FUNCTION        [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! VAR             [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! SWITCH          [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! CHARSTRING      [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! LBRACE          [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! FOR             [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! INT             [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! FLOAT           [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! $end            [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! RBRACE          [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! CASE            [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! DEFAULT         [ reduce using rule 33 (value -> CHARSTRING .) ]
  ! COLON           [ reduce using rule 33 (value -> CHARSTRING .) ]


state 89

    (42) input_statement -> INPUT LPAREN values . RPAREN

    RPAREN          shift and go to state 135


state 90

    (44) input_statement -> INPUT LPAREN RPAREN .

    PRINT           reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    IF              reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    VARIABLE        reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    TYPE            reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    FUNCTION        reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    VAR             reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    SWITCH          reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    CHARSTRING      reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    LBRACE          reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    INT             reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    FLOAT           reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    $end            reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    CASE            reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)
    DEFAULT         reduce using rule 44 (input_statement -> INPUT LPAREN RPAREN .)


state 91

    (43) input_statement -> INPUT LPAREN operation . RPAREN

    RPAREN          shift and go to state 136


state 92

    (27) values -> value .
    (28) values -> value . COMMA values
    (45) operation -> value . operator value
    (46) operation -> value . operator operation
    (47) operation -> value . double_operator
    (48) operator -> . PLUS
    (49) operator -> . MINUS
    (50) operator -> . TIMES
    (51) operator -> . DIVIDE
    (52) operator -> . ASSIGN
    (53) double_operator -> . INCREMENT
    (54) double_operator -> . DECREMENT

    RPAREN          reduce using rule 27 (values -> value .)
    COMMA           shift and go to state 118
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    ASSIGN          shift and go to state 53
    INCREMENT       shift and go to state 54
    DECREMENT       shift and go to state 55

    operator                       shift and go to state 47
    double_operator                shift and go to state 48

state 93

    (67) conditional_structure -> IF conditions conditional_body .
    (68) conditional_structure -> IF conditions conditional_body . ELSE conditional_body
    (69) conditional_structure -> IF conditions conditional_body . ELSE IF conditions conditional_body ELSE conditional_body

    PRINT           reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    INPUT           reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    IF              reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    VARIABLE        reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    TYPE            reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    FUNCTION        reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    VAR             reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    SWITCH          reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    CHARSTRING      reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    LBRACE          reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    FOR             reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    INT             reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    FLOAT           reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    $end            reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    RBRACE          reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    CASE            reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    DEFAULT         reduce using rule 67 (conditional_structure -> IF conditions conditional_body .)
    ELSE            shift and go to state 137


state 94

    (70) conditional_body -> LBRACE . statement RBRACE
    (71) conditional_body -> LBRACE . BREAK RBRACE
    (72) conditional_body -> LBRACE . CONTINUE RBRACE
    (1) statement -> . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (16) block -> . switch_structure
    (17) block -> . slice_structure
    (36) print_statement -> . PRINT LPAREN values RPAREN
    (37) print_statement -> . PRINT LPAREN string_value RPAREN
    (38) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (39) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (40) print_statement -> . PRINT LPAREN operation RPAREN
    (41) print_statement -> . PRINT LPAREN RPAREN
    (42) input_statement -> . INPUT LPAREN values RPAREN
    (43) input_statement -> . INPUT LPAREN operation RPAREN
    (44) input_statement -> . INPUT LPAREN RPAREN
    (67) conditional_structure -> . IF conditions conditional_body
    (68) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (69) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (45) operation -> . value operator value
    (46) operation -> . value operator operation
    (47) operation -> . value double_operator
    (99) list_structure -> . empty_list
    (100) list_structure -> . list_with_data
    (101) list_structure -> . defined_list
    (105) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (106) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (110) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (85) for_estructure -> . for_initialization
    (86) for_estructure -> . for_infinite_bucle
    (87) for_estructure -> . for_iterator
    (22) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (24) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (25) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (26) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (55) parameters -> . parameter
    (56) parameters -> . parameter parameters
    (57) parameters -> . parameter COMMA parameters
    (18) variable_declaration -> . VAR VARIABLE type
    (19) variable_declaration -> . VAR VARIABLE ASSIGN value
    (20) variable_declaration -> . VARIABLE SHORTASSIGN value
    (21) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (91) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (111) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (112) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (113) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (114) slice_structure -> . VARIABLE ASSIGN append_statement
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (102) empty_list -> . LBRACE RBRACE
    (103) list_with_data -> . LBRACE values RBRACE
    (104) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (88) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (89) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (90) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (58) parameter -> . VARIABLE type
    (34) number -> . INT
    (35) number -> . FLOAT

    BREAK           shift and go to state 139
    CONTINUE        shift and go to state 140
    PRINT           shift and go to state 18
    INPUT           shift and go to state 19
    IF              shift and go to state 20
    VARIABLE        shift and go to state 25
    TYPE            shift and go to state 30
    FUNCTION        shift and go to state 31
    VAR             shift and go to state 33
    SWITCH          shift and go to state 34
    CHARSTRING      shift and go to state 36
    LBRACE          shift and go to state 26
    FOR             shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    statement                      shift and go to state 138
    blocks                         shift and go to state 2
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    switch_structure               shift and go to state 16
    slice_structure                shift and go to state 17
    value                          shift and go to state 21
    empty_list                     shift and go to state 22
    list_with_data                 shift and go to state 23
    defined_list                   shift and go to state 24
    for_initialization             shift and go to state 27
    for_infinite_bucle             shift and go to state 28
    for_iterator                   shift and go to state 29
    parameter                      shift and go to state 32
    number                         shift and go to state 35

state 95

    (74) conditions -> condition logical_operator . conditions
    (73) conditions -> . condition
    (74) conditions -> . condition logical_operator conditions
    (75) condition -> . value relational_operator value
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    condition                      shift and go to state 44
    conditions                     shift and go to state 141
    value                          shift and go to state 45
    number                         shift and go to state 35

state 96

    (76) logical_operator -> AND .

    VARIABLE        reduce using rule 76 (logical_operator -> AND .)
    CHARSTRING      reduce using rule 76 (logical_operator -> AND .)
    INT             reduce using rule 76 (logical_operator -> AND .)
    FLOAT           reduce using rule 76 (logical_operator -> AND .)


state 97

    (77) logical_operator -> OR .

    VARIABLE        reduce using rule 77 (logical_operator -> OR .)
    CHARSTRING      reduce using rule 77 (logical_operator -> OR .)
    INT             reduce using rule 77 (logical_operator -> OR .)
    FLOAT           reduce using rule 77 (logical_operator -> OR .)


state 98

    (78) logical_operator -> NOT .

    VARIABLE        reduce using rule 78 (logical_operator -> NOT .)
    CHARSTRING      reduce using rule 78 (logical_operator -> NOT .)
    INT             reduce using rule 78 (logical_operator -> NOT .)
    FLOAT           reduce using rule 78 (logical_operator -> NOT .)


state 99

    (75) condition -> value relational_operator . value
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    value                          shift and go to state 142
    number                         shift and go to state 35

state 100

    (79) relational_operator -> GREATER .

    VARIABLE        reduce using rule 79 (relational_operator -> GREATER .)
    CHARSTRING      reduce using rule 79 (relational_operator -> GREATER .)
    INT             reduce using rule 79 (relational_operator -> GREATER .)
    FLOAT           reduce using rule 79 (relational_operator -> GREATER .)


state 101

    (80) relational_operator -> LESS .

    VARIABLE        reduce using rule 80 (relational_operator -> LESS .)
    CHARSTRING      reduce using rule 80 (relational_operator -> LESS .)
    INT             reduce using rule 80 (relational_operator -> LESS .)
    FLOAT           reduce using rule 80 (relational_operator -> LESS .)


state 102

    (81) relational_operator -> GREATEREQUALS .

    VARIABLE        reduce using rule 81 (relational_operator -> GREATEREQUALS .)
    CHARSTRING      reduce using rule 81 (relational_operator -> GREATEREQUALS .)
    INT             reduce using rule 81 (relational_operator -> GREATEREQUALS .)
    FLOAT           reduce using rule 81 (relational_operator -> GREATEREQUALS .)


state 103

    (82) relational_operator -> LESSEQUALS .

    VARIABLE        reduce using rule 82 (relational_operator -> LESSEQUALS .)
    CHARSTRING      reduce using rule 82 (relational_operator -> LESSEQUALS .)
    INT             reduce using rule 82 (relational_operator -> LESSEQUALS .)
    FLOAT           reduce using rule 82 (relational_operator -> LESSEQUALS .)


state 104

    (83) relational_operator -> EQUALS .

    VARIABLE        reduce using rule 83 (relational_operator -> EQUALS .)
    CHARSTRING      reduce using rule 83 (relational_operator -> EQUALS .)
    INT             reduce using rule 83 (relational_operator -> EQUALS .)
    FLOAT           reduce using rule 83 (relational_operator -> EQUALS .)


state 105

    (84) relational_operator -> DIFFERENT .

    VARIABLE        reduce using rule 84 (relational_operator -> DIFFERENT .)
    CHARSTRING      reduce using rule 84 (relational_operator -> DIFFERENT .)
    INT             reduce using rule 84 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 84 (relational_operator -> DIFFERENT .)


state 106

    (45) operation -> value operator value .
    (45) operation -> value . operator value
    (46) operation -> value . operator operation
    (47) operation -> value . double_operator
    (48) operator -> . PLUS
    (49) operator -> . MINUS
    (50) operator -> . TIMES
    (51) operator -> . DIVIDE
    (52) operator -> . ASSIGN
    (53) double_operator -> . INCREMENT
    (54) double_operator -> . DECREMENT

    PRINT           reduce using rule 45 (operation -> value operator value .)
    INPUT           reduce using rule 45 (operation -> value operator value .)
    IF              reduce using rule 45 (operation -> value operator value .)
    VARIABLE        reduce using rule 45 (operation -> value operator value .)
    TYPE            reduce using rule 45 (operation -> value operator value .)
    FUNCTION        reduce using rule 45 (operation -> value operator value .)
    VAR             reduce using rule 45 (operation -> value operator value .)
    SWITCH          reduce using rule 45 (operation -> value operator value .)
    CHARSTRING      reduce using rule 45 (operation -> value operator value .)
    LBRACE          reduce using rule 45 (operation -> value operator value .)
    FOR             reduce using rule 45 (operation -> value operator value .)
    INT             reduce using rule 45 (operation -> value operator value .)
    FLOAT           reduce using rule 45 (operation -> value operator value .)
    $end            reduce using rule 45 (operation -> value operator value .)
    RBRACE          reduce using rule 45 (operation -> value operator value .)
    CASE            reduce using rule 45 (operation -> value operator value .)
    DEFAULT         reduce using rule 45 (operation -> value operator value .)
    RPAREN          reduce using rule 45 (operation -> value operator value .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    ASSIGN          shift and go to state 53
    INCREMENT       shift and go to state 54
    DECREMENT       shift and go to state 55

    operator                       shift and go to state 47
    double_operator                shift and go to state 48

state 107

    (46) operation -> value operator operation .

    PRINT           reduce using rule 46 (operation -> value operator operation .)
    INPUT           reduce using rule 46 (operation -> value operator operation .)
    IF              reduce using rule 46 (operation -> value operator operation .)
    VARIABLE        reduce using rule 46 (operation -> value operator operation .)
    TYPE            reduce using rule 46 (operation -> value operator operation .)
    FUNCTION        reduce using rule 46 (operation -> value operator operation .)
    VAR             reduce using rule 46 (operation -> value operator operation .)
    SWITCH          reduce using rule 46 (operation -> value operator operation .)
    CHARSTRING      reduce using rule 46 (operation -> value operator operation .)
    LBRACE          reduce using rule 46 (operation -> value operator operation .)
    FOR             reduce using rule 46 (operation -> value operator operation .)
    INT             reduce using rule 46 (operation -> value operator operation .)
    FLOAT           reduce using rule 46 (operation -> value operator operation .)
    $end            reduce using rule 46 (operation -> value operator operation .)
    RBRACE          reduce using rule 46 (operation -> value operator operation .)
    CASE            reduce using rule 46 (operation -> value operator operation .)
    DEFAULT         reduce using rule 46 (operation -> value operator operation .)
    RPAREN          reduce using rule 46 (operation -> value operator operation .)


state 108

    (105) map_estructure -> VARIABLE SHORTASSIGN MAP . LBRACKET type RBRACKET type LBRACE map_values RBRACE

    LBRACKET        shift and go to state 143


state 109

    (111) slice_structure -> VARIABLE SHORTASSIGN LBRACKET . RBRACKET type LBRACE values RBRACE
    (113) slice_structure -> VARIABLE SHORTASSIGN LBRACKET . RBRACKET type

    RBRACKET        shift and go to state 144


state 110

    (106) map_estructure -> VARIABLE SHORTASSIGN MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN

    LPAREN          shift and go to state 145


state 111

    (20) variable_declaration -> VARIABLE SHORTASSIGN value .
    (45) operation -> value . operator value
    (46) operation -> value . operator operation
    (47) operation -> value . double_operator
    (48) operator -> . PLUS
    (49) operator -> . MINUS
    (50) operator -> . TIMES
    (51) operator -> . DIVIDE
    (52) operator -> . ASSIGN
    (53) double_operator -> . INCREMENT
    (54) double_operator -> . DECREMENT

    PRINT           reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INPUT           reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    IF              reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VARIABLE        reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    TYPE            reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FUNCTION        reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VAR             reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    SWITCH          reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CHARSTRING      reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    LBRACE          reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FOR             reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INT             reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FLOAT           reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    $end            reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    RBRACE          reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CASE            reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    DEFAULT         reduce using rule 20 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    PLUS            shift and go to state 49
    MINUS           shift and go to state 50
    TIMES           shift and go to state 51
    DIVIDE          shift and go to state 52
    ASSIGN          shift and go to state 53
    INCREMENT       shift and go to state 54
    DECREMENT       shift and go to state 55

    operator                       shift and go to state 47
    double_operator                shift and go to state 48

state 112

    (21) variable_declaration -> VARIABLE SHORTASSIGN operation .

    PRINT           reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    INPUT           reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    IF              reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    VARIABLE        reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    TYPE            reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FUNCTION        reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    VAR             reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    SWITCH          reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CHARSTRING      reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    LBRACE          reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FOR             reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    INT             reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FLOAT           reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    $end            reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    RBRACE          reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CASE            reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    DEFAULT         reduce using rule 21 (variable_declaration -> VARIABLE SHORTASSIGN operation .)


state 113

    (110) map_assign -> VARIABLE LBRACKET string_value . RBRACKET ASSIGN string_value

    RBRACKET        shift and go to state 146


state 114

    (29) string_value -> value .

    RBRACKET        reduce using rule 29 (string_value -> value .)
    PRINT           reduce using rule 29 (string_value -> value .)
    INPUT           reduce using rule 29 (string_value -> value .)
    IF              reduce using rule 29 (string_value -> value .)
    VARIABLE        reduce using rule 29 (string_value -> value .)
    TYPE            reduce using rule 29 (string_value -> value .)
    FUNCTION        reduce using rule 29 (string_value -> value .)
    VAR             reduce using rule 29 (string_value -> value .)
    SWITCH          reduce using rule 29 (string_value -> value .)
    CHARSTRING      reduce using rule 29 (string_value -> value .)
    LBRACE          reduce using rule 29 (string_value -> value .)
    FOR             reduce using rule 29 (string_value -> value .)
    INT             reduce using rule 29 (string_value -> value .)
    FLOAT           reduce using rule 29 (string_value -> value .)
    $end            reduce using rule 29 (string_value -> value .)
    RBRACE          reduce using rule 29 (string_value -> value .)
    CASE            reduce using rule 29 (string_value -> value .)
    DEFAULT         reduce using rule 29 (string_value -> value .)
    COLON           reduce using rule 29 (string_value -> value .)
    COMMA           reduce using rule 29 (string_value -> value .)


state 115

    (114) slice_structure -> VARIABLE ASSIGN append_statement .

    PRINT           reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    INPUT           reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    IF              reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    VARIABLE        reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    TYPE            reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FUNCTION        reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    VAR             reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    SWITCH          reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CHARSTRING      reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    LBRACE          reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FOR             reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    INT             reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FLOAT           reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    $end            reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    RBRACE          reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CASE            reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)
    DEFAULT         reduce using rule 114 (slice_structure -> VARIABLE ASSIGN append_statement .)


state 116

    (115) append_statement -> APPEND . LPAREN VARIABLE COMMA values RPAREN

    LPAREN          shift and go to state 147


state 117

    (103) list_with_data -> LBRACE values RBRACE .

    PRINT           reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    INPUT           reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    IF              reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    VARIABLE        reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    TYPE            reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    FUNCTION        reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    VAR             reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    SWITCH          reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    LBRACE          reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    FOR             reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    INT             reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    FLOAT           reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    $end            reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    RBRACE          reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    CASE            reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)
    DEFAULT         reduce using rule 103 (list_with_data -> LBRACE values RBRACE .)


state 118

    (28) values -> value COMMA . values
    (27) values -> . value
    (28) values -> . value COMMA values
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    value                          shift and go to state 70
    values                         shift and go to state 148
    number                         shift and go to state 35

state 119

    (22) structure -> TYPE VARIABLE STRUCT . LBRACE statement RBRACE

    LBRACE          shift and go to state 149


state 120

    (104) defined_list -> TYPE VARIABLE LBRACE . values RBRACE
    (27) values -> . value
    (28) values -> . value COMMA values
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    values                         shift and go to state 150
    value                          shift and go to state 70
    number                         shift and go to state 35

state 121

    (23) function -> FUNCTION VARIABLE LPAREN . RPAREN LBRACE blocks RBRACE
    (24) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN LBRACE blocks RBRACE
    (25) function -> FUNCTION VARIABLE LPAREN . RPAREN type LBRACE RETURN value RBRACE
    (26) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN type LBRACE RETURN value RBRACE
    (55) parameters -> . parameter
    (56) parameters -> . parameter parameters
    (57) parameters -> . parameter COMMA parameters
    (58) parameter -> . VARIABLE type

    RPAREN          shift and go to state 151
    VARIABLE        shift and go to state 75

    parameters                     shift and go to state 152
    parameter                      shift and go to state 32

state 122

    (57) parameters -> parameter COMMA parameters .

    PRINT           reduce using rule 57 (parameters -> parameter COMMA parameters .)
    INPUT           reduce using rule 57 (parameters -> parameter COMMA parameters .)
    IF              reduce using rule 57 (parameters -> parameter COMMA parameters .)
    VARIABLE        reduce using rule 57 (parameters -> parameter COMMA parameters .)
    TYPE            reduce using rule 57 (parameters -> parameter COMMA parameters .)
    FUNCTION        reduce using rule 57 (parameters -> parameter COMMA parameters .)
    VAR             reduce using rule 57 (parameters -> parameter COMMA parameters .)
    SWITCH          reduce using rule 57 (parameters -> parameter COMMA parameters .)
    CHARSTRING      reduce using rule 57 (parameters -> parameter COMMA parameters .)
    LBRACE          reduce using rule 57 (parameters -> parameter COMMA parameters .)
    FOR             reduce using rule 57 (parameters -> parameter COMMA parameters .)
    INT             reduce using rule 57 (parameters -> parameter COMMA parameters .)
    FLOAT           reduce using rule 57 (parameters -> parameter COMMA parameters .)
    $end            reduce using rule 57 (parameters -> parameter COMMA parameters .)
    RBRACE          reduce using rule 57 (parameters -> parameter COMMA parameters .)
    CASE            reduce using rule 57 (parameters -> parameter COMMA parameters .)
    DEFAULT         reduce using rule 57 (parameters -> parameter COMMA parameters .)
    RPAREN          reduce using rule 57 (parameters -> parameter COMMA parameters .)


state 123

    (18) variable_declaration -> VAR VARIABLE type .

    PRINT           reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    INPUT           reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    IF              reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    VARIABLE        reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    TYPE            reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    FUNCTION        reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    VAR             reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    SWITCH          reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    CHARSTRING      reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    LBRACE          reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    FOR             reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    INT             reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    FLOAT           reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    $end            reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    RBRACE          reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    CASE            reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)
    DEFAULT         reduce using rule 18 (variable_declaration -> VAR VARIABLE type .)


state 124

    (19) variable_declaration -> VAR VARIABLE ASSIGN . value
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    value                          shift and go to state 153
    number                         shift and go to state 35

state 125

    (112) slice_structure -> VAR VARIABLE LBRACKET . RBRACKET type

    RBRACKET        shift and go to state 154


state 126

    (91) switch_structure -> SWITCH switch_expression LBRACE . case_blocks RBRACE
    (94) case_blocks -> . case_block
    (95) case_blocks -> . case_block case_blocks
    (96) case_block -> . CASE values COLON statement
    (97) case_block -> . DEFAULT COLON statement

    CASE            shift and go to state 157
    DEFAULT         shift and go to state 158

    case_blocks                    shift and go to state 155
    case_block                     shift and go to state 156

state 127

    (88) for_initialization -> FOR VARIABLE SHORTASSIGN . value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    value                          shift and go to state 159
    number                         shift and go to state 35

state 128

    (90) for_iterator -> FOR VARIABLE SEMICOLON . VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 160


state 129

    (89) for_infinite_bucle -> FOR LBRACE statement . RBRACE

    RBRACE          shift and go to state 161


state 130

    (36) print_statement -> PRINT LPAREN values RPAREN .

    PRINT           reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    INPUT           reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    IF              reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    TYPE            reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    VAR             reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    SWITCH          reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    CHARSTRING      reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    LBRACE          reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    FOR             reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    INT             reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    FLOAT           reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    $end            reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    RBRACE          reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    CASE            reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)
    DEFAULT         reduce using rule 36 (print_statement -> PRINT LPAREN values RPAREN .)


state 131

    (37) print_statement -> PRINT LPAREN string_value RPAREN .

    PRINT           reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    INPUT           reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    IF              reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    VARIABLE        reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    TYPE            reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    FUNCTION        reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    VAR             reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    SWITCH          reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    CHARSTRING      reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    LBRACE          reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    FOR             reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    INT             reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    FLOAT           reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    $end            reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    RBRACE          reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    CASE            reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)
    DEFAULT         reduce using rule 37 (print_statement -> PRINT LPAREN string_value RPAREN .)


state 132

    (39) print_statement -> PRINT LPAREN string_value COMMA . values RPAREN
    (27) values -> . value
    (28) values -> . value COMMA values
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    values                         shift and go to state 162
    value                          shift and go to state 70
    number                         shift and go to state 35

state 133

    (38) print_statement -> PRINT LPAREN FORMATSTRING COMMA . values RPAREN
    (27) values -> . value
    (28) values -> . value COMMA values
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    values                         shift and go to state 163
    value                          shift and go to state 70
    number                         shift and go to state 35

state 134

    (40) print_statement -> PRINT LPAREN operation RPAREN .

    PRINT           reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    INPUT           reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    IF              reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    TYPE            reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    VAR             reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    SWITCH          reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    LBRACE          reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    FOR             reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    INT             reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    $end            reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    CASE            reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 40 (print_statement -> PRINT LPAREN operation RPAREN .)


state 135

    (42) input_statement -> INPUT LPAREN values RPAREN .

    PRINT           reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    INPUT           reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    IF              reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    TYPE            reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    VAR             reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    SWITCH          reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    CHARSTRING      reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    LBRACE          reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    FOR             reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    INT             reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    FLOAT           reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    $end            reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    RBRACE          reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    CASE            reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)
    DEFAULT         reduce using rule 42 (input_statement -> INPUT LPAREN values RPAREN .)


state 136

    (43) input_statement -> INPUT LPAREN operation RPAREN .

    PRINT           reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    INPUT           reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    IF              reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    TYPE            reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    VAR             reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    SWITCH          reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    LBRACE          reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    FOR             reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    INT             reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    $end            reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    CASE            reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 43 (input_statement -> INPUT LPAREN operation RPAREN .)


state 137

    (68) conditional_structure -> IF conditions conditional_body ELSE . conditional_body
    (69) conditional_structure -> IF conditions conditional_body ELSE . IF conditions conditional_body ELSE conditional_body
    (70) conditional_body -> . LBRACE statement RBRACE
    (71) conditional_body -> . LBRACE BREAK RBRACE
    (72) conditional_body -> . LBRACE CONTINUE RBRACE

    IF              shift and go to state 164
    LBRACE          shift and go to state 94

    conditional_body               shift and go to state 165

state 138

    (70) conditional_body -> LBRACE statement . RBRACE

    RBRACE          shift and go to state 166


state 139

    (71) conditional_body -> LBRACE BREAK . RBRACE

    RBRACE          shift and go to state 167


state 140

    (72) conditional_body -> LBRACE CONTINUE . RBRACE

    RBRACE          shift and go to state 168


state 141

    (74) conditions -> condition logical_operator conditions .

    LBRACE          reduce using rule 74 (conditions -> condition logical_operator conditions .)


state 142

    (75) condition -> value relational_operator value .

    AND             reduce using rule 75 (condition -> value relational_operator value .)
    OR              reduce using rule 75 (condition -> value relational_operator value .)
    NOT             reduce using rule 75 (condition -> value relational_operator value .)
    LBRACE          reduce using rule 75 (condition -> value relational_operator value .)
    SEMICOLON       reduce using rule 75 (condition -> value relational_operator value .)


state 143

    (105) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET . type RBRACKET type LBRACE map_values RBRACE
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 60
    INT32           shift and go to state 61
    INT64           shift and go to state 62
    STRING          shift and go to state 63
    FLOAT           shift and go to state 64
    FLOAT32         shift and go to state 65
    FLOAT64         shift and go to state 66
    BOOL            shift and go to state 67

    type                           shift and go to state 169

state 144

    (111) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET . type LBRACE values RBRACE
    (113) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET . type
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 60
    INT32           shift and go to state 61
    INT64           shift and go to state 62
    STRING          shift and go to state 63
    FLOAT           shift and go to state 64
    FLOAT32         shift and go to state 65
    FLOAT64         shift and go to state 66
    BOOL            shift and go to state 67

    type                           shift and go to state 170

state 145

    (106) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN

    MAP             shift and go to state 171


state 146

    (110) map_assign -> VARIABLE LBRACKET string_value RBRACKET . ASSIGN string_value

    ASSIGN          shift and go to state 172


state 147

    (115) append_statement -> APPEND LPAREN . VARIABLE COMMA values RPAREN

    VARIABLE        shift and go to state 173


state 148

    (28) values -> value COMMA values .

    RBRACE          reduce using rule 28 (values -> value COMMA values .)
    RPAREN          reduce using rule 28 (values -> value COMMA values .)
    COLON           reduce using rule 28 (values -> value COMMA values .)


state 149

    (22) structure -> TYPE VARIABLE STRUCT LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (16) block -> . switch_structure
    (17) block -> . slice_structure
    (36) print_statement -> . PRINT LPAREN values RPAREN
    (37) print_statement -> . PRINT LPAREN string_value RPAREN
    (38) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (39) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (40) print_statement -> . PRINT LPAREN operation RPAREN
    (41) print_statement -> . PRINT LPAREN RPAREN
    (42) input_statement -> . INPUT LPAREN values RPAREN
    (43) input_statement -> . INPUT LPAREN operation RPAREN
    (44) input_statement -> . INPUT LPAREN RPAREN
    (67) conditional_structure -> . IF conditions conditional_body
    (68) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (69) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (45) operation -> . value operator value
    (46) operation -> . value operator operation
    (47) operation -> . value double_operator
    (99) list_structure -> . empty_list
    (100) list_structure -> . list_with_data
    (101) list_structure -> . defined_list
    (105) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (106) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (110) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (85) for_estructure -> . for_initialization
    (86) for_estructure -> . for_infinite_bucle
    (87) for_estructure -> . for_iterator
    (22) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (24) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (25) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (26) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (55) parameters -> . parameter
    (56) parameters -> . parameter parameters
    (57) parameters -> . parameter COMMA parameters
    (18) variable_declaration -> . VAR VARIABLE type
    (19) variable_declaration -> . VAR VARIABLE ASSIGN value
    (20) variable_declaration -> . VARIABLE SHORTASSIGN value
    (21) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (91) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (111) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (112) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (113) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (114) slice_structure -> . VARIABLE ASSIGN append_statement
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (102) empty_list -> . LBRACE RBRACE
    (103) list_with_data -> . LBRACE values RBRACE
    (104) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (88) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (89) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (90) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (58) parameter -> . VARIABLE type
    (34) number -> . INT
    (35) number -> . FLOAT

    PRINT           shift and go to state 18
    INPUT           shift and go to state 19
    IF              shift and go to state 20
    VARIABLE        shift and go to state 25
    TYPE            shift and go to state 30
    FUNCTION        shift and go to state 31
    VAR             shift and go to state 33
    SWITCH          shift and go to state 34
    CHARSTRING      shift and go to state 36
    LBRACE          shift and go to state 26
    FOR             shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    statement                      shift and go to state 174
    blocks                         shift and go to state 2
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    switch_structure               shift and go to state 16
    slice_structure                shift and go to state 17
    value                          shift and go to state 21
    empty_list                     shift and go to state 22
    list_with_data                 shift and go to state 23
    defined_list                   shift and go to state 24
    for_initialization             shift and go to state 27
    for_infinite_bucle             shift and go to state 28
    for_iterator                   shift and go to state 29
    parameter                      shift and go to state 32
    number                         shift and go to state 35

state 150

    (104) defined_list -> TYPE VARIABLE LBRACE values . RBRACE

    RBRACE          shift and go to state 175


state 151

    (23) function -> FUNCTION VARIABLE LPAREN RPAREN . LBRACE blocks RBRACE
    (25) function -> FUNCTION VARIABLE LPAREN RPAREN . type LBRACE RETURN value RBRACE
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    LBRACE          shift and go to state 176
    INT             shift and go to state 60
    INT32           shift and go to state 61
    INT64           shift and go to state 62
    STRING          shift and go to state 63
    FLOAT           shift and go to state 64
    FLOAT32         shift and go to state 65
    FLOAT64         shift and go to state 66
    BOOL            shift and go to state 67

    type                           shift and go to state 177

state 152

    (24) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN LBRACE blocks RBRACE
    (26) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN type LBRACE RETURN value RBRACE

    RPAREN          shift and go to state 178


state 153

    (19) variable_declaration -> VAR VARIABLE ASSIGN value .

    PRINT           reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    INPUT           reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    IF              reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    VARIABLE        reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    TYPE            reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    FUNCTION        reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    VAR             reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    SWITCH          reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    CHARSTRING      reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    LBRACE          reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    FOR             reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    INT             reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    FLOAT           reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    $end            reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    RBRACE          reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    CASE            reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    DEFAULT         reduce using rule 19 (variable_declaration -> VAR VARIABLE ASSIGN value .)


state 154

    (112) slice_structure -> VAR VARIABLE LBRACKET RBRACKET . type
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 60
    INT32           shift and go to state 61
    INT64           shift and go to state 62
    STRING          shift and go to state 63
    FLOAT           shift and go to state 64
    FLOAT32         shift and go to state 65
    FLOAT64         shift and go to state 66
    BOOL            shift and go to state 67

    type                           shift and go to state 179

state 155

    (91) switch_structure -> SWITCH switch_expression LBRACE case_blocks . RBRACE

    RBRACE          shift and go to state 180


state 156

    (94) case_blocks -> case_block .
    (95) case_blocks -> case_block . case_blocks
    (94) case_blocks -> . case_block
    (95) case_blocks -> . case_block case_blocks
    (96) case_block -> . CASE values COLON statement
    (97) case_block -> . DEFAULT COLON statement

    RBRACE          reduce using rule 94 (case_blocks -> case_block .)
    CASE            shift and go to state 157
    DEFAULT         shift and go to state 158

    case_block                     shift and go to state 156
    case_blocks                    shift and go to state 181

state 157

    (96) case_block -> CASE . values COLON statement
    (27) values -> . value
    (28) values -> . value COMMA values
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    values                         shift and go to state 182
    value                          shift and go to state 70
    number                         shift and go to state 35

state 158

    (97) case_block -> DEFAULT . COLON statement

    COLON           shift and go to state 183


state 159

    (88) for_initialization -> FOR VARIABLE SHORTASSIGN value . SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 184


state 160

    (90) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE . SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 185


state 161

    (89) for_infinite_bucle -> FOR LBRACE statement RBRACE .

    PRINT           reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INPUT           reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    IF              reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    TYPE            reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VAR             reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    SWITCH          reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    LBRACE          reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FOR             reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INT             reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FLOAT           reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    $end            reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RBRACE          reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CASE            reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 89 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)


state 162

    (39) print_statement -> PRINT LPAREN string_value COMMA values . RPAREN

    RPAREN          shift and go to state 186


state 163

    (38) print_statement -> PRINT LPAREN FORMATSTRING COMMA values . RPAREN

    RPAREN          shift and go to state 187


state 164

    (69) conditional_structure -> IF conditions conditional_body ELSE IF . conditions conditional_body ELSE conditional_body
    (73) conditions -> . condition
    (74) conditions -> . condition logical_operator conditions
    (75) condition -> . value relational_operator value
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    conditions                     shift and go to state 188
    condition                      shift and go to state 44
    value                          shift and go to state 45
    number                         shift and go to state 35

state 165

    (68) conditional_structure -> IF conditions conditional_body ELSE conditional_body .

    PRINT           reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    SWITCH          reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CHARSTRING      reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    LBRACE          reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CASE            reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    DEFAULT         reduce using rule 68 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)


state 166

    (70) conditional_body -> LBRACE statement RBRACE .

    ELSE            reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    PRINT           reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    INPUT           reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    IF              reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    TYPE            reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    VAR             reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    SWITCH          reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    LBRACE          reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    FOR             reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    INT             reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    FLOAT           reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    $end            reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    RBRACE          reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    CASE            reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 70 (conditional_body -> LBRACE statement RBRACE .)


state 167

    (71) conditional_body -> LBRACE BREAK RBRACE .

    ELSE            reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    PRINT           reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    INPUT           reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    IF              reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    VARIABLE        reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    TYPE            reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    FUNCTION        reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    VAR             reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    SWITCH          reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    CHARSTRING      reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    LBRACE          reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    FOR             reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    INT             reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    FLOAT           reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    $end            reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    RBRACE          reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    CASE            reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)
    DEFAULT         reduce using rule 71 (conditional_body -> LBRACE BREAK RBRACE .)


state 168

    (72) conditional_body -> LBRACE CONTINUE RBRACE .

    ELSE            reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    PRINT           reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INPUT           reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    IF              reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VARIABLE        reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    TYPE            reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FUNCTION        reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VAR             reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    SWITCH          reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CHARSTRING      reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    LBRACE          reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FOR             reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INT             reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FLOAT           reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    $end            reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RBRACE          reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CASE            reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)
    DEFAULT         reduce using rule 72 (conditional_body -> LBRACE CONTINUE RBRACE .)


state 169

    (105) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type . RBRACKET type LBRACE map_values RBRACE

    RBRACKET        shift and go to state 189


state 170

    (111) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type . LBRACE values RBRACE
    (113) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .

  ! shift/reduce conflict for LBRACE resolved as shift
    LBRACE          shift and go to state 190
    PRINT           reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    INPUT           reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    IF              reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    TYPE            reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FUNCTION        reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    VAR             reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CHARSTRING      reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FOR             reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    INT             reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FLOAT           reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    $end            reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CASE            reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)

  ! LBRACE          [ reduce using rule 113 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .) ]


state 171

    (106) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN

    LBRACKET        shift and go to state 191


state 172

    (110) map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN . string_value
    (29) string_value -> . value
    (30) string_value -> . CHARSTRING
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    CHARSTRING      shift and go to state 88
    VARIABLE        shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    string_value                   shift and go to state 192
    value                          shift and go to state 114
    number                         shift and go to state 35

state 173

    (115) append_statement -> APPEND LPAREN VARIABLE . COMMA values RPAREN

    COMMA           shift and go to state 193


state 174

    (22) structure -> TYPE VARIABLE STRUCT LBRACE statement . RBRACE

    RBRACE          shift and go to state 194


state 175

    (104) defined_list -> TYPE VARIABLE LBRACE values RBRACE .

    PRINT           reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    INPUT           reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    IF              reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    VARIABLE        reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    TYPE            reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    FUNCTION        reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    VAR             reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    SWITCH          reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    LBRACE          reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    FOR             reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    INT             reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    FLOAT           reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    $end            reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    RBRACE          reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    CASE            reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    DEFAULT         reduce using rule 104 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)


state 176

    (23) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE . blocks RBRACE
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (16) block -> . switch_structure
    (17) block -> . slice_structure
    (36) print_statement -> . PRINT LPAREN values RPAREN
    (37) print_statement -> . PRINT LPAREN string_value RPAREN
    (38) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (39) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (40) print_statement -> . PRINT LPAREN operation RPAREN
    (41) print_statement -> . PRINT LPAREN RPAREN
    (42) input_statement -> . INPUT LPAREN values RPAREN
    (43) input_statement -> . INPUT LPAREN operation RPAREN
    (44) input_statement -> . INPUT LPAREN RPAREN
    (67) conditional_structure -> . IF conditions conditional_body
    (68) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (69) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (45) operation -> . value operator value
    (46) operation -> . value operator operation
    (47) operation -> . value double_operator
    (99) list_structure -> . empty_list
    (100) list_structure -> . list_with_data
    (101) list_structure -> . defined_list
    (105) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (106) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (110) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (85) for_estructure -> . for_initialization
    (86) for_estructure -> . for_infinite_bucle
    (87) for_estructure -> . for_iterator
    (22) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (24) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (25) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (26) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (55) parameters -> . parameter
    (56) parameters -> . parameter parameters
    (57) parameters -> . parameter COMMA parameters
    (18) variable_declaration -> . VAR VARIABLE type
    (19) variable_declaration -> . VAR VARIABLE ASSIGN value
    (20) variable_declaration -> . VARIABLE SHORTASSIGN value
    (21) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (91) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (111) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (112) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (113) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (114) slice_structure -> . VARIABLE ASSIGN append_statement
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (102) empty_list -> . LBRACE RBRACE
    (103) list_with_data -> . LBRACE values RBRACE
    (104) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (88) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (89) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (90) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (58) parameter -> . VARIABLE type
    (34) number -> . INT
    (35) number -> . FLOAT

    PRINT           shift and go to state 18
    INPUT           shift and go to state 19
    IF              shift and go to state 20
    VARIABLE        shift and go to state 25
    TYPE            shift and go to state 30
    FUNCTION        shift and go to state 31
    VAR             shift and go to state 33
    SWITCH          shift and go to state 34
    CHARSTRING      shift and go to state 36
    LBRACE          shift and go to state 26
    FOR             shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    blocks                         shift and go to state 195
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    switch_structure               shift and go to state 16
    slice_structure                shift and go to state 17
    value                          shift and go to state 21
    empty_list                     shift and go to state 22
    list_with_data                 shift and go to state 23
    defined_list                   shift and go to state 24
    for_initialization             shift and go to state 27
    for_infinite_bucle             shift and go to state 28
    for_iterator                   shift and go to state 29
    parameter                      shift and go to state 32
    number                         shift and go to state 35

state 177

    (25) function -> FUNCTION VARIABLE LPAREN RPAREN type . LBRACE RETURN value RBRACE

    LBRACE          shift and go to state 196


state 178

    (24) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . LBRACE blocks RBRACE
    (26) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . type LBRACE RETURN value RBRACE
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    LBRACE          shift and go to state 197
    INT             shift and go to state 60
    INT32           shift and go to state 61
    INT64           shift and go to state 62
    STRING          shift and go to state 63
    FLOAT           shift and go to state 64
    FLOAT32         shift and go to state 65
    FLOAT64         shift and go to state 66
    BOOL            shift and go to state 67

    type                           shift and go to state 198

state 179

    (112) slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .

    PRINT           reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    INPUT           reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    IF              reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    TYPE            reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FUNCTION        reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    VAR             reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CHARSTRING      reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    LBRACE          reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FOR             reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    INT             reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FLOAT           reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    $end            reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CASE            reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 112 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)


state 180

    (91) switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .

    PRINT           reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    INPUT           reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    IF              reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    VARIABLE        reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    TYPE            reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FUNCTION        reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    VAR             reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    SWITCH          reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CHARSTRING      reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    LBRACE          reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FOR             reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    INT             reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FLOAT           reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    $end            reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    RBRACE          reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CASE            reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    DEFAULT         reduce using rule 91 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)


state 181

    (95) case_blocks -> case_block case_blocks .

    RBRACE          reduce using rule 95 (case_blocks -> case_block case_blocks .)


state 182

    (96) case_block -> CASE values . COLON statement

    COLON           shift and go to state 199


state 183

    (97) case_block -> DEFAULT COLON . statement
    (1) statement -> . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (16) block -> . switch_structure
    (17) block -> . slice_structure
    (36) print_statement -> . PRINT LPAREN values RPAREN
    (37) print_statement -> . PRINT LPAREN string_value RPAREN
    (38) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (39) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (40) print_statement -> . PRINT LPAREN operation RPAREN
    (41) print_statement -> . PRINT LPAREN RPAREN
    (42) input_statement -> . INPUT LPAREN values RPAREN
    (43) input_statement -> . INPUT LPAREN operation RPAREN
    (44) input_statement -> . INPUT LPAREN RPAREN
    (67) conditional_structure -> . IF conditions conditional_body
    (68) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (69) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (45) operation -> . value operator value
    (46) operation -> . value operator operation
    (47) operation -> . value double_operator
    (99) list_structure -> . empty_list
    (100) list_structure -> . list_with_data
    (101) list_structure -> . defined_list
    (105) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (106) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (110) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (85) for_estructure -> . for_initialization
    (86) for_estructure -> . for_infinite_bucle
    (87) for_estructure -> . for_iterator
    (22) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (24) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (25) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (26) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (55) parameters -> . parameter
    (56) parameters -> . parameter parameters
    (57) parameters -> . parameter COMMA parameters
    (18) variable_declaration -> . VAR VARIABLE type
    (19) variable_declaration -> . VAR VARIABLE ASSIGN value
    (20) variable_declaration -> . VARIABLE SHORTASSIGN value
    (21) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (91) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (111) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (112) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (113) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (114) slice_structure -> . VARIABLE ASSIGN append_statement
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (102) empty_list -> . LBRACE RBRACE
    (103) list_with_data -> . LBRACE values RBRACE
    (104) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (88) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (89) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (90) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (58) parameter -> . VARIABLE type
    (34) number -> . INT
    (35) number -> . FLOAT

    PRINT           shift and go to state 18
    INPUT           shift and go to state 19
    IF              shift and go to state 20
    VARIABLE        shift and go to state 25
    TYPE            shift and go to state 30
    FUNCTION        shift and go to state 31
    VAR             shift and go to state 33
    SWITCH          shift and go to state 34
    CHARSTRING      shift and go to state 36
    LBRACE          shift and go to state 26
    FOR             shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    statement                      shift and go to state 200
    blocks                         shift and go to state 2
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    switch_structure               shift and go to state 16
    slice_structure                shift and go to state 17
    value                          shift and go to state 21
    empty_list                     shift and go to state 22
    list_with_data                 shift and go to state 23
    defined_list                   shift and go to state 24
    for_initialization             shift and go to state 27
    for_infinite_bucle             shift and go to state 28
    for_iterator                   shift and go to state 29
    parameter                      shift and go to state 32
    number                         shift and go to state 35

state 184

    (88) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON . condition SEMICOLON value double_operator LBRACE statement RBRACE
    (75) condition -> . value relational_operator value
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    value                          shift and go to state 45
    condition                      shift and go to state 201
    number                         shift and go to state 35

state 185

    (90) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN . RANGE VARIABLE LBRACE statement RBRACE

    RANGE           shift and go to state 202


state 186

    (39) print_statement -> PRINT LPAREN string_value COMMA values RPAREN .

    PRINT           reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    INPUT           reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    IF              reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    VARIABLE        reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    TYPE            reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    FUNCTION        reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    VAR             reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    SWITCH          reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    CHARSTRING      reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    LBRACE          reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    FOR             reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    INT             reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    FLOAT           reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    $end            reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    RBRACE          reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    CASE            reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    DEFAULT         reduce using rule 39 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)


state 187

    (38) print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .

    PRINT           reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    INPUT           reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    IF              reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    VARIABLE        reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    TYPE            reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    FUNCTION        reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    VAR             reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    SWITCH          reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    CHARSTRING      reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    LBRACE          reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    FOR             reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    INT             reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    FLOAT           reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    $end            reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    RBRACE          reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    CASE            reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)
    DEFAULT         reduce using rule 38 (print_statement -> PRINT LPAREN FORMATSTRING COMMA values RPAREN .)


state 188

    (69) conditional_structure -> IF conditions conditional_body ELSE IF conditions . conditional_body ELSE conditional_body
    (70) conditional_body -> . LBRACE statement RBRACE
    (71) conditional_body -> . LBRACE BREAK RBRACE
    (72) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 94

    conditional_body               shift and go to state 203

state 189

    (105) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET . type LBRACE map_values RBRACE
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 60
    INT32           shift and go to state 61
    INT64           shift and go to state 62
    STRING          shift and go to state 63
    FLOAT           shift and go to state 64
    FLOAT32         shift and go to state 65
    FLOAT64         shift and go to state 66
    BOOL            shift and go to state 67

    type                           shift and go to state 204

state 190

    (111) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE . values RBRACE
    (27) values -> . value
    (28) values -> . value COMMA values
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    values                         shift and go to state 205
    value                          shift and go to state 70
    number                         shift and go to state 35

state 191

    (106) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 60
    INT32           shift and go to state 61
    INT64           shift and go to state 62
    STRING          shift and go to state 63
    FLOAT           shift and go to state 64
    FLOAT32         shift and go to state 65
    FLOAT64         shift and go to state 66
    BOOL            shift and go to state 67

    type                           shift and go to state 206

state 192

    (110) map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .

    PRINT           reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    INPUT           reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    IF              reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    VARIABLE        reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    TYPE            reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    FUNCTION        reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    VAR             reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    SWITCH          reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    CHARSTRING      reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    LBRACE          reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    FOR             reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    INT             reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    FLOAT           reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    $end            reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    RBRACE          reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    CASE            reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    DEFAULT         reduce using rule 110 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)


state 193

    (115) append_statement -> APPEND LPAREN VARIABLE COMMA . values RPAREN
    (27) values -> . value
    (28) values -> . value COMMA values
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    values                         shift and go to state 207
    value                          shift and go to state 70
    number                         shift and go to state 35

state 194

    (22) structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .

    PRINT           reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    INPUT           reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    IF              reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    TYPE            reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    VAR             reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    SWITCH          reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    LBRACE          reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    FOR             reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    INT             reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    FLOAT           reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    $end            reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    RBRACE          reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    CASE            reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 22 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)


state 195

    (23) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 208


state 196

    (25) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE . RETURN value RBRACE

    RETURN          shift and go to state 209


state 197

    (24) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE . blocks RBRACE
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (16) block -> . switch_structure
    (17) block -> . slice_structure
    (36) print_statement -> . PRINT LPAREN values RPAREN
    (37) print_statement -> . PRINT LPAREN string_value RPAREN
    (38) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (39) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (40) print_statement -> . PRINT LPAREN operation RPAREN
    (41) print_statement -> . PRINT LPAREN RPAREN
    (42) input_statement -> . INPUT LPAREN values RPAREN
    (43) input_statement -> . INPUT LPAREN operation RPAREN
    (44) input_statement -> . INPUT LPAREN RPAREN
    (67) conditional_structure -> . IF conditions conditional_body
    (68) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (69) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (45) operation -> . value operator value
    (46) operation -> . value operator operation
    (47) operation -> . value double_operator
    (99) list_structure -> . empty_list
    (100) list_structure -> . list_with_data
    (101) list_structure -> . defined_list
    (105) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (106) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (110) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (85) for_estructure -> . for_initialization
    (86) for_estructure -> . for_infinite_bucle
    (87) for_estructure -> . for_iterator
    (22) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (24) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (25) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (26) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (55) parameters -> . parameter
    (56) parameters -> . parameter parameters
    (57) parameters -> . parameter COMMA parameters
    (18) variable_declaration -> . VAR VARIABLE type
    (19) variable_declaration -> . VAR VARIABLE ASSIGN value
    (20) variable_declaration -> . VARIABLE SHORTASSIGN value
    (21) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (91) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (111) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (112) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (113) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (114) slice_structure -> . VARIABLE ASSIGN append_statement
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (102) empty_list -> . LBRACE RBRACE
    (103) list_with_data -> . LBRACE values RBRACE
    (104) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (88) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (89) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (90) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (58) parameter -> . VARIABLE type
    (34) number -> . INT
    (35) number -> . FLOAT

    PRINT           shift and go to state 18
    INPUT           shift and go to state 19
    IF              shift and go to state 20
    VARIABLE        shift and go to state 25
    TYPE            shift and go to state 30
    FUNCTION        shift and go to state 31
    VAR             shift and go to state 33
    SWITCH          shift and go to state 34
    CHARSTRING      shift and go to state 36
    LBRACE          shift and go to state 26
    FOR             shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    parameters                     shift and go to state 14
    blocks                         shift and go to state 210
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    variable_declaration           shift and go to state 15
    switch_structure               shift and go to state 16
    slice_structure                shift and go to state 17
    value                          shift and go to state 21
    empty_list                     shift and go to state 22
    list_with_data                 shift and go to state 23
    defined_list                   shift and go to state 24
    for_initialization             shift and go to state 27
    for_infinite_bucle             shift and go to state 28
    for_iterator                   shift and go to state 29
    parameter                      shift and go to state 32
    number                         shift and go to state 35

state 198

    (26) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type . LBRACE RETURN value RBRACE

    LBRACE          shift and go to state 211


state 199

    (96) case_block -> CASE values COLON . statement
    (1) statement -> . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (16) block -> . switch_structure
    (17) block -> . slice_structure
    (36) print_statement -> . PRINT LPAREN values RPAREN
    (37) print_statement -> . PRINT LPAREN string_value RPAREN
    (38) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (39) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (40) print_statement -> . PRINT LPAREN operation RPAREN
    (41) print_statement -> . PRINT LPAREN RPAREN
    (42) input_statement -> . INPUT LPAREN values RPAREN
    (43) input_statement -> . INPUT LPAREN operation RPAREN
    (44) input_statement -> . INPUT LPAREN RPAREN
    (67) conditional_structure -> . IF conditions conditional_body
    (68) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (69) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (45) operation -> . value operator value
    (46) operation -> . value operator operation
    (47) operation -> . value double_operator
    (99) list_structure -> . empty_list
    (100) list_structure -> . list_with_data
    (101) list_structure -> . defined_list
    (105) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (106) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (110) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (85) for_estructure -> . for_initialization
    (86) for_estructure -> . for_infinite_bucle
    (87) for_estructure -> . for_iterator
    (22) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (24) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (25) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (26) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (55) parameters -> . parameter
    (56) parameters -> . parameter parameters
    (57) parameters -> . parameter COMMA parameters
    (18) variable_declaration -> . VAR VARIABLE type
    (19) variable_declaration -> . VAR VARIABLE ASSIGN value
    (20) variable_declaration -> . VARIABLE SHORTASSIGN value
    (21) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (91) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (111) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (112) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (113) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (114) slice_structure -> . VARIABLE ASSIGN append_statement
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (102) empty_list -> . LBRACE RBRACE
    (103) list_with_data -> . LBRACE values RBRACE
    (104) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (88) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (89) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (90) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (58) parameter -> . VARIABLE type
    (34) number -> . INT
    (35) number -> . FLOAT

    PRINT           shift and go to state 18
    INPUT           shift and go to state 19
    IF              shift and go to state 20
    VARIABLE        shift and go to state 25
    TYPE            shift and go to state 30
    FUNCTION        shift and go to state 31
    VAR             shift and go to state 33
    SWITCH          shift and go to state 34
    CHARSTRING      shift and go to state 36
    LBRACE          shift and go to state 26
    FOR             shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    statement                      shift and go to state 212
    blocks                         shift and go to state 2
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    switch_structure               shift and go to state 16
    slice_structure                shift and go to state 17
    value                          shift and go to state 21
    empty_list                     shift and go to state 22
    list_with_data                 shift and go to state 23
    defined_list                   shift and go to state 24
    for_initialization             shift and go to state 27
    for_infinite_bucle             shift and go to state 28
    for_iterator                   shift and go to state 29
    parameter                      shift and go to state 32
    number                         shift and go to state 35

state 200

    (97) case_block -> DEFAULT COLON statement .

    CASE            reduce using rule 97 (case_block -> DEFAULT COLON statement .)
    DEFAULT         reduce using rule 97 (case_block -> DEFAULT COLON statement .)
    RBRACE          reduce using rule 97 (case_block -> DEFAULT COLON statement .)


state 201

    (88) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition . SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 213


state 202

    (90) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE . VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 214


state 203

    (69) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body . ELSE conditional_body

    ELSE            shift and go to state 215


state 204

    (105) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type . LBRACE map_values RBRACE

    LBRACE          shift and go to state 216


state 205

    (111) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values . RBRACE

    RBRACE          shift and go to state 217


state 206

    (106) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN

    RBRACKET        shift and go to state 218


state 207

    (115) append_statement -> APPEND LPAREN VARIABLE COMMA values . RPAREN

    RPAREN          shift and go to state 219


state 208

    (23) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .

    PRINT           reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    LBRACE          reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CASE            reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 23 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)


state 209

    (25) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN . value RBRACE
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    value                          shift and go to state 220
    number                         shift and go to state 35

state 210

    (24) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 221


state 211

    (26) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE . RETURN value RBRACE

    RETURN          shift and go to state 222


state 212

    (96) case_block -> CASE values COLON statement .

    CASE            reduce using rule 96 (case_block -> CASE values COLON statement .)
    DEFAULT         reduce using rule 96 (case_block -> CASE values COLON statement .)
    RBRACE          reduce using rule 96 (case_block -> CASE values COLON statement .)


state 213

    (88) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON . value double_operator LBRACE statement RBRACE
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    value                          shift and go to state 223
    number                         shift and go to state 35

state 214

    (90) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE . LBRACE statement RBRACE

    LBRACE          shift and go to state 224


state 215

    (69) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE . conditional_body
    (70) conditional_body -> . LBRACE statement RBRACE
    (71) conditional_body -> . LBRACE BREAK RBRACE
    (72) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 94

    conditional_body               shift and go to state 225

state 216

    (105) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE . map_values RBRACE
    (107) map_values -> . map_value
    (108) map_values -> . map_value COMMA map_values
    (109) map_value -> . string_value COLON string_value
    (29) string_value -> . value
    (30) string_value -> . CHARSTRING
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    CHARSTRING      shift and go to state 88
    VARIABLE        shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    map_values                     shift and go to state 226
    map_value                      shift and go to state 227
    string_value                   shift and go to state 228
    value                          shift and go to state 114
    number                         shift and go to state 35

state 217

    (111) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .

    PRINT           reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    INPUT           reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    IF              reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    VARIABLE        reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    TYPE            reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FUNCTION        reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    VAR             reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    SWITCH          reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    LBRACE          reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FOR             reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    INT             reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FLOAT           reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    $end            reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    RBRACE          reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CASE            reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    DEFAULT         reduce using rule 111 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)


state 218

    (106) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (59) type -> . INT
    (60) type -> . INT32
    (61) type -> . INT64
    (62) type -> . STRING
    (63) type -> . FLOAT
    (64) type -> . FLOAT32
    (65) type -> . FLOAT64
    (66) type -> . BOOL

    INT             shift and go to state 60
    INT32           shift and go to state 61
    INT64           shift and go to state 62
    STRING          shift and go to state 63
    FLOAT           shift and go to state 64
    FLOAT32         shift and go to state 65
    FLOAT64         shift and go to state 66
    BOOL            shift and go to state 67

    type                           shift and go to state 229

state 219

    (115) append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .

    PRINT           reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    INPUT           reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    IF              reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    VARIABLE        reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    TYPE            reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FUNCTION        reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    VAR             reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    SWITCH          reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CHARSTRING      reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    LBRACE          reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FOR             reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    INT             reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FLOAT           reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    $end            reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    RBRACE          reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CASE            reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    DEFAULT         reduce using rule 115 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)


state 220

    (25) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value . RBRACE

    RBRACE          shift and go to state 230


state 221

    (24) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .

    PRINT           reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    LBRACE          reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CASE            reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 24 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)


state 222

    (26) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN . value RBRACE
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    VARIABLE        shift and go to state 46
    CHARSTRING      shift and go to state 36
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    value                          shift and go to state 231
    number                         shift and go to state 35

state 223

    (88) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value . double_operator LBRACE statement RBRACE
    (53) double_operator -> . INCREMENT
    (54) double_operator -> . DECREMENT

    INCREMENT       shift and go to state 54
    DECREMENT       shift and go to state 55

    double_operator                shift and go to state 232

state 224

    (90) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (16) block -> . switch_structure
    (17) block -> . slice_structure
    (36) print_statement -> . PRINT LPAREN values RPAREN
    (37) print_statement -> . PRINT LPAREN string_value RPAREN
    (38) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (39) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (40) print_statement -> . PRINT LPAREN operation RPAREN
    (41) print_statement -> . PRINT LPAREN RPAREN
    (42) input_statement -> . INPUT LPAREN values RPAREN
    (43) input_statement -> . INPUT LPAREN operation RPAREN
    (44) input_statement -> . INPUT LPAREN RPAREN
    (67) conditional_structure -> . IF conditions conditional_body
    (68) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (69) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (45) operation -> . value operator value
    (46) operation -> . value operator operation
    (47) operation -> . value double_operator
    (99) list_structure -> . empty_list
    (100) list_structure -> . list_with_data
    (101) list_structure -> . defined_list
    (105) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (106) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (110) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (85) for_estructure -> . for_initialization
    (86) for_estructure -> . for_infinite_bucle
    (87) for_estructure -> . for_iterator
    (22) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (24) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (25) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (26) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (55) parameters -> . parameter
    (56) parameters -> . parameter parameters
    (57) parameters -> . parameter COMMA parameters
    (18) variable_declaration -> . VAR VARIABLE type
    (19) variable_declaration -> . VAR VARIABLE ASSIGN value
    (20) variable_declaration -> . VARIABLE SHORTASSIGN value
    (21) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (91) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (111) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (112) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (113) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (114) slice_structure -> . VARIABLE ASSIGN append_statement
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (102) empty_list -> . LBRACE RBRACE
    (103) list_with_data -> . LBRACE values RBRACE
    (104) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (88) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (89) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (90) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (58) parameter -> . VARIABLE type
    (34) number -> . INT
    (35) number -> . FLOAT

    PRINT           shift and go to state 18
    INPUT           shift and go to state 19
    IF              shift and go to state 20
    VARIABLE        shift and go to state 25
    TYPE            shift and go to state 30
    FUNCTION        shift and go to state 31
    VAR             shift and go to state 33
    SWITCH          shift and go to state 34
    CHARSTRING      shift and go to state 36
    LBRACE          shift and go to state 26
    FOR             shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    statement                      shift and go to state 233
    blocks                         shift and go to state 2
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    switch_structure               shift and go to state 16
    slice_structure                shift and go to state 17
    value                          shift and go to state 21
    empty_list                     shift and go to state 22
    list_with_data                 shift and go to state 23
    defined_list                   shift and go to state 24
    for_initialization             shift and go to state 27
    for_infinite_bucle             shift and go to state 28
    for_iterator                   shift and go to state 29
    parameter                      shift and go to state 32
    number                         shift and go to state 35

state 225

    (69) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .

    PRINT           reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    SWITCH          reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CHARSTRING      reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    LBRACE          reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CASE            reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    DEFAULT         reduce using rule 69 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)


state 226

    (105) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values . RBRACE

    RBRACE          shift and go to state 234


state 227

    (107) map_values -> map_value .
    (108) map_values -> map_value . COMMA map_values

    RBRACE          reduce using rule 107 (map_values -> map_value .)
    COMMA           shift and go to state 235


state 228

    (109) map_value -> string_value . COLON string_value

    COLON           shift and go to state 236


state 229

    (106) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN

    RPAREN          shift and go to state 237


state 230

    (25) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .

    PRINT           reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    INPUT           reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    IF              reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    VARIABLE        reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    TYPE            reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    FUNCTION        reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    VAR             reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    SWITCH          reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    CHARSTRING      reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    LBRACE          reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    FOR             reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    INT             reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    FLOAT           reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    $end            reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    RBRACE          reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    CASE            reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    DEFAULT         reduce using rule 25 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)


state 231

    (26) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value . RBRACE

    RBRACE          shift and go to state 238


state 232

    (88) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator . LBRACE statement RBRACE

    LBRACE          shift and go to state 239


state 233

    (90) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement . RBRACE

    RBRACE          shift and go to state 240


state 234

    (105) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .

    PRINT           reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INPUT           reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    IF              reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VARIABLE        reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    TYPE            reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FUNCTION        reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VAR             reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    SWITCH          reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CHARSTRING      reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    LBRACE          reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FOR             reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INT             reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FLOAT           reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    $end            reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RBRACE          reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CASE            reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    DEFAULT         reduce using rule 105 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)


state 235

    (108) map_values -> map_value COMMA . map_values
    (107) map_values -> . map_value
    (108) map_values -> . map_value COMMA map_values
    (109) map_value -> . string_value COLON string_value
    (29) string_value -> . value
    (30) string_value -> . CHARSTRING
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    CHARSTRING      shift and go to state 88
    VARIABLE        shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    map_value                      shift and go to state 227
    map_values                     shift and go to state 241
    string_value                   shift and go to state 228
    value                          shift and go to state 114
    number                         shift and go to state 35

state 236

    (109) map_value -> string_value COLON . string_value
    (29) string_value -> . value
    (30) string_value -> . CHARSTRING
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (34) number -> . INT
    (35) number -> . FLOAT

    CHARSTRING      shift and go to state 88
    VARIABLE        shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    string_value                   shift and go to state 242
    value                          shift and go to state 114
    number                         shift and go to state 35

state 237

    (106) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .

    PRINT           reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INPUT           reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    IF              reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TYPE            reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FUNCTION        reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VAR             reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SWITCH          reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CHARSTRING      reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LBRACE          reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FOR             reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INT             reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FLOAT           reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    $end            reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RBRACE          reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CASE            reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 106 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)


state 238

    (26) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .

    PRINT           reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    INPUT           reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    IF              reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    VARIABLE        reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    TYPE            reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    FUNCTION        reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    VAR             reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    SWITCH          reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    CHARSTRING      reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    LBRACE          reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    FOR             reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    INT             reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    FLOAT           reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    $end            reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    RBRACE          reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    CASE            reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    DEFAULT         reduce using rule 26 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)


state 239

    (88) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) blocks -> . block
    (3) blocks -> . block blocks
    (4) block -> . print_statement
    (5) block -> . input_statement
    (6) block -> . conditional_structure
    (7) block -> . operation
    (8) block -> . list_structure
    (9) block -> . map_estructure
    (10) block -> . map_assign
    (11) block -> . for_estructure
    (12) block -> . structure
    (13) block -> . function
    (14) block -> . parameters
    (15) block -> . variable_declaration
    (16) block -> . switch_structure
    (17) block -> . slice_structure
    (36) print_statement -> . PRINT LPAREN values RPAREN
    (37) print_statement -> . PRINT LPAREN string_value RPAREN
    (38) print_statement -> . PRINT LPAREN FORMATSTRING COMMA values RPAREN
    (39) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (40) print_statement -> . PRINT LPAREN operation RPAREN
    (41) print_statement -> . PRINT LPAREN RPAREN
    (42) input_statement -> . INPUT LPAREN values RPAREN
    (43) input_statement -> . INPUT LPAREN operation RPAREN
    (44) input_statement -> . INPUT LPAREN RPAREN
    (67) conditional_structure -> . IF conditions conditional_body
    (68) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (69) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (45) operation -> . value operator value
    (46) operation -> . value operator operation
    (47) operation -> . value double_operator
    (99) list_structure -> . empty_list
    (100) list_structure -> . list_with_data
    (101) list_structure -> . defined_list
    (105) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (106) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (110) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (85) for_estructure -> . for_initialization
    (86) for_estructure -> . for_infinite_bucle
    (87) for_estructure -> . for_iterator
    (22) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (23) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (24) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (25) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (26) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (55) parameters -> . parameter
    (56) parameters -> . parameter parameters
    (57) parameters -> . parameter COMMA parameters
    (18) variable_declaration -> . VAR VARIABLE type
    (19) variable_declaration -> . VAR VARIABLE ASSIGN value
    (20) variable_declaration -> . VARIABLE SHORTASSIGN value
    (21) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (91) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (111) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (112) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (113) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (114) slice_structure -> . VARIABLE ASSIGN append_statement
    (31) value -> . VARIABLE
    (32) value -> . number
    (33) value -> . CHARSTRING
    (102) empty_list -> . LBRACE RBRACE
    (103) list_with_data -> . LBRACE values RBRACE
    (104) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (88) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (89) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (90) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (58) parameter -> . VARIABLE type
    (34) number -> . INT
    (35) number -> . FLOAT

    PRINT           shift and go to state 18
    INPUT           shift and go to state 19
    IF              shift and go to state 20
    VARIABLE        shift and go to state 25
    TYPE            shift and go to state 30
    FUNCTION        shift and go to state 31
    VAR             shift and go to state 33
    SWITCH          shift and go to state 34
    CHARSTRING      shift and go to state 36
    LBRACE          shift and go to state 26
    FOR             shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    value                          shift and go to state 21
    statement                      shift and go to state 243
    blocks                         shift and go to state 2
    block                          shift and go to state 3
    print_statement                shift and go to state 4
    input_statement                shift and go to state 5
    conditional_structure          shift and go to state 6
    operation                      shift and go to state 7
    list_structure                 shift and go to state 8
    map_estructure                 shift and go to state 9
    map_assign                     shift and go to state 10
    for_estructure                 shift and go to state 11
    structure                      shift and go to state 12
    function                       shift and go to state 13
    parameters                     shift and go to state 14
    variable_declaration           shift and go to state 15
    switch_structure               shift and go to state 16
    slice_structure                shift and go to state 17
    empty_list                     shift and go to state 22
    list_with_data                 shift and go to state 23
    defined_list                   shift and go to state 24
    for_initialization             shift and go to state 27
    for_infinite_bucle             shift and go to state 28
    for_iterator                   shift and go to state 29
    parameter                      shift and go to state 32
    number                         shift and go to state 35

state 240

    (90) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .

    PRINT           reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INPUT           reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    IF              reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    TYPE            reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VAR             reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    SWITCH          reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    LBRACE          reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FOR             reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INT             reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FLOAT           reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    $end            reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RBRACE          reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CASE            reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 90 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)


state 241

    (108) map_values -> map_value COMMA map_values .

    RBRACE          reduce using rule 108 (map_values -> map_value COMMA map_values .)


state 242

    (109) map_value -> string_value COLON string_value .

    COMMA           reduce using rule 109 (map_value -> string_value COLON string_value .)
    RBRACE          reduce using rule 109 (map_value -> string_value COLON string_value .)


state 243

    (88) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement . RBRACE

    RBRACE          shift and go to state 244


state 244

    (88) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .

    PRINT           reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INPUT           reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    IF              reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    TYPE            reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VAR             reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    SWITCH          reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    LBRACE          reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FOR             reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INT             reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FLOAT           reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    $end            reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RBRACE          reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CASE            reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 88 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ASSIGN in state 25 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 32 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 87 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 170 resolved as shift
WARNING: reduce/reduce conflict in state 87 resolved using rule (values -> value)
WARNING: rejected rule (string_value -> value) in state 87
WARNING: reduce/reduce conflict in state 88 resolved using rule (string_value -> CHARSTRING)
WARNING: rejected rule (value -> CHARSTRING) in state 88
