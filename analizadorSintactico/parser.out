Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    CONST
    DIVIDEASSIGN
    FALSE
    IDENTIFIER
    MINUSASSIGN
    MOD
    MODASSIGN
    PLUSASSIGN
    TEXT
    TIMESASSIGN
    TRUE

Grammar

Rule 0     S' -> statement
Rule 1     statement -> blocks
Rule 2     statement -> import blocks
Rule 3     statement -> package blocks
Rule 4     statement -> package import blocks
Rule 5     statement -> main LBRACE blocks RBRACE
Rule 6     statement -> package main LBRACE blocks RBRACE
Rule 7     statement -> import main LBRACE blocks RBRACE
Rule 8     statement -> package import main LBRACE blocks RBRACE
Rule 9     import -> <empty>
Rule 10    import -> IMPORT CHARSTRING
Rule 11    import -> IMPORT LPAREN values_import RPAREN
Rule 12    values_import -> CHARSTRING
Rule 13    values_import -> CHARSTRING values_import
Rule 14    package -> PACKAGE VARIABLE
Rule 15    main -> FUNCTION MAIN LPAREN RPAREN
Rule 16    blocks -> block
Rule 17    blocks -> block blocks
Rule 18    block -> print_statement
Rule 19    block -> input_statement
Rule 20    block -> conditional_structure
Rule 21    block -> operation
Rule 22    block -> list_structure
Rule 23    block -> map_estructure
Rule 24    block -> map_assign
Rule 25    block -> for_estructure
Rule 26    block -> structure
Rule 27    block -> function
Rule 28    block -> parameters
Rule 29    block -> variable_declaration
Rule 30    block -> switch_structure
Rule 31    block -> slice_structure
Rule 32    variable_declaration -> VAR VARIABLE type
Rule 33    variable_declaration -> VAR VARIABLE ASSIGN value
Rule 34    variable_declaration -> VAR VARIABLE ASSIGN list_structure
Rule 35    variable_declaration -> VARIABLE SHORTASSIGN value
Rule 36    variable_declaration -> VARIABLE SHORTASSIGN operation
Rule 37    structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE
Rule 38    function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
Rule 39    function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
Rule 40    function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
Rule 41    function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
Rule 42    function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
Rule 43    values -> value
Rule 44    values -> value COMMA values
Rule 45    string_value -> value
Rule 46    string_value -> CHARSTRING
Rule 47    value -> VARIABLE
Rule 48    value -> number
Rule 49    value -> CHARSTRING
Rule 50    number -> INT
Rule 51    number -> FLOAT
Rule 52    print_statement -> PRINT LPAREN values RPAREN
Rule 53    print_statement -> PRINT LPAREN string_value RPAREN
Rule 54    print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN
Rule 55    print_statement -> PRINT LPAREN string_value COMMA values RPAREN
Rule 56    print_statement -> PRINT LPAREN operation RPAREN
Rule 57    print_statement -> PRINT LPAREN RPAREN
Rule 58    input_statement -> INPUT LPAREN values RPAREN
Rule 59    input_statement -> INPUT LPAREN operation RPAREN
Rule 60    input_statement -> INPUT LPAREN RPAREN
Rule 61    operation -> value operator value
Rule 62    operation -> value operator operation
Rule 63    operation -> value double_operator
Rule 64    operator -> PLUS
Rule 65    operator -> MINUS
Rule 66    operator -> TIMES
Rule 67    operator -> DIVIDE
Rule 68    operator -> ASSIGN
Rule 69    double_operator -> INCREMENT
Rule 70    double_operator -> DECREMENT
Rule 71    parameters -> parameter
Rule 72    parameters -> parameter parameters
Rule 73    parameters -> parameter COMMA parameters
Rule 74    parameter -> VARIABLE type
Rule 75    type -> INT
Rule 76    type -> INT32
Rule 77    type -> INT64
Rule 78    type -> STRING
Rule 79    type -> FLOAT
Rule 80    type -> FLOAT32
Rule 81    type -> FLOAT64
Rule 82    type -> BOOL
Rule 83    conditional_structure -> IF conditions conditional_body
Rule 84    conditional_structure -> IF conditions conditional_body ELSE conditional_body
Rule 85    conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
Rule 86    conditional_body -> LBRACE statement RBRACE
Rule 87    conditional_body -> LBRACE BREAK RBRACE
Rule 88    conditional_body -> LBRACE CONTINUE RBRACE
Rule 89    conditions -> condition
Rule 90    conditions -> condition logical_operator conditions
Rule 91    condition -> value relational_operator value
Rule 92    logical_operator -> AND
Rule 93    logical_operator -> OR
Rule 94    logical_operator -> NOT
Rule 95    relational_operator -> GREATER
Rule 96    relational_operator -> LESS
Rule 97    relational_operator -> GREATEREQUALS
Rule 98    relational_operator -> LESSEQUALS
Rule 99    relational_operator -> EQUALS
Rule 100   relational_operator -> DIFFERENT
Rule 101   for_estructure -> for_initialization
Rule 102   for_estructure -> for_infinite_bucle
Rule 103   for_estructure -> for_iterator
Rule 104   for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
Rule 105   for_infinite_bucle -> FOR LBRACE statement RBRACE
Rule 106   for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
Rule 107   switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE
Rule 108   switch_expression -> value
Rule 109   switch_expression -> empty
Rule 110   case_blocks -> case_block
Rule 111   case_blocks -> case_block case_blocks
Rule 112   case_block -> CASE values COLON statement
Rule 113   case_block -> DEFAULT COLON statement
Rule 114   empty -> <empty>
Rule 115   list_structure -> empty_list
Rule 116   list_structure -> list_with_data
Rule 117   list_structure -> defined_list
Rule 118   empty_list -> LBRACE RBRACE
Rule 119   list_with_data -> LBRACE values RBRACE
Rule 120   defined_list -> TYPE VARIABLE LBRACE values RBRACE
Rule 121   map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
Rule 122   map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
Rule 123   map_values -> map_value
Rule 124   map_values -> map_value COMMA map_values
Rule 125   map_value -> string_value COLON string_value
Rule 126   map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
Rule 127   slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
Rule 128   slice_structure -> VAR VARIABLE LBRACKET RBRACKET type
Rule 129   slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type
Rule 130   slice_structure -> VARIABLE ASSIGN append_statement
Rule 131   append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 92
APPEND               : 131
ASSIGN               : 33 34 68 126 130
BOOL                 : 82
BREAK                : 87
CASE                 : 112
CHARSTRING           : 10 12 13 46 49
COLON                : 112 113 125
COMMA                : 44 54 55 73 124 131
CONST                : 
CONTINUE             : 88
DECREMENT            : 70
DEFAULT              : 113
DIFFERENT            : 100
DIVIDE               : 67
DIVIDEASSIGN         : 
ELSE                 : 84 85 85
EQUALS               : 99
FALSE                : 
FLOAT                : 51 79
FLOAT32              : 80
FLOAT64              : 81
FOR                  : 104 105 106
FORMATSTRING         : 54
FUNCTION             : 15 38 39 40 41 42
GREATER              : 95
GREATEREQUALS        : 97
IDENTIFIER           : 
IF                   : 83 84 85 85
IMPORT               : 10 11
INCREMENT            : 69
INPUT                : 58 59 60
INT                  : 50 75
INT32                : 76
INT64                : 77
LBRACE               : 5 6 7 8 37 38 39 40 41 42 86 87 88 104 105 106 107 118 119 120 121 127
LBRACKET             : 121 122 126 127 128 129
LESS                 : 96
LESSEQUALS           : 98
LPAREN               : 11 15 38 39 40 41 42 52 53 54 55 56 57 58 59 60 122 131
MAIN                 : 15
MAKE                 : 122
MAP                  : 121 122
MINUS                : 65
MINUSASSIGN          : 
MOD                  : 
MODASSIGN            : 
NOT                  : 94
OR                   : 93
PACKAGE              : 14
PLUS                 : 64
PLUSASSIGN           : 
PRINT                : 52 53 55 56 57
PRINTF               : 54
RANGE                : 106
RBRACE               : 5 6 7 8 37 38 39 40 41 42 86 87 88 104 105 106 107 118 119 120 121 127
RBRACKET             : 121 122 126 127 128 129
RETURN               : 40 41 42
RPAREN               : 11 15 38 39 40 41 42 52 53 54 55 56 57 58 59 60 122 131
SEMICOLON            : 104 104 106
SHORTASSIGN          : 35 36 104 106 121 122 127 129
STRING               : 78
STRUCT               : 37
SWITCH               : 107
TEXT                 : 
TIMES                : 66
TIMESASSIGN          : 
TRUE                 : 
TYPE                 : 37 120
VAR                  : 32 33 34 128
VARIABLE             : 14 32 33 34 35 36 37 38 39 40 41 42 47 74 104 106 106 106 120 121 122 126 127 128 129 130 131
error                : 

Nonterminals, with rules where they appear

append_statement     : 130
block                : 16 17
blocks               : 1 2 3 4 5 6 7 8 17 38 39 42
case_block           : 110 111
case_blocks          : 107 111
condition            : 89 90 104
conditional_body     : 83 84 84 85 85 85
conditional_structure : 20
conditions           : 83 84 85 85 90
defined_list         : 117
double_operator      : 63 104
empty                : 109
empty_list           : 115
for_estructure       : 25
for_infinite_bucle   : 102
for_initialization   : 101
for_iterator         : 103
function             : 27
import               : 2 4 7 8
input_statement      : 19
list_structure       : 22 34
list_with_data       : 116
logical_operator     : 90
main                 : 5 6 7 8
map_assign           : 24
map_estructure       : 23
map_value            : 123 124
map_values           : 121 124
number               : 48
operation            : 21 36 56 59 62
operator             : 61 62
package              : 3 4 6 8
parameter            : 71 72 73
parameters           : 28 39 41 42 72 73
print_statement      : 18
relational_operator  : 91
slice_structure      : 31
statement            : 37 86 104 105 106 112 113 0
string_value         : 53 55 125 125 126 126
structure            : 26
switch_expression    : 107
switch_structure     : 30
type                 : 32 40 41 42 74 121 121 122 122 127 128 129
value                : 33 35 40 41 42 43 44 45 61 61 62 63 91 91 104 104 108
values               : 44 52 54 55 58 112 119 120 127 131
values_import        : 11 13
variable_declaration : 29

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) main -> . FUNCTION MAIN LPAREN RPAREN
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 8
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! LBRACE          [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 1
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 1

    (0) S' -> statement .



state 2

    (1) statement -> blocks .

    $end            reduce using rule 1 (statement -> blocks .)
    RBRACE          reduce using rule 1 (statement -> blocks .)
    CASE            reduce using rule 1 (statement -> blocks .)
    DEFAULT         reduce using rule 1 (statement -> blocks .)


state 3

    (2) statement -> import . blocks
    (7) statement -> import . main LBRACE blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (15) main -> . FUNCTION MAIN LPAREN RPAREN
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    blocks                         shift and go to state 46
    main                           shift and go to state 47
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 4

    (3) statement -> package . blocks
    (4) statement -> package . import blocks
    (6) statement -> package . main LBRACE blocks RBRACE
    (8) statement -> package . import main LBRACE blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_import RPAREN
    (15) main -> . FUNCTION MAIN LPAREN RPAREN
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 8
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! LBRACE          [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    blocks                         shift and go to state 48
    import                         shift and go to state 49
    main                           shift and go to state 50
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 5

    (5) statement -> main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 51


state 6

    (118) empty_list -> LBRACE . RBRACE
    (119) list_with_data -> LBRACE . values RBRACE
    (43) values -> . value
    (44) values -> . value COMMA values
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    RBRACE          shift and go to state 52
    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    values                         shift and go to state 53
    value                          shift and go to state 54
    number                         shift and go to state 42

state 7

    (16) blocks -> block .
    (17) blocks -> block . blocks
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

    $end            reduce using rule 16 (blocks -> block .)
    RBRACE          reduce using rule 16 (blocks -> block .)
    CASE            reduce using rule 16 (blocks -> block .)
    DEFAULT         reduce using rule 16 (blocks -> block .)
    RETURN          reduce using rule 16 (blocks -> block .)
    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    block                          shift and go to state 7
    blocks                         shift and go to state 56
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 8

    (10) import -> IMPORT . CHARSTRING
    (11) import -> IMPORT . LPAREN values_import RPAREN

    CHARSTRING      shift and go to state 58
    LPAREN          shift and go to state 59


state 9

    (49) value -> CHARSTRING .

    PLUS            reduce using rule 49 (value -> CHARSTRING .)
    MINUS           reduce using rule 49 (value -> CHARSTRING .)
    TIMES           reduce using rule 49 (value -> CHARSTRING .)
    DIVIDE          reduce using rule 49 (value -> CHARSTRING .)
    ASSIGN          reduce using rule 49 (value -> CHARSTRING .)
    INCREMENT       reduce using rule 49 (value -> CHARSTRING .)
    DECREMENT       reduce using rule 49 (value -> CHARSTRING .)
    COMMA           reduce using rule 49 (value -> CHARSTRING .)
    RBRACE          reduce using rule 49 (value -> CHARSTRING .)
    GREATER         reduce using rule 49 (value -> CHARSTRING .)
    LESS            reduce using rule 49 (value -> CHARSTRING .)
    GREATEREQUALS   reduce using rule 49 (value -> CHARSTRING .)
    LESSEQUALS      reduce using rule 49 (value -> CHARSTRING .)
    EQUALS          reduce using rule 49 (value -> CHARSTRING .)
    DIFFERENT       reduce using rule 49 (value -> CHARSTRING .)
    LBRACE          reduce using rule 49 (value -> CHARSTRING .)
    PRINT           reduce using rule 49 (value -> CHARSTRING .)
    PRINTF          reduce using rule 49 (value -> CHARSTRING .)
    INPUT           reduce using rule 49 (value -> CHARSTRING .)
    IF              reduce using rule 49 (value -> CHARSTRING .)
    VARIABLE        reduce using rule 49 (value -> CHARSTRING .)
    TYPE            reduce using rule 49 (value -> CHARSTRING .)
    FUNCTION        reduce using rule 49 (value -> CHARSTRING .)
    VAR             reduce using rule 49 (value -> CHARSTRING .)
    SWITCH          reduce using rule 49 (value -> CHARSTRING .)
    CHARSTRING      reduce using rule 49 (value -> CHARSTRING .)
    FOR             reduce using rule 49 (value -> CHARSTRING .)
    INT             reduce using rule 49 (value -> CHARSTRING .)
    FLOAT           reduce using rule 49 (value -> CHARSTRING .)
    $end            reduce using rule 49 (value -> CHARSTRING .)
    CASE            reduce using rule 49 (value -> CHARSTRING .)
    DEFAULT         reduce using rule 49 (value -> CHARSTRING .)
    RETURN          reduce using rule 49 (value -> CHARSTRING .)
    RPAREN          reduce using rule 49 (value -> CHARSTRING .)
    COLON           reduce using rule 49 (value -> CHARSTRING .)
    AND             reduce using rule 49 (value -> CHARSTRING .)
    OR              reduce using rule 49 (value -> CHARSTRING .)
    NOT             reduce using rule 49 (value -> CHARSTRING .)
    SEMICOLON       reduce using rule 49 (value -> CHARSTRING .)


state 10

    (14) package -> PACKAGE . VARIABLE

    VARIABLE        shift and go to state 60


state 11

    (121) map_estructure -> VARIABLE . SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> VARIABLE . SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> VARIABLE . LBRACKET string_value RBRACKET ASSIGN string_value
    (35) variable_declaration -> VARIABLE . SHORTASSIGN value
    (36) variable_declaration -> VARIABLE . SHORTASSIGN operation
    (127) slice_structure -> VARIABLE . SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (129) slice_structure -> VARIABLE . SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> VARIABLE . ASSIGN append_statement
    (47) value -> VARIABLE .
    (74) parameter -> VARIABLE . type
    (75) type -> . INT
    (76) type -> . INT32
    (77) type -> . INT64
    (78) type -> . STRING
    (79) type -> . FLOAT
    (80) type -> . FLOAT32
    (81) type -> . FLOAT64
    (82) type -> . BOOL

  ! shift/reduce conflict for ASSIGN resolved as shift
    SHORTASSIGN     shift and go to state 61
    LBRACKET        shift and go to state 62
    ASSIGN          shift and go to state 64
    PLUS            reduce using rule 47 (value -> VARIABLE .)
    MINUS           reduce using rule 47 (value -> VARIABLE .)
    TIMES           reduce using rule 47 (value -> VARIABLE .)
    DIVIDE          reduce using rule 47 (value -> VARIABLE .)
    INCREMENT       reduce using rule 47 (value -> VARIABLE .)
    DECREMENT       reduce using rule 47 (value -> VARIABLE .)
    INT             shift and go to state 65
    INT32           shift and go to state 66
    INT64           shift and go to state 67
    STRING          shift and go to state 68
    FLOAT           shift and go to state 69
    FLOAT32         shift and go to state 70
    FLOAT64         shift and go to state 71
    BOOL            shift and go to state 72

  ! ASSIGN          [ reduce using rule 47 (value -> VARIABLE .) ]

    type                           shift and go to state 63

state 12

    (15) main -> FUNCTION . MAIN LPAREN RPAREN
    (38) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE

    MAIN            shift and go to state 73
    VARIABLE        shift and go to state 74


state 13

    (18) block -> print_statement .

    PRINT           reduce using rule 18 (block -> print_statement .)
    PRINTF          reduce using rule 18 (block -> print_statement .)
    INPUT           reduce using rule 18 (block -> print_statement .)
    IF              reduce using rule 18 (block -> print_statement .)
    VARIABLE        reduce using rule 18 (block -> print_statement .)
    TYPE            reduce using rule 18 (block -> print_statement .)
    FUNCTION        reduce using rule 18 (block -> print_statement .)
    VAR             reduce using rule 18 (block -> print_statement .)
    SWITCH          reduce using rule 18 (block -> print_statement .)
    CHARSTRING      reduce using rule 18 (block -> print_statement .)
    LBRACE          reduce using rule 18 (block -> print_statement .)
    FOR             reduce using rule 18 (block -> print_statement .)
    INT             reduce using rule 18 (block -> print_statement .)
    FLOAT           reduce using rule 18 (block -> print_statement .)
    $end            reduce using rule 18 (block -> print_statement .)
    RBRACE          reduce using rule 18 (block -> print_statement .)
    CASE            reduce using rule 18 (block -> print_statement .)
    DEFAULT         reduce using rule 18 (block -> print_statement .)
    RETURN          reduce using rule 18 (block -> print_statement .)


state 14

    (19) block -> input_statement .

    PRINT           reduce using rule 19 (block -> input_statement .)
    PRINTF          reduce using rule 19 (block -> input_statement .)
    INPUT           reduce using rule 19 (block -> input_statement .)
    IF              reduce using rule 19 (block -> input_statement .)
    VARIABLE        reduce using rule 19 (block -> input_statement .)
    TYPE            reduce using rule 19 (block -> input_statement .)
    FUNCTION        reduce using rule 19 (block -> input_statement .)
    VAR             reduce using rule 19 (block -> input_statement .)
    SWITCH          reduce using rule 19 (block -> input_statement .)
    CHARSTRING      reduce using rule 19 (block -> input_statement .)
    LBRACE          reduce using rule 19 (block -> input_statement .)
    FOR             reduce using rule 19 (block -> input_statement .)
    INT             reduce using rule 19 (block -> input_statement .)
    FLOAT           reduce using rule 19 (block -> input_statement .)
    $end            reduce using rule 19 (block -> input_statement .)
    RBRACE          reduce using rule 19 (block -> input_statement .)
    CASE            reduce using rule 19 (block -> input_statement .)
    DEFAULT         reduce using rule 19 (block -> input_statement .)
    RETURN          reduce using rule 19 (block -> input_statement .)


state 15

    (20) block -> conditional_structure .

    PRINT           reduce using rule 20 (block -> conditional_structure .)
    PRINTF          reduce using rule 20 (block -> conditional_structure .)
    INPUT           reduce using rule 20 (block -> conditional_structure .)
    IF              reduce using rule 20 (block -> conditional_structure .)
    VARIABLE        reduce using rule 20 (block -> conditional_structure .)
    TYPE            reduce using rule 20 (block -> conditional_structure .)
    FUNCTION        reduce using rule 20 (block -> conditional_structure .)
    VAR             reduce using rule 20 (block -> conditional_structure .)
    SWITCH          reduce using rule 20 (block -> conditional_structure .)
    CHARSTRING      reduce using rule 20 (block -> conditional_structure .)
    LBRACE          reduce using rule 20 (block -> conditional_structure .)
    FOR             reduce using rule 20 (block -> conditional_structure .)
    INT             reduce using rule 20 (block -> conditional_structure .)
    FLOAT           reduce using rule 20 (block -> conditional_structure .)
    $end            reduce using rule 20 (block -> conditional_structure .)
    RBRACE          reduce using rule 20 (block -> conditional_structure .)
    CASE            reduce using rule 20 (block -> conditional_structure .)
    DEFAULT         reduce using rule 20 (block -> conditional_structure .)
    RETURN          reduce using rule 20 (block -> conditional_structure .)


state 16

    (21) block -> operation .

    PRINT           reduce using rule 21 (block -> operation .)
    PRINTF          reduce using rule 21 (block -> operation .)
    INPUT           reduce using rule 21 (block -> operation .)
    IF              reduce using rule 21 (block -> operation .)
    VARIABLE        reduce using rule 21 (block -> operation .)
    TYPE            reduce using rule 21 (block -> operation .)
    FUNCTION        reduce using rule 21 (block -> operation .)
    VAR             reduce using rule 21 (block -> operation .)
    SWITCH          reduce using rule 21 (block -> operation .)
    CHARSTRING      reduce using rule 21 (block -> operation .)
    LBRACE          reduce using rule 21 (block -> operation .)
    FOR             reduce using rule 21 (block -> operation .)
    INT             reduce using rule 21 (block -> operation .)
    FLOAT           reduce using rule 21 (block -> operation .)
    $end            reduce using rule 21 (block -> operation .)
    RBRACE          reduce using rule 21 (block -> operation .)
    CASE            reduce using rule 21 (block -> operation .)
    DEFAULT         reduce using rule 21 (block -> operation .)
    RETURN          reduce using rule 21 (block -> operation .)


state 17

    (22) block -> list_structure .

    PRINT           reduce using rule 22 (block -> list_structure .)
    PRINTF          reduce using rule 22 (block -> list_structure .)
    INPUT           reduce using rule 22 (block -> list_structure .)
    IF              reduce using rule 22 (block -> list_structure .)
    VARIABLE        reduce using rule 22 (block -> list_structure .)
    TYPE            reduce using rule 22 (block -> list_structure .)
    FUNCTION        reduce using rule 22 (block -> list_structure .)
    VAR             reduce using rule 22 (block -> list_structure .)
    SWITCH          reduce using rule 22 (block -> list_structure .)
    CHARSTRING      reduce using rule 22 (block -> list_structure .)
    LBRACE          reduce using rule 22 (block -> list_structure .)
    FOR             reduce using rule 22 (block -> list_structure .)
    INT             reduce using rule 22 (block -> list_structure .)
    FLOAT           reduce using rule 22 (block -> list_structure .)
    $end            reduce using rule 22 (block -> list_structure .)
    RBRACE          reduce using rule 22 (block -> list_structure .)
    CASE            reduce using rule 22 (block -> list_structure .)
    DEFAULT         reduce using rule 22 (block -> list_structure .)
    RETURN          reduce using rule 22 (block -> list_structure .)


state 18

    (23) block -> map_estructure .

    PRINT           reduce using rule 23 (block -> map_estructure .)
    PRINTF          reduce using rule 23 (block -> map_estructure .)
    INPUT           reduce using rule 23 (block -> map_estructure .)
    IF              reduce using rule 23 (block -> map_estructure .)
    VARIABLE        reduce using rule 23 (block -> map_estructure .)
    TYPE            reduce using rule 23 (block -> map_estructure .)
    FUNCTION        reduce using rule 23 (block -> map_estructure .)
    VAR             reduce using rule 23 (block -> map_estructure .)
    SWITCH          reduce using rule 23 (block -> map_estructure .)
    CHARSTRING      reduce using rule 23 (block -> map_estructure .)
    LBRACE          reduce using rule 23 (block -> map_estructure .)
    FOR             reduce using rule 23 (block -> map_estructure .)
    INT             reduce using rule 23 (block -> map_estructure .)
    FLOAT           reduce using rule 23 (block -> map_estructure .)
    $end            reduce using rule 23 (block -> map_estructure .)
    RBRACE          reduce using rule 23 (block -> map_estructure .)
    CASE            reduce using rule 23 (block -> map_estructure .)
    DEFAULT         reduce using rule 23 (block -> map_estructure .)
    RETURN          reduce using rule 23 (block -> map_estructure .)


state 19

    (24) block -> map_assign .

    PRINT           reduce using rule 24 (block -> map_assign .)
    PRINTF          reduce using rule 24 (block -> map_assign .)
    INPUT           reduce using rule 24 (block -> map_assign .)
    IF              reduce using rule 24 (block -> map_assign .)
    VARIABLE        reduce using rule 24 (block -> map_assign .)
    TYPE            reduce using rule 24 (block -> map_assign .)
    FUNCTION        reduce using rule 24 (block -> map_assign .)
    VAR             reduce using rule 24 (block -> map_assign .)
    SWITCH          reduce using rule 24 (block -> map_assign .)
    CHARSTRING      reduce using rule 24 (block -> map_assign .)
    LBRACE          reduce using rule 24 (block -> map_assign .)
    FOR             reduce using rule 24 (block -> map_assign .)
    INT             reduce using rule 24 (block -> map_assign .)
    FLOAT           reduce using rule 24 (block -> map_assign .)
    $end            reduce using rule 24 (block -> map_assign .)
    RBRACE          reduce using rule 24 (block -> map_assign .)
    CASE            reduce using rule 24 (block -> map_assign .)
    DEFAULT         reduce using rule 24 (block -> map_assign .)
    RETURN          reduce using rule 24 (block -> map_assign .)


state 20

    (25) block -> for_estructure .

    PRINT           reduce using rule 25 (block -> for_estructure .)
    PRINTF          reduce using rule 25 (block -> for_estructure .)
    INPUT           reduce using rule 25 (block -> for_estructure .)
    IF              reduce using rule 25 (block -> for_estructure .)
    VARIABLE        reduce using rule 25 (block -> for_estructure .)
    TYPE            reduce using rule 25 (block -> for_estructure .)
    FUNCTION        reduce using rule 25 (block -> for_estructure .)
    VAR             reduce using rule 25 (block -> for_estructure .)
    SWITCH          reduce using rule 25 (block -> for_estructure .)
    CHARSTRING      reduce using rule 25 (block -> for_estructure .)
    LBRACE          reduce using rule 25 (block -> for_estructure .)
    FOR             reduce using rule 25 (block -> for_estructure .)
    INT             reduce using rule 25 (block -> for_estructure .)
    FLOAT           reduce using rule 25 (block -> for_estructure .)
    $end            reduce using rule 25 (block -> for_estructure .)
    RBRACE          reduce using rule 25 (block -> for_estructure .)
    CASE            reduce using rule 25 (block -> for_estructure .)
    DEFAULT         reduce using rule 25 (block -> for_estructure .)
    RETURN          reduce using rule 25 (block -> for_estructure .)


state 21

    (26) block -> structure .

    PRINT           reduce using rule 26 (block -> structure .)
    PRINTF          reduce using rule 26 (block -> structure .)
    INPUT           reduce using rule 26 (block -> structure .)
    IF              reduce using rule 26 (block -> structure .)
    VARIABLE        reduce using rule 26 (block -> structure .)
    TYPE            reduce using rule 26 (block -> structure .)
    FUNCTION        reduce using rule 26 (block -> structure .)
    VAR             reduce using rule 26 (block -> structure .)
    SWITCH          reduce using rule 26 (block -> structure .)
    CHARSTRING      reduce using rule 26 (block -> structure .)
    LBRACE          reduce using rule 26 (block -> structure .)
    FOR             reduce using rule 26 (block -> structure .)
    INT             reduce using rule 26 (block -> structure .)
    FLOAT           reduce using rule 26 (block -> structure .)
    $end            reduce using rule 26 (block -> structure .)
    RBRACE          reduce using rule 26 (block -> structure .)
    CASE            reduce using rule 26 (block -> structure .)
    DEFAULT         reduce using rule 26 (block -> structure .)
    RETURN          reduce using rule 26 (block -> structure .)


state 22

    (27) block -> function .

    PRINT           reduce using rule 27 (block -> function .)
    PRINTF          reduce using rule 27 (block -> function .)
    INPUT           reduce using rule 27 (block -> function .)
    IF              reduce using rule 27 (block -> function .)
    VARIABLE        reduce using rule 27 (block -> function .)
    TYPE            reduce using rule 27 (block -> function .)
    FUNCTION        reduce using rule 27 (block -> function .)
    VAR             reduce using rule 27 (block -> function .)
    SWITCH          reduce using rule 27 (block -> function .)
    CHARSTRING      reduce using rule 27 (block -> function .)
    LBRACE          reduce using rule 27 (block -> function .)
    FOR             reduce using rule 27 (block -> function .)
    INT             reduce using rule 27 (block -> function .)
    FLOAT           reduce using rule 27 (block -> function .)
    $end            reduce using rule 27 (block -> function .)
    RBRACE          reduce using rule 27 (block -> function .)
    CASE            reduce using rule 27 (block -> function .)
    DEFAULT         reduce using rule 27 (block -> function .)
    RETURN          reduce using rule 27 (block -> function .)


state 23

    (28) block -> parameters .

    PRINT           reduce using rule 28 (block -> parameters .)
    PRINTF          reduce using rule 28 (block -> parameters .)
    INPUT           reduce using rule 28 (block -> parameters .)
    IF              reduce using rule 28 (block -> parameters .)
    VARIABLE        reduce using rule 28 (block -> parameters .)
    TYPE            reduce using rule 28 (block -> parameters .)
    FUNCTION        reduce using rule 28 (block -> parameters .)
    VAR             reduce using rule 28 (block -> parameters .)
    SWITCH          reduce using rule 28 (block -> parameters .)
    CHARSTRING      reduce using rule 28 (block -> parameters .)
    LBRACE          reduce using rule 28 (block -> parameters .)
    FOR             reduce using rule 28 (block -> parameters .)
    INT             reduce using rule 28 (block -> parameters .)
    FLOAT           reduce using rule 28 (block -> parameters .)
    $end            reduce using rule 28 (block -> parameters .)
    RBRACE          reduce using rule 28 (block -> parameters .)
    CASE            reduce using rule 28 (block -> parameters .)
    DEFAULT         reduce using rule 28 (block -> parameters .)
    RETURN          reduce using rule 28 (block -> parameters .)


state 24

    (29) block -> variable_declaration .

    PRINT           reduce using rule 29 (block -> variable_declaration .)
    PRINTF          reduce using rule 29 (block -> variable_declaration .)
    INPUT           reduce using rule 29 (block -> variable_declaration .)
    IF              reduce using rule 29 (block -> variable_declaration .)
    VARIABLE        reduce using rule 29 (block -> variable_declaration .)
    TYPE            reduce using rule 29 (block -> variable_declaration .)
    FUNCTION        reduce using rule 29 (block -> variable_declaration .)
    VAR             reduce using rule 29 (block -> variable_declaration .)
    SWITCH          reduce using rule 29 (block -> variable_declaration .)
    CHARSTRING      reduce using rule 29 (block -> variable_declaration .)
    LBRACE          reduce using rule 29 (block -> variable_declaration .)
    FOR             reduce using rule 29 (block -> variable_declaration .)
    INT             reduce using rule 29 (block -> variable_declaration .)
    FLOAT           reduce using rule 29 (block -> variable_declaration .)
    $end            reduce using rule 29 (block -> variable_declaration .)
    RBRACE          reduce using rule 29 (block -> variable_declaration .)
    CASE            reduce using rule 29 (block -> variable_declaration .)
    DEFAULT         reduce using rule 29 (block -> variable_declaration .)
    RETURN          reduce using rule 29 (block -> variable_declaration .)


state 25

    (30) block -> switch_structure .

    PRINT           reduce using rule 30 (block -> switch_structure .)
    PRINTF          reduce using rule 30 (block -> switch_structure .)
    INPUT           reduce using rule 30 (block -> switch_structure .)
    IF              reduce using rule 30 (block -> switch_structure .)
    VARIABLE        reduce using rule 30 (block -> switch_structure .)
    TYPE            reduce using rule 30 (block -> switch_structure .)
    FUNCTION        reduce using rule 30 (block -> switch_structure .)
    VAR             reduce using rule 30 (block -> switch_structure .)
    SWITCH          reduce using rule 30 (block -> switch_structure .)
    CHARSTRING      reduce using rule 30 (block -> switch_structure .)
    LBRACE          reduce using rule 30 (block -> switch_structure .)
    FOR             reduce using rule 30 (block -> switch_structure .)
    INT             reduce using rule 30 (block -> switch_structure .)
    FLOAT           reduce using rule 30 (block -> switch_structure .)
    $end            reduce using rule 30 (block -> switch_structure .)
    RBRACE          reduce using rule 30 (block -> switch_structure .)
    CASE            reduce using rule 30 (block -> switch_structure .)
    DEFAULT         reduce using rule 30 (block -> switch_structure .)
    RETURN          reduce using rule 30 (block -> switch_structure .)


state 26

    (31) block -> slice_structure .

    PRINT           reduce using rule 31 (block -> slice_structure .)
    PRINTF          reduce using rule 31 (block -> slice_structure .)
    INPUT           reduce using rule 31 (block -> slice_structure .)
    IF              reduce using rule 31 (block -> slice_structure .)
    VARIABLE        reduce using rule 31 (block -> slice_structure .)
    TYPE            reduce using rule 31 (block -> slice_structure .)
    FUNCTION        reduce using rule 31 (block -> slice_structure .)
    VAR             reduce using rule 31 (block -> slice_structure .)
    SWITCH          reduce using rule 31 (block -> slice_structure .)
    CHARSTRING      reduce using rule 31 (block -> slice_structure .)
    LBRACE          reduce using rule 31 (block -> slice_structure .)
    FOR             reduce using rule 31 (block -> slice_structure .)
    INT             reduce using rule 31 (block -> slice_structure .)
    FLOAT           reduce using rule 31 (block -> slice_structure .)
    $end            reduce using rule 31 (block -> slice_structure .)
    RBRACE          reduce using rule 31 (block -> slice_structure .)
    CASE            reduce using rule 31 (block -> slice_structure .)
    DEFAULT         reduce using rule 31 (block -> slice_structure .)
    RETURN          reduce using rule 31 (block -> slice_structure .)


state 27

    (52) print_statement -> PRINT . LPAREN values RPAREN
    (53) print_statement -> PRINT . LPAREN string_value RPAREN
    (55) print_statement -> PRINT . LPAREN string_value COMMA values RPAREN
    (56) print_statement -> PRINT . LPAREN operation RPAREN
    (57) print_statement -> PRINT . LPAREN RPAREN

    LPAREN          shift and go to state 75


state 28

    (54) print_statement -> PRINTF . LPAREN FORMATSTRING COMMA values RPAREN

    LPAREN          shift and go to state 76


state 29

    (58) input_statement -> INPUT . LPAREN values RPAREN
    (59) input_statement -> INPUT . LPAREN operation RPAREN
    (60) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 77


state 30

    (83) conditional_structure -> IF . conditions conditional_body
    (84) conditional_structure -> IF . conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> IF . conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (89) conditions -> . condition
    (90) conditions -> . condition logical_operator conditions
    (91) condition -> . value relational_operator value
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    conditions                     shift and go to state 78
    condition                      shift and go to state 79
    value                          shift and go to state 80
    number                         shift and go to state 42

state 31

    (61) operation -> value . operator value
    (62) operation -> value . operator operation
    (63) operation -> value . double_operator
    (64) operator -> . PLUS
    (65) operator -> . MINUS
    (66) operator -> . TIMES
    (67) operator -> . DIVIDE
    (68) operator -> . ASSIGN
    (69) double_operator -> . INCREMENT
    (70) double_operator -> . DECREMENT

    PLUS            shift and go to state 83
    MINUS           shift and go to state 84
    TIMES           shift and go to state 85
    DIVIDE          shift and go to state 86
    ASSIGN          shift and go to state 87
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89

    operator                       shift and go to state 81
    double_operator                shift and go to state 82

state 32

    (115) list_structure -> empty_list .

    PRINT           reduce using rule 115 (list_structure -> empty_list .)
    PRINTF          reduce using rule 115 (list_structure -> empty_list .)
    INPUT           reduce using rule 115 (list_structure -> empty_list .)
    IF              reduce using rule 115 (list_structure -> empty_list .)
    VARIABLE        reduce using rule 115 (list_structure -> empty_list .)
    TYPE            reduce using rule 115 (list_structure -> empty_list .)
    FUNCTION        reduce using rule 115 (list_structure -> empty_list .)
    VAR             reduce using rule 115 (list_structure -> empty_list .)
    SWITCH          reduce using rule 115 (list_structure -> empty_list .)
    CHARSTRING      reduce using rule 115 (list_structure -> empty_list .)
    LBRACE          reduce using rule 115 (list_structure -> empty_list .)
    FOR             reduce using rule 115 (list_structure -> empty_list .)
    INT             reduce using rule 115 (list_structure -> empty_list .)
    FLOAT           reduce using rule 115 (list_structure -> empty_list .)
    $end            reduce using rule 115 (list_structure -> empty_list .)
    RBRACE          reduce using rule 115 (list_structure -> empty_list .)
    CASE            reduce using rule 115 (list_structure -> empty_list .)
    DEFAULT         reduce using rule 115 (list_structure -> empty_list .)
    RETURN          reduce using rule 115 (list_structure -> empty_list .)


state 33

    (116) list_structure -> list_with_data .

    PRINT           reduce using rule 116 (list_structure -> list_with_data .)
    PRINTF          reduce using rule 116 (list_structure -> list_with_data .)
    INPUT           reduce using rule 116 (list_structure -> list_with_data .)
    IF              reduce using rule 116 (list_structure -> list_with_data .)
    VARIABLE        reduce using rule 116 (list_structure -> list_with_data .)
    TYPE            reduce using rule 116 (list_structure -> list_with_data .)
    FUNCTION        reduce using rule 116 (list_structure -> list_with_data .)
    VAR             reduce using rule 116 (list_structure -> list_with_data .)
    SWITCH          reduce using rule 116 (list_structure -> list_with_data .)
    CHARSTRING      reduce using rule 116 (list_structure -> list_with_data .)
    LBRACE          reduce using rule 116 (list_structure -> list_with_data .)
    FOR             reduce using rule 116 (list_structure -> list_with_data .)
    INT             reduce using rule 116 (list_structure -> list_with_data .)
    FLOAT           reduce using rule 116 (list_structure -> list_with_data .)
    $end            reduce using rule 116 (list_structure -> list_with_data .)
    RBRACE          reduce using rule 116 (list_structure -> list_with_data .)
    CASE            reduce using rule 116 (list_structure -> list_with_data .)
    DEFAULT         reduce using rule 116 (list_structure -> list_with_data .)
    RETURN          reduce using rule 116 (list_structure -> list_with_data .)


state 34

    (117) list_structure -> defined_list .

    PRINT           reduce using rule 117 (list_structure -> defined_list .)
    PRINTF          reduce using rule 117 (list_structure -> defined_list .)
    INPUT           reduce using rule 117 (list_structure -> defined_list .)
    IF              reduce using rule 117 (list_structure -> defined_list .)
    VARIABLE        reduce using rule 117 (list_structure -> defined_list .)
    TYPE            reduce using rule 117 (list_structure -> defined_list .)
    FUNCTION        reduce using rule 117 (list_structure -> defined_list .)
    VAR             reduce using rule 117 (list_structure -> defined_list .)
    SWITCH          reduce using rule 117 (list_structure -> defined_list .)
    CHARSTRING      reduce using rule 117 (list_structure -> defined_list .)
    LBRACE          reduce using rule 117 (list_structure -> defined_list .)
    FOR             reduce using rule 117 (list_structure -> defined_list .)
    INT             reduce using rule 117 (list_structure -> defined_list .)
    FLOAT           reduce using rule 117 (list_structure -> defined_list .)
    $end            reduce using rule 117 (list_structure -> defined_list .)
    RBRACE          reduce using rule 117 (list_structure -> defined_list .)
    CASE            reduce using rule 117 (list_structure -> defined_list .)
    DEFAULT         reduce using rule 117 (list_structure -> defined_list .)
    RETURN          reduce using rule 117 (list_structure -> defined_list .)


state 35

    (101) for_estructure -> for_initialization .

    PRINT           reduce using rule 101 (for_estructure -> for_initialization .)
    PRINTF          reduce using rule 101 (for_estructure -> for_initialization .)
    INPUT           reduce using rule 101 (for_estructure -> for_initialization .)
    IF              reduce using rule 101 (for_estructure -> for_initialization .)
    VARIABLE        reduce using rule 101 (for_estructure -> for_initialization .)
    TYPE            reduce using rule 101 (for_estructure -> for_initialization .)
    FUNCTION        reduce using rule 101 (for_estructure -> for_initialization .)
    VAR             reduce using rule 101 (for_estructure -> for_initialization .)
    SWITCH          reduce using rule 101 (for_estructure -> for_initialization .)
    CHARSTRING      reduce using rule 101 (for_estructure -> for_initialization .)
    LBRACE          reduce using rule 101 (for_estructure -> for_initialization .)
    FOR             reduce using rule 101 (for_estructure -> for_initialization .)
    INT             reduce using rule 101 (for_estructure -> for_initialization .)
    FLOAT           reduce using rule 101 (for_estructure -> for_initialization .)
    $end            reduce using rule 101 (for_estructure -> for_initialization .)
    RBRACE          reduce using rule 101 (for_estructure -> for_initialization .)
    CASE            reduce using rule 101 (for_estructure -> for_initialization .)
    DEFAULT         reduce using rule 101 (for_estructure -> for_initialization .)
    RETURN          reduce using rule 101 (for_estructure -> for_initialization .)


state 36

    (102) for_estructure -> for_infinite_bucle .

    PRINT           reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    PRINTF          reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    INPUT           reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    IF              reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    VARIABLE        reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    TYPE            reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    FUNCTION        reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    VAR             reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    SWITCH          reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    CHARSTRING      reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    LBRACE          reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    FOR             reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    INT             reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    FLOAT           reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    $end            reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    RBRACE          reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    CASE            reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    DEFAULT         reduce using rule 102 (for_estructure -> for_infinite_bucle .)
    RETURN          reduce using rule 102 (for_estructure -> for_infinite_bucle .)


state 37

    (103) for_estructure -> for_iterator .

    PRINT           reduce using rule 103 (for_estructure -> for_iterator .)
    PRINTF          reduce using rule 103 (for_estructure -> for_iterator .)
    INPUT           reduce using rule 103 (for_estructure -> for_iterator .)
    IF              reduce using rule 103 (for_estructure -> for_iterator .)
    VARIABLE        reduce using rule 103 (for_estructure -> for_iterator .)
    TYPE            reduce using rule 103 (for_estructure -> for_iterator .)
    FUNCTION        reduce using rule 103 (for_estructure -> for_iterator .)
    VAR             reduce using rule 103 (for_estructure -> for_iterator .)
    SWITCH          reduce using rule 103 (for_estructure -> for_iterator .)
    CHARSTRING      reduce using rule 103 (for_estructure -> for_iterator .)
    LBRACE          reduce using rule 103 (for_estructure -> for_iterator .)
    FOR             reduce using rule 103 (for_estructure -> for_iterator .)
    INT             reduce using rule 103 (for_estructure -> for_iterator .)
    FLOAT           reduce using rule 103 (for_estructure -> for_iterator .)
    $end            reduce using rule 103 (for_estructure -> for_iterator .)
    RBRACE          reduce using rule 103 (for_estructure -> for_iterator .)
    CASE            reduce using rule 103 (for_estructure -> for_iterator .)
    DEFAULT         reduce using rule 103 (for_estructure -> for_iterator .)
    RETURN          reduce using rule 103 (for_estructure -> for_iterator .)


state 38

    (37) structure -> TYPE . VARIABLE STRUCT LBRACE statement RBRACE
    (120) defined_list -> TYPE . VARIABLE LBRACE values RBRACE

    VARIABLE        shift and go to state 90


state 39

    (71) parameters -> parameter .
    (72) parameters -> parameter . parameters
    (73) parameters -> parameter . COMMA parameters
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (74) parameter -> . VARIABLE type

  ! shift/reduce conflict for VARIABLE resolved as shift
    PRINT           reduce using rule 71 (parameters -> parameter .)
    PRINTF          reduce using rule 71 (parameters -> parameter .)
    INPUT           reduce using rule 71 (parameters -> parameter .)
    IF              reduce using rule 71 (parameters -> parameter .)
    TYPE            reduce using rule 71 (parameters -> parameter .)
    FUNCTION        reduce using rule 71 (parameters -> parameter .)
    VAR             reduce using rule 71 (parameters -> parameter .)
    SWITCH          reduce using rule 71 (parameters -> parameter .)
    CHARSTRING      reduce using rule 71 (parameters -> parameter .)
    LBRACE          reduce using rule 71 (parameters -> parameter .)
    FOR             reduce using rule 71 (parameters -> parameter .)
    INT             reduce using rule 71 (parameters -> parameter .)
    FLOAT           reduce using rule 71 (parameters -> parameter .)
    $end            reduce using rule 71 (parameters -> parameter .)
    RBRACE          reduce using rule 71 (parameters -> parameter .)
    CASE            reduce using rule 71 (parameters -> parameter .)
    DEFAULT         reduce using rule 71 (parameters -> parameter .)
    RETURN          reduce using rule 71 (parameters -> parameter .)
    RPAREN          reduce using rule 71 (parameters -> parameter .)
    COMMA           shift and go to state 92
    VARIABLE        shift and go to state 93

  ! VARIABLE        [ reduce using rule 71 (parameters -> parameter .) ]

    parameter                      shift and go to state 39
    parameters                     shift and go to state 91

state 40

    (32) variable_declaration -> VAR . VARIABLE type
    (33) variable_declaration -> VAR . VARIABLE ASSIGN value
    (34) variable_declaration -> VAR . VARIABLE ASSIGN list_structure
    (128) slice_structure -> VAR . VARIABLE LBRACKET RBRACKET type

    VARIABLE        shift and go to state 94


state 41

    (107) switch_structure -> SWITCH . switch_expression LBRACE case_blocks RBRACE
    (108) switch_expression -> . value
    (109) switch_expression -> . empty
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (114) empty -> .
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    LBRACE          reduce using rule 114 (empty -> .)
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    switch_expression              shift and go to state 95
    value                          shift and go to state 96
    empty                          shift and go to state 97
    number                         shift and go to state 42

state 42

    (48) value -> number .

    PLUS            reduce using rule 48 (value -> number .)
    MINUS           reduce using rule 48 (value -> number .)
    TIMES           reduce using rule 48 (value -> number .)
    DIVIDE          reduce using rule 48 (value -> number .)
    ASSIGN          reduce using rule 48 (value -> number .)
    INCREMENT       reduce using rule 48 (value -> number .)
    DECREMENT       reduce using rule 48 (value -> number .)
    COMMA           reduce using rule 48 (value -> number .)
    RBRACE          reduce using rule 48 (value -> number .)
    GREATER         reduce using rule 48 (value -> number .)
    LESS            reduce using rule 48 (value -> number .)
    GREATEREQUALS   reduce using rule 48 (value -> number .)
    LESSEQUALS      reduce using rule 48 (value -> number .)
    EQUALS          reduce using rule 48 (value -> number .)
    DIFFERENT       reduce using rule 48 (value -> number .)
    LBRACE          reduce using rule 48 (value -> number .)
    PRINT           reduce using rule 48 (value -> number .)
    PRINTF          reduce using rule 48 (value -> number .)
    INPUT           reduce using rule 48 (value -> number .)
    IF              reduce using rule 48 (value -> number .)
    VARIABLE        reduce using rule 48 (value -> number .)
    TYPE            reduce using rule 48 (value -> number .)
    FUNCTION        reduce using rule 48 (value -> number .)
    VAR             reduce using rule 48 (value -> number .)
    SWITCH          reduce using rule 48 (value -> number .)
    CHARSTRING      reduce using rule 48 (value -> number .)
    FOR             reduce using rule 48 (value -> number .)
    INT             reduce using rule 48 (value -> number .)
    FLOAT           reduce using rule 48 (value -> number .)
    $end            reduce using rule 48 (value -> number .)
    CASE            reduce using rule 48 (value -> number .)
    DEFAULT         reduce using rule 48 (value -> number .)
    RETURN          reduce using rule 48 (value -> number .)
    RBRACKET        reduce using rule 48 (value -> number .)
    RPAREN          reduce using rule 48 (value -> number .)
    COLON           reduce using rule 48 (value -> number .)
    AND             reduce using rule 48 (value -> number .)
    OR              reduce using rule 48 (value -> number .)
    NOT             reduce using rule 48 (value -> number .)
    SEMICOLON       reduce using rule 48 (value -> number .)


state 43

    (104) for_initialization -> FOR . VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> FOR . LBRACE statement RBRACE
    (106) for_iterator -> FOR . VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 98
    LBRACE          shift and go to state 99


state 44

    (50) number -> INT .

    PLUS            reduce using rule 50 (number -> INT .)
    MINUS           reduce using rule 50 (number -> INT .)
    TIMES           reduce using rule 50 (number -> INT .)
    DIVIDE          reduce using rule 50 (number -> INT .)
    ASSIGN          reduce using rule 50 (number -> INT .)
    INCREMENT       reduce using rule 50 (number -> INT .)
    DECREMENT       reduce using rule 50 (number -> INT .)
    COMMA           reduce using rule 50 (number -> INT .)
    RBRACE          reduce using rule 50 (number -> INT .)
    GREATER         reduce using rule 50 (number -> INT .)
    LESS            reduce using rule 50 (number -> INT .)
    GREATEREQUALS   reduce using rule 50 (number -> INT .)
    LESSEQUALS      reduce using rule 50 (number -> INT .)
    EQUALS          reduce using rule 50 (number -> INT .)
    DIFFERENT       reduce using rule 50 (number -> INT .)
    LBRACE          reduce using rule 50 (number -> INT .)
    PRINT           reduce using rule 50 (number -> INT .)
    PRINTF          reduce using rule 50 (number -> INT .)
    INPUT           reduce using rule 50 (number -> INT .)
    IF              reduce using rule 50 (number -> INT .)
    VARIABLE        reduce using rule 50 (number -> INT .)
    TYPE            reduce using rule 50 (number -> INT .)
    FUNCTION        reduce using rule 50 (number -> INT .)
    VAR             reduce using rule 50 (number -> INT .)
    SWITCH          reduce using rule 50 (number -> INT .)
    CHARSTRING      reduce using rule 50 (number -> INT .)
    FOR             reduce using rule 50 (number -> INT .)
    INT             reduce using rule 50 (number -> INT .)
    FLOAT           reduce using rule 50 (number -> INT .)
    $end            reduce using rule 50 (number -> INT .)
    CASE            reduce using rule 50 (number -> INT .)
    DEFAULT         reduce using rule 50 (number -> INT .)
    RETURN          reduce using rule 50 (number -> INT .)
    RBRACKET        reduce using rule 50 (number -> INT .)
    RPAREN          reduce using rule 50 (number -> INT .)
    COLON           reduce using rule 50 (number -> INT .)
    AND             reduce using rule 50 (number -> INT .)
    OR              reduce using rule 50 (number -> INT .)
    NOT             reduce using rule 50 (number -> INT .)
    SEMICOLON       reduce using rule 50 (number -> INT .)


state 45

    (51) number -> FLOAT .

    PLUS            reduce using rule 51 (number -> FLOAT .)
    MINUS           reduce using rule 51 (number -> FLOAT .)
    TIMES           reduce using rule 51 (number -> FLOAT .)
    DIVIDE          reduce using rule 51 (number -> FLOAT .)
    ASSIGN          reduce using rule 51 (number -> FLOAT .)
    INCREMENT       reduce using rule 51 (number -> FLOAT .)
    DECREMENT       reduce using rule 51 (number -> FLOAT .)
    COMMA           reduce using rule 51 (number -> FLOAT .)
    RBRACE          reduce using rule 51 (number -> FLOAT .)
    GREATER         reduce using rule 51 (number -> FLOAT .)
    LESS            reduce using rule 51 (number -> FLOAT .)
    GREATEREQUALS   reduce using rule 51 (number -> FLOAT .)
    LESSEQUALS      reduce using rule 51 (number -> FLOAT .)
    EQUALS          reduce using rule 51 (number -> FLOAT .)
    DIFFERENT       reduce using rule 51 (number -> FLOAT .)
    LBRACE          reduce using rule 51 (number -> FLOAT .)
    PRINT           reduce using rule 51 (number -> FLOAT .)
    PRINTF          reduce using rule 51 (number -> FLOAT .)
    INPUT           reduce using rule 51 (number -> FLOAT .)
    IF              reduce using rule 51 (number -> FLOAT .)
    VARIABLE        reduce using rule 51 (number -> FLOAT .)
    TYPE            reduce using rule 51 (number -> FLOAT .)
    FUNCTION        reduce using rule 51 (number -> FLOAT .)
    VAR             reduce using rule 51 (number -> FLOAT .)
    SWITCH          reduce using rule 51 (number -> FLOAT .)
    CHARSTRING      reduce using rule 51 (number -> FLOAT .)
    FOR             reduce using rule 51 (number -> FLOAT .)
    INT             reduce using rule 51 (number -> FLOAT .)
    FLOAT           reduce using rule 51 (number -> FLOAT .)
    $end            reduce using rule 51 (number -> FLOAT .)
    CASE            reduce using rule 51 (number -> FLOAT .)
    DEFAULT         reduce using rule 51 (number -> FLOAT .)
    RETURN          reduce using rule 51 (number -> FLOAT .)
    RBRACKET        reduce using rule 51 (number -> FLOAT .)
    RPAREN          reduce using rule 51 (number -> FLOAT .)
    COLON           reduce using rule 51 (number -> FLOAT .)
    AND             reduce using rule 51 (number -> FLOAT .)
    OR              reduce using rule 51 (number -> FLOAT .)
    NOT             reduce using rule 51 (number -> FLOAT .)
    SEMICOLON       reduce using rule 51 (number -> FLOAT .)


state 46

    (2) statement -> import blocks .

    $end            reduce using rule 2 (statement -> import blocks .)
    RBRACE          reduce using rule 2 (statement -> import blocks .)
    CASE            reduce using rule 2 (statement -> import blocks .)
    DEFAULT         reduce using rule 2 (statement -> import blocks .)


state 47

    (7) statement -> import main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 100


state 48

    (3) statement -> package blocks .

    $end            reduce using rule 3 (statement -> package blocks .)
    RBRACE          reduce using rule 3 (statement -> package blocks .)
    CASE            reduce using rule 3 (statement -> package blocks .)
    DEFAULT         reduce using rule 3 (statement -> package blocks .)


state 49

    (4) statement -> package import . blocks
    (8) statement -> package import . main LBRACE blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (15) main -> . FUNCTION MAIN LPAREN RPAREN
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    blocks                         shift and go to state 101
    main                           shift and go to state 102
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 50

    (6) statement -> package main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 103


state 51

    (5) statement -> main LBRACE . blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    blocks                         shift and go to state 104
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 52

    (118) empty_list -> LBRACE RBRACE .

    PRINT           reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    PRINTF          reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    INPUT           reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    IF              reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    VARIABLE        reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    TYPE            reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    FUNCTION        reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    VAR             reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    SWITCH          reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    CHARSTRING      reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    LBRACE          reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    FOR             reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    INT             reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    FLOAT           reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    $end            reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    RBRACE          reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    CASE            reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    DEFAULT         reduce using rule 118 (empty_list -> LBRACE RBRACE .)
    RETURN          reduce using rule 118 (empty_list -> LBRACE RBRACE .)


state 53

    (119) list_with_data -> LBRACE values . RBRACE

    RBRACE          shift and go to state 105


state 54

    (43) values -> value .
    (44) values -> value . COMMA values

    RBRACE          reduce using rule 43 (values -> value .)
    RPAREN          reduce using rule 43 (values -> value .)
    COLON           reduce using rule 43 (values -> value .)
    COMMA           shift and go to state 106


state 55

    (47) value -> VARIABLE .

    COMMA           reduce using rule 47 (value -> VARIABLE .)
    RBRACE          reduce using rule 47 (value -> VARIABLE .)
    GREATER         reduce using rule 47 (value -> VARIABLE .)
    LESS            reduce using rule 47 (value -> VARIABLE .)
    GREATEREQUALS   reduce using rule 47 (value -> VARIABLE .)
    LESSEQUALS      reduce using rule 47 (value -> VARIABLE .)
    EQUALS          reduce using rule 47 (value -> VARIABLE .)
    DIFFERENT       reduce using rule 47 (value -> VARIABLE .)
    LBRACE          reduce using rule 47 (value -> VARIABLE .)
    PLUS            reduce using rule 47 (value -> VARIABLE .)
    MINUS           reduce using rule 47 (value -> VARIABLE .)
    TIMES           reduce using rule 47 (value -> VARIABLE .)
    DIVIDE          reduce using rule 47 (value -> VARIABLE .)
    ASSIGN          reduce using rule 47 (value -> VARIABLE .)
    INCREMENT       reduce using rule 47 (value -> VARIABLE .)
    DECREMENT       reduce using rule 47 (value -> VARIABLE .)
    PRINT           reduce using rule 47 (value -> VARIABLE .)
    PRINTF          reduce using rule 47 (value -> VARIABLE .)
    INPUT           reduce using rule 47 (value -> VARIABLE .)
    IF              reduce using rule 47 (value -> VARIABLE .)
    VARIABLE        reduce using rule 47 (value -> VARIABLE .)
    TYPE            reduce using rule 47 (value -> VARIABLE .)
    FUNCTION        reduce using rule 47 (value -> VARIABLE .)
    VAR             reduce using rule 47 (value -> VARIABLE .)
    SWITCH          reduce using rule 47 (value -> VARIABLE .)
    CHARSTRING      reduce using rule 47 (value -> VARIABLE .)
    FOR             reduce using rule 47 (value -> VARIABLE .)
    INT             reduce using rule 47 (value -> VARIABLE .)
    FLOAT           reduce using rule 47 (value -> VARIABLE .)
    $end            reduce using rule 47 (value -> VARIABLE .)
    CASE            reduce using rule 47 (value -> VARIABLE .)
    DEFAULT         reduce using rule 47 (value -> VARIABLE .)
    RETURN          reduce using rule 47 (value -> VARIABLE .)
    RBRACKET        reduce using rule 47 (value -> VARIABLE .)
    RPAREN          reduce using rule 47 (value -> VARIABLE .)
    COLON           reduce using rule 47 (value -> VARIABLE .)
    AND             reduce using rule 47 (value -> VARIABLE .)
    OR              reduce using rule 47 (value -> VARIABLE .)
    NOT             reduce using rule 47 (value -> VARIABLE .)
    SEMICOLON       reduce using rule 47 (value -> VARIABLE .)


state 56

    (17) blocks -> block blocks .

    $end            reduce using rule 17 (blocks -> block blocks .)
    RBRACE          reduce using rule 17 (blocks -> block blocks .)
    CASE            reduce using rule 17 (blocks -> block blocks .)
    DEFAULT         reduce using rule 17 (blocks -> block blocks .)
    RETURN          reduce using rule 17 (blocks -> block blocks .)


state 57

    (38) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE

    VARIABLE        shift and go to state 74


state 58

    (10) import -> IMPORT CHARSTRING .

    FUNCTION        reduce using rule 10 (import -> IMPORT CHARSTRING .)
    PRINT           reduce using rule 10 (import -> IMPORT CHARSTRING .)
    PRINTF          reduce using rule 10 (import -> IMPORT CHARSTRING .)
    INPUT           reduce using rule 10 (import -> IMPORT CHARSTRING .)
    IF              reduce using rule 10 (import -> IMPORT CHARSTRING .)
    VARIABLE        reduce using rule 10 (import -> IMPORT CHARSTRING .)
    TYPE            reduce using rule 10 (import -> IMPORT CHARSTRING .)
    VAR             reduce using rule 10 (import -> IMPORT CHARSTRING .)
    SWITCH          reduce using rule 10 (import -> IMPORT CHARSTRING .)
    CHARSTRING      reduce using rule 10 (import -> IMPORT CHARSTRING .)
    LBRACE          reduce using rule 10 (import -> IMPORT CHARSTRING .)
    FOR             reduce using rule 10 (import -> IMPORT CHARSTRING .)
    INT             reduce using rule 10 (import -> IMPORT CHARSTRING .)
    FLOAT           reduce using rule 10 (import -> IMPORT CHARSTRING .)


state 59

    (11) import -> IMPORT LPAREN . values_import RPAREN
    (12) values_import -> . CHARSTRING
    (13) values_import -> . CHARSTRING values_import

    CHARSTRING      shift and go to state 108

    values_import                  shift and go to state 107

state 60

    (14) package -> PACKAGE VARIABLE .

    IMPORT          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    FUNCTION        reduce using rule 14 (package -> PACKAGE VARIABLE .)
    PRINT           reduce using rule 14 (package -> PACKAGE VARIABLE .)
    PRINTF          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    INPUT           reduce using rule 14 (package -> PACKAGE VARIABLE .)
    IF              reduce using rule 14 (package -> PACKAGE VARIABLE .)
    VARIABLE        reduce using rule 14 (package -> PACKAGE VARIABLE .)
    TYPE            reduce using rule 14 (package -> PACKAGE VARIABLE .)
    VAR             reduce using rule 14 (package -> PACKAGE VARIABLE .)
    SWITCH          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    CHARSTRING      reduce using rule 14 (package -> PACKAGE VARIABLE .)
    LBRACE          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    FOR             reduce using rule 14 (package -> PACKAGE VARIABLE .)
    INT             reduce using rule 14 (package -> PACKAGE VARIABLE .)
    FLOAT           reduce using rule 14 (package -> PACKAGE VARIABLE .)


state 61

    (121) map_estructure -> VARIABLE SHORTASSIGN . MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> VARIABLE SHORTASSIGN . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (35) variable_declaration -> VARIABLE SHORTASSIGN . value
    (36) variable_declaration -> VARIABLE SHORTASSIGN . operation
    (127) slice_structure -> VARIABLE SHORTASSIGN . LBRACKET RBRACKET type LBRACE values RBRACE
    (129) slice_structure -> VARIABLE SHORTASSIGN . LBRACKET RBRACKET type
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (50) number -> . INT
    (51) number -> . FLOAT

    MAP             shift and go to state 109
    MAKE            shift and go to state 111
    LBRACKET        shift and go to state 110
    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    value                          shift and go to state 112
    operation                      shift and go to state 113
    number                         shift and go to state 42

state 62

    (126) map_assign -> VARIABLE LBRACKET . string_value RBRACKET ASSIGN string_value
    (45) string_value -> . value
    (46) string_value -> . CHARSTRING
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    CHARSTRING      shift and go to state 116
    VARIABLE        shift and go to state 55
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    string_value                   shift and go to state 114
    value                          shift and go to state 115
    number                         shift and go to state 42

state 63

    (74) parameter -> VARIABLE type .

    COMMA           reduce using rule 74 (parameter -> VARIABLE type .)
    VARIABLE        reduce using rule 74 (parameter -> VARIABLE type .)
    PRINT           reduce using rule 74 (parameter -> VARIABLE type .)
    PRINTF          reduce using rule 74 (parameter -> VARIABLE type .)
    INPUT           reduce using rule 74 (parameter -> VARIABLE type .)
    IF              reduce using rule 74 (parameter -> VARIABLE type .)
    TYPE            reduce using rule 74 (parameter -> VARIABLE type .)
    FUNCTION        reduce using rule 74 (parameter -> VARIABLE type .)
    VAR             reduce using rule 74 (parameter -> VARIABLE type .)
    SWITCH          reduce using rule 74 (parameter -> VARIABLE type .)
    CHARSTRING      reduce using rule 74 (parameter -> VARIABLE type .)
    LBRACE          reduce using rule 74 (parameter -> VARIABLE type .)
    FOR             reduce using rule 74 (parameter -> VARIABLE type .)
    INT             reduce using rule 74 (parameter -> VARIABLE type .)
    FLOAT           reduce using rule 74 (parameter -> VARIABLE type .)
    $end            reduce using rule 74 (parameter -> VARIABLE type .)
    RBRACE          reduce using rule 74 (parameter -> VARIABLE type .)
    CASE            reduce using rule 74 (parameter -> VARIABLE type .)
    DEFAULT         reduce using rule 74 (parameter -> VARIABLE type .)
    RETURN          reduce using rule 74 (parameter -> VARIABLE type .)
    RPAREN          reduce using rule 74 (parameter -> VARIABLE type .)


state 64

    (130) slice_structure -> VARIABLE ASSIGN . append_statement
    (131) append_statement -> . APPEND LPAREN VARIABLE COMMA values RPAREN

    APPEND          shift and go to state 118

    append_statement               shift and go to state 117

state 65

    (75) type -> INT .

    COMMA           reduce using rule 75 (type -> INT .)
    VARIABLE        reduce using rule 75 (type -> INT .)
    PRINT           reduce using rule 75 (type -> INT .)
    PRINTF          reduce using rule 75 (type -> INT .)
    INPUT           reduce using rule 75 (type -> INT .)
    IF              reduce using rule 75 (type -> INT .)
    TYPE            reduce using rule 75 (type -> INT .)
    FUNCTION        reduce using rule 75 (type -> INT .)
    VAR             reduce using rule 75 (type -> INT .)
    SWITCH          reduce using rule 75 (type -> INT .)
    CHARSTRING      reduce using rule 75 (type -> INT .)
    LBRACE          reduce using rule 75 (type -> INT .)
    FOR             reduce using rule 75 (type -> INT .)
    INT             reduce using rule 75 (type -> INT .)
    FLOAT           reduce using rule 75 (type -> INT .)
    $end            reduce using rule 75 (type -> INT .)
    RBRACE          reduce using rule 75 (type -> INT .)
    CASE            reduce using rule 75 (type -> INT .)
    DEFAULT         reduce using rule 75 (type -> INT .)
    RETURN          reduce using rule 75 (type -> INT .)
    RPAREN          reduce using rule 75 (type -> INT .)
    RBRACKET        reduce using rule 75 (type -> INT .)


state 66

    (76) type -> INT32 .

    COMMA           reduce using rule 76 (type -> INT32 .)
    VARIABLE        reduce using rule 76 (type -> INT32 .)
    PRINT           reduce using rule 76 (type -> INT32 .)
    PRINTF          reduce using rule 76 (type -> INT32 .)
    INPUT           reduce using rule 76 (type -> INT32 .)
    IF              reduce using rule 76 (type -> INT32 .)
    TYPE            reduce using rule 76 (type -> INT32 .)
    FUNCTION        reduce using rule 76 (type -> INT32 .)
    VAR             reduce using rule 76 (type -> INT32 .)
    SWITCH          reduce using rule 76 (type -> INT32 .)
    CHARSTRING      reduce using rule 76 (type -> INT32 .)
    LBRACE          reduce using rule 76 (type -> INT32 .)
    FOR             reduce using rule 76 (type -> INT32 .)
    INT             reduce using rule 76 (type -> INT32 .)
    FLOAT           reduce using rule 76 (type -> INT32 .)
    $end            reduce using rule 76 (type -> INT32 .)
    RBRACE          reduce using rule 76 (type -> INT32 .)
    CASE            reduce using rule 76 (type -> INT32 .)
    DEFAULT         reduce using rule 76 (type -> INT32 .)
    RETURN          reduce using rule 76 (type -> INT32 .)
    RPAREN          reduce using rule 76 (type -> INT32 .)
    RBRACKET        reduce using rule 76 (type -> INT32 .)


state 67

    (77) type -> INT64 .

    COMMA           reduce using rule 77 (type -> INT64 .)
    VARIABLE        reduce using rule 77 (type -> INT64 .)
    PRINT           reduce using rule 77 (type -> INT64 .)
    PRINTF          reduce using rule 77 (type -> INT64 .)
    INPUT           reduce using rule 77 (type -> INT64 .)
    IF              reduce using rule 77 (type -> INT64 .)
    TYPE            reduce using rule 77 (type -> INT64 .)
    FUNCTION        reduce using rule 77 (type -> INT64 .)
    VAR             reduce using rule 77 (type -> INT64 .)
    SWITCH          reduce using rule 77 (type -> INT64 .)
    CHARSTRING      reduce using rule 77 (type -> INT64 .)
    LBRACE          reduce using rule 77 (type -> INT64 .)
    FOR             reduce using rule 77 (type -> INT64 .)
    INT             reduce using rule 77 (type -> INT64 .)
    FLOAT           reduce using rule 77 (type -> INT64 .)
    $end            reduce using rule 77 (type -> INT64 .)
    RBRACE          reduce using rule 77 (type -> INT64 .)
    CASE            reduce using rule 77 (type -> INT64 .)
    DEFAULT         reduce using rule 77 (type -> INT64 .)
    RETURN          reduce using rule 77 (type -> INT64 .)
    RPAREN          reduce using rule 77 (type -> INT64 .)
    RBRACKET        reduce using rule 77 (type -> INT64 .)


state 68

    (78) type -> STRING .

    COMMA           reduce using rule 78 (type -> STRING .)
    VARIABLE        reduce using rule 78 (type -> STRING .)
    PRINT           reduce using rule 78 (type -> STRING .)
    PRINTF          reduce using rule 78 (type -> STRING .)
    INPUT           reduce using rule 78 (type -> STRING .)
    IF              reduce using rule 78 (type -> STRING .)
    TYPE            reduce using rule 78 (type -> STRING .)
    FUNCTION        reduce using rule 78 (type -> STRING .)
    VAR             reduce using rule 78 (type -> STRING .)
    SWITCH          reduce using rule 78 (type -> STRING .)
    CHARSTRING      reduce using rule 78 (type -> STRING .)
    LBRACE          reduce using rule 78 (type -> STRING .)
    FOR             reduce using rule 78 (type -> STRING .)
    INT             reduce using rule 78 (type -> STRING .)
    FLOAT           reduce using rule 78 (type -> STRING .)
    $end            reduce using rule 78 (type -> STRING .)
    RBRACE          reduce using rule 78 (type -> STRING .)
    CASE            reduce using rule 78 (type -> STRING .)
    DEFAULT         reduce using rule 78 (type -> STRING .)
    RETURN          reduce using rule 78 (type -> STRING .)
    RPAREN          reduce using rule 78 (type -> STRING .)
    RBRACKET        reduce using rule 78 (type -> STRING .)


state 69

    (79) type -> FLOAT .

    COMMA           reduce using rule 79 (type -> FLOAT .)
    VARIABLE        reduce using rule 79 (type -> FLOAT .)
    PRINT           reduce using rule 79 (type -> FLOAT .)
    PRINTF          reduce using rule 79 (type -> FLOAT .)
    INPUT           reduce using rule 79 (type -> FLOAT .)
    IF              reduce using rule 79 (type -> FLOAT .)
    TYPE            reduce using rule 79 (type -> FLOAT .)
    FUNCTION        reduce using rule 79 (type -> FLOAT .)
    VAR             reduce using rule 79 (type -> FLOAT .)
    SWITCH          reduce using rule 79 (type -> FLOAT .)
    CHARSTRING      reduce using rule 79 (type -> FLOAT .)
    LBRACE          reduce using rule 79 (type -> FLOAT .)
    FOR             reduce using rule 79 (type -> FLOAT .)
    INT             reduce using rule 79 (type -> FLOAT .)
    FLOAT           reduce using rule 79 (type -> FLOAT .)
    $end            reduce using rule 79 (type -> FLOAT .)
    RBRACE          reduce using rule 79 (type -> FLOAT .)
    CASE            reduce using rule 79 (type -> FLOAT .)
    DEFAULT         reduce using rule 79 (type -> FLOAT .)
    RETURN          reduce using rule 79 (type -> FLOAT .)
    RPAREN          reduce using rule 79 (type -> FLOAT .)
    RBRACKET        reduce using rule 79 (type -> FLOAT .)


state 70

    (80) type -> FLOAT32 .

    COMMA           reduce using rule 80 (type -> FLOAT32 .)
    VARIABLE        reduce using rule 80 (type -> FLOAT32 .)
    PRINT           reduce using rule 80 (type -> FLOAT32 .)
    PRINTF          reduce using rule 80 (type -> FLOAT32 .)
    INPUT           reduce using rule 80 (type -> FLOAT32 .)
    IF              reduce using rule 80 (type -> FLOAT32 .)
    TYPE            reduce using rule 80 (type -> FLOAT32 .)
    FUNCTION        reduce using rule 80 (type -> FLOAT32 .)
    VAR             reduce using rule 80 (type -> FLOAT32 .)
    SWITCH          reduce using rule 80 (type -> FLOAT32 .)
    CHARSTRING      reduce using rule 80 (type -> FLOAT32 .)
    LBRACE          reduce using rule 80 (type -> FLOAT32 .)
    FOR             reduce using rule 80 (type -> FLOAT32 .)
    INT             reduce using rule 80 (type -> FLOAT32 .)
    FLOAT           reduce using rule 80 (type -> FLOAT32 .)
    $end            reduce using rule 80 (type -> FLOAT32 .)
    RBRACE          reduce using rule 80 (type -> FLOAT32 .)
    CASE            reduce using rule 80 (type -> FLOAT32 .)
    DEFAULT         reduce using rule 80 (type -> FLOAT32 .)
    RETURN          reduce using rule 80 (type -> FLOAT32 .)
    RPAREN          reduce using rule 80 (type -> FLOAT32 .)
    RBRACKET        reduce using rule 80 (type -> FLOAT32 .)


state 71

    (81) type -> FLOAT64 .

    COMMA           reduce using rule 81 (type -> FLOAT64 .)
    VARIABLE        reduce using rule 81 (type -> FLOAT64 .)
    PRINT           reduce using rule 81 (type -> FLOAT64 .)
    PRINTF          reduce using rule 81 (type -> FLOAT64 .)
    INPUT           reduce using rule 81 (type -> FLOAT64 .)
    IF              reduce using rule 81 (type -> FLOAT64 .)
    TYPE            reduce using rule 81 (type -> FLOAT64 .)
    FUNCTION        reduce using rule 81 (type -> FLOAT64 .)
    VAR             reduce using rule 81 (type -> FLOAT64 .)
    SWITCH          reduce using rule 81 (type -> FLOAT64 .)
    CHARSTRING      reduce using rule 81 (type -> FLOAT64 .)
    LBRACE          reduce using rule 81 (type -> FLOAT64 .)
    FOR             reduce using rule 81 (type -> FLOAT64 .)
    INT             reduce using rule 81 (type -> FLOAT64 .)
    FLOAT           reduce using rule 81 (type -> FLOAT64 .)
    $end            reduce using rule 81 (type -> FLOAT64 .)
    RBRACE          reduce using rule 81 (type -> FLOAT64 .)
    CASE            reduce using rule 81 (type -> FLOAT64 .)
    DEFAULT         reduce using rule 81 (type -> FLOAT64 .)
    RETURN          reduce using rule 81 (type -> FLOAT64 .)
    RPAREN          reduce using rule 81 (type -> FLOAT64 .)
    RBRACKET        reduce using rule 81 (type -> FLOAT64 .)


state 72

    (82) type -> BOOL .

    COMMA           reduce using rule 82 (type -> BOOL .)
    VARIABLE        reduce using rule 82 (type -> BOOL .)
    PRINT           reduce using rule 82 (type -> BOOL .)
    PRINTF          reduce using rule 82 (type -> BOOL .)
    INPUT           reduce using rule 82 (type -> BOOL .)
    IF              reduce using rule 82 (type -> BOOL .)
    TYPE            reduce using rule 82 (type -> BOOL .)
    FUNCTION        reduce using rule 82 (type -> BOOL .)
    VAR             reduce using rule 82 (type -> BOOL .)
    SWITCH          reduce using rule 82 (type -> BOOL .)
    CHARSTRING      reduce using rule 82 (type -> BOOL .)
    LBRACE          reduce using rule 82 (type -> BOOL .)
    FOR             reduce using rule 82 (type -> BOOL .)
    INT             reduce using rule 82 (type -> BOOL .)
    FLOAT           reduce using rule 82 (type -> BOOL .)
    $end            reduce using rule 82 (type -> BOOL .)
    RBRACE          reduce using rule 82 (type -> BOOL .)
    CASE            reduce using rule 82 (type -> BOOL .)
    DEFAULT         reduce using rule 82 (type -> BOOL .)
    RETURN          reduce using rule 82 (type -> BOOL .)
    RPAREN          reduce using rule 82 (type -> BOOL .)
    RBRACKET        reduce using rule 82 (type -> BOOL .)


state 73

    (15) main -> FUNCTION MAIN . LPAREN RPAREN

    LPAREN          shift and go to state 119


state 74

    (38) function -> FUNCTION VARIABLE . LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> FUNCTION VARIABLE . LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE

    LPAREN          shift and go to state 120


state 75

    (52) print_statement -> PRINT LPAREN . values RPAREN
    (53) print_statement -> PRINT LPAREN . string_value RPAREN
    (55) print_statement -> PRINT LPAREN . string_value COMMA values RPAREN
    (56) print_statement -> PRINT LPAREN . operation RPAREN
    (57) print_statement -> PRINT LPAREN . RPAREN
    (43) values -> . value
    (44) values -> . value COMMA values
    (45) string_value -> . value
    (46) string_value -> . CHARSTRING
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    RPAREN          shift and go to state 122
    CHARSTRING      shift and go to state 116
    VARIABLE        shift and go to state 55
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    values                         shift and go to state 121
    string_value                   shift and go to state 123
    operation                      shift and go to state 124
    value                          shift and go to state 125
    number                         shift and go to state 42

state 76

    (54) print_statement -> PRINTF LPAREN . FORMATSTRING COMMA values RPAREN

    FORMATSTRING    shift and go to state 126


state 77

    (58) input_statement -> INPUT LPAREN . values RPAREN
    (59) input_statement -> INPUT LPAREN . operation RPAREN
    (60) input_statement -> INPUT LPAREN . RPAREN
    (43) values -> . value
    (44) values -> . value COMMA values
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    RPAREN          shift and go to state 128
    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    values                         shift and go to state 127
    operation                      shift and go to state 129
    value                          shift and go to state 130
    number                         shift and go to state 42

state 78

    (83) conditional_structure -> IF conditions . conditional_body
    (84) conditional_structure -> IF conditions . conditional_body ELSE conditional_body
    (85) conditional_structure -> IF conditions . conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (86) conditional_body -> . LBRACE statement RBRACE
    (87) conditional_body -> . LBRACE BREAK RBRACE
    (88) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 132

    conditional_body               shift and go to state 131

state 79

    (89) conditions -> condition .
    (90) conditions -> condition . logical_operator conditions
    (92) logical_operator -> . AND
    (93) logical_operator -> . OR
    (94) logical_operator -> . NOT

    LBRACE          reduce using rule 89 (conditions -> condition .)
    AND             shift and go to state 134
    OR              shift and go to state 135
    NOT             shift and go to state 136

    logical_operator               shift and go to state 133

state 80

    (91) condition -> value . relational_operator value
    (95) relational_operator -> . GREATER
    (96) relational_operator -> . LESS
    (97) relational_operator -> . GREATEREQUALS
    (98) relational_operator -> . LESSEQUALS
    (99) relational_operator -> . EQUALS
    (100) relational_operator -> . DIFFERENT

    GREATER         shift and go to state 138
    LESS            shift and go to state 139
    GREATEREQUALS   shift and go to state 140
    LESSEQUALS      shift and go to state 141
    EQUALS          shift and go to state 142
    DIFFERENT       shift and go to state 143

    relational_operator            shift and go to state 137

state 81

    (61) operation -> value operator . value
    (62) operation -> value operator . operation
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    value                          shift and go to state 144
    operation                      shift and go to state 145
    number                         shift and go to state 42

state 82

    (63) operation -> value double_operator .

    PRINT           reduce using rule 63 (operation -> value double_operator .)
    PRINTF          reduce using rule 63 (operation -> value double_operator .)
    INPUT           reduce using rule 63 (operation -> value double_operator .)
    IF              reduce using rule 63 (operation -> value double_operator .)
    VARIABLE        reduce using rule 63 (operation -> value double_operator .)
    TYPE            reduce using rule 63 (operation -> value double_operator .)
    FUNCTION        reduce using rule 63 (operation -> value double_operator .)
    VAR             reduce using rule 63 (operation -> value double_operator .)
    SWITCH          reduce using rule 63 (operation -> value double_operator .)
    CHARSTRING      reduce using rule 63 (operation -> value double_operator .)
    LBRACE          reduce using rule 63 (operation -> value double_operator .)
    FOR             reduce using rule 63 (operation -> value double_operator .)
    INT             reduce using rule 63 (operation -> value double_operator .)
    FLOAT           reduce using rule 63 (operation -> value double_operator .)
    $end            reduce using rule 63 (operation -> value double_operator .)
    RBRACE          reduce using rule 63 (operation -> value double_operator .)
    CASE            reduce using rule 63 (operation -> value double_operator .)
    DEFAULT         reduce using rule 63 (operation -> value double_operator .)
    RETURN          reduce using rule 63 (operation -> value double_operator .)
    RPAREN          reduce using rule 63 (operation -> value double_operator .)


state 83

    (64) operator -> PLUS .

    VARIABLE        reduce using rule 64 (operator -> PLUS .)
    CHARSTRING      reduce using rule 64 (operator -> PLUS .)
    INT             reduce using rule 64 (operator -> PLUS .)
    FLOAT           reduce using rule 64 (operator -> PLUS .)


state 84

    (65) operator -> MINUS .

    VARIABLE        reduce using rule 65 (operator -> MINUS .)
    CHARSTRING      reduce using rule 65 (operator -> MINUS .)
    INT             reduce using rule 65 (operator -> MINUS .)
    FLOAT           reduce using rule 65 (operator -> MINUS .)


state 85

    (66) operator -> TIMES .

    VARIABLE        reduce using rule 66 (operator -> TIMES .)
    CHARSTRING      reduce using rule 66 (operator -> TIMES .)
    INT             reduce using rule 66 (operator -> TIMES .)
    FLOAT           reduce using rule 66 (operator -> TIMES .)


state 86

    (67) operator -> DIVIDE .

    VARIABLE        reduce using rule 67 (operator -> DIVIDE .)
    CHARSTRING      reduce using rule 67 (operator -> DIVIDE .)
    INT             reduce using rule 67 (operator -> DIVIDE .)
    FLOAT           reduce using rule 67 (operator -> DIVIDE .)


state 87

    (68) operator -> ASSIGN .

    VARIABLE        reduce using rule 68 (operator -> ASSIGN .)
    CHARSTRING      reduce using rule 68 (operator -> ASSIGN .)
    INT             reduce using rule 68 (operator -> ASSIGN .)
    FLOAT           reduce using rule 68 (operator -> ASSIGN .)


state 88

    (69) double_operator -> INCREMENT .

    PRINT           reduce using rule 69 (double_operator -> INCREMENT .)
    PRINTF          reduce using rule 69 (double_operator -> INCREMENT .)
    INPUT           reduce using rule 69 (double_operator -> INCREMENT .)
    IF              reduce using rule 69 (double_operator -> INCREMENT .)
    VARIABLE        reduce using rule 69 (double_operator -> INCREMENT .)
    TYPE            reduce using rule 69 (double_operator -> INCREMENT .)
    FUNCTION        reduce using rule 69 (double_operator -> INCREMENT .)
    VAR             reduce using rule 69 (double_operator -> INCREMENT .)
    SWITCH          reduce using rule 69 (double_operator -> INCREMENT .)
    CHARSTRING      reduce using rule 69 (double_operator -> INCREMENT .)
    LBRACE          reduce using rule 69 (double_operator -> INCREMENT .)
    FOR             reduce using rule 69 (double_operator -> INCREMENT .)
    INT             reduce using rule 69 (double_operator -> INCREMENT .)
    FLOAT           reduce using rule 69 (double_operator -> INCREMENT .)
    $end            reduce using rule 69 (double_operator -> INCREMENT .)
    RBRACE          reduce using rule 69 (double_operator -> INCREMENT .)
    CASE            reduce using rule 69 (double_operator -> INCREMENT .)
    DEFAULT         reduce using rule 69 (double_operator -> INCREMENT .)
    RETURN          reduce using rule 69 (double_operator -> INCREMENT .)
    RPAREN          reduce using rule 69 (double_operator -> INCREMENT .)


state 89

    (70) double_operator -> DECREMENT .

    PRINT           reduce using rule 70 (double_operator -> DECREMENT .)
    PRINTF          reduce using rule 70 (double_operator -> DECREMENT .)
    INPUT           reduce using rule 70 (double_operator -> DECREMENT .)
    IF              reduce using rule 70 (double_operator -> DECREMENT .)
    VARIABLE        reduce using rule 70 (double_operator -> DECREMENT .)
    TYPE            reduce using rule 70 (double_operator -> DECREMENT .)
    FUNCTION        reduce using rule 70 (double_operator -> DECREMENT .)
    VAR             reduce using rule 70 (double_operator -> DECREMENT .)
    SWITCH          reduce using rule 70 (double_operator -> DECREMENT .)
    CHARSTRING      reduce using rule 70 (double_operator -> DECREMENT .)
    LBRACE          reduce using rule 70 (double_operator -> DECREMENT .)
    FOR             reduce using rule 70 (double_operator -> DECREMENT .)
    INT             reduce using rule 70 (double_operator -> DECREMENT .)
    FLOAT           reduce using rule 70 (double_operator -> DECREMENT .)
    $end            reduce using rule 70 (double_operator -> DECREMENT .)
    RBRACE          reduce using rule 70 (double_operator -> DECREMENT .)
    CASE            reduce using rule 70 (double_operator -> DECREMENT .)
    DEFAULT         reduce using rule 70 (double_operator -> DECREMENT .)
    RETURN          reduce using rule 70 (double_operator -> DECREMENT .)
    RPAREN          reduce using rule 70 (double_operator -> DECREMENT .)


state 90

    (37) structure -> TYPE VARIABLE . STRUCT LBRACE statement RBRACE
    (120) defined_list -> TYPE VARIABLE . LBRACE values RBRACE

    STRUCT          shift and go to state 146
    LBRACE          shift and go to state 147


state 91

    (72) parameters -> parameter parameters .

    PRINT           reduce using rule 72 (parameters -> parameter parameters .)
    PRINTF          reduce using rule 72 (parameters -> parameter parameters .)
    INPUT           reduce using rule 72 (parameters -> parameter parameters .)
    IF              reduce using rule 72 (parameters -> parameter parameters .)
    VARIABLE        reduce using rule 72 (parameters -> parameter parameters .)
    TYPE            reduce using rule 72 (parameters -> parameter parameters .)
    FUNCTION        reduce using rule 72 (parameters -> parameter parameters .)
    VAR             reduce using rule 72 (parameters -> parameter parameters .)
    SWITCH          reduce using rule 72 (parameters -> parameter parameters .)
    CHARSTRING      reduce using rule 72 (parameters -> parameter parameters .)
    LBRACE          reduce using rule 72 (parameters -> parameter parameters .)
    FOR             reduce using rule 72 (parameters -> parameter parameters .)
    INT             reduce using rule 72 (parameters -> parameter parameters .)
    FLOAT           reduce using rule 72 (parameters -> parameter parameters .)
    $end            reduce using rule 72 (parameters -> parameter parameters .)
    RBRACE          reduce using rule 72 (parameters -> parameter parameters .)
    CASE            reduce using rule 72 (parameters -> parameter parameters .)
    DEFAULT         reduce using rule 72 (parameters -> parameter parameters .)
    RETURN          reduce using rule 72 (parameters -> parameter parameters .)
    RPAREN          reduce using rule 72 (parameters -> parameter parameters .)


state 92

    (73) parameters -> parameter COMMA . parameters
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (74) parameter -> . VARIABLE type

    VARIABLE        shift and go to state 93

    parameter                      shift and go to state 39
    parameters                     shift and go to state 148

state 93

    (74) parameter -> VARIABLE . type
    (75) type -> . INT
    (76) type -> . INT32
    (77) type -> . INT64
    (78) type -> . STRING
    (79) type -> . FLOAT
    (80) type -> . FLOAT32
    (81) type -> . FLOAT64
    (82) type -> . BOOL

    INT             shift and go to state 65
    INT32           shift and go to state 66
    INT64           shift and go to state 67
    STRING          shift and go to state 68
    FLOAT           shift and go to state 69
    FLOAT32         shift and go to state 70
    FLOAT64         shift and go to state 71
    BOOL            shift and go to state 72

    type                           shift and go to state 63

state 94

    (32) variable_declaration -> VAR VARIABLE . type
    (33) variable_declaration -> VAR VARIABLE . ASSIGN value
    (34) variable_declaration -> VAR VARIABLE . ASSIGN list_structure
    (128) slice_structure -> VAR VARIABLE . LBRACKET RBRACKET type
    (75) type -> . INT
    (76) type -> . INT32
    (77) type -> . INT64
    (78) type -> . STRING
    (79) type -> . FLOAT
    (80) type -> . FLOAT32
    (81) type -> . FLOAT64
    (82) type -> . BOOL

    ASSIGN          shift and go to state 150
    LBRACKET        shift and go to state 151
    INT             shift and go to state 65
    INT32           shift and go to state 66
    INT64           shift and go to state 67
    STRING          shift and go to state 68
    FLOAT           shift and go to state 69
    FLOAT32         shift and go to state 70
    FLOAT64         shift and go to state 71
    BOOL            shift and go to state 72

    type                           shift and go to state 149

state 95

    (107) switch_structure -> SWITCH switch_expression . LBRACE case_blocks RBRACE

    LBRACE          shift and go to state 152


state 96

    (108) switch_expression -> value .

    LBRACE          reduce using rule 108 (switch_expression -> value .)


state 97

    (109) switch_expression -> empty .

    LBRACE          reduce using rule 109 (switch_expression -> empty .)


state 98

    (104) for_initialization -> FOR VARIABLE . SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (106) for_iterator -> FOR VARIABLE . SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 153
    SEMICOLON       shift and go to state 154


state 99

    (105) for_infinite_bucle -> FOR LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) main -> . FUNCTION MAIN LPAREN RPAREN
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 8
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! LBRACE          [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 155
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 100

    (7) statement -> import main LBRACE . blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    blocks                         shift and go to state 156
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 101

    (4) statement -> package import blocks .

    $end            reduce using rule 4 (statement -> package import blocks .)
    RBRACE          reduce using rule 4 (statement -> package import blocks .)
    CASE            reduce using rule 4 (statement -> package import blocks .)
    DEFAULT         reduce using rule 4 (statement -> package import blocks .)


state 102

    (8) statement -> package import main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 157


state 103

    (6) statement -> package main LBRACE . blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    blocks                         shift and go to state 158
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 104

    (5) statement -> main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 159


state 105

    (119) list_with_data -> LBRACE values RBRACE .

    PRINT           reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    PRINTF          reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    INPUT           reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    IF              reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    VARIABLE        reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    TYPE            reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    FUNCTION        reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    VAR             reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    SWITCH          reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    LBRACE          reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    FOR             reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    INT             reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    FLOAT           reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    $end            reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    RBRACE          reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    CASE            reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    DEFAULT         reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)
    RETURN          reduce using rule 119 (list_with_data -> LBRACE values RBRACE .)


state 106

    (44) values -> value COMMA . values
    (43) values -> . value
    (44) values -> . value COMMA values
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    value                          shift and go to state 54
    values                         shift and go to state 160
    number                         shift and go to state 42

state 107

    (11) import -> IMPORT LPAREN values_import . RPAREN

    RPAREN          shift and go to state 161


state 108

    (12) values_import -> CHARSTRING .
    (13) values_import -> CHARSTRING . values_import
    (12) values_import -> . CHARSTRING
    (13) values_import -> . CHARSTRING values_import

    RPAREN          reduce using rule 12 (values_import -> CHARSTRING .)
    CHARSTRING      shift and go to state 108

    values_import                  shift and go to state 162

state 109

    (121) map_estructure -> VARIABLE SHORTASSIGN MAP . LBRACKET type RBRACKET type LBRACE map_values RBRACE

    LBRACKET        shift and go to state 163


state 110

    (127) slice_structure -> VARIABLE SHORTASSIGN LBRACKET . RBRACKET type LBRACE values RBRACE
    (129) slice_structure -> VARIABLE SHORTASSIGN LBRACKET . RBRACKET type

    RBRACKET        shift and go to state 164


state 111

    (122) map_estructure -> VARIABLE SHORTASSIGN MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN

    LPAREN          shift and go to state 165


state 112

    (35) variable_declaration -> VARIABLE SHORTASSIGN value .
    (61) operation -> value . operator value
    (62) operation -> value . operator operation
    (63) operation -> value . double_operator
    (64) operator -> . PLUS
    (65) operator -> . MINUS
    (66) operator -> . TIMES
    (67) operator -> . DIVIDE
    (68) operator -> . ASSIGN
    (69) double_operator -> . INCREMENT
    (70) double_operator -> . DECREMENT

    PRINT           reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    PRINTF          reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INPUT           reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    IF              reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VARIABLE        reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    TYPE            reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FUNCTION        reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VAR             reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    SWITCH          reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CHARSTRING      reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    LBRACE          reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FOR             reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INT             reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FLOAT           reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    $end            reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    RBRACE          reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CASE            reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    DEFAULT         reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    RETURN          reduce using rule 35 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    PLUS            shift and go to state 83
    MINUS           shift and go to state 84
    TIMES           shift and go to state 85
    DIVIDE          shift and go to state 86
    ASSIGN          shift and go to state 87
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89

    operator                       shift and go to state 81
    double_operator                shift and go to state 82

state 113

    (36) variable_declaration -> VARIABLE SHORTASSIGN operation .

    PRINT           reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    PRINTF          reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    INPUT           reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    IF              reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    VARIABLE        reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    TYPE            reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FUNCTION        reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    VAR             reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    SWITCH          reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CHARSTRING      reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    LBRACE          reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FOR             reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    INT             reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FLOAT           reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    $end            reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    RBRACE          reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CASE            reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    DEFAULT         reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    RETURN          reduce using rule 36 (variable_declaration -> VARIABLE SHORTASSIGN operation .)


state 114

    (126) map_assign -> VARIABLE LBRACKET string_value . RBRACKET ASSIGN string_value

    RBRACKET        shift and go to state 166


state 115

    (45) string_value -> value .

    RBRACKET        reduce using rule 45 (string_value -> value .)
    PRINT           reduce using rule 45 (string_value -> value .)
    PRINTF          reduce using rule 45 (string_value -> value .)
    INPUT           reduce using rule 45 (string_value -> value .)
    IF              reduce using rule 45 (string_value -> value .)
    VARIABLE        reduce using rule 45 (string_value -> value .)
    TYPE            reduce using rule 45 (string_value -> value .)
    FUNCTION        reduce using rule 45 (string_value -> value .)
    VAR             reduce using rule 45 (string_value -> value .)
    SWITCH          reduce using rule 45 (string_value -> value .)
    CHARSTRING      reduce using rule 45 (string_value -> value .)
    LBRACE          reduce using rule 45 (string_value -> value .)
    FOR             reduce using rule 45 (string_value -> value .)
    INT             reduce using rule 45 (string_value -> value .)
    FLOAT           reduce using rule 45 (string_value -> value .)
    $end            reduce using rule 45 (string_value -> value .)
    RBRACE          reduce using rule 45 (string_value -> value .)
    CASE            reduce using rule 45 (string_value -> value .)
    DEFAULT         reduce using rule 45 (string_value -> value .)
    RETURN          reduce using rule 45 (string_value -> value .)
    COLON           reduce using rule 45 (string_value -> value .)
    COMMA           reduce using rule 45 (string_value -> value .)


state 116

    (46) string_value -> CHARSTRING .
    (49) value -> CHARSTRING .

  ! reduce/reduce conflict for RBRACKET resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for COMMA resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for RPAREN resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for PRINT resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for PRINTF resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for INPUT resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for IF resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for TYPE resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for VAR resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for SWITCH resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for CHARSTRING resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for LBRACE resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for FOR resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for INT resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for FLOAT resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for $end resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for RBRACE resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for CASE resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for RETURN resolved using rule 46 (string_value -> CHARSTRING .)
  ! reduce/reduce conflict for COLON resolved using rule 46 (string_value -> CHARSTRING .)
    RBRACKET        reduce using rule 46 (string_value -> CHARSTRING .)
    RPAREN          reduce using rule 46 (string_value -> CHARSTRING .)
    COMMA           reduce using rule 46 (string_value -> CHARSTRING .)
    PRINT           reduce using rule 46 (string_value -> CHARSTRING .)
    PRINTF          reduce using rule 46 (string_value -> CHARSTRING .)
    INPUT           reduce using rule 46 (string_value -> CHARSTRING .)
    IF              reduce using rule 46 (string_value -> CHARSTRING .)
    VARIABLE        reduce using rule 46 (string_value -> CHARSTRING .)
    TYPE            reduce using rule 46 (string_value -> CHARSTRING .)
    FUNCTION        reduce using rule 46 (string_value -> CHARSTRING .)
    VAR             reduce using rule 46 (string_value -> CHARSTRING .)
    SWITCH          reduce using rule 46 (string_value -> CHARSTRING .)
    CHARSTRING      reduce using rule 46 (string_value -> CHARSTRING .)
    LBRACE          reduce using rule 46 (string_value -> CHARSTRING .)
    FOR             reduce using rule 46 (string_value -> CHARSTRING .)
    INT             reduce using rule 46 (string_value -> CHARSTRING .)
    FLOAT           reduce using rule 46 (string_value -> CHARSTRING .)
    $end            reduce using rule 46 (string_value -> CHARSTRING .)
    RBRACE          reduce using rule 46 (string_value -> CHARSTRING .)
    CASE            reduce using rule 46 (string_value -> CHARSTRING .)
    DEFAULT         reduce using rule 46 (string_value -> CHARSTRING .)
    RETURN          reduce using rule 46 (string_value -> CHARSTRING .)
    COLON           reduce using rule 46 (string_value -> CHARSTRING .)
    PLUS            reduce using rule 49 (value -> CHARSTRING .)
    MINUS           reduce using rule 49 (value -> CHARSTRING .)
    TIMES           reduce using rule 49 (value -> CHARSTRING .)
    DIVIDE          reduce using rule 49 (value -> CHARSTRING .)
    ASSIGN          reduce using rule 49 (value -> CHARSTRING .)
    INCREMENT       reduce using rule 49 (value -> CHARSTRING .)
    DECREMENT       reduce using rule 49 (value -> CHARSTRING .)

  ! RBRACKET        [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! COMMA           [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! RPAREN          [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! PRINT           [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! PRINTF          [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! INPUT           [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! IF              [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! VARIABLE        [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! TYPE            [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! FUNCTION        [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! VAR             [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! SWITCH          [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! CHARSTRING      [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! LBRACE          [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! FOR             [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! INT             [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! FLOAT           [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! $end            [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! RBRACE          [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! CASE            [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! DEFAULT         [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! RETURN          [ reduce using rule 49 (value -> CHARSTRING .) ]
  ! COLON           [ reduce using rule 49 (value -> CHARSTRING .) ]


state 117

    (130) slice_structure -> VARIABLE ASSIGN append_statement .

    PRINT           reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    PRINTF          reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    INPUT           reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    IF              reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    VARIABLE        reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    TYPE            reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FUNCTION        reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    VAR             reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    SWITCH          reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CHARSTRING      reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    LBRACE          reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FOR             reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    INT             reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FLOAT           reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    $end            reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    RBRACE          reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CASE            reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    DEFAULT         reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)
    RETURN          reduce using rule 130 (slice_structure -> VARIABLE ASSIGN append_statement .)


state 118

    (131) append_statement -> APPEND . LPAREN VARIABLE COMMA values RPAREN

    LPAREN          shift and go to state 167


state 119

    (15) main -> FUNCTION MAIN LPAREN . RPAREN

    RPAREN          shift and go to state 168


state 120

    (38) function -> FUNCTION VARIABLE LPAREN . RPAREN LBRACE blocks RBRACE
    (39) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN LBRACE blocks RBRACE
    (40) function -> FUNCTION VARIABLE LPAREN . RPAREN type LBRACE RETURN value RBRACE
    (41) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (74) parameter -> . VARIABLE type

    RPAREN          shift and go to state 169
    VARIABLE        shift and go to state 93

    parameters                     shift and go to state 170
    parameter                      shift and go to state 39

state 121

    (52) print_statement -> PRINT LPAREN values . RPAREN

    RPAREN          shift and go to state 171


state 122

    (57) print_statement -> PRINT LPAREN RPAREN .

    PRINT           reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    PRINTF          reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    INPUT           reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    IF              reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    VARIABLE        reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    TYPE            reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    FUNCTION        reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    VAR             reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    SWITCH          reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    CHARSTRING      reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    LBRACE          reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    FOR             reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    INT             reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    FLOAT           reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    $end            reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    RBRACE          reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    CASE            reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    DEFAULT         reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)
    RETURN          reduce using rule 57 (print_statement -> PRINT LPAREN RPAREN .)


state 123

    (53) print_statement -> PRINT LPAREN string_value . RPAREN
    (55) print_statement -> PRINT LPAREN string_value . COMMA values RPAREN

    RPAREN          shift and go to state 172
    COMMA           shift and go to state 173


state 124

    (56) print_statement -> PRINT LPAREN operation . RPAREN

    RPAREN          shift and go to state 174


state 125

    (43) values -> value .
    (44) values -> value . COMMA values
    (45) string_value -> value .
    (61) operation -> value . operator value
    (62) operation -> value . operator operation
    (63) operation -> value . double_operator
    (64) operator -> . PLUS
    (65) operator -> . MINUS
    (66) operator -> . TIMES
    (67) operator -> . DIVIDE
    (68) operator -> . ASSIGN
    (69) double_operator -> . INCREMENT
    (70) double_operator -> . DECREMENT

  ! reduce/reduce conflict for RPAREN resolved using rule 43 (values -> value .)
  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 43 (values -> value .)
    COMMA           shift and go to state 106
    PLUS            shift and go to state 83
    MINUS           shift and go to state 84
    TIMES           shift and go to state 85
    DIVIDE          shift and go to state 86
    ASSIGN          shift and go to state 87
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89

  ! RPAREN          [ reduce using rule 45 (string_value -> value .) ]
  ! COMMA           [ reduce using rule 45 (string_value -> value .) ]

    operator                       shift and go to state 81
    double_operator                shift and go to state 82

state 126

    (54) print_statement -> PRINTF LPAREN FORMATSTRING . COMMA values RPAREN

    COMMA           shift and go to state 175


state 127

    (58) input_statement -> INPUT LPAREN values . RPAREN

    RPAREN          shift and go to state 176


state 128

    (60) input_statement -> INPUT LPAREN RPAREN .

    PRINT           reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    PRINTF          reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    IF              reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    VARIABLE        reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    TYPE            reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    FUNCTION        reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    VAR             reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    SWITCH          reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    CHARSTRING      reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    LBRACE          reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    INT             reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    FLOAT           reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    $end            reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    CASE            reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    DEFAULT         reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)
    RETURN          reduce using rule 60 (input_statement -> INPUT LPAREN RPAREN .)


state 129

    (59) input_statement -> INPUT LPAREN operation . RPAREN

    RPAREN          shift and go to state 177


state 130

    (43) values -> value .
    (44) values -> value . COMMA values
    (61) operation -> value . operator value
    (62) operation -> value . operator operation
    (63) operation -> value . double_operator
    (64) operator -> . PLUS
    (65) operator -> . MINUS
    (66) operator -> . TIMES
    (67) operator -> . DIVIDE
    (68) operator -> . ASSIGN
    (69) double_operator -> . INCREMENT
    (70) double_operator -> . DECREMENT

    RPAREN          reduce using rule 43 (values -> value .)
    COMMA           shift and go to state 106
    PLUS            shift and go to state 83
    MINUS           shift and go to state 84
    TIMES           shift and go to state 85
    DIVIDE          shift and go to state 86
    ASSIGN          shift and go to state 87
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89

    operator                       shift and go to state 81
    double_operator                shift and go to state 82

state 131

    (83) conditional_structure -> IF conditions conditional_body .
    (84) conditional_structure -> IF conditions conditional_body . ELSE conditional_body
    (85) conditional_structure -> IF conditions conditional_body . ELSE IF conditions conditional_body ELSE conditional_body

    PRINT           reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    PRINTF          reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    INPUT           reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    IF              reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    VARIABLE        reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    TYPE            reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    FUNCTION        reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    VAR             reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    SWITCH          reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    CHARSTRING      reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    LBRACE          reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    FOR             reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    INT             reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    FLOAT           reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    $end            reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    RBRACE          reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    CASE            reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    DEFAULT         reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    RETURN          reduce using rule 83 (conditional_structure -> IF conditions conditional_body .)
    ELSE            shift and go to state 178


state 132

    (86) conditional_body -> LBRACE . statement RBRACE
    (87) conditional_body -> LBRACE . BREAK RBRACE
    (88) conditional_body -> LBRACE . CONTINUE RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) main -> . FUNCTION MAIN LPAREN RPAREN
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    BREAK           shift and go to state 180
    CONTINUE        shift and go to state 181
    IMPORT          shift and go to state 8
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! LBRACE          [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 179
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 133

    (90) conditions -> condition logical_operator . conditions
    (89) conditions -> . condition
    (90) conditions -> . condition logical_operator conditions
    (91) condition -> . value relational_operator value
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    condition                      shift and go to state 79
    conditions                     shift and go to state 182
    value                          shift and go to state 80
    number                         shift and go to state 42

state 134

    (92) logical_operator -> AND .

    VARIABLE        reduce using rule 92 (logical_operator -> AND .)
    CHARSTRING      reduce using rule 92 (logical_operator -> AND .)
    INT             reduce using rule 92 (logical_operator -> AND .)
    FLOAT           reduce using rule 92 (logical_operator -> AND .)


state 135

    (93) logical_operator -> OR .

    VARIABLE        reduce using rule 93 (logical_operator -> OR .)
    CHARSTRING      reduce using rule 93 (logical_operator -> OR .)
    INT             reduce using rule 93 (logical_operator -> OR .)
    FLOAT           reduce using rule 93 (logical_operator -> OR .)


state 136

    (94) logical_operator -> NOT .

    VARIABLE        reduce using rule 94 (logical_operator -> NOT .)
    CHARSTRING      reduce using rule 94 (logical_operator -> NOT .)
    INT             reduce using rule 94 (logical_operator -> NOT .)
    FLOAT           reduce using rule 94 (logical_operator -> NOT .)


state 137

    (91) condition -> value relational_operator . value
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    value                          shift and go to state 183
    number                         shift and go to state 42

state 138

    (95) relational_operator -> GREATER .

    VARIABLE        reduce using rule 95 (relational_operator -> GREATER .)
    CHARSTRING      reduce using rule 95 (relational_operator -> GREATER .)
    INT             reduce using rule 95 (relational_operator -> GREATER .)
    FLOAT           reduce using rule 95 (relational_operator -> GREATER .)


state 139

    (96) relational_operator -> LESS .

    VARIABLE        reduce using rule 96 (relational_operator -> LESS .)
    CHARSTRING      reduce using rule 96 (relational_operator -> LESS .)
    INT             reduce using rule 96 (relational_operator -> LESS .)
    FLOAT           reduce using rule 96 (relational_operator -> LESS .)


state 140

    (97) relational_operator -> GREATEREQUALS .

    VARIABLE        reduce using rule 97 (relational_operator -> GREATEREQUALS .)
    CHARSTRING      reduce using rule 97 (relational_operator -> GREATEREQUALS .)
    INT             reduce using rule 97 (relational_operator -> GREATEREQUALS .)
    FLOAT           reduce using rule 97 (relational_operator -> GREATEREQUALS .)


state 141

    (98) relational_operator -> LESSEQUALS .

    VARIABLE        reduce using rule 98 (relational_operator -> LESSEQUALS .)
    CHARSTRING      reduce using rule 98 (relational_operator -> LESSEQUALS .)
    INT             reduce using rule 98 (relational_operator -> LESSEQUALS .)
    FLOAT           reduce using rule 98 (relational_operator -> LESSEQUALS .)


state 142

    (99) relational_operator -> EQUALS .

    VARIABLE        reduce using rule 99 (relational_operator -> EQUALS .)
    CHARSTRING      reduce using rule 99 (relational_operator -> EQUALS .)
    INT             reduce using rule 99 (relational_operator -> EQUALS .)
    FLOAT           reduce using rule 99 (relational_operator -> EQUALS .)


state 143

    (100) relational_operator -> DIFFERENT .

    VARIABLE        reduce using rule 100 (relational_operator -> DIFFERENT .)
    CHARSTRING      reduce using rule 100 (relational_operator -> DIFFERENT .)
    INT             reduce using rule 100 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 100 (relational_operator -> DIFFERENT .)


state 144

    (61) operation -> value operator value .
    (61) operation -> value . operator value
    (62) operation -> value . operator operation
    (63) operation -> value . double_operator
    (64) operator -> . PLUS
    (65) operator -> . MINUS
    (66) operator -> . TIMES
    (67) operator -> . DIVIDE
    (68) operator -> . ASSIGN
    (69) double_operator -> . INCREMENT
    (70) double_operator -> . DECREMENT

    PRINT           reduce using rule 61 (operation -> value operator value .)
    PRINTF          reduce using rule 61 (operation -> value operator value .)
    INPUT           reduce using rule 61 (operation -> value operator value .)
    IF              reduce using rule 61 (operation -> value operator value .)
    VARIABLE        reduce using rule 61 (operation -> value operator value .)
    TYPE            reduce using rule 61 (operation -> value operator value .)
    FUNCTION        reduce using rule 61 (operation -> value operator value .)
    VAR             reduce using rule 61 (operation -> value operator value .)
    SWITCH          reduce using rule 61 (operation -> value operator value .)
    CHARSTRING      reduce using rule 61 (operation -> value operator value .)
    LBRACE          reduce using rule 61 (operation -> value operator value .)
    FOR             reduce using rule 61 (operation -> value operator value .)
    INT             reduce using rule 61 (operation -> value operator value .)
    FLOAT           reduce using rule 61 (operation -> value operator value .)
    $end            reduce using rule 61 (operation -> value operator value .)
    RBRACE          reduce using rule 61 (operation -> value operator value .)
    CASE            reduce using rule 61 (operation -> value operator value .)
    DEFAULT         reduce using rule 61 (operation -> value operator value .)
    RETURN          reduce using rule 61 (operation -> value operator value .)
    RPAREN          reduce using rule 61 (operation -> value operator value .)
    PLUS            shift and go to state 83
    MINUS           shift and go to state 84
    TIMES           shift and go to state 85
    DIVIDE          shift and go to state 86
    ASSIGN          shift and go to state 87
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89

    operator                       shift and go to state 81
    double_operator                shift and go to state 82

state 145

    (62) operation -> value operator operation .

    PRINT           reduce using rule 62 (operation -> value operator operation .)
    PRINTF          reduce using rule 62 (operation -> value operator operation .)
    INPUT           reduce using rule 62 (operation -> value operator operation .)
    IF              reduce using rule 62 (operation -> value operator operation .)
    VARIABLE        reduce using rule 62 (operation -> value operator operation .)
    TYPE            reduce using rule 62 (operation -> value operator operation .)
    FUNCTION        reduce using rule 62 (operation -> value operator operation .)
    VAR             reduce using rule 62 (operation -> value operator operation .)
    SWITCH          reduce using rule 62 (operation -> value operator operation .)
    CHARSTRING      reduce using rule 62 (operation -> value operator operation .)
    LBRACE          reduce using rule 62 (operation -> value operator operation .)
    FOR             reduce using rule 62 (operation -> value operator operation .)
    INT             reduce using rule 62 (operation -> value operator operation .)
    FLOAT           reduce using rule 62 (operation -> value operator operation .)
    $end            reduce using rule 62 (operation -> value operator operation .)
    RBRACE          reduce using rule 62 (operation -> value operator operation .)
    CASE            reduce using rule 62 (operation -> value operator operation .)
    DEFAULT         reduce using rule 62 (operation -> value operator operation .)
    RETURN          reduce using rule 62 (operation -> value operator operation .)
    RPAREN          reduce using rule 62 (operation -> value operator operation .)


state 146

    (37) structure -> TYPE VARIABLE STRUCT . LBRACE statement RBRACE

    LBRACE          shift and go to state 184


state 147

    (120) defined_list -> TYPE VARIABLE LBRACE . values RBRACE
    (43) values -> . value
    (44) values -> . value COMMA values
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    values                         shift and go to state 185
    value                          shift and go to state 54
    number                         shift and go to state 42

state 148

    (73) parameters -> parameter COMMA parameters .

    PRINT           reduce using rule 73 (parameters -> parameter COMMA parameters .)
    PRINTF          reduce using rule 73 (parameters -> parameter COMMA parameters .)
    INPUT           reduce using rule 73 (parameters -> parameter COMMA parameters .)
    IF              reduce using rule 73 (parameters -> parameter COMMA parameters .)
    VARIABLE        reduce using rule 73 (parameters -> parameter COMMA parameters .)
    TYPE            reduce using rule 73 (parameters -> parameter COMMA parameters .)
    FUNCTION        reduce using rule 73 (parameters -> parameter COMMA parameters .)
    VAR             reduce using rule 73 (parameters -> parameter COMMA parameters .)
    SWITCH          reduce using rule 73 (parameters -> parameter COMMA parameters .)
    CHARSTRING      reduce using rule 73 (parameters -> parameter COMMA parameters .)
    LBRACE          reduce using rule 73 (parameters -> parameter COMMA parameters .)
    FOR             reduce using rule 73 (parameters -> parameter COMMA parameters .)
    INT             reduce using rule 73 (parameters -> parameter COMMA parameters .)
    FLOAT           reduce using rule 73 (parameters -> parameter COMMA parameters .)
    $end            reduce using rule 73 (parameters -> parameter COMMA parameters .)
    RBRACE          reduce using rule 73 (parameters -> parameter COMMA parameters .)
    CASE            reduce using rule 73 (parameters -> parameter COMMA parameters .)
    DEFAULT         reduce using rule 73 (parameters -> parameter COMMA parameters .)
    RETURN          reduce using rule 73 (parameters -> parameter COMMA parameters .)
    RPAREN          reduce using rule 73 (parameters -> parameter COMMA parameters .)


state 149

    (32) variable_declaration -> VAR VARIABLE type .

    PRINT           reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    PRINTF          reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    INPUT           reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    IF              reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    VARIABLE        reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    TYPE            reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    FUNCTION        reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    VAR             reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    SWITCH          reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    CHARSTRING      reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    LBRACE          reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    FOR             reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    INT             reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    FLOAT           reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    $end            reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    RBRACE          reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    CASE            reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    DEFAULT         reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)
    RETURN          reduce using rule 32 (variable_declaration -> VAR VARIABLE type .)


state 150

    (33) variable_declaration -> VAR VARIABLE ASSIGN . value
    (34) variable_declaration -> VAR VARIABLE ASSIGN . list_structure
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (50) number -> . INT
    (51) number -> . FLOAT
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45
    LBRACE          shift and go to state 6
    TYPE            shift and go to state 188

    value                          shift and go to state 186
    list_structure                 shift and go to state 187
    number                         shift and go to state 42
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34

state 151

    (128) slice_structure -> VAR VARIABLE LBRACKET . RBRACKET type

    RBRACKET        shift and go to state 189


state 152

    (107) switch_structure -> SWITCH switch_expression LBRACE . case_blocks RBRACE
    (110) case_blocks -> . case_block
    (111) case_blocks -> . case_block case_blocks
    (112) case_block -> . CASE values COLON statement
    (113) case_block -> . DEFAULT COLON statement

    CASE            shift and go to state 192
    DEFAULT         shift and go to state 193

    case_blocks                    shift and go to state 190
    case_block                     shift and go to state 191

state 153

    (104) for_initialization -> FOR VARIABLE SHORTASSIGN . value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    value                          shift and go to state 194
    number                         shift and go to state 42

state 154

    (106) for_iterator -> FOR VARIABLE SEMICOLON . VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 195


state 155

    (105) for_infinite_bucle -> FOR LBRACE statement . RBRACE

    RBRACE          shift and go to state 196


state 156

    (7) statement -> import main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 197


state 157

    (8) statement -> package import main LBRACE . blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    blocks                         shift and go to state 198
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 158

    (6) statement -> package main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 199


state 159

    (5) statement -> main LBRACE blocks RBRACE .

    $end            reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)
    CASE            reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)


state 160

    (44) values -> value COMMA values .

    RBRACE          reduce using rule 44 (values -> value COMMA values .)
    RPAREN          reduce using rule 44 (values -> value COMMA values .)
    COLON           reduce using rule 44 (values -> value COMMA values .)


state 161

    (11) import -> IMPORT LPAREN values_import RPAREN .

    FUNCTION        reduce using rule 11 (import -> IMPORT LPAREN values_import RPAREN .)
    PRINT           reduce using rule 11 (import -> IMPORT LPAREN values_import RPAREN .)
    PRINTF          reduce using rule 11 (import -> IMPORT LPAREN values_import RPAREN .)
    INPUT           reduce using rule 11 (import -> IMPORT LPAREN values_import RPAREN .)
    IF              reduce using rule 11 (import -> IMPORT LPAREN values_import RPAREN .)
    VARIABLE        reduce using rule 11 (import -> IMPORT LPAREN values_import RPAREN .)
    TYPE            reduce using rule 11 (import -> IMPORT LPAREN values_import RPAREN .)
    VAR             reduce using rule 11 (import -> IMPORT LPAREN values_import RPAREN .)
    SWITCH          reduce using rule 11 (import -> IMPORT LPAREN values_import RPAREN .)
    CHARSTRING      reduce using rule 11 (import -> IMPORT LPAREN values_import RPAREN .)
    LBRACE          reduce using rule 11 (import -> IMPORT LPAREN values_import RPAREN .)
    FOR             reduce using rule 11 (import -> IMPORT LPAREN values_import RPAREN .)
    INT             reduce using rule 11 (import -> IMPORT LPAREN values_import RPAREN .)
    FLOAT           reduce using rule 11 (import -> IMPORT LPAREN values_import RPAREN .)


state 162

    (13) values_import -> CHARSTRING values_import .

    RPAREN          reduce using rule 13 (values_import -> CHARSTRING values_import .)


state 163

    (121) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET . type RBRACKET type LBRACE map_values RBRACE
    (75) type -> . INT
    (76) type -> . INT32
    (77) type -> . INT64
    (78) type -> . STRING
    (79) type -> . FLOAT
    (80) type -> . FLOAT32
    (81) type -> . FLOAT64
    (82) type -> . BOOL

    INT             shift and go to state 65
    INT32           shift and go to state 66
    INT64           shift and go to state 67
    STRING          shift and go to state 68
    FLOAT           shift and go to state 69
    FLOAT32         shift and go to state 70
    FLOAT64         shift and go to state 71
    BOOL            shift and go to state 72

    type                           shift and go to state 200

state 164

    (127) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET . type LBRACE values RBRACE
    (129) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET . type
    (75) type -> . INT
    (76) type -> . INT32
    (77) type -> . INT64
    (78) type -> . STRING
    (79) type -> . FLOAT
    (80) type -> . FLOAT32
    (81) type -> . FLOAT64
    (82) type -> . BOOL

    INT             shift and go to state 65
    INT32           shift and go to state 66
    INT64           shift and go to state 67
    STRING          shift and go to state 68
    FLOAT           shift and go to state 69
    FLOAT32         shift and go to state 70
    FLOAT64         shift and go to state 71
    BOOL            shift and go to state 72

    type                           shift and go to state 201

state 165

    (122) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN

    MAP             shift and go to state 202


state 166

    (126) map_assign -> VARIABLE LBRACKET string_value RBRACKET . ASSIGN string_value

    ASSIGN          shift and go to state 203


state 167

    (131) append_statement -> APPEND LPAREN . VARIABLE COMMA values RPAREN

    VARIABLE        shift and go to state 204


state 168

    (15) main -> FUNCTION MAIN LPAREN RPAREN .

    LBRACE          reduce using rule 15 (main -> FUNCTION MAIN LPAREN RPAREN .)


state 169

    (38) function -> FUNCTION VARIABLE LPAREN RPAREN . LBRACE blocks RBRACE
    (40) function -> FUNCTION VARIABLE LPAREN RPAREN . type LBRACE RETURN value RBRACE
    (75) type -> . INT
    (76) type -> . INT32
    (77) type -> . INT64
    (78) type -> . STRING
    (79) type -> . FLOAT
    (80) type -> . FLOAT32
    (81) type -> . FLOAT64
    (82) type -> . BOOL

    LBRACE          shift and go to state 205
    INT             shift and go to state 65
    INT32           shift and go to state 66
    INT64           shift and go to state 67
    STRING          shift and go to state 68
    FLOAT           shift and go to state 69
    FLOAT32         shift and go to state 70
    FLOAT64         shift and go to state 71
    BOOL            shift and go to state 72

    type                           shift and go to state 206

state 170

    (39) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN LBRACE blocks RBRACE
    (41) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN type LBRACE RETURN value RBRACE
    (42) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN type LBRACE blocks RETURN value RBRACE

    RPAREN          shift and go to state 207


state 171

    (52) print_statement -> PRINT LPAREN values RPAREN .

    PRINT           reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    PRINTF          reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    INPUT           reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    IF              reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    TYPE            reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    VAR             reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    SWITCH          reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    CHARSTRING      reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    LBRACE          reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    FOR             reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    INT             reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    FLOAT           reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    $end            reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    RBRACE          reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    CASE            reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    DEFAULT         reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)
    RETURN          reduce using rule 52 (print_statement -> PRINT LPAREN values RPAREN .)


state 172

    (53) print_statement -> PRINT LPAREN string_value RPAREN .

    PRINT           reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    PRINTF          reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    INPUT           reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    IF              reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    VARIABLE        reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    TYPE            reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    FUNCTION        reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    VAR             reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    SWITCH          reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    CHARSTRING      reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    LBRACE          reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    FOR             reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    INT             reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    FLOAT           reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    $end            reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    RBRACE          reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    CASE            reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    DEFAULT         reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)
    RETURN          reduce using rule 53 (print_statement -> PRINT LPAREN string_value RPAREN .)


state 173

    (55) print_statement -> PRINT LPAREN string_value COMMA . values RPAREN
    (43) values -> . value
    (44) values -> . value COMMA values
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    values                         shift and go to state 208
    value                          shift and go to state 54
    number                         shift and go to state 42

state 174

    (56) print_statement -> PRINT LPAREN operation RPAREN .

    PRINT           reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    PRINTF          reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    INPUT           reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    IF              reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    TYPE            reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    VAR             reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    SWITCH          reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    LBRACE          reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    FOR             reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    INT             reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    $end            reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    CASE            reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)
    RETURN          reduce using rule 56 (print_statement -> PRINT LPAREN operation RPAREN .)


state 175

    (54) print_statement -> PRINTF LPAREN FORMATSTRING COMMA . values RPAREN
    (43) values -> . value
    (44) values -> . value COMMA values
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    values                         shift and go to state 209
    value                          shift and go to state 54
    number                         shift and go to state 42

state 176

    (58) input_statement -> INPUT LPAREN values RPAREN .

    PRINT           reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    PRINTF          reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    INPUT           reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    IF              reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    TYPE            reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    VAR             reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    SWITCH          reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    CHARSTRING      reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    LBRACE          reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    FOR             reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    INT             reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    FLOAT           reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    $end            reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    RBRACE          reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    CASE            reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    DEFAULT         reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)
    RETURN          reduce using rule 58 (input_statement -> INPUT LPAREN values RPAREN .)


state 177

    (59) input_statement -> INPUT LPAREN operation RPAREN .

    PRINT           reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    PRINTF          reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    INPUT           reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    IF              reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    TYPE            reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    VAR             reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    SWITCH          reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    LBRACE          reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    FOR             reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    INT             reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    $end            reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    CASE            reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)
    RETURN          reduce using rule 59 (input_statement -> INPUT LPAREN operation RPAREN .)


state 178

    (84) conditional_structure -> IF conditions conditional_body ELSE . conditional_body
    (85) conditional_structure -> IF conditions conditional_body ELSE . IF conditions conditional_body ELSE conditional_body
    (86) conditional_body -> . LBRACE statement RBRACE
    (87) conditional_body -> . LBRACE BREAK RBRACE
    (88) conditional_body -> . LBRACE CONTINUE RBRACE

    IF              shift and go to state 210
    LBRACE          shift and go to state 132

    conditional_body               shift and go to state 211

state 179

    (86) conditional_body -> LBRACE statement . RBRACE

    RBRACE          shift and go to state 212


state 180

    (87) conditional_body -> LBRACE BREAK . RBRACE

    RBRACE          shift and go to state 213


state 181

    (88) conditional_body -> LBRACE CONTINUE . RBRACE

    RBRACE          shift and go to state 214


state 182

    (90) conditions -> condition logical_operator conditions .

    LBRACE          reduce using rule 90 (conditions -> condition logical_operator conditions .)


state 183

    (91) condition -> value relational_operator value .

    AND             reduce using rule 91 (condition -> value relational_operator value .)
    OR              reduce using rule 91 (condition -> value relational_operator value .)
    NOT             reduce using rule 91 (condition -> value relational_operator value .)
    LBRACE          reduce using rule 91 (condition -> value relational_operator value .)
    SEMICOLON       reduce using rule 91 (condition -> value relational_operator value .)


state 184

    (37) structure -> TYPE VARIABLE STRUCT LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) main -> . FUNCTION MAIN LPAREN RPAREN
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 8
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! LBRACE          [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 215
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 185

    (120) defined_list -> TYPE VARIABLE LBRACE values . RBRACE

    RBRACE          shift and go to state 216


state 186

    (33) variable_declaration -> VAR VARIABLE ASSIGN value .

    PRINT           reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    PRINTF          reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    INPUT           reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    IF              reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    VARIABLE        reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    TYPE            reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    FUNCTION        reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    VAR             reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    SWITCH          reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    CHARSTRING      reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    LBRACE          reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    FOR             reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    INT             reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    FLOAT           reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    $end            reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    RBRACE          reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    CASE            reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    DEFAULT         reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)
    RETURN          reduce using rule 33 (variable_declaration -> VAR VARIABLE ASSIGN value .)


state 187

    (34) variable_declaration -> VAR VARIABLE ASSIGN list_structure .

    PRINT           reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    PRINTF          reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    INPUT           reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    IF              reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    VARIABLE        reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    TYPE            reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    FUNCTION        reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    VAR             reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    SWITCH          reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    CHARSTRING      reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    LBRACE          reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    FOR             reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    INT             reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    FLOAT           reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    $end            reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    RBRACE          reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    CASE            reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    DEFAULT         reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)
    RETURN          reduce using rule 34 (variable_declaration -> VAR VARIABLE ASSIGN list_structure .)


state 188

    (120) defined_list -> TYPE . VARIABLE LBRACE values RBRACE

    VARIABLE        shift and go to state 217


state 189

    (128) slice_structure -> VAR VARIABLE LBRACKET RBRACKET . type
    (75) type -> . INT
    (76) type -> . INT32
    (77) type -> . INT64
    (78) type -> . STRING
    (79) type -> . FLOAT
    (80) type -> . FLOAT32
    (81) type -> . FLOAT64
    (82) type -> . BOOL

    INT             shift and go to state 65
    INT32           shift and go to state 66
    INT64           shift and go to state 67
    STRING          shift and go to state 68
    FLOAT           shift and go to state 69
    FLOAT32         shift and go to state 70
    FLOAT64         shift and go to state 71
    BOOL            shift and go to state 72

    type                           shift and go to state 218

state 190

    (107) switch_structure -> SWITCH switch_expression LBRACE case_blocks . RBRACE

    RBRACE          shift and go to state 219


state 191

    (110) case_blocks -> case_block .
    (111) case_blocks -> case_block . case_blocks
    (110) case_blocks -> . case_block
    (111) case_blocks -> . case_block case_blocks
    (112) case_block -> . CASE values COLON statement
    (113) case_block -> . DEFAULT COLON statement

    RBRACE          reduce using rule 110 (case_blocks -> case_block .)
    CASE            shift and go to state 192
    DEFAULT         shift and go to state 193

    case_block                     shift and go to state 191
    case_blocks                    shift and go to state 220

state 192

    (112) case_block -> CASE . values COLON statement
    (43) values -> . value
    (44) values -> . value COMMA values
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    values                         shift and go to state 221
    value                          shift and go to state 54
    number                         shift and go to state 42

state 193

    (113) case_block -> DEFAULT . COLON statement

    COLON           shift and go to state 222


state 194

    (104) for_initialization -> FOR VARIABLE SHORTASSIGN value . SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 223


state 195

    (106) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE . SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 224


state 196

    (105) for_infinite_bucle -> FOR LBRACE statement RBRACE .

    PRINT           reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    PRINTF          reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INPUT           reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    IF              reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    TYPE            reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VAR             reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    SWITCH          reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    LBRACE          reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FOR             reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INT             reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FLOAT           reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    $end            reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RBRACE          reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CASE            reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RETURN          reduce using rule 105 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)


state 197

    (7) statement -> import main LBRACE blocks RBRACE .

    $end            reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)
    CASE            reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)


state 198

    (8) statement -> package import main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 225


state 199

    (6) statement -> package main LBRACE blocks RBRACE .

    $end            reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)
    CASE            reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)


state 200

    (121) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type . RBRACKET type LBRACE map_values RBRACE

    RBRACKET        shift and go to state 226


state 201

    (127) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type . LBRACE values RBRACE
    (129) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .

  ! shift/reduce conflict for LBRACE resolved as shift
    LBRACE          shift and go to state 227
    PRINT           reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    PRINTF          reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    INPUT           reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    IF              reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    TYPE            reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FUNCTION        reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    VAR             reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CHARSTRING      reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FOR             reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    INT             reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FLOAT           reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    $end            reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CASE            reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    RETURN          reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)

  ! LBRACE          [ reduce using rule 129 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .) ]


state 202

    (122) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN

    LBRACKET        shift and go to state 228


state 203

    (126) map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN . string_value
    (45) string_value -> . value
    (46) string_value -> . CHARSTRING
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    CHARSTRING      shift and go to state 116
    VARIABLE        shift and go to state 55
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    string_value                   shift and go to state 229
    value                          shift and go to state 115
    number                         shift and go to state 42

state 204

    (131) append_statement -> APPEND LPAREN VARIABLE . COMMA values RPAREN

    COMMA           shift and go to state 230


state 205

    (38) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE . blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    blocks                         shift and go to state 231
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 206

    (40) function -> FUNCTION VARIABLE LPAREN RPAREN type . LBRACE RETURN value RBRACE

    LBRACE          shift and go to state 232


state 207

    (39) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . LBRACE blocks RBRACE
    (41) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . type LBRACE RETURN value RBRACE
    (42) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . type LBRACE blocks RETURN value RBRACE
    (75) type -> . INT
    (76) type -> . INT32
    (77) type -> . INT64
    (78) type -> . STRING
    (79) type -> . FLOAT
    (80) type -> . FLOAT32
    (81) type -> . FLOAT64
    (82) type -> . BOOL

    LBRACE          shift and go to state 233
    INT             shift and go to state 65
    INT32           shift and go to state 66
    INT64           shift and go to state 67
    STRING          shift and go to state 68
    FLOAT           shift and go to state 69
    FLOAT32         shift and go to state 70
    FLOAT64         shift and go to state 71
    BOOL            shift and go to state 72

    type                           shift and go to state 234

state 208

    (55) print_statement -> PRINT LPAREN string_value COMMA values . RPAREN

    RPAREN          shift and go to state 235


state 209

    (54) print_statement -> PRINTF LPAREN FORMATSTRING COMMA values . RPAREN

    RPAREN          shift and go to state 236


state 210

    (85) conditional_structure -> IF conditions conditional_body ELSE IF . conditions conditional_body ELSE conditional_body
    (89) conditions -> . condition
    (90) conditions -> . condition logical_operator conditions
    (91) condition -> . value relational_operator value
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    conditions                     shift and go to state 237
    condition                      shift and go to state 79
    value                          shift and go to state 80
    number                         shift and go to state 42

state 211

    (84) conditional_structure -> IF conditions conditional_body ELSE conditional_body .

    PRINT           reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    PRINTF          reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    SWITCH          reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CHARSTRING      reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    LBRACE          reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CASE            reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    DEFAULT         reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RETURN          reduce using rule 84 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)


state 212

    (86) conditional_body -> LBRACE statement RBRACE .

    ELSE            reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    PRINT           reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    PRINTF          reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    INPUT           reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    IF              reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    TYPE            reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    VAR             reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    SWITCH          reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    LBRACE          reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    FOR             reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    INT             reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    FLOAT           reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    $end            reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    RBRACE          reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    CASE            reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)
    RETURN          reduce using rule 86 (conditional_body -> LBRACE statement RBRACE .)


state 213

    (87) conditional_body -> LBRACE BREAK RBRACE .

    ELSE            reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    PRINT           reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    PRINTF          reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    INPUT           reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    IF              reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    VARIABLE        reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    TYPE            reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    FUNCTION        reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    VAR             reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    SWITCH          reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    CHARSTRING      reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    LBRACE          reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    FOR             reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    INT             reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    FLOAT           reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    $end            reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    RBRACE          reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    CASE            reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    DEFAULT         reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)
    RETURN          reduce using rule 87 (conditional_body -> LBRACE BREAK RBRACE .)


state 214

    (88) conditional_body -> LBRACE CONTINUE RBRACE .

    ELSE            reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    PRINT           reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    PRINTF          reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INPUT           reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    IF              reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VARIABLE        reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    TYPE            reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FUNCTION        reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VAR             reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    SWITCH          reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CHARSTRING      reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    LBRACE          reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FOR             reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INT             reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FLOAT           reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    $end            reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RBRACE          reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CASE            reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    DEFAULT         reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RETURN          reduce using rule 88 (conditional_body -> LBRACE CONTINUE RBRACE .)


state 215

    (37) structure -> TYPE VARIABLE STRUCT LBRACE statement . RBRACE

    RBRACE          shift and go to state 238


state 216

    (120) defined_list -> TYPE VARIABLE LBRACE values RBRACE .

    PRINT           reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    PRINTF          reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    INPUT           reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    IF              reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    VARIABLE        reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    TYPE            reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    FUNCTION        reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    VAR             reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    SWITCH          reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    LBRACE          reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    FOR             reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    INT             reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    FLOAT           reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    $end            reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    RBRACE          reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    CASE            reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    DEFAULT         reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)
    RETURN          reduce using rule 120 (defined_list -> TYPE VARIABLE LBRACE values RBRACE .)


state 217

    (120) defined_list -> TYPE VARIABLE . LBRACE values RBRACE

    LBRACE          shift and go to state 147


state 218

    (128) slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .

    PRINT           reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    PRINTF          reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    INPUT           reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    IF              reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    TYPE            reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FUNCTION        reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    VAR             reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CHARSTRING      reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    LBRACE          reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FOR             reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    INT             reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FLOAT           reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    $end            reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CASE            reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    RETURN          reduce using rule 128 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)


state 219

    (107) switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .

    PRINT           reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    PRINTF          reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    INPUT           reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    IF              reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    VARIABLE        reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    TYPE            reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FUNCTION        reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    VAR             reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    SWITCH          reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CHARSTRING      reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    LBRACE          reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FOR             reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    INT             reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FLOAT           reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    $end            reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    RBRACE          reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CASE            reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    DEFAULT         reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    RETURN          reduce using rule 107 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)


state 220

    (111) case_blocks -> case_block case_blocks .

    RBRACE          reduce using rule 111 (case_blocks -> case_block case_blocks .)


state 221

    (112) case_block -> CASE values . COLON statement

    COLON           shift and go to state 239


state 222

    (113) case_block -> DEFAULT COLON . statement
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) main -> . FUNCTION MAIN LPAREN RPAREN
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 8
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! LBRACE          [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 240
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 223

    (104) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON . condition SEMICOLON value double_operator LBRACE statement RBRACE
    (91) condition -> . value relational_operator value
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    value                          shift and go to state 80
    condition                      shift and go to state 241
    number                         shift and go to state 42

state 224

    (106) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN . RANGE VARIABLE LBRACE statement RBRACE

    RANGE           shift and go to state 242


state 225

    (8) statement -> package import main LBRACE blocks RBRACE .

    $end            reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)
    CASE            reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)


state 226

    (121) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET . type LBRACE map_values RBRACE
    (75) type -> . INT
    (76) type -> . INT32
    (77) type -> . INT64
    (78) type -> . STRING
    (79) type -> . FLOAT
    (80) type -> . FLOAT32
    (81) type -> . FLOAT64
    (82) type -> . BOOL

    INT             shift and go to state 65
    INT32           shift and go to state 66
    INT64           shift and go to state 67
    STRING          shift and go to state 68
    FLOAT           shift and go to state 69
    FLOAT32         shift and go to state 70
    FLOAT64         shift and go to state 71
    BOOL            shift and go to state 72

    type                           shift and go to state 243

state 227

    (127) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE . values RBRACE
    (43) values -> . value
    (44) values -> . value COMMA values
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    values                         shift and go to state 244
    value                          shift and go to state 54
    number                         shift and go to state 42

state 228

    (122) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (75) type -> . INT
    (76) type -> . INT32
    (77) type -> . INT64
    (78) type -> . STRING
    (79) type -> . FLOAT
    (80) type -> . FLOAT32
    (81) type -> . FLOAT64
    (82) type -> . BOOL

    INT             shift and go to state 65
    INT32           shift and go to state 66
    INT64           shift and go to state 67
    STRING          shift and go to state 68
    FLOAT           shift and go to state 69
    FLOAT32         shift and go to state 70
    FLOAT64         shift and go to state 71
    BOOL            shift and go to state 72

    type                           shift and go to state 245

state 229

    (126) map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .

    PRINT           reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    PRINTF          reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    INPUT           reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    IF              reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    VARIABLE        reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    TYPE            reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    FUNCTION        reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    VAR             reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    SWITCH          reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    CHARSTRING      reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    LBRACE          reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    FOR             reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    INT             reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    FLOAT           reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    $end            reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    RBRACE          reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    CASE            reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    DEFAULT         reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)
    RETURN          reduce using rule 126 (map_assign -> VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value .)


state 230

    (131) append_statement -> APPEND LPAREN VARIABLE COMMA . values RPAREN
    (43) values -> . value
    (44) values -> . value COMMA values
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    values                         shift and go to state 246
    value                          shift and go to state 54
    number                         shift and go to state 42

state 231

    (38) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 247


state 232

    (40) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE . RETURN value RBRACE

    RETURN          shift and go to state 248


state 233

    (39) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE . blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    parameters                     shift and go to state 23
    blocks                         shift and go to state 249
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 234

    (41) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type . LBRACE RETURN value RBRACE
    (42) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type . LBRACE blocks RETURN value RBRACE

    LBRACE          shift and go to state 250


state 235

    (55) print_statement -> PRINT LPAREN string_value COMMA values RPAREN .

    PRINT           reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    PRINTF          reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    INPUT           reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    IF              reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    VARIABLE        reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    TYPE            reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    FUNCTION        reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    VAR             reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    SWITCH          reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    CHARSTRING      reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    LBRACE          reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    FOR             reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    INT             reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    FLOAT           reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    $end            reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    RBRACE          reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    CASE            reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    DEFAULT         reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)
    RETURN          reduce using rule 55 (print_statement -> PRINT LPAREN string_value COMMA values RPAREN .)


state 236

    (54) print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .

    PRINT           reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    PRINTF          reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    INPUT           reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    IF              reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    VARIABLE        reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    TYPE            reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FUNCTION        reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    VAR             reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    SWITCH          reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CHARSTRING      reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    LBRACE          reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FOR             reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    INT             reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FLOAT           reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    $end            reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    RBRACE          reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CASE            reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    DEFAULT         reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    RETURN          reduce using rule 54 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)


state 237

    (85) conditional_structure -> IF conditions conditional_body ELSE IF conditions . conditional_body ELSE conditional_body
    (86) conditional_body -> . LBRACE statement RBRACE
    (87) conditional_body -> . LBRACE BREAK RBRACE
    (88) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 132

    conditional_body               shift and go to state 251

state 238

    (37) structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .

    PRINT           reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    PRINTF          reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    INPUT           reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    IF              reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    TYPE            reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    VAR             reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    SWITCH          reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    LBRACE          reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    FOR             reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    INT             reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    FLOAT           reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    $end            reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    RBRACE          reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    CASE            reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)
    RETURN          reduce using rule 37 (structure -> TYPE VARIABLE STRUCT LBRACE statement RBRACE .)


state 239

    (112) case_block -> CASE values COLON . statement
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) main -> . FUNCTION MAIN LPAREN RPAREN
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 8
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! LBRACE          [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 252
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 240

    (113) case_block -> DEFAULT COLON statement .

    CASE            reduce using rule 113 (case_block -> DEFAULT COLON statement .)
    DEFAULT         reduce using rule 113 (case_block -> DEFAULT COLON statement .)
    RBRACE          reduce using rule 113 (case_block -> DEFAULT COLON statement .)


state 241

    (104) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition . SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 253


state 242

    (106) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE . VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 254


state 243

    (121) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type . LBRACE map_values RBRACE

    LBRACE          shift and go to state 255


state 244

    (127) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values . RBRACE

    RBRACE          shift and go to state 256


state 245

    (122) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN

    RBRACKET        shift and go to state 257


state 246

    (131) append_statement -> APPEND LPAREN VARIABLE COMMA values . RPAREN

    RPAREN          shift and go to state 258


state 247

    (38) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .

    PRINT           reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    LBRACE          reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CASE            reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    RETURN          reduce using rule 38 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)


state 248

    (40) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN . value RBRACE
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    value                          shift and go to state 259
    number                         shift and go to state 42

state 249

    (39) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 260


state 250

    (41) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE . RETURN value RBRACE
    (42) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE . blocks RETURN value RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

    RETURN          shift and go to state 261
    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    FUNCTION        shift and go to state 57
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    parameters                     shift and go to state 23
    value                          shift and go to state 31
    blocks                         shift and go to state 262
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 251

    (85) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body . ELSE conditional_body

    ELSE            shift and go to state 263


state 252

    (112) case_block -> CASE values COLON statement .

    CASE            reduce using rule 112 (case_block -> CASE values COLON statement .)
    DEFAULT         reduce using rule 112 (case_block -> CASE values COLON statement .)
    RBRACE          reduce using rule 112 (case_block -> CASE values COLON statement .)


state 253

    (104) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON . value double_operator LBRACE statement RBRACE
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    value                          shift and go to state 264
    number                         shift and go to state 42

state 254

    (106) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE . LBRACE statement RBRACE

    LBRACE          shift and go to state 265


state 255

    (121) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE . map_values RBRACE
    (123) map_values -> . map_value
    (124) map_values -> . map_value COMMA map_values
    (125) map_value -> . string_value COLON string_value
    (45) string_value -> . value
    (46) string_value -> . CHARSTRING
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    CHARSTRING      shift and go to state 116
    VARIABLE        shift and go to state 55
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    map_values                     shift and go to state 266
    map_value                      shift and go to state 267
    string_value                   shift and go to state 268
    value                          shift and go to state 115
    number                         shift and go to state 42

state 256

    (127) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .

    PRINT           reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    PRINTF          reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    INPUT           reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    IF              reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    VARIABLE        reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    TYPE            reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FUNCTION        reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    VAR             reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    SWITCH          reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    LBRACE          reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FOR             reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    INT             reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FLOAT           reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    $end            reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    RBRACE          reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CASE            reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    DEFAULT         reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    RETURN          reduce using rule 127 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)


state 257

    (122) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (75) type -> . INT
    (76) type -> . INT32
    (77) type -> . INT64
    (78) type -> . STRING
    (79) type -> . FLOAT
    (80) type -> . FLOAT32
    (81) type -> . FLOAT64
    (82) type -> . BOOL

    INT             shift and go to state 65
    INT32           shift and go to state 66
    INT64           shift and go to state 67
    STRING          shift and go to state 68
    FLOAT           shift and go to state 69
    FLOAT32         shift and go to state 70
    FLOAT64         shift and go to state 71
    BOOL            shift and go to state 72

    type                           shift and go to state 269

state 258

    (131) append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .

    PRINT           reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    PRINTF          reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    INPUT           reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    IF              reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    VARIABLE        reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    TYPE            reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FUNCTION        reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    VAR             reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    SWITCH          reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CHARSTRING      reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    LBRACE          reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FOR             reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    INT             reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FLOAT           reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    $end            reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    RBRACE          reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CASE            reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    DEFAULT         reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    RETURN          reduce using rule 131 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)


state 259

    (40) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value . RBRACE

    RBRACE          shift and go to state 270


state 260

    (39) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .

    PRINT           reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    LBRACE          reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CASE            reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    RETURN          reduce using rule 39 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)


state 261

    (41) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN . value RBRACE
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    value                          shift and go to state 271
    number                         shift and go to state 42

state 262

    (42) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks . RETURN value RBRACE

    RETURN          shift and go to state 272


state 263

    (85) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE . conditional_body
    (86) conditional_body -> . LBRACE statement RBRACE
    (87) conditional_body -> . LBRACE BREAK RBRACE
    (88) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 132

    conditional_body               shift and go to state 273

state 264

    (104) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value . double_operator LBRACE statement RBRACE
    (69) double_operator -> . INCREMENT
    (70) double_operator -> . DECREMENT

    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89

    double_operator                shift and go to state 274

state 265

    (106) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) main -> . FUNCTION MAIN LPAREN RPAREN
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 8
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! LBRACE          [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 275
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    value                          shift and go to state 31
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 266

    (121) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values . RBRACE

    RBRACE          shift and go to state 276


state 267

    (123) map_values -> map_value .
    (124) map_values -> map_value . COMMA map_values

    RBRACE          reduce using rule 123 (map_values -> map_value .)
    COMMA           shift and go to state 277


state 268

    (125) map_value -> string_value . COLON string_value

    COLON           shift and go to state 278


state 269

    (122) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN

    RPAREN          shift and go to state 279


state 270

    (40) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .

    PRINT           reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    PRINTF          reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    INPUT           reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    IF              reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    VARIABLE        reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    TYPE            reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    FUNCTION        reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    VAR             reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    SWITCH          reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    CHARSTRING      reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    LBRACE          reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    FOR             reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    INT             reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    FLOAT           reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    $end            reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    RBRACE          reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    CASE            reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    DEFAULT         reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)
    RETURN          reduce using rule 40 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE .)


state 271

    (41) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value . RBRACE

    RBRACE          shift and go to state 280


state 272

    (42) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN . value RBRACE
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    VARIABLE        shift and go to state 55
    CHARSTRING      shift and go to state 9
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    value                          shift and go to state 281
    number                         shift and go to state 42

state 273

    (85) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .

    PRINT           reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    PRINTF          reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    SWITCH          reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CHARSTRING      reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    LBRACE          reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CASE            reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    DEFAULT         reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RETURN          reduce using rule 85 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)


state 274

    (104) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator . LBRACE statement RBRACE

    LBRACE          shift and go to state 282


state 275

    (106) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement . RBRACE

    RBRACE          shift and go to state 283


state 276

    (121) map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .

    PRINT           reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    PRINTF          reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INPUT           reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    IF              reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VARIABLE        reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    TYPE            reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FUNCTION        reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VAR             reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    SWITCH          reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CHARSTRING      reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    LBRACE          reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FOR             reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INT             reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FLOAT           reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    $end            reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RBRACE          reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CASE            reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    DEFAULT         reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RETURN          reduce using rule 121 (map_estructure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)


state 277

    (124) map_values -> map_value COMMA . map_values
    (123) map_values -> . map_value
    (124) map_values -> . map_value COMMA map_values
    (125) map_value -> . string_value COLON string_value
    (45) string_value -> . value
    (46) string_value -> . CHARSTRING
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    CHARSTRING      shift and go to state 116
    VARIABLE        shift and go to state 55
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    map_value                      shift and go to state 267
    map_values                     shift and go to state 284
    string_value                   shift and go to state 268
    value                          shift and go to state 115
    number                         shift and go to state 42

state 278

    (125) map_value -> string_value COLON . string_value
    (45) string_value -> . value
    (46) string_value -> . CHARSTRING
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (50) number -> . INT
    (51) number -> . FLOAT

    CHARSTRING      shift and go to state 116
    VARIABLE        shift and go to state 55
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

    string_value                   shift and go to state 285
    value                          shift and go to state 115
    number                         shift and go to state 42

state 279

    (122) map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .

    PRINT           reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    PRINTF          reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INPUT           reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    IF              reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TYPE            reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FUNCTION        reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VAR             reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SWITCH          reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CHARSTRING      reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LBRACE          reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FOR             reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INT             reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FLOAT           reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    $end            reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RBRACE          reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CASE            reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RETURN          reduce using rule 122 (map_estructure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)


state 280

    (41) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .

    PRINT           reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    PRINTF          reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    INPUT           reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    IF              reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    VARIABLE        reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    TYPE            reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    FUNCTION        reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    VAR             reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    SWITCH          reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    CHARSTRING      reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    LBRACE          reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    FOR             reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    INT             reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    FLOAT           reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    $end            reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    RBRACE          reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    CASE            reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    DEFAULT         reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)
    RETURN          reduce using rule 41 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE .)


state 281

    (42) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value . RBRACE

    RBRACE          shift and go to state 286


state 282

    (104) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (16) blocks -> . block
    (17) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) main -> . FUNCTION MAIN LPAREN RPAREN
    (18) block -> . print_statement
    (19) block -> . input_statement
    (20) block -> . conditional_structure
    (21) block -> . operation
    (22) block -> . list_structure
    (23) block -> . map_estructure
    (24) block -> . map_assign
    (25) block -> . for_estructure
    (26) block -> . structure
    (27) block -> . function
    (28) block -> . parameters
    (29) block -> . variable_declaration
    (30) block -> . switch_structure
    (31) block -> . slice_structure
    (52) print_statement -> . PRINT LPAREN values RPAREN
    (53) print_statement -> . PRINT LPAREN string_value RPAREN
    (54) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (55) print_statement -> . PRINT LPAREN string_value COMMA values RPAREN
    (56) print_statement -> . PRINT LPAREN operation RPAREN
    (57) print_statement -> . PRINT LPAREN RPAREN
    (58) input_statement -> . INPUT LPAREN values RPAREN
    (59) input_statement -> . INPUT LPAREN operation RPAREN
    (60) input_statement -> . INPUT LPAREN RPAREN
    (83) conditional_structure -> . IF conditions conditional_body
    (84) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (85) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (61) operation -> . value operator value
    (62) operation -> . value operator operation
    (63) operation -> . value double_operator
    (115) list_structure -> . empty_list
    (116) list_structure -> . list_with_data
    (117) list_structure -> . defined_list
    (121) map_estructure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (122) map_estructure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (126) map_assign -> . VARIABLE LBRACKET string_value RBRACKET ASSIGN string_value
    (101) for_estructure -> . for_initialization
    (102) for_estructure -> . for_infinite_bucle
    (103) for_estructure -> . for_iterator
    (37) structure -> . TYPE VARIABLE STRUCT LBRACE statement RBRACE
    (38) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (39) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (40) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE RETURN value RBRACE
    (41) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE RETURN value RBRACE
    (42) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE
    (71) parameters -> . parameter
    (72) parameters -> . parameter parameters
    (73) parameters -> . parameter COMMA parameters
    (32) variable_declaration -> . VAR VARIABLE type
    (33) variable_declaration -> . VAR VARIABLE ASSIGN value
    (34) variable_declaration -> . VAR VARIABLE ASSIGN list_structure
    (35) variable_declaration -> . VARIABLE SHORTASSIGN value
    (36) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (107) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (127) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (128) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (129) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (130) slice_structure -> . VARIABLE ASSIGN append_statement
    (47) value -> . VARIABLE
    (48) value -> . number
    (49) value -> . CHARSTRING
    (118) empty_list -> . LBRACE RBRACE
    (119) list_with_data -> . LBRACE values RBRACE
    (120) defined_list -> . TYPE VARIABLE LBRACE values RBRACE
    (104) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (105) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (106) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (74) parameter -> . VARIABLE type
    (50) number -> . INT
    (51) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 8
    PACKAGE         shift and go to state 10
    FUNCTION        shift and go to state 12
    PRINT           shift and go to state 27
    PRINTF          shift and go to state 28
    INPUT           shift and go to state 29
    IF              shift and go to state 30
    VARIABLE        shift and go to state 11
    TYPE            shift and go to state 38
    VAR             shift and go to state 40
    SWITCH          shift and go to state 41
    CHARSTRING      shift and go to state 9
    LBRACE          shift and go to state 6
    FOR             shift and go to state 43
    INT             shift and go to state 44
    FLOAT           shift and go to state 45

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! LBRACE          [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    value                          shift and go to state 31
    statement                      shift and go to state 287
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 7
    print_statement                shift and go to state 13
    input_statement                shift and go to state 14
    conditional_structure          shift and go to state 15
    operation                      shift and go to state 16
    list_structure                 shift and go to state 17
    map_estructure                 shift and go to state 18
    map_assign                     shift and go to state 19
    for_estructure                 shift and go to state 20
    structure                      shift and go to state 21
    function                       shift and go to state 22
    parameters                     shift and go to state 23
    variable_declaration           shift and go to state 24
    switch_structure               shift and go to state 25
    slice_structure                shift and go to state 26
    empty_list                     shift and go to state 32
    list_with_data                 shift and go to state 33
    defined_list                   shift and go to state 34
    for_initialization             shift and go to state 35
    for_infinite_bucle             shift and go to state 36
    for_iterator                   shift and go to state 37
    parameter                      shift and go to state 39
    number                         shift and go to state 42

state 283

    (106) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .

    PRINT           reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    PRINTF          reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INPUT           reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    IF              reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    TYPE            reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VAR             reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    SWITCH          reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    LBRACE          reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FOR             reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INT             reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FLOAT           reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    $end            reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RBRACE          reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CASE            reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RETURN          reduce using rule 106 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)


state 284

    (124) map_values -> map_value COMMA map_values .

    RBRACE          reduce using rule 124 (map_values -> map_value COMMA map_values .)


state 285

    (125) map_value -> string_value COLON string_value .

    COMMA           reduce using rule 125 (map_value -> string_value COLON string_value .)
    RBRACE          reduce using rule 125 (map_value -> string_value COLON string_value .)


state 286

    (42) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .

    PRINT           reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    PRINTF          reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    INPUT           reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    IF              reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    VARIABLE        reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    TYPE            reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    FUNCTION        reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    VAR             reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    SWITCH          reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    CHARSTRING      reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    LBRACE          reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    FOR             reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    INT             reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    FLOAT           reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    $end            reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    RBRACE          reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    CASE            reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    DEFAULT         reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)
    RETURN          reduce using rule 42 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks RETURN value RBRACE .)


state 287

    (104) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement . RBRACE

    RBRACE          shift and go to state 288


state 288

    (104) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .

    PRINT           reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    PRINTF          reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INPUT           reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    IF              reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    TYPE            reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VAR             reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    SWITCH          reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    LBRACE          reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FOR             reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INT             reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FLOAT           reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    $end            reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RBRACE          reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CASE            reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RETURN          reduce using rule 104 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FUNCTION in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 0 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 0 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for VAR in state 0 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 0 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 0 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 4 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 4 resolved as shift
WARNING: shift/reduce conflict for IF in state 4 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 4 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 4 resolved as shift
WARNING: shift/reduce conflict for VAR in state 4 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 4 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 4 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 4 resolved as shift
WARNING: shift/reduce conflict for FOR in state 4 resolved as shift
WARNING: shift/reduce conflict for INT in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 11 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 39 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 99 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 99 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 99 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 99 resolved as shift
WARNING: shift/reduce conflict for IF in state 99 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 99 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 99 resolved as shift
WARNING: shift/reduce conflict for VAR in state 99 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 99 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 99 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 99 resolved as shift
WARNING: shift/reduce conflict for FOR in state 99 resolved as shift
WARNING: shift/reduce conflict for INT in state 99 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 99 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 125 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 132 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 132 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 132 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 132 resolved as shift
WARNING: shift/reduce conflict for IF in state 132 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 132 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 132 resolved as shift
WARNING: shift/reduce conflict for VAR in state 132 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 132 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 132 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 132 resolved as shift
WARNING: shift/reduce conflict for FOR in state 132 resolved as shift
WARNING: shift/reduce conflict for INT in state 132 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 132 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 184 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 184 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 184 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 184 resolved as shift
WARNING: shift/reduce conflict for IF in state 184 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 184 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 184 resolved as shift
WARNING: shift/reduce conflict for VAR in state 184 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 184 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 184 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 184 resolved as shift
WARNING: shift/reduce conflict for FOR in state 184 resolved as shift
WARNING: shift/reduce conflict for INT in state 184 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 184 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 201 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 222 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 222 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 222 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 222 resolved as shift
WARNING: shift/reduce conflict for IF in state 222 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 222 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 222 resolved as shift
WARNING: shift/reduce conflict for VAR in state 222 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 222 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 222 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 222 resolved as shift
WARNING: shift/reduce conflict for FOR in state 222 resolved as shift
WARNING: shift/reduce conflict for INT in state 222 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 222 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 239 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 239 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 239 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 239 resolved as shift
WARNING: shift/reduce conflict for IF in state 239 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 239 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 239 resolved as shift
WARNING: shift/reduce conflict for VAR in state 239 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 239 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 239 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 239 resolved as shift
WARNING: shift/reduce conflict for FOR in state 239 resolved as shift
WARNING: shift/reduce conflict for INT in state 239 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 239 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 265 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 265 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 265 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 265 resolved as shift
WARNING: shift/reduce conflict for IF in state 265 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 265 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 265 resolved as shift
WARNING: shift/reduce conflict for VAR in state 265 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 265 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 265 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 265 resolved as shift
WARNING: shift/reduce conflict for FOR in state 265 resolved as shift
WARNING: shift/reduce conflict for INT in state 265 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 265 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 282 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 282 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 282 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 282 resolved as shift
WARNING: shift/reduce conflict for IF in state 282 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 282 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 282 resolved as shift
WARNING: shift/reduce conflict for VAR in state 282 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 282 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 282 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 282 resolved as shift
WARNING: shift/reduce conflict for FOR in state 282 resolved as shift
WARNING: shift/reduce conflict for INT in state 282 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 282 resolved as shift
WARNING: reduce/reduce conflict in state 116 resolved using rule (string_value -> CHARSTRING)
WARNING: rejected rule (value -> CHARSTRING) in state 116
WARNING: reduce/reduce conflict in state 125 resolved using rule (values -> value)
WARNING: rejected rule (string_value -> value) in state 125
