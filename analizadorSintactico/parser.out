Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    FALSE
    IDENTIFIER
    MOD
    TEXT
    TRUE

Grammar

Rule 0     S' -> statement
Rule 1     statement -> blocks
Rule 2     statement -> import blocks
Rule 3     statement -> package blocks
Rule 4     statement -> package import blocks
Rule 5     statement -> main LBRACE blocks RBRACE
Rule 6     statement -> package main LBRACE blocks RBRACE
Rule 7     statement -> import main LBRACE blocks RBRACE
Rule 8     statement -> package import main LBRACE blocks RBRACE
Rule 9     import -> <empty>
Rule 10    import -> IMPORT CHARSTRING
Rule 11    import -> IMPORT LPAREN values_for_import RPAREN
Rule 12    values_for_import -> CHARSTRING
Rule 13    values_for_import -> CHARSTRING values_for_import
Rule 14    package -> PACKAGE VARIABLE
Rule 15    package -> PACKAGE MAIN
Rule 16    main -> FUNCTION MAIN LPAREN RPAREN
Rule 17    blocks -> block
Rule 18    blocks -> block blocks
Rule 19    block -> print_statement
Rule 20    block -> input_statement
Rule 21    block -> operation
Rule 22    block -> data_structure
Rule 23    block -> control_structure
Rule 24    block -> function
Rule 25    block -> parameters
Rule 26    block -> variable_declaration
Rule 27    block -> variable_assignation
Rule 28    variable_declaration -> VAR VARIABLE type
Rule 29    variable_declaration -> VAR VARIABLE type ASSIGN value
Rule 30    variable_declaration -> VARIABLE SHORTASSIGN value
Rule 31    variable_declaration -> VARIABLE SHORTASSIGN operation
Rule 32    variable_declaration -> CONST VARIABLE ASSIGN value
Rule 33    variable_assignation -> VARIABLE assignation value
Rule 34    variable_assignation -> VARIABLE assignation operation
Rule 35    variable_assignation -> VARIABLE double_operator
Rule 36    variable_assignation -> map_assign
Rule 37    variable_assignation -> array_assign
Rule 38    assignation -> ASSIGN
Rule 39    assignation -> PLUSASSIGN
Rule 40    assignation -> MINUSASSIGN
Rule 41    assignation -> TIMESASSIGN
Rule 42    assignation -> DIVIDEASSIGN
Rule 43    assignation -> MODASSIGN
Rule 44    function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
Rule 45    function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
Rule 46    function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
Rule 47    function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
Rule 48    function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
Rule 49    function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
Rule 50    return -> RETURN values
Rule 51    return -> RETURN value LBRACKET value RBRACKET
Rule 52    return -> RETURN value PERIOD value
Rule 53    values -> value
Rule 54    values -> value COMMA values
Rule 55    value -> VARIABLE
Rule 56    value -> not_variable_value
Rule 57    not_variable_value -> CHARSTRING
Rule 58    not_variable_value -> number
Rule 59    number -> INT
Rule 60    number -> FLOAT
Rule 61    print_statement -> PRINT LPAREN values RPAREN
Rule 62    print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN
Rule 63    print_statement -> PRINT LPAREN operation RPAREN
Rule 64    print_statement -> PRINT LPAREN RPAREN
Rule 65    input_statement -> INPUT LPAREN values RPAREN
Rule 66    input_statement -> INPUT LPAREN operation RPAREN
Rule 67    input_statement -> INPUT LPAREN RPAREN
Rule 68    operation -> value operator value
Rule 69    operation -> value operator operation
Rule 70    operation -> value double_operator
Rule 71    operator -> PLUS
Rule 72    operator -> MINUS
Rule 73    operator -> TIMES
Rule 74    operator -> DIVIDE
Rule 75    operator -> ASSIGN
Rule 76    double_operator -> INCREMENT
Rule 77    double_operator -> DECREMENT
Rule 78    parameters -> parameter
Rule 79    parameters -> parameter COMMA parameters
Rule 80    parameter -> VARIABLE type
Rule 81    type -> INT
Rule 82    type -> INT32
Rule 83    type -> INT64
Rule 84    type -> STRING
Rule 85    type -> FLOAT
Rule 86    type -> FLOAT32
Rule 87    type -> FLOAT64
Rule 88    type -> BOOL
Rule 89    control_structure -> conditional_structure
Rule 90    control_structure -> for_estructure
Rule 91    control_structure -> switch_structure
Rule 92    conditional_structure -> IF conditions conditional_body
Rule 93    conditional_structure -> IF conditions conditional_body ELSE conditional_body
Rule 94    conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
Rule 95    conditional_body -> LBRACE statement RBRACE
Rule 96    conditional_body -> LBRACE BREAK RBRACE
Rule 97    conditional_body -> LBRACE CONTINUE RBRACE
Rule 98    conditions -> condition
Rule 99    conditions -> condition logical_operator conditions
Rule 100   condition -> value relational_operator value
Rule 101   logical_operator -> AND
Rule 102   logical_operator -> OR
Rule 103   logical_operator -> NOT
Rule 104   relational_operator -> GREATER
Rule 105   relational_operator -> LESS
Rule 106   relational_operator -> GREATEREQUALS
Rule 107   relational_operator -> LESSEQUALS
Rule 108   relational_operator -> EQUALS
Rule 109   relational_operator -> DIFFERENT
Rule 110   for_estructure -> for_initialization
Rule 111   for_estructure -> for_infinite_bucle
Rule 112   for_estructure -> for_iterator
Rule 113   for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
Rule 114   for_infinite_bucle -> FOR LBRACE statement RBRACE
Rule 115   for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
Rule 116   switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE
Rule 117   switch_expression -> value
Rule 118   switch_expression -> empty
Rule 119   case_blocks -> case_block
Rule 120   case_blocks -> case_block case_blocks
Rule 121   case_block -> CASE values COLON statement
Rule 122   case_block -> DEFAULT COLON statement
Rule 123   empty -> <empty>
Rule 124   data_structure -> array_structure
Rule 125   data_structure -> map_structure
Rule 126   data_structure -> slice_structure
Rule 127   data_structure -> struct_structure
Rule 128   struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
Rule 129   struct_fields -> struct_field
Rule 130   struct_fields -> struct_field struct_fields
Rule 131   struct_field -> VARIABLE type
Rule 132   array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type
Rule 133   array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
Rule 134   array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value
Rule 135   map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
Rule 136   map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
Rule 137   map_values -> map_value
Rule 138   map_values -> map_value COMMA map_values
Rule 139   map_value -> value COLON value
Rule 140   map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value
Rule 141   slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
Rule 142   slice_structure -> VAR VARIABLE LBRACKET RBRACKET type
Rule 143   slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type
Rule 144   slice_structure -> VARIABLE ASSIGN append_statement
Rule 145   append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 101
APPEND               : 145
ASSIGN               : 29 32 38 75 133 134 140 144
BOOL                 : 88
BREAK                : 96
CASE                 : 121
CHARSTRING           : 10 12 13 57
COLON                : 121 122 139
COMMA                : 54 62 79 138 145
CONST                : 32
CONTINUE             : 97
DECREMENT            : 77
DEFAULT              : 122
DIFFERENT            : 109
DIVIDE               : 74
DIVIDEASSIGN         : 42
ELSE                 : 93 94 94
EQUALS               : 108
FALSE                : 
FLOAT                : 60 85
FLOAT32              : 86
FLOAT64              : 87
FOR                  : 113 114 115
FORMATSTRING         : 62
FUNCTION             : 16 44 45 46 47 48 49
GREATER              : 104
GREATEREQUALS        : 106
IDENTIFIER           : 
IF                   : 92 93 94 94
IMPORT               : 10 11
INCREMENT            : 76
INPUT                : 65 66 67
INT                  : 59 81 132 133 134
INT32                : 82
INT64                : 83
LBRACE               : 5 6 7 8 44 45 46 47 48 49 95 96 97 113 114 115 116 128 133 135 141
LBRACKET             : 51 132 133 134 135 136 140 141 142 143
LESS                 : 105
LESSEQUALS           : 107
LPAREN               : 11 16 44 45 46 47 48 49 61 62 63 64 65 66 67 136 145
MAIN                 : 15 16
MAKE                 : 136
MAP                  : 135 136
MINUS                : 72
MINUSASSIGN          : 40
MOD                  : 
MODASSIGN            : 43
NOT                  : 103
OR                   : 102
PACKAGE              : 14 15
PERIOD               : 52
PLUS                 : 71
PLUSASSIGN           : 39
PRINT                : 61 63 64
PRINTF               : 62
RANGE                : 115
RBRACE               : 5 6 7 8 44 45 46 47 48 49 95 96 97 113 114 115 116 128 133 135 141
RBRACKET             : 51 132 133 134 135 136 140 141 142 143
RETURN               : 50 51 52
RPAREN               : 11 16 44 45 46 47 48 49 61 62 63 64 65 66 67 136 145
SEMICOLON            : 113 113 115
SHORTASSIGN          : 30 31 113 115 135 136 141 143
STRING               : 84
STRUCT               : 128
SWITCH               : 116
TEXT                 : 
TIMES                : 73
TIMESASSIGN          : 41
TRUE                 : 
TYPE                 : 128
VAR                  : 28 29 132 133 142
VARIABLE             : 14 28 29 30 31 32 33 34 35 44 45 46 47 48 49 55 80 113 115 115 115 128 131 132 133 134 135 136 140 141 142 143 144 145
error                : 

Nonterminals, with rules where they appear

append_statement     : 144
array_assign         : 37
array_structure      : 124
assignation          : 33 34
block                : 17 18
blocks               : 1 2 3 4 5 6 7 8 18 44 45 48 49
case_block           : 119 120
case_blocks          : 116 120
condition            : 98 99 113
conditional_body     : 92 93 93 94 94 94
conditional_structure : 89
conditions           : 92 93 94 94 99
control_structure    : 23
data_structure       : 22
double_operator      : 35 70 113
empty                : 118
for_estructure       : 90
for_infinite_bucle   : 111
for_initialization   : 110
for_iterator         : 112
function             : 24
import               : 2 4 7 8
input_statement      : 20
logical_operator     : 99
main                 : 5 6 7 8
map_assign           : 36
map_structure        : 125
map_value            : 137 138
map_values           : 135 138
not_variable_value   : 56
number               : 58
operation            : 21 31 34 63 66 69
operator             : 68 69
package              : 3 4 6 8
parameter            : 78 79
parameters           : 25 45 47 48 79
print_statement      : 19
relational_operator  : 100
return               : 46 47 48 49
slice_structure      : 126
statement            : 95 113 114 115 121 122 0
struct_field         : 129 130
struct_fields        : 128 130
struct_structure     : 127
switch_expression    : 116
switch_structure     : 91
type                 : 28 29 46 47 48 49 80 131 132 133 135 135 136 136 141 142 143
value                : 29 30 32 33 51 51 52 52 53 54 68 68 69 70 100 100 113 113 117 134 139 139 140 140
values               : 50 54 61 62 65 121 133 141 145
values_for_import    : 11 13
variable_assignation : 27
variable_declaration : 26

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 9
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 1
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 1

    (0) S' -> statement .



state 2

    (1) statement -> blocks .

    $end            reduce using rule 1 (statement -> blocks .)
    RBRACE          reduce using rule 1 (statement -> blocks .)
    CASE            reduce using rule 1 (statement -> blocks .)
    DEFAULT         reduce using rule 1 (statement -> blocks .)


state 3

    (2) statement -> import . blocks
    (7) statement -> import . main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    blocks                         shift and go to state 48
    main                           shift and go to state 49
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 4

    (3) statement -> package . blocks
    (4) statement -> package . import blocks
    (6) statement -> package . main LBRACE blocks RBRACE
    (8) statement -> package . import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    blocks                         shift and go to state 50
    import                         shift and go to state 51
    main                           shift and go to state 52
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 5

    (5) statement -> main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 53


state 6

    (17) blocks -> block .
    (18) blocks -> block . blocks
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

    $end            reduce using rule 17 (blocks -> block .)
    RBRACE          reduce using rule 17 (blocks -> block .)
    CASE            reduce using rule 17 (blocks -> block .)
    DEFAULT         reduce using rule 17 (blocks -> block .)
    RETURN          reduce using rule 17 (blocks -> block .)
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    block                          shift and go to state 6
    blocks                         shift and go to state 54
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 7

    (10) import -> IMPORT . CHARSTRING
    (11) import -> IMPORT . LPAREN values_for_import RPAREN

    CHARSTRING      shift and go to state 56
    LPAREN          shift and go to state 57


state 8

    (57) not_variable_value -> CHARSTRING .

    PLUS            reduce using rule 57 (not_variable_value -> CHARSTRING .)
    MINUS           reduce using rule 57 (not_variable_value -> CHARSTRING .)
    TIMES           reduce using rule 57 (not_variable_value -> CHARSTRING .)
    DIVIDE          reduce using rule 57 (not_variable_value -> CHARSTRING .)
    ASSIGN          reduce using rule 57 (not_variable_value -> CHARSTRING .)
    INCREMENT       reduce using rule 57 (not_variable_value -> CHARSTRING .)
    DECREMENT       reduce using rule 57 (not_variable_value -> CHARSTRING .)
    GREATER         reduce using rule 57 (not_variable_value -> CHARSTRING .)
    LESS            reduce using rule 57 (not_variable_value -> CHARSTRING .)
    GREATEREQUALS   reduce using rule 57 (not_variable_value -> CHARSTRING .)
    LESSEQUALS      reduce using rule 57 (not_variable_value -> CHARSTRING .)
    EQUALS          reduce using rule 57 (not_variable_value -> CHARSTRING .)
    DIFFERENT       reduce using rule 57 (not_variable_value -> CHARSTRING .)
    LBRACE          reduce using rule 57 (not_variable_value -> CHARSTRING .)
    PRINT           reduce using rule 57 (not_variable_value -> CHARSTRING .)
    PRINTF          reduce using rule 57 (not_variable_value -> CHARSTRING .)
    INPUT           reduce using rule 57 (not_variable_value -> CHARSTRING .)
    FUNCTION        reduce using rule 57 (not_variable_value -> CHARSTRING .)
    VAR             reduce using rule 57 (not_variable_value -> CHARSTRING .)
    VARIABLE        reduce using rule 57 (not_variable_value -> CHARSTRING .)
    CONST           reduce using rule 57 (not_variable_value -> CHARSTRING .)
    TYPE            reduce using rule 57 (not_variable_value -> CHARSTRING .)
    IF              reduce using rule 57 (not_variable_value -> CHARSTRING .)
    SWITCH          reduce using rule 57 (not_variable_value -> CHARSTRING .)
    CHARSTRING      reduce using rule 57 (not_variable_value -> CHARSTRING .)
    FOR             reduce using rule 57 (not_variable_value -> CHARSTRING .)
    INT             reduce using rule 57 (not_variable_value -> CHARSTRING .)
    FLOAT           reduce using rule 57 (not_variable_value -> CHARSTRING .)
    $end            reduce using rule 57 (not_variable_value -> CHARSTRING .)
    RBRACE          reduce using rule 57 (not_variable_value -> CHARSTRING .)
    CASE            reduce using rule 57 (not_variable_value -> CHARSTRING .)
    DEFAULT         reduce using rule 57 (not_variable_value -> CHARSTRING .)
    RETURN          reduce using rule 57 (not_variable_value -> CHARSTRING .)
    RBRACKET        reduce using rule 57 (not_variable_value -> CHARSTRING .)
    COMMA           reduce using rule 57 (not_variable_value -> CHARSTRING .)
    RPAREN          reduce using rule 57 (not_variable_value -> CHARSTRING .)
    AND             reduce using rule 57 (not_variable_value -> CHARSTRING .)
    OR              reduce using rule 57 (not_variable_value -> CHARSTRING .)
    NOT             reduce using rule 57 (not_variable_value -> CHARSTRING .)
    SEMICOLON       reduce using rule 57 (not_variable_value -> CHARSTRING .)
    COLON           reduce using rule 57 (not_variable_value -> CHARSTRING .)
    LBRACKET        reduce using rule 57 (not_variable_value -> CHARSTRING .)
    PERIOD          reduce using rule 57 (not_variable_value -> CHARSTRING .)


state 9

    (14) package -> PACKAGE . VARIABLE
    (15) package -> PACKAGE . MAIN

    VARIABLE        shift and go to state 58
    MAIN            shift and go to state 59


state 10

    (30) variable_declaration -> VARIABLE . SHORTASSIGN value
    (31) variable_declaration -> VARIABLE . SHORTASSIGN operation
    (33) variable_assignation -> VARIABLE . assignation value
    (34) variable_assignation -> VARIABLE . assignation operation
    (35) variable_assignation -> VARIABLE . double_operator
    (55) value -> VARIABLE .
    (135) map_structure -> VARIABLE . SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> VARIABLE . SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> VARIABLE . SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (143) slice_structure -> VARIABLE . SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> VARIABLE . ASSIGN append_statement
    (80) parameter -> VARIABLE . type
    (140) map_assign -> VARIABLE . LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> VARIABLE . LBRACKET INT RBRACKET ASSIGN value
    (38) assignation -> . ASSIGN
    (39) assignation -> . PLUSASSIGN
    (40) assignation -> . MINUSASSIGN
    (41) assignation -> . TIMESASSIGN
    (42) assignation -> . DIVIDEASSIGN
    (43) assignation -> . MODASSIGN
    (76) double_operator -> . INCREMENT
    (77) double_operator -> . DECREMENT
    (81) type -> . INT
    (82) type -> . INT32
    (83) type -> . INT64
    (84) type -> . STRING
    (85) type -> . FLOAT
    (86) type -> . FLOAT32
    (87) type -> . FLOAT64
    (88) type -> . BOOL

  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
    SHORTASSIGN     shift and go to state 60
    PLUS            reduce using rule 55 (value -> VARIABLE .)
    MINUS           reduce using rule 55 (value -> VARIABLE .)
    TIMES           reduce using rule 55 (value -> VARIABLE .)
    DIVIDE          reduce using rule 55 (value -> VARIABLE .)
    ASSIGN          shift and go to state 65
    LBRACKET        shift and go to state 63
    PLUSASSIGN      shift and go to state 67
    MINUSASSIGN     shift and go to state 68
    TIMESASSIGN     shift and go to state 69
    DIVIDEASSIGN    shift and go to state 70
    MODASSIGN       shift and go to state 71
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73
    INT             shift and go to state 66
    INT32           shift and go to state 74
    INT64           shift and go to state 75
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    FLOAT32         shift and go to state 78
    FLOAT64         shift and go to state 79
    BOOL            shift and go to state 80

  ! ASSIGN          [ reduce using rule 55 (value -> VARIABLE .) ]
  ! INCREMENT       [ reduce using rule 55 (value -> VARIABLE .) ]
  ! DECREMENT       [ reduce using rule 55 (value -> VARIABLE .) ]

    assignation                    shift and go to state 61
    double_operator                shift and go to state 62
    type                           shift and go to state 64

state 11

    (16) main -> FUNCTION . MAIN LPAREN RPAREN
    (44) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE

    MAIN            shift and go to state 81
    VARIABLE        shift and go to state 82


state 12

    (19) block -> print_statement .

    PRINT           reduce using rule 19 (block -> print_statement .)
    PRINTF          reduce using rule 19 (block -> print_statement .)
    INPUT           reduce using rule 19 (block -> print_statement .)
    FUNCTION        reduce using rule 19 (block -> print_statement .)
    VAR             reduce using rule 19 (block -> print_statement .)
    VARIABLE        reduce using rule 19 (block -> print_statement .)
    CONST           reduce using rule 19 (block -> print_statement .)
    TYPE            reduce using rule 19 (block -> print_statement .)
    IF              reduce using rule 19 (block -> print_statement .)
    SWITCH          reduce using rule 19 (block -> print_statement .)
    CHARSTRING      reduce using rule 19 (block -> print_statement .)
    FOR             reduce using rule 19 (block -> print_statement .)
    INT             reduce using rule 19 (block -> print_statement .)
    FLOAT           reduce using rule 19 (block -> print_statement .)
    $end            reduce using rule 19 (block -> print_statement .)
    RBRACE          reduce using rule 19 (block -> print_statement .)
    CASE            reduce using rule 19 (block -> print_statement .)
    DEFAULT         reduce using rule 19 (block -> print_statement .)
    RETURN          reduce using rule 19 (block -> print_statement .)


state 13

    (20) block -> input_statement .

    PRINT           reduce using rule 20 (block -> input_statement .)
    PRINTF          reduce using rule 20 (block -> input_statement .)
    INPUT           reduce using rule 20 (block -> input_statement .)
    FUNCTION        reduce using rule 20 (block -> input_statement .)
    VAR             reduce using rule 20 (block -> input_statement .)
    VARIABLE        reduce using rule 20 (block -> input_statement .)
    CONST           reduce using rule 20 (block -> input_statement .)
    TYPE            reduce using rule 20 (block -> input_statement .)
    IF              reduce using rule 20 (block -> input_statement .)
    SWITCH          reduce using rule 20 (block -> input_statement .)
    CHARSTRING      reduce using rule 20 (block -> input_statement .)
    FOR             reduce using rule 20 (block -> input_statement .)
    INT             reduce using rule 20 (block -> input_statement .)
    FLOAT           reduce using rule 20 (block -> input_statement .)
    $end            reduce using rule 20 (block -> input_statement .)
    RBRACE          reduce using rule 20 (block -> input_statement .)
    CASE            reduce using rule 20 (block -> input_statement .)
    DEFAULT         reduce using rule 20 (block -> input_statement .)
    RETURN          reduce using rule 20 (block -> input_statement .)


state 14

    (21) block -> operation .

    PRINT           reduce using rule 21 (block -> operation .)
    PRINTF          reduce using rule 21 (block -> operation .)
    INPUT           reduce using rule 21 (block -> operation .)
    FUNCTION        reduce using rule 21 (block -> operation .)
    VAR             reduce using rule 21 (block -> operation .)
    VARIABLE        reduce using rule 21 (block -> operation .)
    CONST           reduce using rule 21 (block -> operation .)
    TYPE            reduce using rule 21 (block -> operation .)
    IF              reduce using rule 21 (block -> operation .)
    SWITCH          reduce using rule 21 (block -> operation .)
    CHARSTRING      reduce using rule 21 (block -> operation .)
    FOR             reduce using rule 21 (block -> operation .)
    INT             reduce using rule 21 (block -> operation .)
    FLOAT           reduce using rule 21 (block -> operation .)
    $end            reduce using rule 21 (block -> operation .)
    RBRACE          reduce using rule 21 (block -> operation .)
    CASE            reduce using rule 21 (block -> operation .)
    DEFAULT         reduce using rule 21 (block -> operation .)
    RETURN          reduce using rule 21 (block -> operation .)


state 15

    (22) block -> data_structure .

    PRINT           reduce using rule 22 (block -> data_structure .)
    PRINTF          reduce using rule 22 (block -> data_structure .)
    INPUT           reduce using rule 22 (block -> data_structure .)
    FUNCTION        reduce using rule 22 (block -> data_structure .)
    VAR             reduce using rule 22 (block -> data_structure .)
    VARIABLE        reduce using rule 22 (block -> data_structure .)
    CONST           reduce using rule 22 (block -> data_structure .)
    TYPE            reduce using rule 22 (block -> data_structure .)
    IF              reduce using rule 22 (block -> data_structure .)
    SWITCH          reduce using rule 22 (block -> data_structure .)
    CHARSTRING      reduce using rule 22 (block -> data_structure .)
    FOR             reduce using rule 22 (block -> data_structure .)
    INT             reduce using rule 22 (block -> data_structure .)
    FLOAT           reduce using rule 22 (block -> data_structure .)
    $end            reduce using rule 22 (block -> data_structure .)
    RBRACE          reduce using rule 22 (block -> data_structure .)
    CASE            reduce using rule 22 (block -> data_structure .)
    DEFAULT         reduce using rule 22 (block -> data_structure .)
    RETURN          reduce using rule 22 (block -> data_structure .)


state 16

    (23) block -> control_structure .

    PRINT           reduce using rule 23 (block -> control_structure .)
    PRINTF          reduce using rule 23 (block -> control_structure .)
    INPUT           reduce using rule 23 (block -> control_structure .)
    FUNCTION        reduce using rule 23 (block -> control_structure .)
    VAR             reduce using rule 23 (block -> control_structure .)
    VARIABLE        reduce using rule 23 (block -> control_structure .)
    CONST           reduce using rule 23 (block -> control_structure .)
    TYPE            reduce using rule 23 (block -> control_structure .)
    IF              reduce using rule 23 (block -> control_structure .)
    SWITCH          reduce using rule 23 (block -> control_structure .)
    CHARSTRING      reduce using rule 23 (block -> control_structure .)
    FOR             reduce using rule 23 (block -> control_structure .)
    INT             reduce using rule 23 (block -> control_structure .)
    FLOAT           reduce using rule 23 (block -> control_structure .)
    $end            reduce using rule 23 (block -> control_structure .)
    RBRACE          reduce using rule 23 (block -> control_structure .)
    CASE            reduce using rule 23 (block -> control_structure .)
    DEFAULT         reduce using rule 23 (block -> control_structure .)
    RETURN          reduce using rule 23 (block -> control_structure .)


state 17

    (24) block -> function .

    PRINT           reduce using rule 24 (block -> function .)
    PRINTF          reduce using rule 24 (block -> function .)
    INPUT           reduce using rule 24 (block -> function .)
    FUNCTION        reduce using rule 24 (block -> function .)
    VAR             reduce using rule 24 (block -> function .)
    VARIABLE        reduce using rule 24 (block -> function .)
    CONST           reduce using rule 24 (block -> function .)
    TYPE            reduce using rule 24 (block -> function .)
    IF              reduce using rule 24 (block -> function .)
    SWITCH          reduce using rule 24 (block -> function .)
    CHARSTRING      reduce using rule 24 (block -> function .)
    FOR             reduce using rule 24 (block -> function .)
    INT             reduce using rule 24 (block -> function .)
    FLOAT           reduce using rule 24 (block -> function .)
    $end            reduce using rule 24 (block -> function .)
    RBRACE          reduce using rule 24 (block -> function .)
    CASE            reduce using rule 24 (block -> function .)
    DEFAULT         reduce using rule 24 (block -> function .)
    RETURN          reduce using rule 24 (block -> function .)


state 18

    (25) block -> parameters .

    PRINT           reduce using rule 25 (block -> parameters .)
    PRINTF          reduce using rule 25 (block -> parameters .)
    INPUT           reduce using rule 25 (block -> parameters .)
    FUNCTION        reduce using rule 25 (block -> parameters .)
    VAR             reduce using rule 25 (block -> parameters .)
    VARIABLE        reduce using rule 25 (block -> parameters .)
    CONST           reduce using rule 25 (block -> parameters .)
    TYPE            reduce using rule 25 (block -> parameters .)
    IF              reduce using rule 25 (block -> parameters .)
    SWITCH          reduce using rule 25 (block -> parameters .)
    CHARSTRING      reduce using rule 25 (block -> parameters .)
    FOR             reduce using rule 25 (block -> parameters .)
    INT             reduce using rule 25 (block -> parameters .)
    FLOAT           reduce using rule 25 (block -> parameters .)
    $end            reduce using rule 25 (block -> parameters .)
    RBRACE          reduce using rule 25 (block -> parameters .)
    CASE            reduce using rule 25 (block -> parameters .)
    DEFAULT         reduce using rule 25 (block -> parameters .)
    RETURN          reduce using rule 25 (block -> parameters .)


state 19

    (26) block -> variable_declaration .

    PRINT           reduce using rule 26 (block -> variable_declaration .)
    PRINTF          reduce using rule 26 (block -> variable_declaration .)
    INPUT           reduce using rule 26 (block -> variable_declaration .)
    FUNCTION        reduce using rule 26 (block -> variable_declaration .)
    VAR             reduce using rule 26 (block -> variable_declaration .)
    VARIABLE        reduce using rule 26 (block -> variable_declaration .)
    CONST           reduce using rule 26 (block -> variable_declaration .)
    TYPE            reduce using rule 26 (block -> variable_declaration .)
    IF              reduce using rule 26 (block -> variable_declaration .)
    SWITCH          reduce using rule 26 (block -> variable_declaration .)
    CHARSTRING      reduce using rule 26 (block -> variable_declaration .)
    FOR             reduce using rule 26 (block -> variable_declaration .)
    INT             reduce using rule 26 (block -> variable_declaration .)
    FLOAT           reduce using rule 26 (block -> variable_declaration .)
    $end            reduce using rule 26 (block -> variable_declaration .)
    RBRACE          reduce using rule 26 (block -> variable_declaration .)
    CASE            reduce using rule 26 (block -> variable_declaration .)
    DEFAULT         reduce using rule 26 (block -> variable_declaration .)
    RETURN          reduce using rule 26 (block -> variable_declaration .)


state 20

    (27) block -> variable_assignation .

    PRINT           reduce using rule 27 (block -> variable_assignation .)
    PRINTF          reduce using rule 27 (block -> variable_assignation .)
    INPUT           reduce using rule 27 (block -> variable_assignation .)
    FUNCTION        reduce using rule 27 (block -> variable_assignation .)
    VAR             reduce using rule 27 (block -> variable_assignation .)
    VARIABLE        reduce using rule 27 (block -> variable_assignation .)
    CONST           reduce using rule 27 (block -> variable_assignation .)
    TYPE            reduce using rule 27 (block -> variable_assignation .)
    IF              reduce using rule 27 (block -> variable_assignation .)
    SWITCH          reduce using rule 27 (block -> variable_assignation .)
    CHARSTRING      reduce using rule 27 (block -> variable_assignation .)
    FOR             reduce using rule 27 (block -> variable_assignation .)
    INT             reduce using rule 27 (block -> variable_assignation .)
    FLOAT           reduce using rule 27 (block -> variable_assignation .)
    $end            reduce using rule 27 (block -> variable_assignation .)
    RBRACE          reduce using rule 27 (block -> variable_assignation .)
    CASE            reduce using rule 27 (block -> variable_assignation .)
    DEFAULT         reduce using rule 27 (block -> variable_assignation .)
    RETURN          reduce using rule 27 (block -> variable_assignation .)


state 21

    (61) print_statement -> PRINT . LPAREN values RPAREN
    (63) print_statement -> PRINT . LPAREN operation RPAREN
    (64) print_statement -> PRINT . LPAREN RPAREN

    LPAREN          shift and go to state 83


state 22

    (62) print_statement -> PRINTF . LPAREN FORMATSTRING COMMA values RPAREN

    LPAREN          shift and go to state 84


state 23

    (65) input_statement -> INPUT . LPAREN values RPAREN
    (66) input_statement -> INPUT . LPAREN operation RPAREN
    (67) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 85


state 24

    (68) operation -> value . operator value
    (69) operation -> value . operator operation
    (70) operation -> value . double_operator
    (71) operator -> . PLUS
    (72) operator -> . MINUS
    (73) operator -> . TIMES
    (74) operator -> . DIVIDE
    (75) operator -> . ASSIGN
    (76) double_operator -> . INCREMENT
    (77) double_operator -> . DECREMENT

    PLUS            shift and go to state 88
    MINUS           shift and go to state 89
    TIMES           shift and go to state 90
    DIVIDE          shift and go to state 91
    ASSIGN          shift and go to state 92
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    operator                       shift and go to state 86
    double_operator                shift and go to state 87

state 25

    (124) data_structure -> array_structure .

    PRINT           reduce using rule 124 (data_structure -> array_structure .)
    PRINTF          reduce using rule 124 (data_structure -> array_structure .)
    INPUT           reduce using rule 124 (data_structure -> array_structure .)
    FUNCTION        reduce using rule 124 (data_structure -> array_structure .)
    VAR             reduce using rule 124 (data_structure -> array_structure .)
    VARIABLE        reduce using rule 124 (data_structure -> array_structure .)
    CONST           reduce using rule 124 (data_structure -> array_structure .)
    TYPE            reduce using rule 124 (data_structure -> array_structure .)
    IF              reduce using rule 124 (data_structure -> array_structure .)
    SWITCH          reduce using rule 124 (data_structure -> array_structure .)
    CHARSTRING      reduce using rule 124 (data_structure -> array_structure .)
    FOR             reduce using rule 124 (data_structure -> array_structure .)
    INT             reduce using rule 124 (data_structure -> array_structure .)
    FLOAT           reduce using rule 124 (data_structure -> array_structure .)
    $end            reduce using rule 124 (data_structure -> array_structure .)
    RBRACE          reduce using rule 124 (data_structure -> array_structure .)
    CASE            reduce using rule 124 (data_structure -> array_structure .)
    DEFAULT         reduce using rule 124 (data_structure -> array_structure .)
    RETURN          reduce using rule 124 (data_structure -> array_structure .)


state 26

    (125) data_structure -> map_structure .

    PRINT           reduce using rule 125 (data_structure -> map_structure .)
    PRINTF          reduce using rule 125 (data_structure -> map_structure .)
    INPUT           reduce using rule 125 (data_structure -> map_structure .)
    FUNCTION        reduce using rule 125 (data_structure -> map_structure .)
    VAR             reduce using rule 125 (data_structure -> map_structure .)
    VARIABLE        reduce using rule 125 (data_structure -> map_structure .)
    CONST           reduce using rule 125 (data_structure -> map_structure .)
    TYPE            reduce using rule 125 (data_structure -> map_structure .)
    IF              reduce using rule 125 (data_structure -> map_structure .)
    SWITCH          reduce using rule 125 (data_structure -> map_structure .)
    CHARSTRING      reduce using rule 125 (data_structure -> map_structure .)
    FOR             reduce using rule 125 (data_structure -> map_structure .)
    INT             reduce using rule 125 (data_structure -> map_structure .)
    FLOAT           reduce using rule 125 (data_structure -> map_structure .)
    $end            reduce using rule 125 (data_structure -> map_structure .)
    RBRACE          reduce using rule 125 (data_structure -> map_structure .)
    CASE            reduce using rule 125 (data_structure -> map_structure .)
    DEFAULT         reduce using rule 125 (data_structure -> map_structure .)
    RETURN          reduce using rule 125 (data_structure -> map_structure .)


state 27

    (126) data_structure -> slice_structure .

    PRINT           reduce using rule 126 (data_structure -> slice_structure .)
    PRINTF          reduce using rule 126 (data_structure -> slice_structure .)
    INPUT           reduce using rule 126 (data_structure -> slice_structure .)
    FUNCTION        reduce using rule 126 (data_structure -> slice_structure .)
    VAR             reduce using rule 126 (data_structure -> slice_structure .)
    VARIABLE        reduce using rule 126 (data_structure -> slice_structure .)
    CONST           reduce using rule 126 (data_structure -> slice_structure .)
    TYPE            reduce using rule 126 (data_structure -> slice_structure .)
    IF              reduce using rule 126 (data_structure -> slice_structure .)
    SWITCH          reduce using rule 126 (data_structure -> slice_structure .)
    CHARSTRING      reduce using rule 126 (data_structure -> slice_structure .)
    FOR             reduce using rule 126 (data_structure -> slice_structure .)
    INT             reduce using rule 126 (data_structure -> slice_structure .)
    FLOAT           reduce using rule 126 (data_structure -> slice_structure .)
    $end            reduce using rule 126 (data_structure -> slice_structure .)
    RBRACE          reduce using rule 126 (data_structure -> slice_structure .)
    CASE            reduce using rule 126 (data_structure -> slice_structure .)
    DEFAULT         reduce using rule 126 (data_structure -> slice_structure .)
    RETURN          reduce using rule 126 (data_structure -> slice_structure .)


state 28

    (127) data_structure -> struct_structure .

    PRINT           reduce using rule 127 (data_structure -> struct_structure .)
    PRINTF          reduce using rule 127 (data_structure -> struct_structure .)
    INPUT           reduce using rule 127 (data_structure -> struct_structure .)
    FUNCTION        reduce using rule 127 (data_structure -> struct_structure .)
    VAR             reduce using rule 127 (data_structure -> struct_structure .)
    VARIABLE        reduce using rule 127 (data_structure -> struct_structure .)
    CONST           reduce using rule 127 (data_structure -> struct_structure .)
    TYPE            reduce using rule 127 (data_structure -> struct_structure .)
    IF              reduce using rule 127 (data_structure -> struct_structure .)
    SWITCH          reduce using rule 127 (data_structure -> struct_structure .)
    CHARSTRING      reduce using rule 127 (data_structure -> struct_structure .)
    FOR             reduce using rule 127 (data_structure -> struct_structure .)
    INT             reduce using rule 127 (data_structure -> struct_structure .)
    FLOAT           reduce using rule 127 (data_structure -> struct_structure .)
    $end            reduce using rule 127 (data_structure -> struct_structure .)
    RBRACE          reduce using rule 127 (data_structure -> struct_structure .)
    CASE            reduce using rule 127 (data_structure -> struct_structure .)
    DEFAULT         reduce using rule 127 (data_structure -> struct_structure .)
    RETURN          reduce using rule 127 (data_structure -> struct_structure .)


state 29

    (89) control_structure -> conditional_structure .

    PRINT           reduce using rule 89 (control_structure -> conditional_structure .)
    PRINTF          reduce using rule 89 (control_structure -> conditional_structure .)
    INPUT           reduce using rule 89 (control_structure -> conditional_structure .)
    FUNCTION        reduce using rule 89 (control_structure -> conditional_structure .)
    VAR             reduce using rule 89 (control_structure -> conditional_structure .)
    VARIABLE        reduce using rule 89 (control_structure -> conditional_structure .)
    CONST           reduce using rule 89 (control_structure -> conditional_structure .)
    TYPE            reduce using rule 89 (control_structure -> conditional_structure .)
    IF              reduce using rule 89 (control_structure -> conditional_structure .)
    SWITCH          reduce using rule 89 (control_structure -> conditional_structure .)
    CHARSTRING      reduce using rule 89 (control_structure -> conditional_structure .)
    FOR             reduce using rule 89 (control_structure -> conditional_structure .)
    INT             reduce using rule 89 (control_structure -> conditional_structure .)
    FLOAT           reduce using rule 89 (control_structure -> conditional_structure .)
    $end            reduce using rule 89 (control_structure -> conditional_structure .)
    RBRACE          reduce using rule 89 (control_structure -> conditional_structure .)
    CASE            reduce using rule 89 (control_structure -> conditional_structure .)
    DEFAULT         reduce using rule 89 (control_structure -> conditional_structure .)
    RETURN          reduce using rule 89 (control_structure -> conditional_structure .)


state 30

    (90) control_structure -> for_estructure .

    PRINT           reduce using rule 90 (control_structure -> for_estructure .)
    PRINTF          reduce using rule 90 (control_structure -> for_estructure .)
    INPUT           reduce using rule 90 (control_structure -> for_estructure .)
    FUNCTION        reduce using rule 90 (control_structure -> for_estructure .)
    VAR             reduce using rule 90 (control_structure -> for_estructure .)
    VARIABLE        reduce using rule 90 (control_structure -> for_estructure .)
    CONST           reduce using rule 90 (control_structure -> for_estructure .)
    TYPE            reduce using rule 90 (control_structure -> for_estructure .)
    IF              reduce using rule 90 (control_structure -> for_estructure .)
    SWITCH          reduce using rule 90 (control_structure -> for_estructure .)
    CHARSTRING      reduce using rule 90 (control_structure -> for_estructure .)
    FOR             reduce using rule 90 (control_structure -> for_estructure .)
    INT             reduce using rule 90 (control_structure -> for_estructure .)
    FLOAT           reduce using rule 90 (control_structure -> for_estructure .)
    $end            reduce using rule 90 (control_structure -> for_estructure .)
    RBRACE          reduce using rule 90 (control_structure -> for_estructure .)
    CASE            reduce using rule 90 (control_structure -> for_estructure .)
    DEFAULT         reduce using rule 90 (control_structure -> for_estructure .)
    RETURN          reduce using rule 90 (control_structure -> for_estructure .)


state 31

    (91) control_structure -> switch_structure .

    PRINT           reduce using rule 91 (control_structure -> switch_structure .)
    PRINTF          reduce using rule 91 (control_structure -> switch_structure .)
    INPUT           reduce using rule 91 (control_structure -> switch_structure .)
    FUNCTION        reduce using rule 91 (control_structure -> switch_structure .)
    VAR             reduce using rule 91 (control_structure -> switch_structure .)
    VARIABLE        reduce using rule 91 (control_structure -> switch_structure .)
    CONST           reduce using rule 91 (control_structure -> switch_structure .)
    TYPE            reduce using rule 91 (control_structure -> switch_structure .)
    IF              reduce using rule 91 (control_structure -> switch_structure .)
    SWITCH          reduce using rule 91 (control_structure -> switch_structure .)
    CHARSTRING      reduce using rule 91 (control_structure -> switch_structure .)
    FOR             reduce using rule 91 (control_structure -> switch_structure .)
    INT             reduce using rule 91 (control_structure -> switch_structure .)
    FLOAT           reduce using rule 91 (control_structure -> switch_structure .)
    $end            reduce using rule 91 (control_structure -> switch_structure .)
    RBRACE          reduce using rule 91 (control_structure -> switch_structure .)
    CASE            reduce using rule 91 (control_structure -> switch_structure .)
    DEFAULT         reduce using rule 91 (control_structure -> switch_structure .)
    RETURN          reduce using rule 91 (control_structure -> switch_structure .)


state 32

    (78) parameters -> parameter .
    (79) parameters -> parameter . COMMA parameters

    PRINT           reduce using rule 78 (parameters -> parameter .)
    PRINTF          reduce using rule 78 (parameters -> parameter .)
    INPUT           reduce using rule 78 (parameters -> parameter .)
    FUNCTION        reduce using rule 78 (parameters -> parameter .)
    VAR             reduce using rule 78 (parameters -> parameter .)
    VARIABLE        reduce using rule 78 (parameters -> parameter .)
    CONST           reduce using rule 78 (parameters -> parameter .)
    TYPE            reduce using rule 78 (parameters -> parameter .)
    IF              reduce using rule 78 (parameters -> parameter .)
    SWITCH          reduce using rule 78 (parameters -> parameter .)
    CHARSTRING      reduce using rule 78 (parameters -> parameter .)
    FOR             reduce using rule 78 (parameters -> parameter .)
    INT             reduce using rule 78 (parameters -> parameter .)
    FLOAT           reduce using rule 78 (parameters -> parameter .)
    $end            reduce using rule 78 (parameters -> parameter .)
    RBRACE          reduce using rule 78 (parameters -> parameter .)
    CASE            reduce using rule 78 (parameters -> parameter .)
    DEFAULT         reduce using rule 78 (parameters -> parameter .)
    RETURN          reduce using rule 78 (parameters -> parameter .)
    RPAREN          reduce using rule 78 (parameters -> parameter .)
    COMMA           shift and go to state 93


state 33

    (28) variable_declaration -> VAR . VARIABLE type
    (29) variable_declaration -> VAR . VARIABLE type ASSIGN value
    (132) array_structure -> VAR . VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> VAR . VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> VAR . VARIABLE LBRACKET RBRACKET type

    VARIABLE        shift and go to state 94


state 34

    (32) variable_declaration -> CONST . VARIABLE ASSIGN value

    VARIABLE        shift and go to state 95


state 35

    (36) variable_assignation -> map_assign .

    PRINT           reduce using rule 36 (variable_assignation -> map_assign .)
    PRINTF          reduce using rule 36 (variable_assignation -> map_assign .)
    INPUT           reduce using rule 36 (variable_assignation -> map_assign .)
    FUNCTION        reduce using rule 36 (variable_assignation -> map_assign .)
    VAR             reduce using rule 36 (variable_assignation -> map_assign .)
    VARIABLE        reduce using rule 36 (variable_assignation -> map_assign .)
    CONST           reduce using rule 36 (variable_assignation -> map_assign .)
    TYPE            reduce using rule 36 (variable_assignation -> map_assign .)
    IF              reduce using rule 36 (variable_assignation -> map_assign .)
    SWITCH          reduce using rule 36 (variable_assignation -> map_assign .)
    CHARSTRING      reduce using rule 36 (variable_assignation -> map_assign .)
    FOR             reduce using rule 36 (variable_assignation -> map_assign .)
    INT             reduce using rule 36 (variable_assignation -> map_assign .)
    FLOAT           reduce using rule 36 (variable_assignation -> map_assign .)
    $end            reduce using rule 36 (variable_assignation -> map_assign .)
    RBRACE          reduce using rule 36 (variable_assignation -> map_assign .)
    CASE            reduce using rule 36 (variable_assignation -> map_assign .)
    DEFAULT         reduce using rule 36 (variable_assignation -> map_assign .)
    RETURN          reduce using rule 36 (variable_assignation -> map_assign .)


state 36

    (37) variable_assignation -> array_assign .

    PRINT           reduce using rule 37 (variable_assignation -> array_assign .)
    PRINTF          reduce using rule 37 (variable_assignation -> array_assign .)
    INPUT           reduce using rule 37 (variable_assignation -> array_assign .)
    FUNCTION        reduce using rule 37 (variable_assignation -> array_assign .)
    VAR             reduce using rule 37 (variable_assignation -> array_assign .)
    VARIABLE        reduce using rule 37 (variable_assignation -> array_assign .)
    CONST           reduce using rule 37 (variable_assignation -> array_assign .)
    TYPE            reduce using rule 37 (variable_assignation -> array_assign .)
    IF              reduce using rule 37 (variable_assignation -> array_assign .)
    SWITCH          reduce using rule 37 (variable_assignation -> array_assign .)
    CHARSTRING      reduce using rule 37 (variable_assignation -> array_assign .)
    FOR             reduce using rule 37 (variable_assignation -> array_assign .)
    INT             reduce using rule 37 (variable_assignation -> array_assign .)
    FLOAT           reduce using rule 37 (variable_assignation -> array_assign .)
    $end            reduce using rule 37 (variable_assignation -> array_assign .)
    RBRACE          reduce using rule 37 (variable_assignation -> array_assign .)
    CASE            reduce using rule 37 (variable_assignation -> array_assign .)
    DEFAULT         reduce using rule 37 (variable_assignation -> array_assign .)
    RETURN          reduce using rule 37 (variable_assignation -> array_assign .)


state 37

    (56) value -> not_variable_value .

    PLUS            reduce using rule 56 (value -> not_variable_value .)
    MINUS           reduce using rule 56 (value -> not_variable_value .)
    TIMES           reduce using rule 56 (value -> not_variable_value .)
    DIVIDE          reduce using rule 56 (value -> not_variable_value .)
    ASSIGN          reduce using rule 56 (value -> not_variable_value .)
    INCREMENT       reduce using rule 56 (value -> not_variable_value .)
    DECREMENT       reduce using rule 56 (value -> not_variable_value .)
    GREATER         reduce using rule 56 (value -> not_variable_value .)
    LESS            reduce using rule 56 (value -> not_variable_value .)
    GREATEREQUALS   reduce using rule 56 (value -> not_variable_value .)
    LESSEQUALS      reduce using rule 56 (value -> not_variable_value .)
    EQUALS          reduce using rule 56 (value -> not_variable_value .)
    DIFFERENT       reduce using rule 56 (value -> not_variable_value .)
    LBRACE          reduce using rule 56 (value -> not_variable_value .)
    PRINT           reduce using rule 56 (value -> not_variable_value .)
    PRINTF          reduce using rule 56 (value -> not_variable_value .)
    INPUT           reduce using rule 56 (value -> not_variable_value .)
    FUNCTION        reduce using rule 56 (value -> not_variable_value .)
    VAR             reduce using rule 56 (value -> not_variable_value .)
    VARIABLE        reduce using rule 56 (value -> not_variable_value .)
    CONST           reduce using rule 56 (value -> not_variable_value .)
    TYPE            reduce using rule 56 (value -> not_variable_value .)
    IF              reduce using rule 56 (value -> not_variable_value .)
    SWITCH          reduce using rule 56 (value -> not_variable_value .)
    CHARSTRING      reduce using rule 56 (value -> not_variable_value .)
    FOR             reduce using rule 56 (value -> not_variable_value .)
    INT             reduce using rule 56 (value -> not_variable_value .)
    FLOAT           reduce using rule 56 (value -> not_variable_value .)
    $end            reduce using rule 56 (value -> not_variable_value .)
    RBRACE          reduce using rule 56 (value -> not_variable_value .)
    CASE            reduce using rule 56 (value -> not_variable_value .)
    DEFAULT         reduce using rule 56 (value -> not_variable_value .)
    RETURN          reduce using rule 56 (value -> not_variable_value .)
    RBRACKET        reduce using rule 56 (value -> not_variable_value .)
    COMMA           reduce using rule 56 (value -> not_variable_value .)
    RPAREN          reduce using rule 56 (value -> not_variable_value .)
    AND             reduce using rule 56 (value -> not_variable_value .)
    OR              reduce using rule 56 (value -> not_variable_value .)
    NOT             reduce using rule 56 (value -> not_variable_value .)
    SEMICOLON       reduce using rule 56 (value -> not_variable_value .)
    COLON           reduce using rule 56 (value -> not_variable_value .)
    LBRACKET        reduce using rule 56 (value -> not_variable_value .)
    PERIOD          reduce using rule 56 (value -> not_variable_value .)


state 38

    (59) number -> INT .

    PLUS            reduce using rule 59 (number -> INT .)
    MINUS           reduce using rule 59 (number -> INT .)
    TIMES           reduce using rule 59 (number -> INT .)
    DIVIDE          reduce using rule 59 (number -> INT .)
    ASSIGN          reduce using rule 59 (number -> INT .)
    INCREMENT       reduce using rule 59 (number -> INT .)
    DECREMENT       reduce using rule 59 (number -> INT .)
    GREATER         reduce using rule 59 (number -> INT .)
    LESS            reduce using rule 59 (number -> INT .)
    GREATEREQUALS   reduce using rule 59 (number -> INT .)
    LESSEQUALS      reduce using rule 59 (number -> INT .)
    EQUALS          reduce using rule 59 (number -> INT .)
    DIFFERENT       reduce using rule 59 (number -> INT .)
    LBRACE          reduce using rule 59 (number -> INT .)
    PRINT           reduce using rule 59 (number -> INT .)
    PRINTF          reduce using rule 59 (number -> INT .)
    INPUT           reduce using rule 59 (number -> INT .)
    FUNCTION        reduce using rule 59 (number -> INT .)
    VAR             reduce using rule 59 (number -> INT .)
    VARIABLE        reduce using rule 59 (number -> INT .)
    CONST           reduce using rule 59 (number -> INT .)
    TYPE            reduce using rule 59 (number -> INT .)
    IF              reduce using rule 59 (number -> INT .)
    SWITCH          reduce using rule 59 (number -> INT .)
    CHARSTRING      reduce using rule 59 (number -> INT .)
    FOR             reduce using rule 59 (number -> INT .)
    INT             reduce using rule 59 (number -> INT .)
    FLOAT           reduce using rule 59 (number -> INT .)
    $end            reduce using rule 59 (number -> INT .)
    RBRACE          reduce using rule 59 (number -> INT .)
    CASE            reduce using rule 59 (number -> INT .)
    DEFAULT         reduce using rule 59 (number -> INT .)
    RETURN          reduce using rule 59 (number -> INT .)
    COMMA           reduce using rule 59 (number -> INT .)
    RPAREN          reduce using rule 59 (number -> INT .)
    AND             reduce using rule 59 (number -> INT .)
    OR              reduce using rule 59 (number -> INT .)
    NOT             reduce using rule 59 (number -> INT .)
    SEMICOLON       reduce using rule 59 (number -> INT .)
    COLON           reduce using rule 59 (number -> INT .)
    LBRACKET        reduce using rule 59 (number -> INT .)
    PERIOD          reduce using rule 59 (number -> INT .)
    RBRACKET        reduce using rule 59 (number -> INT .)


state 39

    (128) struct_structure -> TYPE . VARIABLE STRUCT LBRACE struct_fields RBRACE

    VARIABLE        shift and go to state 96


state 40

    (92) conditional_structure -> IF . conditions conditional_body
    (93) conditional_structure -> IF . conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> IF . conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (98) conditions -> . condition
    (99) conditions -> . condition logical_operator conditions
    (100) condition -> . value relational_operator value
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    conditions                     shift and go to state 97
    condition                      shift and go to state 98
    value                          shift and go to state 99
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 41

    (110) for_estructure -> for_initialization .

    PRINT           reduce using rule 110 (for_estructure -> for_initialization .)
    PRINTF          reduce using rule 110 (for_estructure -> for_initialization .)
    INPUT           reduce using rule 110 (for_estructure -> for_initialization .)
    FUNCTION        reduce using rule 110 (for_estructure -> for_initialization .)
    VAR             reduce using rule 110 (for_estructure -> for_initialization .)
    VARIABLE        reduce using rule 110 (for_estructure -> for_initialization .)
    CONST           reduce using rule 110 (for_estructure -> for_initialization .)
    TYPE            reduce using rule 110 (for_estructure -> for_initialization .)
    IF              reduce using rule 110 (for_estructure -> for_initialization .)
    SWITCH          reduce using rule 110 (for_estructure -> for_initialization .)
    CHARSTRING      reduce using rule 110 (for_estructure -> for_initialization .)
    FOR             reduce using rule 110 (for_estructure -> for_initialization .)
    INT             reduce using rule 110 (for_estructure -> for_initialization .)
    FLOAT           reduce using rule 110 (for_estructure -> for_initialization .)
    $end            reduce using rule 110 (for_estructure -> for_initialization .)
    RBRACE          reduce using rule 110 (for_estructure -> for_initialization .)
    CASE            reduce using rule 110 (for_estructure -> for_initialization .)
    DEFAULT         reduce using rule 110 (for_estructure -> for_initialization .)
    RETURN          reduce using rule 110 (for_estructure -> for_initialization .)


state 42

    (111) for_estructure -> for_infinite_bucle .

    PRINT           reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    PRINTF          reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    INPUT           reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    FUNCTION        reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    VAR             reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    VARIABLE        reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    CONST           reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    TYPE            reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    IF              reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    SWITCH          reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    CHARSTRING      reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    FOR             reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    INT             reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    FLOAT           reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    $end            reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    RBRACE          reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    CASE            reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    DEFAULT         reduce using rule 111 (for_estructure -> for_infinite_bucle .)
    RETURN          reduce using rule 111 (for_estructure -> for_infinite_bucle .)


state 43

    (112) for_estructure -> for_iterator .

    PRINT           reduce using rule 112 (for_estructure -> for_iterator .)
    PRINTF          reduce using rule 112 (for_estructure -> for_iterator .)
    INPUT           reduce using rule 112 (for_estructure -> for_iterator .)
    FUNCTION        reduce using rule 112 (for_estructure -> for_iterator .)
    VAR             reduce using rule 112 (for_estructure -> for_iterator .)
    VARIABLE        reduce using rule 112 (for_estructure -> for_iterator .)
    CONST           reduce using rule 112 (for_estructure -> for_iterator .)
    TYPE            reduce using rule 112 (for_estructure -> for_iterator .)
    IF              reduce using rule 112 (for_estructure -> for_iterator .)
    SWITCH          reduce using rule 112 (for_estructure -> for_iterator .)
    CHARSTRING      reduce using rule 112 (for_estructure -> for_iterator .)
    FOR             reduce using rule 112 (for_estructure -> for_iterator .)
    INT             reduce using rule 112 (for_estructure -> for_iterator .)
    FLOAT           reduce using rule 112 (for_estructure -> for_iterator .)
    $end            reduce using rule 112 (for_estructure -> for_iterator .)
    RBRACE          reduce using rule 112 (for_estructure -> for_iterator .)
    CASE            reduce using rule 112 (for_estructure -> for_iterator .)
    DEFAULT         reduce using rule 112 (for_estructure -> for_iterator .)
    RETURN          reduce using rule 112 (for_estructure -> for_iterator .)


state 44

    (116) switch_structure -> SWITCH . switch_expression LBRACE case_blocks RBRACE
    (117) switch_expression -> . value
    (118) switch_expression -> . empty
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (123) empty -> .
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    LBRACE          reduce using rule 123 (empty -> .)
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    switch_expression              shift and go to state 101
    value                          shift and go to state 102
    empty                          shift and go to state 103
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 45

    (58) not_variable_value -> number .

    PLUS            reduce using rule 58 (not_variable_value -> number .)
    MINUS           reduce using rule 58 (not_variable_value -> number .)
    TIMES           reduce using rule 58 (not_variable_value -> number .)
    DIVIDE          reduce using rule 58 (not_variable_value -> number .)
    ASSIGN          reduce using rule 58 (not_variable_value -> number .)
    INCREMENT       reduce using rule 58 (not_variable_value -> number .)
    DECREMENT       reduce using rule 58 (not_variable_value -> number .)
    GREATER         reduce using rule 58 (not_variable_value -> number .)
    LESS            reduce using rule 58 (not_variable_value -> number .)
    GREATEREQUALS   reduce using rule 58 (not_variable_value -> number .)
    LESSEQUALS      reduce using rule 58 (not_variable_value -> number .)
    EQUALS          reduce using rule 58 (not_variable_value -> number .)
    DIFFERENT       reduce using rule 58 (not_variable_value -> number .)
    LBRACE          reduce using rule 58 (not_variable_value -> number .)
    PRINT           reduce using rule 58 (not_variable_value -> number .)
    PRINTF          reduce using rule 58 (not_variable_value -> number .)
    INPUT           reduce using rule 58 (not_variable_value -> number .)
    FUNCTION        reduce using rule 58 (not_variable_value -> number .)
    VAR             reduce using rule 58 (not_variable_value -> number .)
    VARIABLE        reduce using rule 58 (not_variable_value -> number .)
    CONST           reduce using rule 58 (not_variable_value -> number .)
    TYPE            reduce using rule 58 (not_variable_value -> number .)
    IF              reduce using rule 58 (not_variable_value -> number .)
    SWITCH          reduce using rule 58 (not_variable_value -> number .)
    CHARSTRING      reduce using rule 58 (not_variable_value -> number .)
    FOR             reduce using rule 58 (not_variable_value -> number .)
    INT             reduce using rule 58 (not_variable_value -> number .)
    FLOAT           reduce using rule 58 (not_variable_value -> number .)
    $end            reduce using rule 58 (not_variable_value -> number .)
    RBRACE          reduce using rule 58 (not_variable_value -> number .)
    CASE            reduce using rule 58 (not_variable_value -> number .)
    DEFAULT         reduce using rule 58 (not_variable_value -> number .)
    RETURN          reduce using rule 58 (not_variable_value -> number .)
    RBRACKET        reduce using rule 58 (not_variable_value -> number .)
    COMMA           reduce using rule 58 (not_variable_value -> number .)
    RPAREN          reduce using rule 58 (not_variable_value -> number .)
    AND             reduce using rule 58 (not_variable_value -> number .)
    OR              reduce using rule 58 (not_variable_value -> number .)
    NOT             reduce using rule 58 (not_variable_value -> number .)
    SEMICOLON       reduce using rule 58 (not_variable_value -> number .)
    COLON           reduce using rule 58 (not_variable_value -> number .)
    LBRACKET        reduce using rule 58 (not_variable_value -> number .)
    PERIOD          reduce using rule 58 (not_variable_value -> number .)


state 46

    (113) for_initialization -> FOR . VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> FOR . LBRACE statement RBRACE
    (115) for_iterator -> FOR . VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 104
    LBRACE          shift and go to state 105


state 47

    (60) number -> FLOAT .

    PLUS            reduce using rule 60 (number -> FLOAT .)
    MINUS           reduce using rule 60 (number -> FLOAT .)
    TIMES           reduce using rule 60 (number -> FLOAT .)
    DIVIDE          reduce using rule 60 (number -> FLOAT .)
    ASSIGN          reduce using rule 60 (number -> FLOAT .)
    INCREMENT       reduce using rule 60 (number -> FLOAT .)
    DECREMENT       reduce using rule 60 (number -> FLOAT .)
    GREATER         reduce using rule 60 (number -> FLOAT .)
    LESS            reduce using rule 60 (number -> FLOAT .)
    GREATEREQUALS   reduce using rule 60 (number -> FLOAT .)
    LESSEQUALS      reduce using rule 60 (number -> FLOAT .)
    EQUALS          reduce using rule 60 (number -> FLOAT .)
    DIFFERENT       reduce using rule 60 (number -> FLOAT .)
    LBRACE          reduce using rule 60 (number -> FLOAT .)
    PRINT           reduce using rule 60 (number -> FLOAT .)
    PRINTF          reduce using rule 60 (number -> FLOAT .)
    INPUT           reduce using rule 60 (number -> FLOAT .)
    FUNCTION        reduce using rule 60 (number -> FLOAT .)
    VAR             reduce using rule 60 (number -> FLOAT .)
    VARIABLE        reduce using rule 60 (number -> FLOAT .)
    CONST           reduce using rule 60 (number -> FLOAT .)
    TYPE            reduce using rule 60 (number -> FLOAT .)
    IF              reduce using rule 60 (number -> FLOAT .)
    SWITCH          reduce using rule 60 (number -> FLOAT .)
    CHARSTRING      reduce using rule 60 (number -> FLOAT .)
    FOR             reduce using rule 60 (number -> FLOAT .)
    INT             reduce using rule 60 (number -> FLOAT .)
    FLOAT           reduce using rule 60 (number -> FLOAT .)
    $end            reduce using rule 60 (number -> FLOAT .)
    RBRACE          reduce using rule 60 (number -> FLOAT .)
    CASE            reduce using rule 60 (number -> FLOAT .)
    DEFAULT         reduce using rule 60 (number -> FLOAT .)
    RETURN          reduce using rule 60 (number -> FLOAT .)
    RBRACKET        reduce using rule 60 (number -> FLOAT .)
    COMMA           reduce using rule 60 (number -> FLOAT .)
    RPAREN          reduce using rule 60 (number -> FLOAT .)
    AND             reduce using rule 60 (number -> FLOAT .)
    OR              reduce using rule 60 (number -> FLOAT .)
    NOT             reduce using rule 60 (number -> FLOAT .)
    SEMICOLON       reduce using rule 60 (number -> FLOAT .)
    COLON           reduce using rule 60 (number -> FLOAT .)
    LBRACKET        reduce using rule 60 (number -> FLOAT .)
    PERIOD          reduce using rule 60 (number -> FLOAT .)


state 48

    (2) statement -> import blocks .

    $end            reduce using rule 2 (statement -> import blocks .)
    RBRACE          reduce using rule 2 (statement -> import blocks .)
    CASE            reduce using rule 2 (statement -> import blocks .)
    DEFAULT         reduce using rule 2 (statement -> import blocks .)


state 49

    (7) statement -> import main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 106


state 50

    (3) statement -> package blocks .

    $end            reduce using rule 3 (statement -> package blocks .)
    RBRACE          reduce using rule 3 (statement -> package blocks .)
    CASE            reduce using rule 3 (statement -> package blocks .)
    DEFAULT         reduce using rule 3 (statement -> package blocks .)


state 51

    (4) statement -> package import . blocks
    (8) statement -> package import . main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    blocks                         shift and go to state 107
    main                           shift and go to state 108
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 52

    (6) statement -> package main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 109


state 53

    (5) statement -> main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    blocks                         shift and go to state 110
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 54

    (18) blocks -> block blocks .

    $end            reduce using rule 18 (blocks -> block blocks .)
    RBRACE          reduce using rule 18 (blocks -> block blocks .)
    CASE            reduce using rule 18 (blocks -> block blocks .)
    DEFAULT         reduce using rule 18 (blocks -> block blocks .)
    RETURN          reduce using rule 18 (blocks -> block blocks .)


state 55

    (44) function -> FUNCTION . VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> FUNCTION . VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> FUNCTION . VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE

    VARIABLE        shift and go to state 82


state 56

    (10) import -> IMPORT CHARSTRING .

    FUNCTION        reduce using rule 10 (import -> IMPORT CHARSTRING .)
    PRINT           reduce using rule 10 (import -> IMPORT CHARSTRING .)
    PRINTF          reduce using rule 10 (import -> IMPORT CHARSTRING .)
    INPUT           reduce using rule 10 (import -> IMPORT CHARSTRING .)
    VAR             reduce using rule 10 (import -> IMPORT CHARSTRING .)
    VARIABLE        reduce using rule 10 (import -> IMPORT CHARSTRING .)
    CONST           reduce using rule 10 (import -> IMPORT CHARSTRING .)
    TYPE            reduce using rule 10 (import -> IMPORT CHARSTRING .)
    IF              reduce using rule 10 (import -> IMPORT CHARSTRING .)
    SWITCH          reduce using rule 10 (import -> IMPORT CHARSTRING .)
    CHARSTRING      reduce using rule 10 (import -> IMPORT CHARSTRING .)
    FOR             reduce using rule 10 (import -> IMPORT CHARSTRING .)
    INT             reduce using rule 10 (import -> IMPORT CHARSTRING .)
    FLOAT           reduce using rule 10 (import -> IMPORT CHARSTRING .)


state 57

    (11) import -> IMPORT LPAREN . values_for_import RPAREN
    (12) values_for_import -> . CHARSTRING
    (13) values_for_import -> . CHARSTRING values_for_import

    CHARSTRING      shift and go to state 112

    values_for_import              shift and go to state 111

state 58

    (14) package -> PACKAGE VARIABLE .

    IMPORT          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    FUNCTION        reduce using rule 14 (package -> PACKAGE VARIABLE .)
    PRINT           reduce using rule 14 (package -> PACKAGE VARIABLE .)
    PRINTF          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    INPUT           reduce using rule 14 (package -> PACKAGE VARIABLE .)
    VAR             reduce using rule 14 (package -> PACKAGE VARIABLE .)
    VARIABLE        reduce using rule 14 (package -> PACKAGE VARIABLE .)
    CONST           reduce using rule 14 (package -> PACKAGE VARIABLE .)
    TYPE            reduce using rule 14 (package -> PACKAGE VARIABLE .)
    IF              reduce using rule 14 (package -> PACKAGE VARIABLE .)
    SWITCH          reduce using rule 14 (package -> PACKAGE VARIABLE .)
    CHARSTRING      reduce using rule 14 (package -> PACKAGE VARIABLE .)
    FOR             reduce using rule 14 (package -> PACKAGE VARIABLE .)
    INT             reduce using rule 14 (package -> PACKAGE VARIABLE .)
    FLOAT           reduce using rule 14 (package -> PACKAGE VARIABLE .)


state 59

    (15) package -> PACKAGE MAIN .

    IMPORT          reduce using rule 15 (package -> PACKAGE MAIN .)
    FUNCTION        reduce using rule 15 (package -> PACKAGE MAIN .)
    PRINT           reduce using rule 15 (package -> PACKAGE MAIN .)
    PRINTF          reduce using rule 15 (package -> PACKAGE MAIN .)
    INPUT           reduce using rule 15 (package -> PACKAGE MAIN .)
    VAR             reduce using rule 15 (package -> PACKAGE MAIN .)
    VARIABLE        reduce using rule 15 (package -> PACKAGE MAIN .)
    CONST           reduce using rule 15 (package -> PACKAGE MAIN .)
    TYPE            reduce using rule 15 (package -> PACKAGE MAIN .)
    IF              reduce using rule 15 (package -> PACKAGE MAIN .)
    SWITCH          reduce using rule 15 (package -> PACKAGE MAIN .)
    CHARSTRING      reduce using rule 15 (package -> PACKAGE MAIN .)
    FOR             reduce using rule 15 (package -> PACKAGE MAIN .)
    INT             reduce using rule 15 (package -> PACKAGE MAIN .)
    FLOAT           reduce using rule 15 (package -> PACKAGE MAIN .)


state 60

    (30) variable_declaration -> VARIABLE SHORTASSIGN . value
    (31) variable_declaration -> VARIABLE SHORTASSIGN . operation
    (135) map_structure -> VARIABLE SHORTASSIGN . MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> VARIABLE SHORTASSIGN . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> VARIABLE SHORTASSIGN . LBRACKET RBRACKET type LBRACE values RBRACE
    (143) slice_structure -> VARIABLE SHORTASSIGN . LBRACKET RBRACKET type
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    MAP             shift and go to state 115
    MAKE            shift and go to state 117
    LBRACKET        shift and go to state 116
    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    value                          shift and go to state 113
    operation                      shift and go to state 114
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 61

    (33) variable_assignation -> VARIABLE assignation . value
    (34) variable_assignation -> VARIABLE assignation . operation
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    value                          shift and go to state 118
    operation                      shift and go to state 119
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 62

    (35) variable_assignation -> VARIABLE double_operator .

    PRINT           reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    PRINTF          reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    INPUT           reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    FUNCTION        reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    VAR             reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    VARIABLE        reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    CONST           reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    TYPE            reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    IF              reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    SWITCH          reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    CHARSTRING      reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    FOR             reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    INT             reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    FLOAT           reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    $end            reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    RBRACE          reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    CASE            reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    DEFAULT         reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)
    RETURN          reduce using rule 35 (variable_assignation -> VARIABLE double_operator .)


state 63

    (140) map_assign -> VARIABLE LBRACKET . value RBRACKET ASSIGN value
    (134) array_assign -> VARIABLE LBRACKET . INT RBRACKET ASSIGN value
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    INT             shift and go to state 121
    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    FLOAT           shift and go to state 47

    value                          shift and go to state 120
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 64

    (80) parameter -> VARIABLE type .

    COMMA           reduce using rule 80 (parameter -> VARIABLE type .)
    PRINT           reduce using rule 80 (parameter -> VARIABLE type .)
    PRINTF          reduce using rule 80 (parameter -> VARIABLE type .)
    INPUT           reduce using rule 80 (parameter -> VARIABLE type .)
    FUNCTION        reduce using rule 80 (parameter -> VARIABLE type .)
    VAR             reduce using rule 80 (parameter -> VARIABLE type .)
    VARIABLE        reduce using rule 80 (parameter -> VARIABLE type .)
    CONST           reduce using rule 80 (parameter -> VARIABLE type .)
    TYPE            reduce using rule 80 (parameter -> VARIABLE type .)
    IF              reduce using rule 80 (parameter -> VARIABLE type .)
    SWITCH          reduce using rule 80 (parameter -> VARIABLE type .)
    CHARSTRING      reduce using rule 80 (parameter -> VARIABLE type .)
    FOR             reduce using rule 80 (parameter -> VARIABLE type .)
    INT             reduce using rule 80 (parameter -> VARIABLE type .)
    FLOAT           reduce using rule 80 (parameter -> VARIABLE type .)
    $end            reduce using rule 80 (parameter -> VARIABLE type .)
    RBRACE          reduce using rule 80 (parameter -> VARIABLE type .)
    CASE            reduce using rule 80 (parameter -> VARIABLE type .)
    DEFAULT         reduce using rule 80 (parameter -> VARIABLE type .)
    RETURN          reduce using rule 80 (parameter -> VARIABLE type .)
    RPAREN          reduce using rule 80 (parameter -> VARIABLE type .)


state 65

    (144) slice_structure -> VARIABLE ASSIGN . append_statement
    (38) assignation -> ASSIGN .
    (145) append_statement -> . APPEND LPAREN VARIABLE COMMA values RPAREN

    VARIABLE        reduce using rule 38 (assignation -> ASSIGN .)
    CHARSTRING      reduce using rule 38 (assignation -> ASSIGN .)
    INT             reduce using rule 38 (assignation -> ASSIGN .)
    FLOAT           reduce using rule 38 (assignation -> ASSIGN .)
    APPEND          shift and go to state 123

    append_statement               shift and go to state 122

state 66

    (81) type -> INT .

    COMMA           reduce using rule 81 (type -> INT .)
    PRINT           reduce using rule 81 (type -> INT .)
    PRINTF          reduce using rule 81 (type -> INT .)
    INPUT           reduce using rule 81 (type -> INT .)
    FUNCTION        reduce using rule 81 (type -> INT .)
    VAR             reduce using rule 81 (type -> INT .)
    VARIABLE        reduce using rule 81 (type -> INT .)
    CONST           reduce using rule 81 (type -> INT .)
    TYPE            reduce using rule 81 (type -> INT .)
    IF              reduce using rule 81 (type -> INT .)
    SWITCH          reduce using rule 81 (type -> INT .)
    CHARSTRING      reduce using rule 81 (type -> INT .)
    FOR             reduce using rule 81 (type -> INT .)
    INT             reduce using rule 81 (type -> INT .)
    FLOAT           reduce using rule 81 (type -> INT .)
    $end            reduce using rule 81 (type -> INT .)
    RBRACE          reduce using rule 81 (type -> INT .)
    CASE            reduce using rule 81 (type -> INT .)
    DEFAULT         reduce using rule 81 (type -> INT .)
    RETURN          reduce using rule 81 (type -> INT .)
    ASSIGN          reduce using rule 81 (type -> INT .)
    RPAREN          reduce using rule 81 (type -> INT .)
    RBRACKET        reduce using rule 81 (type -> INT .)
    LBRACE          reduce using rule 81 (type -> INT .)


state 67

    (39) assignation -> PLUSASSIGN .

    VARIABLE        reduce using rule 39 (assignation -> PLUSASSIGN .)
    CHARSTRING      reduce using rule 39 (assignation -> PLUSASSIGN .)
    INT             reduce using rule 39 (assignation -> PLUSASSIGN .)
    FLOAT           reduce using rule 39 (assignation -> PLUSASSIGN .)


state 68

    (40) assignation -> MINUSASSIGN .

    VARIABLE        reduce using rule 40 (assignation -> MINUSASSIGN .)
    CHARSTRING      reduce using rule 40 (assignation -> MINUSASSIGN .)
    INT             reduce using rule 40 (assignation -> MINUSASSIGN .)
    FLOAT           reduce using rule 40 (assignation -> MINUSASSIGN .)


state 69

    (41) assignation -> TIMESASSIGN .

    VARIABLE        reduce using rule 41 (assignation -> TIMESASSIGN .)
    CHARSTRING      reduce using rule 41 (assignation -> TIMESASSIGN .)
    INT             reduce using rule 41 (assignation -> TIMESASSIGN .)
    FLOAT           reduce using rule 41 (assignation -> TIMESASSIGN .)


state 70

    (42) assignation -> DIVIDEASSIGN .

    VARIABLE        reduce using rule 42 (assignation -> DIVIDEASSIGN .)
    CHARSTRING      reduce using rule 42 (assignation -> DIVIDEASSIGN .)
    INT             reduce using rule 42 (assignation -> DIVIDEASSIGN .)
    FLOAT           reduce using rule 42 (assignation -> DIVIDEASSIGN .)


state 71

    (43) assignation -> MODASSIGN .

    VARIABLE        reduce using rule 43 (assignation -> MODASSIGN .)
    CHARSTRING      reduce using rule 43 (assignation -> MODASSIGN .)
    INT             reduce using rule 43 (assignation -> MODASSIGN .)
    FLOAT           reduce using rule 43 (assignation -> MODASSIGN .)


state 72

    (76) double_operator -> INCREMENT .

    PRINT           reduce using rule 76 (double_operator -> INCREMENT .)
    PRINTF          reduce using rule 76 (double_operator -> INCREMENT .)
    INPUT           reduce using rule 76 (double_operator -> INCREMENT .)
    FUNCTION        reduce using rule 76 (double_operator -> INCREMENT .)
    VAR             reduce using rule 76 (double_operator -> INCREMENT .)
    VARIABLE        reduce using rule 76 (double_operator -> INCREMENT .)
    CONST           reduce using rule 76 (double_operator -> INCREMENT .)
    TYPE            reduce using rule 76 (double_operator -> INCREMENT .)
    IF              reduce using rule 76 (double_operator -> INCREMENT .)
    SWITCH          reduce using rule 76 (double_operator -> INCREMENT .)
    CHARSTRING      reduce using rule 76 (double_operator -> INCREMENT .)
    FOR             reduce using rule 76 (double_operator -> INCREMENT .)
    INT             reduce using rule 76 (double_operator -> INCREMENT .)
    FLOAT           reduce using rule 76 (double_operator -> INCREMENT .)
    $end            reduce using rule 76 (double_operator -> INCREMENT .)
    RBRACE          reduce using rule 76 (double_operator -> INCREMENT .)
    CASE            reduce using rule 76 (double_operator -> INCREMENT .)
    DEFAULT         reduce using rule 76 (double_operator -> INCREMENT .)
    RETURN          reduce using rule 76 (double_operator -> INCREMENT .)
    RPAREN          reduce using rule 76 (double_operator -> INCREMENT .)
    LBRACE          reduce using rule 76 (double_operator -> INCREMENT .)


state 73

    (77) double_operator -> DECREMENT .

    PRINT           reduce using rule 77 (double_operator -> DECREMENT .)
    PRINTF          reduce using rule 77 (double_operator -> DECREMENT .)
    INPUT           reduce using rule 77 (double_operator -> DECREMENT .)
    FUNCTION        reduce using rule 77 (double_operator -> DECREMENT .)
    VAR             reduce using rule 77 (double_operator -> DECREMENT .)
    VARIABLE        reduce using rule 77 (double_operator -> DECREMENT .)
    CONST           reduce using rule 77 (double_operator -> DECREMENT .)
    TYPE            reduce using rule 77 (double_operator -> DECREMENT .)
    IF              reduce using rule 77 (double_operator -> DECREMENT .)
    SWITCH          reduce using rule 77 (double_operator -> DECREMENT .)
    CHARSTRING      reduce using rule 77 (double_operator -> DECREMENT .)
    FOR             reduce using rule 77 (double_operator -> DECREMENT .)
    INT             reduce using rule 77 (double_operator -> DECREMENT .)
    FLOAT           reduce using rule 77 (double_operator -> DECREMENT .)
    $end            reduce using rule 77 (double_operator -> DECREMENT .)
    RBRACE          reduce using rule 77 (double_operator -> DECREMENT .)
    CASE            reduce using rule 77 (double_operator -> DECREMENT .)
    DEFAULT         reduce using rule 77 (double_operator -> DECREMENT .)
    RETURN          reduce using rule 77 (double_operator -> DECREMENT .)
    RPAREN          reduce using rule 77 (double_operator -> DECREMENT .)
    LBRACE          reduce using rule 77 (double_operator -> DECREMENT .)


state 74

    (82) type -> INT32 .

    COMMA           reduce using rule 82 (type -> INT32 .)
    PRINT           reduce using rule 82 (type -> INT32 .)
    PRINTF          reduce using rule 82 (type -> INT32 .)
    INPUT           reduce using rule 82 (type -> INT32 .)
    FUNCTION        reduce using rule 82 (type -> INT32 .)
    VAR             reduce using rule 82 (type -> INT32 .)
    VARIABLE        reduce using rule 82 (type -> INT32 .)
    CONST           reduce using rule 82 (type -> INT32 .)
    TYPE            reduce using rule 82 (type -> INT32 .)
    IF              reduce using rule 82 (type -> INT32 .)
    SWITCH          reduce using rule 82 (type -> INT32 .)
    CHARSTRING      reduce using rule 82 (type -> INT32 .)
    FOR             reduce using rule 82 (type -> INT32 .)
    INT             reduce using rule 82 (type -> INT32 .)
    FLOAT           reduce using rule 82 (type -> INT32 .)
    $end            reduce using rule 82 (type -> INT32 .)
    RBRACE          reduce using rule 82 (type -> INT32 .)
    CASE            reduce using rule 82 (type -> INT32 .)
    DEFAULT         reduce using rule 82 (type -> INT32 .)
    RETURN          reduce using rule 82 (type -> INT32 .)
    ASSIGN          reduce using rule 82 (type -> INT32 .)
    RPAREN          reduce using rule 82 (type -> INT32 .)
    RBRACKET        reduce using rule 82 (type -> INT32 .)
    LBRACE          reduce using rule 82 (type -> INT32 .)


state 75

    (83) type -> INT64 .

    COMMA           reduce using rule 83 (type -> INT64 .)
    PRINT           reduce using rule 83 (type -> INT64 .)
    PRINTF          reduce using rule 83 (type -> INT64 .)
    INPUT           reduce using rule 83 (type -> INT64 .)
    FUNCTION        reduce using rule 83 (type -> INT64 .)
    VAR             reduce using rule 83 (type -> INT64 .)
    VARIABLE        reduce using rule 83 (type -> INT64 .)
    CONST           reduce using rule 83 (type -> INT64 .)
    TYPE            reduce using rule 83 (type -> INT64 .)
    IF              reduce using rule 83 (type -> INT64 .)
    SWITCH          reduce using rule 83 (type -> INT64 .)
    CHARSTRING      reduce using rule 83 (type -> INT64 .)
    FOR             reduce using rule 83 (type -> INT64 .)
    INT             reduce using rule 83 (type -> INT64 .)
    FLOAT           reduce using rule 83 (type -> INT64 .)
    $end            reduce using rule 83 (type -> INT64 .)
    RBRACE          reduce using rule 83 (type -> INT64 .)
    CASE            reduce using rule 83 (type -> INT64 .)
    DEFAULT         reduce using rule 83 (type -> INT64 .)
    RETURN          reduce using rule 83 (type -> INT64 .)
    ASSIGN          reduce using rule 83 (type -> INT64 .)
    RPAREN          reduce using rule 83 (type -> INT64 .)
    RBRACKET        reduce using rule 83 (type -> INT64 .)
    LBRACE          reduce using rule 83 (type -> INT64 .)


state 76

    (84) type -> STRING .

    COMMA           reduce using rule 84 (type -> STRING .)
    PRINT           reduce using rule 84 (type -> STRING .)
    PRINTF          reduce using rule 84 (type -> STRING .)
    INPUT           reduce using rule 84 (type -> STRING .)
    FUNCTION        reduce using rule 84 (type -> STRING .)
    VAR             reduce using rule 84 (type -> STRING .)
    VARIABLE        reduce using rule 84 (type -> STRING .)
    CONST           reduce using rule 84 (type -> STRING .)
    TYPE            reduce using rule 84 (type -> STRING .)
    IF              reduce using rule 84 (type -> STRING .)
    SWITCH          reduce using rule 84 (type -> STRING .)
    CHARSTRING      reduce using rule 84 (type -> STRING .)
    FOR             reduce using rule 84 (type -> STRING .)
    INT             reduce using rule 84 (type -> STRING .)
    FLOAT           reduce using rule 84 (type -> STRING .)
    $end            reduce using rule 84 (type -> STRING .)
    RBRACE          reduce using rule 84 (type -> STRING .)
    CASE            reduce using rule 84 (type -> STRING .)
    DEFAULT         reduce using rule 84 (type -> STRING .)
    RETURN          reduce using rule 84 (type -> STRING .)
    ASSIGN          reduce using rule 84 (type -> STRING .)
    RPAREN          reduce using rule 84 (type -> STRING .)
    RBRACKET        reduce using rule 84 (type -> STRING .)
    LBRACE          reduce using rule 84 (type -> STRING .)


state 77

    (85) type -> FLOAT .

    COMMA           reduce using rule 85 (type -> FLOAT .)
    PRINT           reduce using rule 85 (type -> FLOAT .)
    PRINTF          reduce using rule 85 (type -> FLOAT .)
    INPUT           reduce using rule 85 (type -> FLOAT .)
    FUNCTION        reduce using rule 85 (type -> FLOAT .)
    VAR             reduce using rule 85 (type -> FLOAT .)
    VARIABLE        reduce using rule 85 (type -> FLOAT .)
    CONST           reduce using rule 85 (type -> FLOAT .)
    TYPE            reduce using rule 85 (type -> FLOAT .)
    IF              reduce using rule 85 (type -> FLOAT .)
    SWITCH          reduce using rule 85 (type -> FLOAT .)
    CHARSTRING      reduce using rule 85 (type -> FLOAT .)
    FOR             reduce using rule 85 (type -> FLOAT .)
    INT             reduce using rule 85 (type -> FLOAT .)
    FLOAT           reduce using rule 85 (type -> FLOAT .)
    $end            reduce using rule 85 (type -> FLOAT .)
    RBRACE          reduce using rule 85 (type -> FLOAT .)
    CASE            reduce using rule 85 (type -> FLOAT .)
    DEFAULT         reduce using rule 85 (type -> FLOAT .)
    RETURN          reduce using rule 85 (type -> FLOAT .)
    ASSIGN          reduce using rule 85 (type -> FLOAT .)
    RPAREN          reduce using rule 85 (type -> FLOAT .)
    RBRACKET        reduce using rule 85 (type -> FLOAT .)
    LBRACE          reduce using rule 85 (type -> FLOAT .)


state 78

    (86) type -> FLOAT32 .

    COMMA           reduce using rule 86 (type -> FLOAT32 .)
    PRINT           reduce using rule 86 (type -> FLOAT32 .)
    PRINTF          reduce using rule 86 (type -> FLOAT32 .)
    INPUT           reduce using rule 86 (type -> FLOAT32 .)
    FUNCTION        reduce using rule 86 (type -> FLOAT32 .)
    VAR             reduce using rule 86 (type -> FLOAT32 .)
    VARIABLE        reduce using rule 86 (type -> FLOAT32 .)
    CONST           reduce using rule 86 (type -> FLOAT32 .)
    TYPE            reduce using rule 86 (type -> FLOAT32 .)
    IF              reduce using rule 86 (type -> FLOAT32 .)
    SWITCH          reduce using rule 86 (type -> FLOAT32 .)
    CHARSTRING      reduce using rule 86 (type -> FLOAT32 .)
    FOR             reduce using rule 86 (type -> FLOAT32 .)
    INT             reduce using rule 86 (type -> FLOAT32 .)
    FLOAT           reduce using rule 86 (type -> FLOAT32 .)
    $end            reduce using rule 86 (type -> FLOAT32 .)
    RBRACE          reduce using rule 86 (type -> FLOAT32 .)
    CASE            reduce using rule 86 (type -> FLOAT32 .)
    DEFAULT         reduce using rule 86 (type -> FLOAT32 .)
    RETURN          reduce using rule 86 (type -> FLOAT32 .)
    ASSIGN          reduce using rule 86 (type -> FLOAT32 .)
    RPAREN          reduce using rule 86 (type -> FLOAT32 .)
    RBRACKET        reduce using rule 86 (type -> FLOAT32 .)
    LBRACE          reduce using rule 86 (type -> FLOAT32 .)


state 79

    (87) type -> FLOAT64 .

    COMMA           reduce using rule 87 (type -> FLOAT64 .)
    PRINT           reduce using rule 87 (type -> FLOAT64 .)
    PRINTF          reduce using rule 87 (type -> FLOAT64 .)
    INPUT           reduce using rule 87 (type -> FLOAT64 .)
    FUNCTION        reduce using rule 87 (type -> FLOAT64 .)
    VAR             reduce using rule 87 (type -> FLOAT64 .)
    VARIABLE        reduce using rule 87 (type -> FLOAT64 .)
    CONST           reduce using rule 87 (type -> FLOAT64 .)
    TYPE            reduce using rule 87 (type -> FLOAT64 .)
    IF              reduce using rule 87 (type -> FLOAT64 .)
    SWITCH          reduce using rule 87 (type -> FLOAT64 .)
    CHARSTRING      reduce using rule 87 (type -> FLOAT64 .)
    FOR             reduce using rule 87 (type -> FLOAT64 .)
    INT             reduce using rule 87 (type -> FLOAT64 .)
    FLOAT           reduce using rule 87 (type -> FLOAT64 .)
    $end            reduce using rule 87 (type -> FLOAT64 .)
    RBRACE          reduce using rule 87 (type -> FLOAT64 .)
    CASE            reduce using rule 87 (type -> FLOAT64 .)
    DEFAULT         reduce using rule 87 (type -> FLOAT64 .)
    RETURN          reduce using rule 87 (type -> FLOAT64 .)
    ASSIGN          reduce using rule 87 (type -> FLOAT64 .)
    RPAREN          reduce using rule 87 (type -> FLOAT64 .)
    RBRACKET        reduce using rule 87 (type -> FLOAT64 .)
    LBRACE          reduce using rule 87 (type -> FLOAT64 .)


state 80

    (88) type -> BOOL .

    COMMA           reduce using rule 88 (type -> BOOL .)
    PRINT           reduce using rule 88 (type -> BOOL .)
    PRINTF          reduce using rule 88 (type -> BOOL .)
    INPUT           reduce using rule 88 (type -> BOOL .)
    FUNCTION        reduce using rule 88 (type -> BOOL .)
    VAR             reduce using rule 88 (type -> BOOL .)
    VARIABLE        reduce using rule 88 (type -> BOOL .)
    CONST           reduce using rule 88 (type -> BOOL .)
    TYPE            reduce using rule 88 (type -> BOOL .)
    IF              reduce using rule 88 (type -> BOOL .)
    SWITCH          reduce using rule 88 (type -> BOOL .)
    CHARSTRING      reduce using rule 88 (type -> BOOL .)
    FOR             reduce using rule 88 (type -> BOOL .)
    INT             reduce using rule 88 (type -> BOOL .)
    FLOAT           reduce using rule 88 (type -> BOOL .)
    $end            reduce using rule 88 (type -> BOOL .)
    RBRACE          reduce using rule 88 (type -> BOOL .)
    CASE            reduce using rule 88 (type -> BOOL .)
    DEFAULT         reduce using rule 88 (type -> BOOL .)
    RETURN          reduce using rule 88 (type -> BOOL .)
    ASSIGN          reduce using rule 88 (type -> BOOL .)
    RPAREN          reduce using rule 88 (type -> BOOL .)
    RBRACKET        reduce using rule 88 (type -> BOOL .)
    LBRACE          reduce using rule 88 (type -> BOOL .)


state 81

    (16) main -> FUNCTION MAIN . LPAREN RPAREN

    LPAREN          shift and go to state 124


state 82

    (44) function -> FUNCTION VARIABLE . LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> FUNCTION VARIABLE . LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> FUNCTION VARIABLE . LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> FUNCTION VARIABLE . LPAREN RPAREN type LBRACE blocks return RBRACE

    LPAREN          shift and go to state 125


state 83

    (61) print_statement -> PRINT LPAREN . values RPAREN
    (63) print_statement -> PRINT LPAREN . operation RPAREN
    (64) print_statement -> PRINT LPAREN . RPAREN
    (53) values -> . value
    (54) values -> . value COMMA values
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    RPAREN          shift and go to state 127
    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    values                         shift and go to state 126
    operation                      shift and go to state 128
    value                          shift and go to state 129
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 84

    (62) print_statement -> PRINTF LPAREN . FORMATSTRING COMMA values RPAREN

    FORMATSTRING    shift and go to state 130


state 85

    (65) input_statement -> INPUT LPAREN . values RPAREN
    (66) input_statement -> INPUT LPAREN . operation RPAREN
    (67) input_statement -> INPUT LPAREN . RPAREN
    (53) values -> . value
    (54) values -> . value COMMA values
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    RPAREN          shift and go to state 132
    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    values                         shift and go to state 131
    operation                      shift and go to state 133
    value                          shift and go to state 129
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 86

    (68) operation -> value operator . value
    (69) operation -> value operator . operation
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    value                          shift and go to state 134
    operation                      shift and go to state 135
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 87

    (70) operation -> value double_operator .

    PRINT           reduce using rule 70 (operation -> value double_operator .)
    PRINTF          reduce using rule 70 (operation -> value double_operator .)
    INPUT           reduce using rule 70 (operation -> value double_operator .)
    FUNCTION        reduce using rule 70 (operation -> value double_operator .)
    VAR             reduce using rule 70 (operation -> value double_operator .)
    VARIABLE        reduce using rule 70 (operation -> value double_operator .)
    CONST           reduce using rule 70 (operation -> value double_operator .)
    TYPE            reduce using rule 70 (operation -> value double_operator .)
    IF              reduce using rule 70 (operation -> value double_operator .)
    SWITCH          reduce using rule 70 (operation -> value double_operator .)
    CHARSTRING      reduce using rule 70 (operation -> value double_operator .)
    FOR             reduce using rule 70 (operation -> value double_operator .)
    INT             reduce using rule 70 (operation -> value double_operator .)
    FLOAT           reduce using rule 70 (operation -> value double_operator .)
    $end            reduce using rule 70 (operation -> value double_operator .)
    RBRACE          reduce using rule 70 (operation -> value double_operator .)
    CASE            reduce using rule 70 (operation -> value double_operator .)
    DEFAULT         reduce using rule 70 (operation -> value double_operator .)
    RETURN          reduce using rule 70 (operation -> value double_operator .)
    RPAREN          reduce using rule 70 (operation -> value double_operator .)


state 88

    (71) operator -> PLUS .

    VARIABLE        reduce using rule 71 (operator -> PLUS .)
    CHARSTRING      reduce using rule 71 (operator -> PLUS .)
    INT             reduce using rule 71 (operator -> PLUS .)
    FLOAT           reduce using rule 71 (operator -> PLUS .)


state 89

    (72) operator -> MINUS .

    VARIABLE        reduce using rule 72 (operator -> MINUS .)
    CHARSTRING      reduce using rule 72 (operator -> MINUS .)
    INT             reduce using rule 72 (operator -> MINUS .)
    FLOAT           reduce using rule 72 (operator -> MINUS .)


state 90

    (73) operator -> TIMES .

    VARIABLE        reduce using rule 73 (operator -> TIMES .)
    CHARSTRING      reduce using rule 73 (operator -> TIMES .)
    INT             reduce using rule 73 (operator -> TIMES .)
    FLOAT           reduce using rule 73 (operator -> TIMES .)


state 91

    (74) operator -> DIVIDE .

    VARIABLE        reduce using rule 74 (operator -> DIVIDE .)
    CHARSTRING      reduce using rule 74 (operator -> DIVIDE .)
    INT             reduce using rule 74 (operator -> DIVIDE .)
    FLOAT           reduce using rule 74 (operator -> DIVIDE .)


state 92

    (75) operator -> ASSIGN .

    VARIABLE        reduce using rule 75 (operator -> ASSIGN .)
    CHARSTRING      reduce using rule 75 (operator -> ASSIGN .)
    INT             reduce using rule 75 (operator -> ASSIGN .)
    FLOAT           reduce using rule 75 (operator -> ASSIGN .)


state 93

    (79) parameters -> parameter COMMA . parameters
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (80) parameter -> . VARIABLE type

    VARIABLE        shift and go to state 137

    parameter                      shift and go to state 32
    parameters                     shift and go to state 136

state 94

    (28) variable_declaration -> VAR VARIABLE . type
    (29) variable_declaration -> VAR VARIABLE . type ASSIGN value
    (132) array_structure -> VAR VARIABLE . LBRACKET INT RBRACKET type
    (133) array_structure -> VAR VARIABLE . ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> VAR VARIABLE . LBRACKET RBRACKET type
    (81) type -> . INT
    (82) type -> . INT32
    (83) type -> . INT64
    (84) type -> . STRING
    (85) type -> . FLOAT
    (86) type -> . FLOAT32
    (87) type -> . FLOAT64
    (88) type -> . BOOL

    LBRACKET        shift and go to state 140
    ASSIGN          shift and go to state 139
    INT             shift and go to state 66
    INT32           shift and go to state 74
    INT64           shift and go to state 75
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    FLOAT32         shift and go to state 78
    FLOAT64         shift and go to state 79
    BOOL            shift and go to state 80

    type                           shift and go to state 138

state 95

    (32) variable_declaration -> CONST VARIABLE . ASSIGN value

    ASSIGN          shift and go to state 141


state 96

    (128) struct_structure -> TYPE VARIABLE . STRUCT LBRACE struct_fields RBRACE

    STRUCT          shift and go to state 142


state 97

    (92) conditional_structure -> IF conditions . conditional_body
    (93) conditional_structure -> IF conditions . conditional_body ELSE conditional_body
    (94) conditional_structure -> IF conditions . conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (95) conditional_body -> . LBRACE statement RBRACE
    (96) conditional_body -> . LBRACE BREAK RBRACE
    (97) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 144

    conditional_body               shift and go to state 143

state 98

    (98) conditions -> condition .
    (99) conditions -> condition . logical_operator conditions
    (101) logical_operator -> . AND
    (102) logical_operator -> . OR
    (103) logical_operator -> . NOT

    LBRACE          reduce using rule 98 (conditions -> condition .)
    AND             shift and go to state 146
    OR              shift and go to state 147
    NOT             shift and go to state 148

    logical_operator               shift and go to state 145

state 99

    (100) condition -> value . relational_operator value
    (104) relational_operator -> . GREATER
    (105) relational_operator -> . LESS
    (106) relational_operator -> . GREATEREQUALS
    (107) relational_operator -> . LESSEQUALS
    (108) relational_operator -> . EQUALS
    (109) relational_operator -> . DIFFERENT

    GREATER         shift and go to state 150
    LESS            shift and go to state 151
    GREATEREQUALS   shift and go to state 152
    LESSEQUALS      shift and go to state 153
    EQUALS          shift and go to state 154
    DIFFERENT       shift and go to state 155

    relational_operator            shift and go to state 149

state 100

    (55) value -> VARIABLE .

    GREATER         reduce using rule 55 (value -> VARIABLE .)
    LESS            reduce using rule 55 (value -> VARIABLE .)
    GREATEREQUALS   reduce using rule 55 (value -> VARIABLE .)
    LESSEQUALS      reduce using rule 55 (value -> VARIABLE .)
    EQUALS          reduce using rule 55 (value -> VARIABLE .)
    DIFFERENT       reduce using rule 55 (value -> VARIABLE .)
    LBRACE          reduce using rule 55 (value -> VARIABLE .)
    PLUS            reduce using rule 55 (value -> VARIABLE .)
    MINUS           reduce using rule 55 (value -> VARIABLE .)
    TIMES           reduce using rule 55 (value -> VARIABLE .)
    DIVIDE          reduce using rule 55 (value -> VARIABLE .)
    ASSIGN          reduce using rule 55 (value -> VARIABLE .)
    INCREMENT       reduce using rule 55 (value -> VARIABLE .)
    DECREMENT       reduce using rule 55 (value -> VARIABLE .)
    PRINT           reduce using rule 55 (value -> VARIABLE .)
    PRINTF          reduce using rule 55 (value -> VARIABLE .)
    INPUT           reduce using rule 55 (value -> VARIABLE .)
    FUNCTION        reduce using rule 55 (value -> VARIABLE .)
    VAR             reduce using rule 55 (value -> VARIABLE .)
    VARIABLE        reduce using rule 55 (value -> VARIABLE .)
    CONST           reduce using rule 55 (value -> VARIABLE .)
    TYPE            reduce using rule 55 (value -> VARIABLE .)
    IF              reduce using rule 55 (value -> VARIABLE .)
    SWITCH          reduce using rule 55 (value -> VARIABLE .)
    CHARSTRING      reduce using rule 55 (value -> VARIABLE .)
    FOR             reduce using rule 55 (value -> VARIABLE .)
    INT             reduce using rule 55 (value -> VARIABLE .)
    FLOAT           reduce using rule 55 (value -> VARIABLE .)
    $end            reduce using rule 55 (value -> VARIABLE .)
    RBRACE          reduce using rule 55 (value -> VARIABLE .)
    CASE            reduce using rule 55 (value -> VARIABLE .)
    DEFAULT         reduce using rule 55 (value -> VARIABLE .)
    RETURN          reduce using rule 55 (value -> VARIABLE .)
    RBRACKET        reduce using rule 55 (value -> VARIABLE .)
    COMMA           reduce using rule 55 (value -> VARIABLE .)
    RPAREN          reduce using rule 55 (value -> VARIABLE .)
    AND             reduce using rule 55 (value -> VARIABLE .)
    OR              reduce using rule 55 (value -> VARIABLE .)
    NOT             reduce using rule 55 (value -> VARIABLE .)
    SEMICOLON       reduce using rule 55 (value -> VARIABLE .)
    COLON           reduce using rule 55 (value -> VARIABLE .)
    LBRACKET        reduce using rule 55 (value -> VARIABLE .)
    PERIOD          reduce using rule 55 (value -> VARIABLE .)


state 101

    (116) switch_structure -> SWITCH switch_expression . LBRACE case_blocks RBRACE

    LBRACE          shift and go to state 156


state 102

    (117) switch_expression -> value .

    LBRACE          reduce using rule 117 (switch_expression -> value .)


state 103

    (118) switch_expression -> empty .

    LBRACE          reduce using rule 118 (switch_expression -> empty .)


state 104

    (113) for_initialization -> FOR VARIABLE . SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (115) for_iterator -> FOR VARIABLE . SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 157
    SEMICOLON       shift and go to state 158


state 105

    (114) for_infinite_bucle -> FOR LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 9
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 159
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 106

    (7) statement -> import main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    blocks                         shift and go to state 160
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 107

    (4) statement -> package import blocks .

    $end            reduce using rule 4 (statement -> package import blocks .)
    RBRACE          reduce using rule 4 (statement -> package import blocks .)
    CASE            reduce using rule 4 (statement -> package import blocks .)
    DEFAULT         reduce using rule 4 (statement -> package import blocks .)


state 108

    (8) statement -> package import main . LBRACE blocks RBRACE

    LBRACE          shift and go to state 161


state 109

    (6) statement -> package main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    blocks                         shift and go to state 162
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 110

    (5) statement -> main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 163


state 111

    (11) import -> IMPORT LPAREN values_for_import . RPAREN

    RPAREN          shift and go to state 164


state 112

    (12) values_for_import -> CHARSTRING .
    (13) values_for_import -> CHARSTRING . values_for_import
    (12) values_for_import -> . CHARSTRING
    (13) values_for_import -> . CHARSTRING values_for_import

    RPAREN          reduce using rule 12 (values_for_import -> CHARSTRING .)
    CHARSTRING      shift and go to state 112

    values_for_import              shift and go to state 165

state 113

    (30) variable_declaration -> VARIABLE SHORTASSIGN value .
    (68) operation -> value . operator value
    (69) operation -> value . operator operation
    (70) operation -> value . double_operator
    (71) operator -> . PLUS
    (72) operator -> . MINUS
    (73) operator -> . TIMES
    (74) operator -> . DIVIDE
    (75) operator -> . ASSIGN
    (76) double_operator -> . INCREMENT
    (77) double_operator -> . DECREMENT

    PRINT           reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    PRINTF          reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INPUT           reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FUNCTION        reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VAR             reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    VARIABLE        reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CONST           reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    TYPE            reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    IF              reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    SWITCH          reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CHARSTRING      reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FOR             reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    INT             reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    FLOAT           reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    $end            reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    RBRACE          reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    CASE            reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    DEFAULT         reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    RETURN          reduce using rule 30 (variable_declaration -> VARIABLE SHORTASSIGN value .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 89
    TIMES           shift and go to state 90
    DIVIDE          shift and go to state 91
    ASSIGN          shift and go to state 92
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    operator                       shift and go to state 86
    double_operator                shift and go to state 87

state 114

    (31) variable_declaration -> VARIABLE SHORTASSIGN operation .

    PRINT           reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    PRINTF          reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    INPUT           reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FUNCTION        reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    VAR             reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    VARIABLE        reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CONST           reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    TYPE            reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    IF              reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    SWITCH          reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CHARSTRING      reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FOR             reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    INT             reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    FLOAT           reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    $end            reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    RBRACE          reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    CASE            reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    DEFAULT         reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)
    RETURN          reduce using rule 31 (variable_declaration -> VARIABLE SHORTASSIGN operation .)


state 115

    (135) map_structure -> VARIABLE SHORTASSIGN MAP . LBRACKET type RBRACKET type LBRACE map_values RBRACE

    LBRACKET        shift and go to state 166


state 116

    (141) slice_structure -> VARIABLE SHORTASSIGN LBRACKET . RBRACKET type LBRACE values RBRACE
    (143) slice_structure -> VARIABLE SHORTASSIGN LBRACKET . RBRACKET type

    RBRACKET        shift and go to state 167


state 117

    (136) map_structure -> VARIABLE SHORTASSIGN MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN

    LPAREN          shift and go to state 168


state 118

    (33) variable_assignation -> VARIABLE assignation value .
    (68) operation -> value . operator value
    (69) operation -> value . operator operation
    (70) operation -> value . double_operator
    (71) operator -> . PLUS
    (72) operator -> . MINUS
    (73) operator -> . TIMES
    (74) operator -> . DIVIDE
    (75) operator -> . ASSIGN
    (76) double_operator -> . INCREMENT
    (77) double_operator -> . DECREMENT

    PRINT           reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    PRINTF          reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    INPUT           reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    FUNCTION        reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    VAR             reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    VARIABLE        reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    CONST           reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    TYPE            reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    IF              reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    SWITCH          reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    CHARSTRING      reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    FOR             reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    INT             reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    FLOAT           reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    $end            reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    RBRACE          reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    CASE            reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    DEFAULT         reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    RETURN          reduce using rule 33 (variable_assignation -> VARIABLE assignation value .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 89
    TIMES           shift and go to state 90
    DIVIDE          shift and go to state 91
    ASSIGN          shift and go to state 92
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    operator                       shift and go to state 86
    double_operator                shift and go to state 87

state 119

    (34) variable_assignation -> VARIABLE assignation operation .

    PRINT           reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    PRINTF          reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    INPUT           reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    FUNCTION        reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    VAR             reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    VARIABLE        reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    CONST           reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    TYPE            reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    IF              reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    SWITCH          reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    CHARSTRING      reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    FOR             reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    INT             reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    FLOAT           reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    $end            reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    RBRACE          reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    CASE            reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    DEFAULT         reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)
    RETURN          reduce using rule 34 (variable_assignation -> VARIABLE assignation operation .)


state 120

    (140) map_assign -> VARIABLE LBRACKET value . RBRACKET ASSIGN value

    RBRACKET        shift and go to state 169


state 121

    (134) array_assign -> VARIABLE LBRACKET INT . RBRACKET ASSIGN value
    (59) number -> INT .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 170

  ! RBRACKET        [ reduce using rule 59 (number -> INT .) ]


state 122

    (144) slice_structure -> VARIABLE ASSIGN append_statement .

    PRINT           reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    PRINTF          reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    INPUT           reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FUNCTION        reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    VAR             reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    VARIABLE        reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CONST           reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    TYPE            reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    IF              reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    SWITCH          reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CHARSTRING      reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FOR             reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    INT             reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    FLOAT           reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    $end            reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    RBRACE          reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    CASE            reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    DEFAULT         reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)
    RETURN          reduce using rule 144 (slice_structure -> VARIABLE ASSIGN append_statement .)


state 123

    (145) append_statement -> APPEND . LPAREN VARIABLE COMMA values RPAREN

    LPAREN          shift and go to state 171


state 124

    (16) main -> FUNCTION MAIN LPAREN . RPAREN

    RPAREN          shift and go to state 172


state 125

    (44) function -> FUNCTION VARIABLE LPAREN . RPAREN LBRACE blocks RBRACE
    (45) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN LBRACE blocks RBRACE
    (46) function -> FUNCTION VARIABLE LPAREN . RPAREN type LBRACE return RBRACE
    (47) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN type LBRACE return RBRACE
    (48) function -> FUNCTION VARIABLE LPAREN . parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> FUNCTION VARIABLE LPAREN . RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (80) parameter -> . VARIABLE type

    RPAREN          shift and go to state 173
    VARIABLE        shift and go to state 137

    parameters                     shift and go to state 174
    parameter                      shift and go to state 32

state 126

    (61) print_statement -> PRINT LPAREN values . RPAREN

    RPAREN          shift and go to state 175


state 127

    (64) print_statement -> PRINT LPAREN RPAREN .

    PRINT           reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    PRINTF          reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    INPUT           reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    FUNCTION        reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    VAR             reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    VARIABLE        reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    CONST           reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    TYPE            reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    IF              reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    SWITCH          reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    CHARSTRING      reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    FOR             reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    INT             reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    FLOAT           reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    $end            reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    RBRACE          reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    CASE            reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    DEFAULT         reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)
    RETURN          reduce using rule 64 (print_statement -> PRINT LPAREN RPAREN .)


state 128

    (63) print_statement -> PRINT LPAREN operation . RPAREN

    RPAREN          shift and go to state 176


state 129

    (53) values -> value .
    (54) values -> value . COMMA values
    (68) operation -> value . operator value
    (69) operation -> value . operator operation
    (70) operation -> value . double_operator
    (71) operator -> . PLUS
    (72) operator -> . MINUS
    (73) operator -> . TIMES
    (74) operator -> . DIVIDE
    (75) operator -> . ASSIGN
    (76) double_operator -> . INCREMENT
    (77) double_operator -> . DECREMENT

    RPAREN          reduce using rule 53 (values -> value .)
    COMMA           shift and go to state 177
    PLUS            shift and go to state 88
    MINUS           shift and go to state 89
    TIMES           shift and go to state 90
    DIVIDE          shift and go to state 91
    ASSIGN          shift and go to state 92
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    operator                       shift and go to state 86
    double_operator                shift and go to state 87

state 130

    (62) print_statement -> PRINTF LPAREN FORMATSTRING . COMMA values RPAREN

    COMMA           shift and go to state 178


state 131

    (65) input_statement -> INPUT LPAREN values . RPAREN

    RPAREN          shift and go to state 179


state 132

    (67) input_statement -> INPUT LPAREN RPAREN .

    PRINT           reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    PRINTF          reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    FUNCTION        reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    VAR             reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    VARIABLE        reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    CONST           reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    TYPE            reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    IF              reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    SWITCH          reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    CHARSTRING      reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    INT             reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    FLOAT           reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    $end            reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    CASE            reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    DEFAULT         reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)
    RETURN          reduce using rule 67 (input_statement -> INPUT LPAREN RPAREN .)


state 133

    (66) input_statement -> INPUT LPAREN operation . RPAREN

    RPAREN          shift and go to state 180


state 134

    (68) operation -> value operator value .
    (68) operation -> value . operator value
    (69) operation -> value . operator operation
    (70) operation -> value . double_operator
    (71) operator -> . PLUS
    (72) operator -> . MINUS
    (73) operator -> . TIMES
    (74) operator -> . DIVIDE
    (75) operator -> . ASSIGN
    (76) double_operator -> . INCREMENT
    (77) double_operator -> . DECREMENT

    PRINT           reduce using rule 68 (operation -> value operator value .)
    PRINTF          reduce using rule 68 (operation -> value operator value .)
    INPUT           reduce using rule 68 (operation -> value operator value .)
    FUNCTION        reduce using rule 68 (operation -> value operator value .)
    VAR             reduce using rule 68 (operation -> value operator value .)
    VARIABLE        reduce using rule 68 (operation -> value operator value .)
    CONST           reduce using rule 68 (operation -> value operator value .)
    TYPE            reduce using rule 68 (operation -> value operator value .)
    IF              reduce using rule 68 (operation -> value operator value .)
    SWITCH          reduce using rule 68 (operation -> value operator value .)
    CHARSTRING      reduce using rule 68 (operation -> value operator value .)
    FOR             reduce using rule 68 (operation -> value operator value .)
    INT             reduce using rule 68 (operation -> value operator value .)
    FLOAT           reduce using rule 68 (operation -> value operator value .)
    $end            reduce using rule 68 (operation -> value operator value .)
    RBRACE          reduce using rule 68 (operation -> value operator value .)
    CASE            reduce using rule 68 (operation -> value operator value .)
    DEFAULT         reduce using rule 68 (operation -> value operator value .)
    RETURN          reduce using rule 68 (operation -> value operator value .)
    RPAREN          reduce using rule 68 (operation -> value operator value .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 89
    TIMES           shift and go to state 90
    DIVIDE          shift and go to state 91
    ASSIGN          shift and go to state 92
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    operator                       shift and go to state 86
    double_operator                shift and go to state 87

state 135

    (69) operation -> value operator operation .

    PRINT           reduce using rule 69 (operation -> value operator operation .)
    PRINTF          reduce using rule 69 (operation -> value operator operation .)
    INPUT           reduce using rule 69 (operation -> value operator operation .)
    FUNCTION        reduce using rule 69 (operation -> value operator operation .)
    VAR             reduce using rule 69 (operation -> value operator operation .)
    VARIABLE        reduce using rule 69 (operation -> value operator operation .)
    CONST           reduce using rule 69 (operation -> value operator operation .)
    TYPE            reduce using rule 69 (operation -> value operator operation .)
    IF              reduce using rule 69 (operation -> value operator operation .)
    SWITCH          reduce using rule 69 (operation -> value operator operation .)
    CHARSTRING      reduce using rule 69 (operation -> value operator operation .)
    FOR             reduce using rule 69 (operation -> value operator operation .)
    INT             reduce using rule 69 (operation -> value operator operation .)
    FLOAT           reduce using rule 69 (operation -> value operator operation .)
    $end            reduce using rule 69 (operation -> value operator operation .)
    RBRACE          reduce using rule 69 (operation -> value operator operation .)
    CASE            reduce using rule 69 (operation -> value operator operation .)
    DEFAULT         reduce using rule 69 (operation -> value operator operation .)
    RETURN          reduce using rule 69 (operation -> value operator operation .)
    RPAREN          reduce using rule 69 (operation -> value operator operation .)


state 136

    (79) parameters -> parameter COMMA parameters .

    PRINT           reduce using rule 79 (parameters -> parameter COMMA parameters .)
    PRINTF          reduce using rule 79 (parameters -> parameter COMMA parameters .)
    INPUT           reduce using rule 79 (parameters -> parameter COMMA parameters .)
    FUNCTION        reduce using rule 79 (parameters -> parameter COMMA parameters .)
    VAR             reduce using rule 79 (parameters -> parameter COMMA parameters .)
    VARIABLE        reduce using rule 79 (parameters -> parameter COMMA parameters .)
    CONST           reduce using rule 79 (parameters -> parameter COMMA parameters .)
    TYPE            reduce using rule 79 (parameters -> parameter COMMA parameters .)
    IF              reduce using rule 79 (parameters -> parameter COMMA parameters .)
    SWITCH          reduce using rule 79 (parameters -> parameter COMMA parameters .)
    CHARSTRING      reduce using rule 79 (parameters -> parameter COMMA parameters .)
    FOR             reduce using rule 79 (parameters -> parameter COMMA parameters .)
    INT             reduce using rule 79 (parameters -> parameter COMMA parameters .)
    FLOAT           reduce using rule 79 (parameters -> parameter COMMA parameters .)
    $end            reduce using rule 79 (parameters -> parameter COMMA parameters .)
    RBRACE          reduce using rule 79 (parameters -> parameter COMMA parameters .)
    CASE            reduce using rule 79 (parameters -> parameter COMMA parameters .)
    DEFAULT         reduce using rule 79 (parameters -> parameter COMMA parameters .)
    RETURN          reduce using rule 79 (parameters -> parameter COMMA parameters .)
    RPAREN          reduce using rule 79 (parameters -> parameter COMMA parameters .)


state 137

    (80) parameter -> VARIABLE . type
    (81) type -> . INT
    (82) type -> . INT32
    (83) type -> . INT64
    (84) type -> . STRING
    (85) type -> . FLOAT
    (86) type -> . FLOAT32
    (87) type -> . FLOAT64
    (88) type -> . BOOL

    INT             shift and go to state 66
    INT32           shift and go to state 74
    INT64           shift and go to state 75
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    FLOAT32         shift and go to state 78
    FLOAT64         shift and go to state 79
    BOOL            shift and go to state 80

    type                           shift and go to state 64

state 138

    (28) variable_declaration -> VAR VARIABLE type .
    (29) variable_declaration -> VAR VARIABLE type . ASSIGN value

    PRINT           reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    PRINTF          reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    INPUT           reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    FUNCTION        reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    VAR             reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    VARIABLE        reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    CONST           reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    TYPE            reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    IF              reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    SWITCH          reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    CHARSTRING      reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    FOR             reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    INT             reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    FLOAT           reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    $end            reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    RBRACE          reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    CASE            reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    DEFAULT         reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    RETURN          reduce using rule 28 (variable_declaration -> VAR VARIABLE type .)
    ASSIGN          shift and go to state 181


state 139

    (133) array_structure -> VAR VARIABLE ASSIGN . LBRACKET INT RBRACKET type LBRACE values RBRACE

    LBRACKET        shift and go to state 182


state 140

    (132) array_structure -> VAR VARIABLE LBRACKET . INT RBRACKET type
    (142) slice_structure -> VAR VARIABLE LBRACKET . RBRACKET type

    INT             shift and go to state 183
    RBRACKET        shift and go to state 184


state 141

    (32) variable_declaration -> CONST VARIABLE ASSIGN . value
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    value                          shift and go to state 185
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 142

    (128) struct_structure -> TYPE VARIABLE STRUCT . LBRACE struct_fields RBRACE

    LBRACE          shift and go to state 186


state 143

    (92) conditional_structure -> IF conditions conditional_body .
    (93) conditional_structure -> IF conditions conditional_body . ELSE conditional_body
    (94) conditional_structure -> IF conditions conditional_body . ELSE IF conditions conditional_body ELSE conditional_body

    PRINT           reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    PRINTF          reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    INPUT           reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    FUNCTION        reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    VAR             reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    VARIABLE        reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    CONST           reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    TYPE            reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    IF              reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    SWITCH          reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    CHARSTRING      reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    FOR             reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    INT             reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    FLOAT           reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    $end            reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    RBRACE          reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    CASE            reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    DEFAULT         reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    RETURN          reduce using rule 92 (conditional_structure -> IF conditions conditional_body .)
    ELSE            shift and go to state 187


state 144

    (95) conditional_body -> LBRACE . statement RBRACE
    (96) conditional_body -> LBRACE . BREAK RBRACE
    (97) conditional_body -> LBRACE . CONTINUE RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    BREAK           shift and go to state 189
    CONTINUE        shift and go to state 190
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 9
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 188
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 145

    (99) conditions -> condition logical_operator . conditions
    (98) conditions -> . condition
    (99) conditions -> . condition logical_operator conditions
    (100) condition -> . value relational_operator value
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    condition                      shift and go to state 98
    conditions                     shift and go to state 191
    value                          shift and go to state 99
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 146

    (101) logical_operator -> AND .

    VARIABLE        reduce using rule 101 (logical_operator -> AND .)
    CHARSTRING      reduce using rule 101 (logical_operator -> AND .)
    INT             reduce using rule 101 (logical_operator -> AND .)
    FLOAT           reduce using rule 101 (logical_operator -> AND .)


state 147

    (102) logical_operator -> OR .

    VARIABLE        reduce using rule 102 (logical_operator -> OR .)
    CHARSTRING      reduce using rule 102 (logical_operator -> OR .)
    INT             reduce using rule 102 (logical_operator -> OR .)
    FLOAT           reduce using rule 102 (logical_operator -> OR .)


state 148

    (103) logical_operator -> NOT .

    VARIABLE        reduce using rule 103 (logical_operator -> NOT .)
    CHARSTRING      reduce using rule 103 (logical_operator -> NOT .)
    INT             reduce using rule 103 (logical_operator -> NOT .)
    FLOAT           reduce using rule 103 (logical_operator -> NOT .)


state 149

    (100) condition -> value relational_operator . value
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    value                          shift and go to state 192
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 150

    (104) relational_operator -> GREATER .

    VARIABLE        reduce using rule 104 (relational_operator -> GREATER .)
    CHARSTRING      reduce using rule 104 (relational_operator -> GREATER .)
    INT             reduce using rule 104 (relational_operator -> GREATER .)
    FLOAT           reduce using rule 104 (relational_operator -> GREATER .)


state 151

    (105) relational_operator -> LESS .

    VARIABLE        reduce using rule 105 (relational_operator -> LESS .)
    CHARSTRING      reduce using rule 105 (relational_operator -> LESS .)
    INT             reduce using rule 105 (relational_operator -> LESS .)
    FLOAT           reduce using rule 105 (relational_operator -> LESS .)


state 152

    (106) relational_operator -> GREATEREQUALS .

    VARIABLE        reduce using rule 106 (relational_operator -> GREATEREQUALS .)
    CHARSTRING      reduce using rule 106 (relational_operator -> GREATEREQUALS .)
    INT             reduce using rule 106 (relational_operator -> GREATEREQUALS .)
    FLOAT           reduce using rule 106 (relational_operator -> GREATEREQUALS .)


state 153

    (107) relational_operator -> LESSEQUALS .

    VARIABLE        reduce using rule 107 (relational_operator -> LESSEQUALS .)
    CHARSTRING      reduce using rule 107 (relational_operator -> LESSEQUALS .)
    INT             reduce using rule 107 (relational_operator -> LESSEQUALS .)
    FLOAT           reduce using rule 107 (relational_operator -> LESSEQUALS .)


state 154

    (108) relational_operator -> EQUALS .

    VARIABLE        reduce using rule 108 (relational_operator -> EQUALS .)
    CHARSTRING      reduce using rule 108 (relational_operator -> EQUALS .)
    INT             reduce using rule 108 (relational_operator -> EQUALS .)
    FLOAT           reduce using rule 108 (relational_operator -> EQUALS .)


state 155

    (109) relational_operator -> DIFFERENT .

    VARIABLE        reduce using rule 109 (relational_operator -> DIFFERENT .)
    CHARSTRING      reduce using rule 109 (relational_operator -> DIFFERENT .)
    INT             reduce using rule 109 (relational_operator -> DIFFERENT .)
    FLOAT           reduce using rule 109 (relational_operator -> DIFFERENT .)


state 156

    (116) switch_structure -> SWITCH switch_expression LBRACE . case_blocks RBRACE
    (119) case_blocks -> . case_block
    (120) case_blocks -> . case_block case_blocks
    (121) case_block -> . CASE values COLON statement
    (122) case_block -> . DEFAULT COLON statement

    CASE            shift and go to state 195
    DEFAULT         shift and go to state 196

    case_blocks                    shift and go to state 193
    case_block                     shift and go to state 194

state 157

    (113) for_initialization -> FOR VARIABLE SHORTASSIGN . value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    value                          shift and go to state 197
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 158

    (115) for_iterator -> FOR VARIABLE SEMICOLON . VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 198


state 159

    (114) for_infinite_bucle -> FOR LBRACE statement . RBRACE

    RBRACE          shift and go to state 199


state 160

    (7) statement -> import main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 200


state 161

    (8) statement -> package import main LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    blocks                         shift and go to state 201
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 162

    (6) statement -> package main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 202


state 163

    (5) statement -> main LBRACE blocks RBRACE .

    $end            reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)
    CASE            reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 5 (statement -> main LBRACE blocks RBRACE .)


state 164

    (11) import -> IMPORT LPAREN values_for_import RPAREN .

    FUNCTION        reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    PRINT           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    PRINTF          reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    INPUT           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    VAR             reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    VARIABLE        reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    CONST           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    TYPE            reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    IF              reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    SWITCH          reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    CHARSTRING      reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    FOR             reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    INT             reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)
    FLOAT           reduce using rule 11 (import -> IMPORT LPAREN values_for_import RPAREN .)


state 165

    (13) values_for_import -> CHARSTRING values_for_import .

    RPAREN          reduce using rule 13 (values_for_import -> CHARSTRING values_for_import .)


state 166

    (135) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET . type RBRACKET type LBRACE map_values RBRACE
    (81) type -> . INT
    (82) type -> . INT32
    (83) type -> . INT64
    (84) type -> . STRING
    (85) type -> . FLOAT
    (86) type -> . FLOAT32
    (87) type -> . FLOAT64
    (88) type -> . BOOL

    INT             shift and go to state 66
    INT32           shift and go to state 74
    INT64           shift and go to state 75
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    FLOAT32         shift and go to state 78
    FLOAT64         shift and go to state 79
    BOOL            shift and go to state 80

    type                           shift and go to state 203

state 167

    (141) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET . type LBRACE values RBRACE
    (143) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET . type
    (81) type -> . INT
    (82) type -> . INT32
    (83) type -> . INT64
    (84) type -> . STRING
    (85) type -> . FLOAT
    (86) type -> . FLOAT32
    (87) type -> . FLOAT64
    (88) type -> . BOOL

    INT             shift and go to state 66
    INT32           shift and go to state 74
    INT64           shift and go to state 75
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    FLOAT32         shift and go to state 78
    FLOAT64         shift and go to state 79
    BOOL            shift and go to state 80

    type                           shift and go to state 204

state 168

    (136) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN

    MAP             shift and go to state 205


state 169

    (140) map_assign -> VARIABLE LBRACKET value RBRACKET . ASSIGN value

    ASSIGN          shift and go to state 206


state 170

    (134) array_assign -> VARIABLE LBRACKET INT RBRACKET . ASSIGN value

    ASSIGN          shift and go to state 207


state 171

    (145) append_statement -> APPEND LPAREN . VARIABLE COMMA values RPAREN

    VARIABLE        shift and go to state 208


state 172

    (16) main -> FUNCTION MAIN LPAREN RPAREN .

    LBRACE          reduce using rule 16 (main -> FUNCTION MAIN LPAREN RPAREN .)


state 173

    (44) function -> FUNCTION VARIABLE LPAREN RPAREN . LBRACE blocks RBRACE
    (46) function -> FUNCTION VARIABLE LPAREN RPAREN . type LBRACE return RBRACE
    (49) function -> FUNCTION VARIABLE LPAREN RPAREN . type LBRACE blocks return RBRACE
    (81) type -> . INT
    (82) type -> . INT32
    (83) type -> . INT64
    (84) type -> . STRING
    (85) type -> . FLOAT
    (86) type -> . FLOAT32
    (87) type -> . FLOAT64
    (88) type -> . BOOL

    LBRACE          shift and go to state 209
    INT             shift and go to state 66
    INT32           shift and go to state 74
    INT64           shift and go to state 75
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    FLOAT32         shift and go to state 78
    FLOAT64         shift and go to state 79
    BOOL            shift and go to state 80

    type                           shift and go to state 210

state 174

    (45) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN LBRACE blocks RBRACE
    (47) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN type LBRACE return RBRACE
    (48) function -> FUNCTION VARIABLE LPAREN parameters . RPAREN type LBRACE blocks return RBRACE

    RPAREN          shift and go to state 211


state 175

    (61) print_statement -> PRINT LPAREN values RPAREN .

    PRINT           reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    PRINTF          reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    INPUT           reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    VAR             reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    CONST           reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    TYPE            reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    IF              reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    SWITCH          reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    CHARSTRING      reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    FOR             reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    INT             reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    FLOAT           reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    $end            reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    RBRACE          reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    CASE            reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    DEFAULT         reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)
    RETURN          reduce using rule 61 (print_statement -> PRINT LPAREN values RPAREN .)


state 176

    (63) print_statement -> PRINT LPAREN operation RPAREN .

    PRINT           reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    PRINTF          reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    INPUT           reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    VAR             reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    CONST           reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    TYPE            reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    IF              reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    SWITCH          reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    FOR             reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    INT             reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    $end            reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    CASE            reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)
    RETURN          reduce using rule 63 (print_statement -> PRINT LPAREN operation RPAREN .)


state 177

    (54) values -> value COMMA . values
    (53) values -> . value
    (54) values -> . value COMMA values
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    value                          shift and go to state 212
    values                         shift and go to state 213
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 178

    (62) print_statement -> PRINTF LPAREN FORMATSTRING COMMA . values RPAREN
    (53) values -> . value
    (54) values -> . value COMMA values
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    values                         shift and go to state 214
    value                          shift and go to state 212
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 179

    (65) input_statement -> INPUT LPAREN values RPAREN .

    PRINT           reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    PRINTF          reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    INPUT           reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    FUNCTION        reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    VAR             reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    VARIABLE        reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    CONST           reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    TYPE            reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    IF              reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    SWITCH          reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    CHARSTRING      reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    FOR             reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    INT             reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    FLOAT           reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    $end            reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    RBRACE          reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    CASE            reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    DEFAULT         reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)
    RETURN          reduce using rule 65 (input_statement -> INPUT LPAREN values RPAREN .)


state 180

    (66) input_statement -> INPUT LPAREN operation RPAREN .

    PRINT           reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    PRINTF          reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    INPUT           reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    FUNCTION        reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    VAR             reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    VARIABLE        reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    CONST           reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    TYPE            reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    IF              reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    SWITCH          reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    CHARSTRING      reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    FOR             reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    INT             reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    FLOAT           reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    $end            reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    RBRACE          reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    CASE            reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    DEFAULT         reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)
    RETURN          reduce using rule 66 (input_statement -> INPUT LPAREN operation RPAREN .)


state 181

    (29) variable_declaration -> VAR VARIABLE type ASSIGN . value
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    value                          shift and go to state 215
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 182

    (133) array_structure -> VAR VARIABLE ASSIGN LBRACKET . INT RBRACKET type LBRACE values RBRACE

    INT             shift and go to state 216


state 183

    (132) array_structure -> VAR VARIABLE LBRACKET INT . RBRACKET type

    RBRACKET        shift and go to state 217


state 184

    (142) slice_structure -> VAR VARIABLE LBRACKET RBRACKET . type
    (81) type -> . INT
    (82) type -> . INT32
    (83) type -> . INT64
    (84) type -> . STRING
    (85) type -> . FLOAT
    (86) type -> . FLOAT32
    (87) type -> . FLOAT64
    (88) type -> . BOOL

    INT             shift and go to state 66
    INT32           shift and go to state 74
    INT64           shift and go to state 75
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    FLOAT32         shift and go to state 78
    FLOAT64         shift and go to state 79
    BOOL            shift and go to state 80

    type                           shift and go to state 218

state 185

    (32) variable_declaration -> CONST VARIABLE ASSIGN value .

    PRINT           reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    PRINTF          reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    INPUT           reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    FUNCTION        reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    VAR             reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    VARIABLE        reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    CONST           reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    TYPE            reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    IF              reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    SWITCH          reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    CHARSTRING      reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    FOR             reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    INT             reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    FLOAT           reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    $end            reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    RBRACE          reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    CASE            reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    DEFAULT         reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)
    RETURN          reduce using rule 32 (variable_declaration -> CONST VARIABLE ASSIGN value .)


state 186

    (128) struct_structure -> TYPE VARIABLE STRUCT LBRACE . struct_fields RBRACE
    (129) struct_fields -> . struct_field
    (130) struct_fields -> . struct_field struct_fields
    (131) struct_field -> . VARIABLE type

    VARIABLE        shift and go to state 219

    struct_fields                  shift and go to state 220
    struct_field                   shift and go to state 221

state 187

    (93) conditional_structure -> IF conditions conditional_body ELSE . conditional_body
    (94) conditional_structure -> IF conditions conditional_body ELSE . IF conditions conditional_body ELSE conditional_body
    (95) conditional_body -> . LBRACE statement RBRACE
    (96) conditional_body -> . LBRACE BREAK RBRACE
    (97) conditional_body -> . LBRACE CONTINUE RBRACE

    IF              shift and go to state 222
    LBRACE          shift and go to state 144

    conditional_body               shift and go to state 223

state 188

    (95) conditional_body -> LBRACE statement . RBRACE

    RBRACE          shift and go to state 224


state 189

    (96) conditional_body -> LBRACE BREAK . RBRACE

    RBRACE          shift and go to state 225


state 190

    (97) conditional_body -> LBRACE CONTINUE . RBRACE

    RBRACE          shift and go to state 226


state 191

    (99) conditions -> condition logical_operator conditions .

    LBRACE          reduce using rule 99 (conditions -> condition logical_operator conditions .)


state 192

    (100) condition -> value relational_operator value .

    AND             reduce using rule 100 (condition -> value relational_operator value .)
    OR              reduce using rule 100 (condition -> value relational_operator value .)
    NOT             reduce using rule 100 (condition -> value relational_operator value .)
    LBRACE          reduce using rule 100 (condition -> value relational_operator value .)
    SEMICOLON       reduce using rule 100 (condition -> value relational_operator value .)


state 193

    (116) switch_structure -> SWITCH switch_expression LBRACE case_blocks . RBRACE

    RBRACE          shift and go to state 227


state 194

    (119) case_blocks -> case_block .
    (120) case_blocks -> case_block . case_blocks
    (119) case_blocks -> . case_block
    (120) case_blocks -> . case_block case_blocks
    (121) case_block -> . CASE values COLON statement
    (122) case_block -> . DEFAULT COLON statement

    RBRACE          reduce using rule 119 (case_blocks -> case_block .)
    CASE            shift and go to state 195
    DEFAULT         shift and go to state 196

    case_block                     shift and go to state 194
    case_blocks                    shift and go to state 228

state 195

    (121) case_block -> CASE . values COLON statement
    (53) values -> . value
    (54) values -> . value COMMA values
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    values                         shift and go to state 229
    value                          shift and go to state 212
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 196

    (122) case_block -> DEFAULT . COLON statement

    COLON           shift and go to state 230


state 197

    (113) for_initialization -> FOR VARIABLE SHORTASSIGN value . SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 231


state 198

    (115) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE . SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE

    SHORTASSIGN     shift and go to state 232


state 199

    (114) for_infinite_bucle -> FOR LBRACE statement RBRACE .

    PRINT           reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    PRINTF          reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INPUT           reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VAR             reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CONST           reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    TYPE            reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    IF              reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    SWITCH          reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FOR             reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    INT             reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    FLOAT           reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    $end            reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RBRACE          reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    CASE            reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)
    RETURN          reduce using rule 114 (for_infinite_bucle -> FOR LBRACE statement RBRACE .)


state 200

    (7) statement -> import main LBRACE blocks RBRACE .

    $end            reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)
    CASE            reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 7 (statement -> import main LBRACE blocks RBRACE .)


state 201

    (8) statement -> package import main LBRACE blocks . RBRACE

    RBRACE          shift and go to state 233


state 202

    (6) statement -> package main LBRACE blocks RBRACE .

    $end            reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)
    CASE            reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 6 (statement -> package main LBRACE blocks RBRACE .)


state 203

    (135) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type . RBRACKET type LBRACE map_values RBRACE

    RBRACKET        shift and go to state 234


state 204

    (141) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type . LBRACE values RBRACE
    (143) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .

    LBRACE          shift and go to state 235
    PRINT           reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    PRINTF          reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    INPUT           reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FUNCTION        reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    VAR             reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CONST           reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    TYPE            reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    IF              reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CHARSTRING      reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FOR             reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    INT             reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    FLOAT           reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    $end            reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    CASE            reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)
    RETURN          reduce using rule 143 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type .)


state 205

    (136) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN

    LBRACKET        shift and go to state 236


state 206

    (140) map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN . value
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    value                          shift and go to state 237
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 207

    (134) array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN . value
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    value                          shift and go to state 238
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 208

    (145) append_statement -> APPEND LPAREN VARIABLE . COMMA values RPAREN

    COMMA           shift and go to state 239


state 209

    (44) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    blocks                         shift and go to state 240
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 210

    (46) function -> FUNCTION VARIABLE LPAREN RPAREN type . LBRACE return RBRACE
    (49) function -> FUNCTION VARIABLE LPAREN RPAREN type . LBRACE blocks return RBRACE

    LBRACE          shift and go to state 241


state 211

    (45) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . LBRACE blocks RBRACE
    (47) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . type LBRACE return RBRACE
    (48) function -> FUNCTION VARIABLE LPAREN parameters RPAREN . type LBRACE blocks return RBRACE
    (81) type -> . INT
    (82) type -> . INT32
    (83) type -> . INT64
    (84) type -> . STRING
    (85) type -> . FLOAT
    (86) type -> . FLOAT32
    (87) type -> . FLOAT64
    (88) type -> . BOOL

    LBRACE          shift and go to state 242
    INT             shift and go to state 66
    INT32           shift and go to state 74
    INT64           shift and go to state 75
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    FLOAT32         shift and go to state 78
    FLOAT64         shift and go to state 79
    BOOL            shift and go to state 80

    type                           shift and go to state 243

state 212

    (53) values -> value .
    (54) values -> value . COMMA values

    RPAREN          reduce using rule 53 (values -> value .)
    COLON           reduce using rule 53 (values -> value .)
    RBRACE          reduce using rule 53 (values -> value .)
    COMMA           shift and go to state 177


state 213

    (54) values -> value COMMA values .

    RPAREN          reduce using rule 54 (values -> value COMMA values .)
    COLON           reduce using rule 54 (values -> value COMMA values .)
    RBRACE          reduce using rule 54 (values -> value COMMA values .)


state 214

    (62) print_statement -> PRINTF LPAREN FORMATSTRING COMMA values . RPAREN

    RPAREN          shift and go to state 244


state 215

    (29) variable_declaration -> VAR VARIABLE type ASSIGN value .

    PRINT           reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    PRINTF          reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    INPUT           reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    FUNCTION        reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    VAR             reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    VARIABLE        reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    CONST           reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    TYPE            reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    IF              reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    SWITCH          reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    CHARSTRING      reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    FOR             reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    INT             reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    FLOAT           reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    $end            reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    RBRACE          reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    CASE            reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    DEFAULT         reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)
    RETURN          reduce using rule 29 (variable_declaration -> VAR VARIABLE type ASSIGN value .)


state 216

    (133) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT . RBRACKET type LBRACE values RBRACE

    RBRACKET        shift and go to state 245


state 217

    (132) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET . type
    (81) type -> . INT
    (82) type -> . INT32
    (83) type -> . INT64
    (84) type -> . STRING
    (85) type -> . FLOAT
    (86) type -> . FLOAT32
    (87) type -> . FLOAT64
    (88) type -> . BOOL

    INT             shift and go to state 66
    INT32           shift and go to state 74
    INT64           shift and go to state 75
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    FLOAT32         shift and go to state 78
    FLOAT64         shift and go to state 79
    BOOL            shift and go to state 80

    type                           shift and go to state 246

state 218

    (142) slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .

    PRINT           reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    PRINTF          reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    INPUT           reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FUNCTION        reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    VAR             reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CONST           reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    TYPE            reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    IF              reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CHARSTRING      reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FOR             reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    INT             reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    FLOAT           reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    $end            reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    CASE            reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)
    RETURN          reduce using rule 142 (slice_structure -> VAR VARIABLE LBRACKET RBRACKET type .)


state 219

    (131) struct_field -> VARIABLE . type
    (81) type -> . INT
    (82) type -> . INT32
    (83) type -> . INT64
    (84) type -> . STRING
    (85) type -> . FLOAT
    (86) type -> . FLOAT32
    (87) type -> . FLOAT64
    (88) type -> . BOOL

    INT             shift and go to state 66
    INT32           shift and go to state 74
    INT64           shift and go to state 75
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    FLOAT32         shift and go to state 78
    FLOAT64         shift and go to state 79
    BOOL            shift and go to state 80

    type                           shift and go to state 247

state 220

    (128) struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields . RBRACE

    RBRACE          shift and go to state 248


state 221

    (129) struct_fields -> struct_field .
    (130) struct_fields -> struct_field . struct_fields
    (129) struct_fields -> . struct_field
    (130) struct_fields -> . struct_field struct_fields
    (131) struct_field -> . VARIABLE type

    RBRACE          reduce using rule 129 (struct_fields -> struct_field .)
    VARIABLE        shift and go to state 219

    struct_field                   shift and go to state 221
    struct_fields                  shift and go to state 249

state 222

    (94) conditional_structure -> IF conditions conditional_body ELSE IF . conditions conditional_body ELSE conditional_body
    (98) conditions -> . condition
    (99) conditions -> . condition logical_operator conditions
    (100) condition -> . value relational_operator value
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    conditions                     shift and go to state 250
    condition                      shift and go to state 98
    value                          shift and go to state 99
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 223

    (93) conditional_structure -> IF conditions conditional_body ELSE conditional_body .

    PRINT           reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    PRINTF          reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CONST           reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    SWITCH          reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CHARSTRING      reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    CASE            reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    DEFAULT         reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)
    RETURN          reduce using rule 93 (conditional_structure -> IF conditions conditional_body ELSE conditional_body .)


state 224

    (95) conditional_body -> LBRACE statement RBRACE .

    ELSE            reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    PRINT           reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    PRINTF          reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    INPUT           reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    VAR             reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    CONST           reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    TYPE            reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    IF              reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    SWITCH          reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    FOR             reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    INT             reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    FLOAT           reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    $end            reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    RBRACE          reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    CASE            reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)
    RETURN          reduce using rule 95 (conditional_body -> LBRACE statement RBRACE .)


state 225

    (96) conditional_body -> LBRACE BREAK RBRACE .

    ELSE            reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    PRINT           reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    PRINTF          reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    INPUT           reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    FUNCTION        reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    VAR             reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    VARIABLE        reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    CONST           reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    TYPE            reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    IF              reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    SWITCH          reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    CHARSTRING      reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    FOR             reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    INT             reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    FLOAT           reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    $end            reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    RBRACE          reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    CASE            reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    DEFAULT         reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)
    RETURN          reduce using rule 96 (conditional_body -> LBRACE BREAK RBRACE .)


state 226

    (97) conditional_body -> LBRACE CONTINUE RBRACE .

    ELSE            reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    PRINT           reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    PRINTF          reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INPUT           reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FUNCTION        reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VAR             reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    VARIABLE        reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CONST           reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    TYPE            reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    IF              reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    SWITCH          reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CHARSTRING      reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FOR             reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    INT             reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    FLOAT           reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    $end            reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RBRACE          reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    CASE            reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    DEFAULT         reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)
    RETURN          reduce using rule 97 (conditional_body -> LBRACE CONTINUE RBRACE .)


state 227

    (116) switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .

    PRINT           reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    PRINTF          reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    INPUT           reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FUNCTION        reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    VAR             reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    VARIABLE        reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CONST           reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    TYPE            reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    IF              reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    SWITCH          reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CHARSTRING      reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FOR             reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    INT             reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    FLOAT           reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    $end            reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    RBRACE          reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    CASE            reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    DEFAULT         reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)
    RETURN          reduce using rule 116 (switch_structure -> SWITCH switch_expression LBRACE case_blocks RBRACE .)


state 228

    (120) case_blocks -> case_block case_blocks .

    RBRACE          reduce using rule 120 (case_blocks -> case_block case_blocks .)


state 229

    (121) case_block -> CASE values . COLON statement

    COLON           shift and go to state 251


state 230

    (122) case_block -> DEFAULT COLON . statement
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 9
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 252
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 231

    (113) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON . condition SEMICOLON value double_operator LBRACE statement RBRACE
    (100) condition -> . value relational_operator value
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    value                          shift and go to state 99
    condition                      shift and go to state 253
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 232

    (115) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN . RANGE VARIABLE LBRACE statement RBRACE

    RANGE           shift and go to state 254


state 233

    (8) statement -> package import main LBRACE blocks RBRACE .

    $end            reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)
    CASE            reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 8 (statement -> package import main LBRACE blocks RBRACE .)


state 234

    (135) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET . type LBRACE map_values RBRACE
    (81) type -> . INT
    (82) type -> . INT32
    (83) type -> . INT64
    (84) type -> . STRING
    (85) type -> . FLOAT
    (86) type -> . FLOAT32
    (87) type -> . FLOAT64
    (88) type -> . BOOL

    INT             shift and go to state 66
    INT32           shift and go to state 74
    INT64           shift and go to state 75
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    FLOAT32         shift and go to state 78
    FLOAT64         shift and go to state 79
    BOOL            shift and go to state 80

    type                           shift and go to state 255

state 235

    (141) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE . values RBRACE
    (53) values -> . value
    (54) values -> . value COMMA values
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    values                         shift and go to state 256
    value                          shift and go to state 212
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 236

    (136) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (81) type -> . INT
    (82) type -> . INT32
    (83) type -> . INT64
    (84) type -> . STRING
    (85) type -> . FLOAT
    (86) type -> . FLOAT32
    (87) type -> . FLOAT64
    (88) type -> . BOOL

    INT             shift and go to state 66
    INT32           shift and go to state 74
    INT64           shift and go to state 75
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    FLOAT32         shift and go to state 78
    FLOAT64         shift and go to state 79
    BOOL            shift and go to state 80

    type                           shift and go to state 257

state 237

    (140) map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .

    PRINT           reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    PRINTF          reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    INPUT           reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    FUNCTION        reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    VAR             reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    VARIABLE        reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    CONST           reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    TYPE            reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    IF              reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    SWITCH          reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    CHARSTRING      reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    FOR             reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    INT             reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    FLOAT           reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    $end            reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    RBRACE          reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    CASE            reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    DEFAULT         reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)
    RETURN          reduce using rule 140 (map_assign -> VARIABLE LBRACKET value RBRACKET ASSIGN value .)


state 238

    (134) array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .

    PRINT           reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    PRINTF          reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    INPUT           reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    FUNCTION        reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    VAR             reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    VARIABLE        reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    CONST           reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    TYPE            reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    IF              reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    SWITCH          reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    CHARSTRING      reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    FOR             reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    INT             reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    FLOAT           reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    $end            reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    RBRACE          reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    CASE            reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    DEFAULT         reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)
    RETURN          reduce using rule 134 (array_assign -> VARIABLE LBRACKET INT RBRACKET ASSIGN value .)


state 239

    (145) append_statement -> APPEND LPAREN VARIABLE COMMA . values RPAREN
    (53) values -> . value
    (54) values -> . value COMMA values
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    values                         shift and go to state 258
    value                          shift and go to state 212
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 240

    (44) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 259


state 241

    (46) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE . return RBRACE
    (49) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE . blocks return RBRACE
    (50) return -> . RETURN values
    (51) return -> . RETURN value LBRACKET value RBRACKET
    (52) return -> . RETURN value PERIOD value
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

    RETURN          shift and go to state 262
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    return                         shift and go to state 260
    blocks                         shift and go to state 261
    value                          shift and go to state 24
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 242

    (45) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE . blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    parameters                     shift and go to state 18
    blocks                         shift and go to state 263
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 243

    (47) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type . LBRACE return RBRACE
    (48) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type . LBRACE blocks return RBRACE

    LBRACE          shift and go to state 264


state 244

    (62) print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .

    PRINT           reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    PRINTF          reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    INPUT           reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FUNCTION        reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    VAR             reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    VARIABLE        reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CONST           reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    TYPE            reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    IF              reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    SWITCH          reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CHARSTRING      reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FOR             reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    INT             reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    FLOAT           reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    $end            reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    RBRACE          reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    CASE            reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    DEFAULT         reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)
    RETURN          reduce using rule 62 (print_statement -> PRINTF LPAREN FORMATSTRING COMMA values RPAREN .)


state 245

    (133) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET . type LBRACE values RBRACE
    (81) type -> . INT
    (82) type -> . INT32
    (83) type -> . INT64
    (84) type -> . STRING
    (85) type -> . FLOAT
    (86) type -> . FLOAT32
    (87) type -> . FLOAT64
    (88) type -> . BOOL

    INT             shift and go to state 66
    INT32           shift and go to state 74
    INT64           shift and go to state 75
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    FLOAT32         shift and go to state 78
    FLOAT64         shift and go to state 79
    BOOL            shift and go to state 80

    type                           shift and go to state 265

state 246

    (132) array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .

    PRINT           reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    PRINTF          reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    INPUT           reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    FUNCTION        reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    VAR             reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    VARIABLE        reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    CONST           reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    TYPE            reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    IF              reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    SWITCH          reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    CHARSTRING      reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    FOR             reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    INT             reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    FLOAT           reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    $end            reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    RBRACE          reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    CASE            reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    DEFAULT         reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)
    RETURN          reduce using rule 132 (array_structure -> VAR VARIABLE LBRACKET INT RBRACKET type .)


state 247

    (131) struct_field -> VARIABLE type .

    VARIABLE        reduce using rule 131 (struct_field -> VARIABLE type .)
    RBRACE          reduce using rule 131 (struct_field -> VARIABLE type .)


state 248

    (128) struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .

    PRINT           reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    PRINTF          reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    INPUT           reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FUNCTION        reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    VAR             reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    VARIABLE        reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CONST           reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    TYPE            reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    IF              reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    SWITCH          reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CHARSTRING      reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FOR             reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    INT             reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FLOAT           reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    $end            reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    RBRACE          reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CASE            reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    DEFAULT         reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    RETURN          reduce using rule 128 (struct_structure -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)


state 249

    (130) struct_fields -> struct_field struct_fields .

    RBRACE          reduce using rule 130 (struct_fields -> struct_field struct_fields .)


state 250

    (94) conditional_structure -> IF conditions conditional_body ELSE IF conditions . conditional_body ELSE conditional_body
    (95) conditional_body -> . LBRACE statement RBRACE
    (96) conditional_body -> . LBRACE BREAK RBRACE
    (97) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 144

    conditional_body               shift and go to state 266

state 251

    (121) case_block -> CASE values COLON . statement
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 9
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 267
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 252

    (122) case_block -> DEFAULT COLON statement .

    CASE            reduce using rule 122 (case_block -> DEFAULT COLON statement .)
    DEFAULT         reduce using rule 122 (case_block -> DEFAULT COLON statement .)
    RBRACE          reduce using rule 122 (case_block -> DEFAULT COLON statement .)


state 253

    (113) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition . SEMICOLON value double_operator LBRACE statement RBRACE

    SEMICOLON       shift and go to state 268


state 254

    (115) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE . VARIABLE LBRACE statement RBRACE

    VARIABLE        shift and go to state 269


state 255

    (135) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type . LBRACE map_values RBRACE

    LBRACE          shift and go to state 270


state 256

    (141) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values . RBRACE

    RBRACE          shift and go to state 271


state 257

    (136) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN

    RBRACKET        shift and go to state 272


state 258

    (145) append_statement -> APPEND LPAREN VARIABLE COMMA values . RPAREN

    RPAREN          shift and go to state 273


state 259

    (44) function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .

    PRINT           reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CONST           reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    CASE            reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)
    RETURN          reduce using rule 44 (function -> FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE .)


state 260

    (46) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return . RBRACE

    RBRACE          shift and go to state 274


state 261

    (49) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks . return RBRACE
    (50) return -> . RETURN values
    (51) return -> . RETURN value LBRACKET value RBRACKET
    (52) return -> . RETURN value PERIOD value

    RETURN          shift and go to state 262

    return                         shift and go to state 275

state 262

    (50) return -> RETURN . values
    (51) return -> RETURN . value LBRACKET value RBRACKET
    (52) return -> RETURN . value PERIOD value
    (53) values -> . value
    (54) values -> . value COMMA values
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    values                         shift and go to state 276
    value                          shift and go to state 277
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 263

    (45) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks . RBRACE

    RBRACE          shift and go to state 278


state 264

    (47) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE . return RBRACE
    (48) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE . blocks return RBRACE
    (50) return -> . RETURN values
    (51) return -> . RETURN value LBRACKET value RBRACKET
    (52) return -> . RETURN value PERIOD value
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

    RETURN          shift and go to state 262
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    FUNCTION        shift and go to state 55
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    parameters                     shift and go to state 18
    return                         shift and go to state 279
    blocks                         shift and go to state 280
    value                          shift and go to state 24
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 265

    (133) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type . LBRACE values RBRACE

    LBRACE          shift and go to state 281


state 266

    (94) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body . ELSE conditional_body

    ELSE            shift and go to state 282


state 267

    (121) case_block -> CASE values COLON statement .

    CASE            reduce using rule 121 (case_block -> CASE values COLON statement .)
    DEFAULT         reduce using rule 121 (case_block -> CASE values COLON statement .)
    RBRACE          reduce using rule 121 (case_block -> CASE values COLON statement .)


state 268

    (113) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON . value double_operator LBRACE statement RBRACE
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    value                          shift and go to state 283
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 269

    (115) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE . LBRACE statement RBRACE

    LBRACE          shift and go to state 284


state 270

    (135) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE . map_values RBRACE
    (137) map_values -> . map_value
    (138) map_values -> . map_value COMMA map_values
    (139) map_value -> . value COLON value
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    map_values                     shift and go to state 285
    map_value                      shift and go to state 286
    value                          shift and go to state 287
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 271

    (141) slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .

    PRINT           reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    PRINTF          reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    INPUT           reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FUNCTION        reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    VAR             reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    VARIABLE        reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CONST           reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    TYPE            reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    IF              reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    SWITCH          reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FOR             reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    INT             reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    FLOAT           reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    $end            reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    RBRACE          reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    CASE            reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    DEFAULT         reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)
    RETURN          reduce using rule 141 (slice_structure -> VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE .)


state 272

    (136) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (81) type -> . INT
    (82) type -> . INT32
    (83) type -> . INT64
    (84) type -> . STRING
    (85) type -> . FLOAT
    (86) type -> . FLOAT32
    (87) type -> . FLOAT64
    (88) type -> . BOOL

    INT             shift and go to state 66
    INT32           shift and go to state 74
    INT64           shift and go to state 75
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    FLOAT32         shift and go to state 78
    FLOAT64         shift and go to state 79
    BOOL            shift and go to state 80

    type                           shift and go to state 288

state 273

    (145) append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .

    PRINT           reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    PRINTF          reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    INPUT           reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FUNCTION        reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    VAR             reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    VARIABLE        reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CONST           reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    TYPE            reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    IF              reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    SWITCH          reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CHARSTRING      reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FOR             reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    INT             reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    FLOAT           reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    $end            reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    RBRACE          reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    CASE            reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    DEFAULT         reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)
    RETURN          reduce using rule 145 (append_statement -> APPEND LPAREN VARIABLE COMMA values RPAREN .)


state 274

    (46) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .

    PRINT           reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    PRINTF          reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    INPUT           reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    FUNCTION        reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    VAR             reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    VARIABLE        reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    CONST           reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    TYPE            reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    IF              reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    SWITCH          reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    CHARSTRING      reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    FOR             reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    INT             reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    FLOAT           reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    $end            reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    RBRACE          reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    CASE            reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    DEFAULT         reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)
    RETURN          reduce using rule 46 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE .)


state 275

    (49) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return . RBRACE

    RBRACE          shift and go to state 289


state 276

    (50) return -> RETURN values .

    RBRACE          reduce using rule 50 (return -> RETURN values .)


state 277

    (51) return -> RETURN value . LBRACKET value RBRACKET
    (52) return -> RETURN value . PERIOD value
    (53) values -> value .
    (54) values -> value . COMMA values

    LBRACKET        shift and go to state 290
    PERIOD          shift and go to state 291
    RBRACE          reduce using rule 53 (values -> value .)
    COMMA           shift and go to state 177


state 278

    (45) function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .

    PRINT           reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    PRINTF          reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INPUT           reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FUNCTION        reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VAR             reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    VARIABLE        reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CONST           reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    TYPE            reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    IF              reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    SWITCH          reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CHARSTRING      reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FOR             reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    INT             reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    FLOAT           reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    $end            reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    RBRACE          reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    CASE            reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    DEFAULT         reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)
    RETURN          reduce using rule 45 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE .)


state 279

    (47) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return . RBRACE

    RBRACE          shift and go to state 292


state 280

    (48) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks . return RBRACE
    (50) return -> . RETURN values
    (51) return -> . RETURN value LBRACKET value RBRACKET
    (52) return -> . RETURN value PERIOD value

    RETURN          shift and go to state 262

    return                         shift and go to state 293

state 281

    (133) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE . values RBRACE
    (53) values -> . value
    (54) values -> . value COMMA values
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    values                         shift and go to state 294
    value                          shift and go to state 212
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 282

    (94) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE . conditional_body
    (95) conditional_body -> . LBRACE statement RBRACE
    (96) conditional_body -> . LBRACE BREAK RBRACE
    (97) conditional_body -> . LBRACE CONTINUE RBRACE

    LBRACE          shift and go to state 144

    conditional_body               shift and go to state 295

state 283

    (113) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value . double_operator LBRACE statement RBRACE
    (76) double_operator -> . INCREMENT
    (77) double_operator -> . DECREMENT

    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73

    double_operator                shift and go to state 296

state 284

    (115) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 9
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    statement                      shift and go to state 297
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    value                          shift and go to state 24
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 285

    (135) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values . RBRACE

    RBRACE          shift and go to state 298


state 286

    (137) map_values -> map_value .
    (138) map_values -> map_value . COMMA map_values

    RBRACE          reduce using rule 137 (map_values -> map_value .)
    COMMA           shift and go to state 299


state 287

    (139) map_value -> value . COLON value

    COLON           shift and go to state 300


state 288

    (136) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN

    RPAREN          shift and go to state 301


state 289

    (49) function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .

    PRINT           reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    PRINTF          reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    INPUT           reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    FUNCTION        reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    VAR             reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    VARIABLE        reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    CONST           reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    TYPE            reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    IF              reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    SWITCH          reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    CHARSTRING      reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    FOR             reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    INT             reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    FLOAT           reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    $end            reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    RBRACE          reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    CASE            reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    DEFAULT         reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)
    RETURN          reduce using rule 49 (function -> FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE .)


state 290

    (51) return -> RETURN value LBRACKET . value RBRACKET
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    value                          shift and go to state 302
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 291

    (52) return -> RETURN value PERIOD . value
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    value                          shift and go to state 303
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 292

    (47) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .

    PRINT           reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    PRINTF          reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    INPUT           reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    FUNCTION        reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    VAR             reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    VARIABLE        reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    CONST           reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    TYPE            reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    IF              reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    SWITCH          reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    CHARSTRING      reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    FOR             reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    INT             reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    FLOAT           reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    $end            reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    RBRACE          reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    CASE            reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    DEFAULT         reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)
    RETURN          reduce using rule 47 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE .)


state 293

    (48) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return . RBRACE

    RBRACE          shift and go to state 304


state 294

    (133) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values . RBRACE

    RBRACE          shift and go to state 305


state 295

    (94) conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .

    PRINT           reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    PRINTF          reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INPUT           reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FUNCTION        reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VAR             reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    VARIABLE        reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CONST           reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    TYPE            reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    IF              reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    SWITCH          reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CHARSTRING      reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FOR             reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    INT             reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    FLOAT           reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    $end            reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RBRACE          reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    CASE            reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    DEFAULT         reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)
    RETURN          reduce using rule 94 (conditional_structure -> IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body .)


state 296

    (113) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator . LBRACE statement RBRACE

    LBRACE          shift and go to state 306


state 297

    (115) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement . RBRACE

    RBRACE          shift and go to state 307


state 298

    (135) map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .

    PRINT           reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    PRINTF          reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INPUT           reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FUNCTION        reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VAR             reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    VARIABLE        reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CONST           reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    TYPE            reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    IF              reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    SWITCH          reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CHARSTRING      reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FOR             reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    INT             reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    FLOAT           reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    $end            reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RBRACE          reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    CASE            reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    DEFAULT         reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)
    RETURN          reduce using rule 135 (map_structure -> VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE .)


state 299

    (138) map_values -> map_value COMMA . map_values
    (137) map_values -> . map_value
    (138) map_values -> . map_value COMMA map_values
    (139) map_value -> . value COLON value
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    map_value                      shift and go to state 286
    map_values                     shift and go to state 308
    value                          shift and go to state 287
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 300

    (139) map_value -> value COLON . value
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (59) number -> . INT
    (60) number -> . FLOAT

    VARIABLE        shift and go to state 100
    CHARSTRING      shift and go to state 8
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

    value                          shift and go to state 309
    not_variable_value             shift and go to state 37
    number                         shift and go to state 45

state 301

    (136) map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .

    PRINT           reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    PRINTF          reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INPUT           reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FUNCTION        reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VAR             reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CONST           reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TYPE            reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    IF              reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SWITCH          reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CHARSTRING      reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FOR             reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    INT             reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FLOAT           reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    $end            reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RBRACE          reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CASE            reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RETURN          reduce using rule 136 (map_structure -> VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)


state 302

    (51) return -> RETURN value LBRACKET value . RBRACKET

    RBRACKET        shift and go to state 310


state 303

    (52) return -> RETURN value PERIOD value .

    RBRACE          reduce using rule 52 (return -> RETURN value PERIOD value .)


state 304

    (48) function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .

    PRINT           reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    PRINTF          reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    INPUT           reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    FUNCTION        reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    VAR             reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    VARIABLE        reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    CONST           reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    TYPE            reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    IF              reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    SWITCH          reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    CHARSTRING      reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    FOR             reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    INT             reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    FLOAT           reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    $end            reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    RBRACE          reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    CASE            reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    DEFAULT         reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)
    RETURN          reduce using rule 48 (function -> FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE .)


state 305

    (133) array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .

    PRINT           reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    PRINTF          reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    INPUT           reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    FUNCTION        reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    VAR             reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    VARIABLE        reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    CONST           reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    TYPE            reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    IF              reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    SWITCH          reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    CHARSTRING      reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    FOR             reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    INT             reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    FLOAT           reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    $end            reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    RBRACE          reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    CASE            reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    DEFAULT         reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)
    RETURN          reduce using rule 133 (array_structure -> VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE .)


state 306

    (113) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE . statement RBRACE
    (1) statement -> . blocks
    (2) statement -> . import blocks
    (3) statement -> . package blocks
    (4) statement -> . package import blocks
    (5) statement -> . main LBRACE blocks RBRACE
    (6) statement -> . package main LBRACE blocks RBRACE
    (7) statement -> . import main LBRACE blocks RBRACE
    (8) statement -> . package import main LBRACE blocks RBRACE
    (17) blocks -> . block
    (18) blocks -> . block blocks
    (9) import -> .
    (10) import -> . IMPORT CHARSTRING
    (11) import -> . IMPORT LPAREN values_for_import RPAREN
    (14) package -> . PACKAGE VARIABLE
    (15) package -> . PACKAGE MAIN
    (16) main -> . FUNCTION MAIN LPAREN RPAREN
    (19) block -> . print_statement
    (20) block -> . input_statement
    (21) block -> . operation
    (22) block -> . data_structure
    (23) block -> . control_structure
    (24) block -> . function
    (25) block -> . parameters
    (26) block -> . variable_declaration
    (27) block -> . variable_assignation
    (61) print_statement -> . PRINT LPAREN values RPAREN
    (62) print_statement -> . PRINTF LPAREN FORMATSTRING COMMA values RPAREN
    (63) print_statement -> . PRINT LPAREN operation RPAREN
    (64) print_statement -> . PRINT LPAREN RPAREN
    (65) input_statement -> . INPUT LPAREN values RPAREN
    (66) input_statement -> . INPUT LPAREN operation RPAREN
    (67) input_statement -> . INPUT LPAREN RPAREN
    (68) operation -> . value operator value
    (69) operation -> . value operator operation
    (70) operation -> . value double_operator
    (124) data_structure -> . array_structure
    (125) data_structure -> . map_structure
    (126) data_structure -> . slice_structure
    (127) data_structure -> . struct_structure
    (89) control_structure -> . conditional_structure
    (90) control_structure -> . for_estructure
    (91) control_structure -> . switch_structure
    (44) function -> . FUNCTION VARIABLE LPAREN RPAREN LBRACE blocks RBRACE
    (45) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN LBRACE blocks RBRACE
    (46) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE return RBRACE
    (47) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE return RBRACE
    (48) function -> . FUNCTION VARIABLE LPAREN parameters RPAREN type LBRACE blocks return RBRACE
    (49) function -> . FUNCTION VARIABLE LPAREN RPAREN type LBRACE blocks return RBRACE
    (78) parameters -> . parameter
    (79) parameters -> . parameter COMMA parameters
    (28) variable_declaration -> . VAR VARIABLE type
    (29) variable_declaration -> . VAR VARIABLE type ASSIGN value
    (30) variable_declaration -> . VARIABLE SHORTASSIGN value
    (31) variable_declaration -> . VARIABLE SHORTASSIGN operation
    (32) variable_declaration -> . CONST VARIABLE ASSIGN value
    (33) variable_assignation -> . VARIABLE assignation value
    (34) variable_assignation -> . VARIABLE assignation operation
    (35) variable_assignation -> . VARIABLE double_operator
    (36) variable_assignation -> . map_assign
    (37) variable_assignation -> . array_assign
    (55) value -> . VARIABLE
    (56) value -> . not_variable_value
    (132) array_structure -> . VAR VARIABLE LBRACKET INT RBRACKET type
    (133) array_structure -> . VAR VARIABLE ASSIGN LBRACKET INT RBRACKET type LBRACE values RBRACE
    (135) map_structure -> . VARIABLE SHORTASSIGN MAP LBRACKET type RBRACKET type LBRACE map_values RBRACE
    (136) map_structure -> . VARIABLE SHORTASSIGN MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (141) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type LBRACE values RBRACE
    (142) slice_structure -> . VAR VARIABLE LBRACKET RBRACKET type
    (143) slice_structure -> . VARIABLE SHORTASSIGN LBRACKET RBRACKET type
    (144) slice_structure -> . VARIABLE ASSIGN append_statement
    (128) struct_structure -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (92) conditional_structure -> . IF conditions conditional_body
    (93) conditional_structure -> . IF conditions conditional_body ELSE conditional_body
    (94) conditional_structure -> . IF conditions conditional_body ELSE IF conditions conditional_body ELSE conditional_body
    (110) for_estructure -> . for_initialization
    (111) for_estructure -> . for_infinite_bucle
    (112) for_estructure -> . for_iterator
    (116) switch_structure -> . SWITCH switch_expression LBRACE case_blocks RBRACE
    (80) parameter -> . VARIABLE type
    (140) map_assign -> . VARIABLE LBRACKET value RBRACKET ASSIGN value
    (134) array_assign -> . VARIABLE LBRACKET INT RBRACKET ASSIGN value
    (57) not_variable_value -> . CHARSTRING
    (58) not_variable_value -> . number
    (113) for_initialization -> . FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE
    (114) for_infinite_bucle -> . FOR LBRACE statement RBRACE
    (115) for_iterator -> . FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE
    (59) number -> . INT
    (60) number -> . FLOAT

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for CHARSTRING resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    IMPORT          shift and go to state 7
    PACKAGE         shift and go to state 9
    FUNCTION        shift and go to state 11
    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    INPUT           shift and go to state 23
    VAR             shift and go to state 33
    VARIABLE        shift and go to state 10
    CONST           shift and go to state 34
    TYPE            shift and go to state 39
    IF              shift and go to state 40
    SWITCH          shift and go to state 44
    CHARSTRING      shift and go to state 8
    FOR             shift and go to state 46
    INT             shift and go to state 38
    FLOAT           shift and go to state 47

  ! FUNCTION        [ reduce using rule 9 (import -> .) ]
  ! PRINT           [ reduce using rule 9 (import -> .) ]
  ! PRINTF          [ reduce using rule 9 (import -> .) ]
  ! INPUT           [ reduce using rule 9 (import -> .) ]
  ! VAR             [ reduce using rule 9 (import -> .) ]
  ! VARIABLE        [ reduce using rule 9 (import -> .) ]
  ! CONST           [ reduce using rule 9 (import -> .) ]
  ! TYPE            [ reduce using rule 9 (import -> .) ]
  ! IF              [ reduce using rule 9 (import -> .) ]
  ! SWITCH          [ reduce using rule 9 (import -> .) ]
  ! CHARSTRING      [ reduce using rule 9 (import -> .) ]
  ! FOR             [ reduce using rule 9 (import -> .) ]
  ! INT             [ reduce using rule 9 (import -> .) ]
  ! FLOAT           [ reduce using rule 9 (import -> .) ]

    value                          shift and go to state 24
    statement                      shift and go to state 311
    blocks                         shift and go to state 2
    import                         shift and go to state 3
    package                        shift and go to state 4
    main                           shift and go to state 5
    block                          shift and go to state 6
    print_statement                shift and go to state 12
    input_statement                shift and go to state 13
    operation                      shift and go to state 14
    data_structure                 shift and go to state 15
    control_structure              shift and go to state 16
    function                       shift and go to state 17
    parameters                     shift and go to state 18
    variable_declaration           shift and go to state 19
    variable_assignation           shift and go to state 20
    array_structure                shift and go to state 25
    map_structure                  shift and go to state 26
    slice_structure                shift and go to state 27
    struct_structure               shift and go to state 28
    conditional_structure          shift and go to state 29
    for_estructure                 shift and go to state 30
    switch_structure               shift and go to state 31
    parameter                      shift and go to state 32
    map_assign                     shift and go to state 35
    array_assign                   shift and go to state 36
    not_variable_value             shift and go to state 37
    for_initialization             shift and go to state 41
    for_infinite_bucle             shift and go to state 42
    for_iterator                   shift and go to state 43
    number                         shift and go to state 45

state 307

    (115) for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .

    PRINT           reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    PRINTF          reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INPUT           reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VAR             reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CONST           reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    TYPE            reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    IF              reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    SWITCH          reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FOR             reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    INT             reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    FLOAT           reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    $end            reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RBRACE          reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    CASE            reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)
    RETURN          reduce using rule 115 (for_iterator -> FOR VARIABLE SEMICOLON VARIABLE SHORTASSIGN RANGE VARIABLE LBRACE statement RBRACE .)


state 308

    (138) map_values -> map_value COMMA map_values .

    RBRACE          reduce using rule 138 (map_values -> map_value COMMA map_values .)


state 309

    (139) map_value -> value COLON value .

    COMMA           reduce using rule 139 (map_value -> value COLON value .)
    RBRACE          reduce using rule 139 (map_value -> value COLON value .)


state 310

    (51) return -> RETURN value LBRACKET value RBRACKET .

    RBRACE          reduce using rule 51 (return -> RETURN value LBRACKET value RBRACKET .)


state 311

    (113) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement . RBRACE

    RBRACE          shift and go to state 312


state 312

    (113) for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .

    PRINT           reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    PRINTF          reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INPUT           reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FUNCTION        reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VAR             reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    VARIABLE        reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CONST           reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    TYPE            reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    IF              reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    SWITCH          reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CHARSTRING      reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FOR             reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    INT             reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    FLOAT           reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    $end            reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RBRACE          reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    CASE            reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    DEFAULT         reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)
    RETURN          reduce using rule 113 (for_initialization -> FOR VARIABLE SHORTASSIGN value SEMICOLON condition SEMICOLON value double_operator LBRACE statement RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FUNCTION in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 0 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 0 resolved as shift
WARNING: shift/reduce conflict for VAR in state 0 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 0 resolved as shift
WARNING: shift/reduce conflict for CONST in state 0 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 0 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 4 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 4 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 4 resolved as shift
WARNING: shift/reduce conflict for VAR in state 4 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 4 resolved as shift
WARNING: shift/reduce conflict for CONST in state 4 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 4 resolved as shift
WARNING: shift/reduce conflict for IF in state 4 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 4 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 4 resolved as shift
WARNING: shift/reduce conflict for FOR in state 4 resolved as shift
WARNING: shift/reduce conflict for INT in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 10 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 10 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 10 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 105 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 105 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 105 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 105 resolved as shift
WARNING: shift/reduce conflict for VAR in state 105 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 105 resolved as shift
WARNING: shift/reduce conflict for CONST in state 105 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 105 resolved as shift
WARNING: shift/reduce conflict for IF in state 105 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 105 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 105 resolved as shift
WARNING: shift/reduce conflict for FOR in state 105 resolved as shift
WARNING: shift/reduce conflict for INT in state 105 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 105 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 121 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 144 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 144 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 144 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 144 resolved as shift
WARNING: shift/reduce conflict for VAR in state 144 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 144 resolved as shift
WARNING: shift/reduce conflict for CONST in state 144 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 144 resolved as shift
WARNING: shift/reduce conflict for IF in state 144 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 144 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 144 resolved as shift
WARNING: shift/reduce conflict for FOR in state 144 resolved as shift
WARNING: shift/reduce conflict for INT in state 144 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 144 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 230 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 230 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 230 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 230 resolved as shift
WARNING: shift/reduce conflict for VAR in state 230 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 230 resolved as shift
WARNING: shift/reduce conflict for CONST in state 230 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 230 resolved as shift
WARNING: shift/reduce conflict for IF in state 230 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 230 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 230 resolved as shift
WARNING: shift/reduce conflict for FOR in state 230 resolved as shift
WARNING: shift/reduce conflict for INT in state 230 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 230 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 251 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 251 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 251 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 251 resolved as shift
WARNING: shift/reduce conflict for VAR in state 251 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 251 resolved as shift
WARNING: shift/reduce conflict for CONST in state 251 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 251 resolved as shift
WARNING: shift/reduce conflict for IF in state 251 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 251 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 251 resolved as shift
WARNING: shift/reduce conflict for FOR in state 251 resolved as shift
WARNING: shift/reduce conflict for INT in state 251 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 251 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 284 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 284 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 284 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 284 resolved as shift
WARNING: shift/reduce conflict for VAR in state 284 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 284 resolved as shift
WARNING: shift/reduce conflict for CONST in state 284 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 284 resolved as shift
WARNING: shift/reduce conflict for IF in state 284 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 284 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 284 resolved as shift
WARNING: shift/reduce conflict for FOR in state 284 resolved as shift
WARNING: shift/reduce conflict for INT in state 284 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 284 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 306 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 306 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 306 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 306 resolved as shift
WARNING: shift/reduce conflict for VAR in state 306 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 306 resolved as shift
WARNING: shift/reduce conflict for CONST in state 306 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 306 resolved as shift
WARNING: shift/reduce conflict for IF in state 306 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 306 resolved as shift
WARNING: shift/reduce conflict for CHARSTRING in state 306 resolved as shift
WARNING: shift/reduce conflict for FOR in state 306 resolved as shift
WARNING: shift/reduce conflict for INT in state 306 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 306 resolved as shift
